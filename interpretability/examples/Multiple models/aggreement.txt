--------------------------------------------------------------------------------------------------------------
Example ids:  244 project:  FFmpeg commit id:  2bfd0a97587d26c0c39413a6291ccc66e4a928d0 Number of lines:  26
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)               {'linevul': 2, 'codebert': 4, 'PLBART': 0, 'devign': 0, 'regvd': 4, 'vulberta_cnn': 1, 'vulberta_mlp': 16}
1 {                                                                                       {'linevul': 24, 'codebert': 19, 'PLBART': 14, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 10, 'vulberta_mlp': 21}
2     uint8_t symbols[256];                                                               {'linevul': 22, 'codebert': 8, 'PLBART': 5, 'devign': 3, 'regvd': 12, 'vulberta_cnn': 11, 'vulberta_mlp': 10}
3     uint8_t bits[256];                                                                  {'linevul': 21, 'codebert': 10, 'PLBART': 9, 'devign': 8, 'regvd': 11, 'vulberta_cnn': 16, 'vulberta_mlp': 6}
4     uint16_t codes[256];                                                                {'linevul': 20, 'codebert': 12, 'PLBART': 6, 'devign': 6, 'regvd': 10, 'vulberta_cnn': 17, 'vulberta_mlp': 8}
5     int num_lens, num_codes, num_codes_sum, prefix;                                     {'linevul': 8, 'codebert': 14, 'PLBART': 1, 'devign': 7, 'regvd': 9, 'vulberta_cnn': 2, 'vulberta_mlp': 13}
6     int i, j, count;                                                                    {'linevul': 23, 'codebert': 15, 'PLBART': 10, 'devign': 5, 'regvd': 20, 'vulberta_cnn': 9, 'vulberta_mlp': 25}
7     prefix        = 0;                                                                  {'linevul': 16, 'codebert': 17, 'PLBART': 11, 'devign': 4, 'regvd': 23, 'vulberta_cnn': 4, 'vulberta_mlp': 24}
8     count         = 0;                                                                  {'linevul': 15, 'codebert': 16, 'PLBART': 12, 'devign': 2, 'regvd': 22, 'vulberta_cnn': 19, 'vulberta_mlp': 23}
9     num_codes_sum = 0;                                                                  {'linevul': 19, 'codebert': 18, 'PLBART': 7, 'devign': 9, 'regvd': 14, 'vulberta_cnn': 13, 'vulberta_mlp': 3}
10     num_lens = get_bits(gb, 5);                                                        {'linevul': 14, 'codebert': 11, 'PLBART': 4, 'devign': 1, 'regvd': 3, 'vulberta_cnn': 23, 'vulberta_mlp': 2}
11     for (i = 0; i < num_lens; i++) {                                                   {'linevul': 11, 'codebert': 7, 'PLBART': 2, 'devign': -1, 'regvd': 7, 'vulberta_cnn': 25, 'vulberta_mlp': 5}
12         num_codes      = get_bits(gb, 9);                                              {'linevul': 5, 'codebert': 13, 'PLBART': 3, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 20, 'vulberta_mlp': 4}
13         num_codes_sum += num_codes;                                                    {'linevul': 13, 'codebert': 9, 'PLBART': 8, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 24, 'vulberta_mlp': 15}
14         if (num_codes_sum > 256) {                                                     {'linevul': 12, 'codebert': 3, 'PLBART': 13, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 15, 'vulberta_mlp': 14}
15             av_log(ctx->avctx, AV_LOG_ERROR,                                           {'linevul': 3, 'codebert': 2, 'PLBART': -1, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 22, 'vulberta_mlp': 22}
16                    "Too many VLCs (%d) to be read.\n", num_codes_sum);                 {'linevul': 0, 'codebert': 1, 'PLBART': -1, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 7, 'vulberta_mlp': 12}
17         for (j = 0; j < num_codes; j++) {                                              {'linevul': 7, 'codebert': 0, 'PLBART': -1, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 3, 'vulberta_mlp': 19}
18             symbols[count] = get_bits(gb, 8);                                          {'linevul': 4, 'codebert': 5, 'PLBART': -1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 12, 'vulberta_mlp': 0}
19             bits[count]    = i + 1;                                                    {'linevul': 6, 'codebert': 6, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 18, 'vulberta_mlp': 1}
20             codes[count]   = prefix++;                                                 {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 5, 'vulberta_mlp': 17}
21             count++;                                                                   {'linevul': 17, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 21, 'vulberta_mlp': 18}
22         if (prefix > (65535 - 256)/2) {                                                {'linevul': 9, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 8, 'vulberta_mlp': 9}
23         prefix <<= 1;                                                                  {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 6, 'vulberta_mlp': 20}
24     return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,                        {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 14, 'vulberta_mlp': 7}
25                               codes, 2, 2, symbols, 1, 1, 0);                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 0, 'vulberta_mlp': 11}
-----------------------
Highlighted lines: 
0 static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
5     int num_lens, num_codes, num_codes_sum, prefix;
10     num_lens = get_bits(gb, 5);
11     for (i = 0; i < num_lens; i++) {
12         num_codes      = get_bits(gb, 9);
16                    "Too many VLCs (%d) to be read.\n", num_codes_sum);
17         for (j = 0; j < num_codes; j++) {
18             symbols[count] = get_bits(gb, 8);
--------------------------------------------------------------------------------------------------------------
Example ids:  265 project:  FFmpeg commit id:  478f1c3d5e5463a284ea7efecfc62d47ba3be11a Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,               {'linevul': 2, 'codebert': 0, 'PLBART': 1, 'devign': 8, 'regvd': 7, 'vulberta_cnn': 11, 'vulberta_mlp': 13}
2                              uint32_t length)                                       {'linevul': 1, 'codebert': 9, 'PLBART': 7, 'devign': 10, 'regvd': 10, 'vulberta_cnn': 4, 'vulberta_mlp': 3}
4 {                                                                                   {'linevul': 19, 'codebert': 14, 'PLBART': 10, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 8, 'vulberta_mlp': 17}
6     int n, i, r, g, b;                                                              {'linevul': 11, 'codebert': 16, 'PLBART': 2, 'devign': 13, 'regvd': 13, 'vulberta_cnn': 14, 'vulberta_mlp': 16}
10     if ((length % 3) != 0 || length > 256 * 3)                                     {'linevul': 8, 'codebert': 1, 'PLBART': 4, 'devign': 6, 'regvd': 6, 'vulberta_cnn': 0, 'vulberta_mlp': 9}
12         return AVERROR_INVALIDDATA;                                                {'linevul': 9, 'codebert': 3, 'PLBART': 5, 'devign': 15, 'regvd': 12, 'vulberta_cnn': 5, 'vulberta_mlp': 12}
14     /* read the palette */                                                         {'linevul': 15, 'codebert': 2, 'PLBART': 9, 'devign': -1, 'regvd': 16, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
16     n = length / 3;                                                                {'linevul': 14, 'codebert': 13, 'PLBART': 8, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 7, 'vulberta_mlp': 1}
18     for (i = 0; i < n; i++) {                                                      {'linevul': 10, 'codebert': 18, 'PLBART': 3, 'devign': 0, 'regvd': 8, 'vulberta_cnn': 17, 'vulberta_mlp': 18}
20         r = bytestream2_get_byte(&s->gb);                                          {'linevul': 7, 'codebert': 8, 'PLBART': 0, 'devign': 5, 'regvd': 4, 'vulberta_cnn': 12, 'vulberta_mlp': 7}
22         g = bytestream2_get_byte(&s->gb);                                          {'linevul': 6, 'codebert': 10, 'PLBART': -1, 'devign': 4, 'regvd': 3, 'vulberta_cnn': 16, 'vulberta_mlp': 11}
24         b = bytestream2_get_byte(&s->gb);                                          {'linevul': 5, 'codebert': 11, 'PLBART': -1, 'devign': 3, 'regvd': 2, 'vulberta_cnn': 3, 'vulberta_mlp': 8}
26         s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;                  {'linevul': 0, 'codebert': 7, 'PLBART': 6, 'devign': 2, 'regvd': 1, 'vulberta_cnn': 13, 'vulberta_mlp': 4}
28     }                                                                              {'linevul': 17, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 10, 'vulberta_mlp': 14}
30     for (; i < 256; i++)                                                           {'linevul': 13, 'codebert': 15, 'PLBART': -1, 'devign': 1, 'regvd': 11, 'vulberta_cnn': 15, 'vulberta_mlp': 15}
32         s->palette[i] = (0xFFU << 24);                                             {'linevul': 4, 'codebert': 6, 'PLBART': -1, 'devign': 7, 'regvd': 5, 'vulberta_cnn': 2, 'vulberta_mlp': 5}
34     s->state |= PNG_PLTE;                                                          {'linevul': 12, 'codebert': 4, 'PLBART': -1, 'devign': 9, 'regvd': 9, 'vulberta_cnn': 1, 'vulberta_mlp': 10}
36     bytestream2_skip(&s->gb, 4);     /* crc */                                     {'linevul': 3, 'codebert': 5, 'PLBART': -1, 'devign': 11, 'regvd': 0, 'vulberta_cnn': 9, 'vulberta_mlp': 6}
40     return 0;                                                                      {'linevul': 16, 'codebert': 17, 'PLBART': -1, 'devign': 14, 'regvd': 15, 'vulberta_cnn': 6, 'vulberta_mlp': 2}
42 }                                                                                  {'linevul': 18, 'codebert': 12, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 18, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
2                              uint32_t length)
10     if ((length % 3) != 0 || length > 256 * 3)
12         return AVERROR_INVALIDDATA;
20         r = bytestream2_get_byte(&s->gb);
24         b = bytestream2_get_byte(&s->gb);
26         s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
32         s->palette[i] = (0xFFU << 24);
34     s->state |= PNG_PLTE;
36     bytestream2_skip(&s->gb, 4);     /* crc */
--------------------------------------------------------------------------------------------------------------
Example ids:  439 project:  FFmpeg commit id:  72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c Number of lines:  20
Original lines: 
Predicted Correctly by :  ['codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 int ff_alloc_entries(AVCodecContext *avctx, int count)                                               {'codebert': 1, 'PLBART': 3, 'devign': 4, 'regvd': 6, 'vulberta_cnn': 1, 'vulberta_mlp': 8}
2 {                                                                                                    {'codebert': 17, 'PLBART': 11, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 7, 'vulberta_mlp': 17}
4     int i;                                                                                           {'codebert': 16, 'PLBART': 9, 'devign': 11, 'regvd': 13, 'vulberta_cnn': 3, 'vulberta_mlp': 16}
8     if (avctx->active_thread_type & FF_THREAD_SLICE)  {                                              {'codebert': 0, 'PLBART': 1, 'devign': 5, 'regvd': 4, 'vulberta_cnn': 16, 'vulberta_mlp': 12}
10         SliceThreadContext *p = avctx->internal->thread_ctx;                                        {'codebert': 3, 'PLBART': 0, 'devign': 2, 'regvd': 8, 'vulberta_cnn': 9, 'vulberta_mlp': 15}
12         p->thread_count  = avctx->thread_count;                                                     {'codebert': 7, 'PLBART': 6, 'devign': 9, 'regvd': 9, 'vulberta_cnn': 0, 'vulberta_mlp': 14}
14         p->entries       = av_mallocz_array(count, sizeof(int));                                    {'codebert': 2, 'PLBART': 4, 'devign': 1, 'regvd': 2, 'vulberta_cnn': 2, 'vulberta_mlp': 10}
18         if (!p->entries) {                                                                          {'codebert': 6, 'PLBART': 8, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 15, 'vulberta_mlp': 18}
20             return AVERROR(ENOMEM);                                                                 {'codebert': 12, 'PLBART': 5, 'devign': 14, 'regvd': 12, 'vulberta_cnn': 12, 'vulberta_mlp': 7}
22         }                                                                                           {'codebert': 15, 'PLBART': 10, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 8, 'vulberta_mlp': 13}
26         p->entries_count  = count;                                                                  {'codebert': 13, 'PLBART': 7, 'devign': 12, 'regvd': 10, 'vulberta_cnn': 14, 'vulberta_mlp': 11}
28         p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));              {'codebert': 4, 'PLBART': 2, 'devign': 8, 'regvd': 0, 'vulberta_cnn': 11, 'vulberta_mlp': 1}
30         p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));               {'codebert': 5, 'PLBART': -1, 'devign': 7, 'regvd': 1, 'vulberta_cnn': 18, 'vulberta_mlp': 2}
34         for (i = 0; i < p->thread_count; i++) {                                                     {'codebert': 11, 'PLBART': -1, 'devign': 0, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 19}
36             pthread_mutex_init(&p->progress_mutex[i], NULL);                                        {'codebert': 10, 'PLBART': -1, 'devign': 10, 'regvd': 3, 'vulberta_cnn': 17, 'vulberta_mlp': 5}
38             pthread_cond_init(&p->progress_cond[i], NULL);                                          {'codebert': 9, 'PLBART': -1, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 5, 'vulberta_mlp': 4}
40         }                                                                                           {'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 10, 'vulberta_mlp': 9}
42     }                                                                                               {'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 6, 'vulberta_mlp': 3}
46     return 0;                                                                                       {'codebert': 14, 'PLBART': -1, 'devign': 13, 'regvd': 14, 'vulberta_cnn': 4, 'vulberta_mlp': 6}
48 }                                                                                                   {'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 19, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 int ff_alloc_entries(AVCodecContext *avctx, int count)
8     if (avctx->active_thread_type & FF_THREAD_SLICE)  {
10         SliceThreadContext *p = avctx->internal->thread_ctx;
12         p->thread_count  = avctx->thread_count;
14         p->entries       = av_mallocz_array(count, sizeof(int));
28         p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
30         p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
38             pthread_cond_init(&p->progress_cond[i], NULL);
--------------------------------------------------------------------------------------------------------------
Example ids:  657 project:  FFmpeg commit id:  56706ac0d5723cb549fec2602e798ab1bf6004cd Number of lines:  35
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)               {'linevul': 2, 'codebert': 0, 'PLBART': 0, 'devign': 8, 'regvd': 3, 'vulberta_cnn': 28, 'vulberta_mlp': 15}
2 {                                                                                                                   {'linevul': 22, 'codebert': 1, 'PLBART': 10, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 22, 'vulberta_mlp': 13}
4     int compno;                                                                                                     {'linevul': 20, 'codebert': 3, 'PLBART': 6, 'devign': 20, 'regvd': 22, 'vulberta_cnn': 31, 'vulberta_mlp': 29}
6     int x, y;                                                                                                       {'linevul': 18, 'codebert': 11, 'PLBART': 9, 'devign': 21, 'regvd': 21, 'vulberta_cnn': 23, 'vulberta_mlp': 14}
8     int *image_line;                                                                                                {'linevul': 16, 'codebert': 9, 'PLBART': 7, 'devign': 19, 'regvd': 20, 'vulberta_cnn': 17, 'vulberta_mlp': 30}
10     int frame_index;                                                                                               {'linevul': 17, 'codebert': 5, 'PLBART': 8, 'devign': 18, 'regvd': 19, 'vulberta_cnn': 5, 'vulberta_mlp': 28}
12     const int numcomps  = image->numcomps;                                                                         {'linevul': 13, 'codebert': 10, 'PLBART': 4, 'devign': 15, 'regvd': 17, 'vulberta_cnn': 27, 'vulberta_mlp': 12}
14     uint16_t *frame_ptr = (uint16_t *)frame->data[0];                                                              {'linevul': 8, 'codebert': 2, 'PLBART': 3, 'devign': 17, 'regvd': 9, 'vulberta_cnn': 3, 'vulberta_mlp': 24}
18     for (compno = 0; compno < numcomps; ++compno) {                                                                {'linevul': 11, 'codebert': 14, 'PLBART': 2, 'devign': 3, 'regvd': 14, 'vulberta_cnn': 4, 'vulberta_mlp': 25}
20         if (image->comps[compno].w > frame->linesize[0] / numcomps) {                                              {'linevul': 4, 'codebert': 6, 'PLBART': 1, 'devign': 13, 'regvd': 4, 'vulberta_cnn': 8, 'vulberta_mlp': 3}
22             av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n");                   {'linevul': 0, 'codebert': 4, 'PLBART': 5, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 34, 'vulberta_mlp': 0}
24             return 0;                                                                                              {'linevul': 14, 'codebert': 17, 'PLBART': -1, 'devign': 23, 'regvd': 23, 'vulberta_cnn': 10, 'vulberta_mlp': 34}
26         }                                                                                                          {'linevul': 19, 'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 34, 'vulberta_cnn': 20, 'vulberta_mlp': 2}
28     }                                                                                                              {'linevul': 21, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 24, 'vulberta_mlp': 11}
32     for (compno = 0; compno < numcomps; ++compno) {                                                                {'linevul': 12, 'codebert': 15, 'PLBART': -1, 'devign': 2, 'regvd': 13, 'vulberta_cnn': 11, 'vulberta_mlp': 19}
34         for (y = 0; y < avctx->height; ++y) {                                                                      {'linevul': 9, 'codebert': 12, 'PLBART': -1, 'devign': 1, 'regvd': 11, 'vulberta_cnn': 1, 'vulberta_mlp': 1}
36             image_line = image->comps[compno].data + y * image->comps[compno].w;                                   {'linevul': 1, 'codebert': 8, 'PLBART': -1, 'devign': 10, 'regvd': 8, 'vulberta_cnn': 16, 'vulberta_mlp': 4}
38             frame_index = y * (frame->linesize[0] / 2) + compno;                                                   {'linevul': 5, 'codebert': 7, 'PLBART': -1, 'devign': 4, 'regvd': 0, 'vulberta_cnn': 26, 'vulberta_mlp': 20}
40             for (x = 0; x < avctx->width; ++x) {                                                                   {'linevul': 7, 'codebert': 13, 'PLBART': -1, 'devign': 6, 'regvd': 12, 'vulberta_cnn': 9, 'vulberta_mlp': 23}
42                 image_line[x] = frame_ptr[frame_index] >> 4;                                                       {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 15, 'vulberta_cnn': 0, 'vulberta_mlp': 16}
44                 frame_index += numcomps;                                                                           {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 16, 'vulberta_cnn': 6, 'vulberta_mlp': 10}
46             }                                                                                                      {'linevul': 15, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 21, 'vulberta_mlp': 9}
48             for (; x < image->comps[compno].w; ++x) {                                                              {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 5, 'vulberta_cnn': 13, 'vulberta_mlp': 8}
50                 image_line[x] = image_line[x - 1];                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 18, 'vulberta_cnn': 30, 'vulberta_mlp': 17}
52             }                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_cnn': 12, 'vulberta_mlp': 33}
54         }                                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_cnn': 19, 'vulberta_mlp': 32}
56         for (; y < image->comps[compno].h; ++y) {                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 6, 'vulberta_cnn': 2, 'vulberta_mlp': 26}
58             image_line = image->comps[compno].data + y * image->comps[compno].w;                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 7, 'vulberta_cnn': 29, 'vulberta_mlp': 18}
60             for (x = 0; x < image->comps[compno].w; ++x) {                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 7, 'vulberta_mlp': 22}
62                 image_line[x] = image_line[x - image->comps[compno].w];                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 10, 'vulberta_cnn': 33, 'vulberta_mlp': 21}
64             }                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 18, 'vulberta_mlp': 7}
66         }                                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 25, 'vulberta_mlp': 31}
68     }                                                                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 15, 'vulberta_mlp': 6}
72     return 1;                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 24, 'vulberta_cnn': 14, 'vulberta_mlp': 27}
74 }                                                                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 32, 'vulberta_mlp': 5}
-----------------------
Highlighted lines: 
0 static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)
14     uint16_t *frame_ptr = (uint16_t *)frame->data[0];
20         if (image->comps[compno].w > frame->linesize[0] / numcomps) {
22             av_log(avctx, AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n");
34         for (y = 0; y < avctx->height; ++y) {
36             image_line = image->comps[compno].data + y * image->comps[compno].w;
38             frame_index = y * (frame->linesize[0] / 2) + compno;
48             for (; x < image->comps[compno].w; ++x) {
--------------------------------------------------------------------------------------------------------------
Example ids:  937 project:  qemu commit id:  ad0ebb91cd8b5fdc4a583b03645677771f420a46 Number of lines:  25
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'devign', 'regvd', 'vulberta_mlp']
0 static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,                  {'linevul': 7, 'codebert': 0, 'devign': 8, 'regvd': 6, 'vulberta_mlp': 12}
2                               target_ulong opcode, target_ulong *args)                    {'linevul': 0, 'codebert': 11, 'devign': 9, 'regvd': 13, 'vulberta_mlp': 8}
4 {                                                                                         {'linevul': 22, 'codebert': 17, 'devign': 59, 'regvd': 24, 'vulberta_mlp': 13}
6     target_ulong liobn = args[0];                                                         {'linevul': 11, 'codebert': 14, 'devign': 13, 'regvd': 10, 'vulberta_mlp': 21}
8     target_ulong ioba = args[1];                                                          {'linevul': 14, 'codebert': 13, 'devign': 12, 'regvd': 9, 'vulberta_mlp': 17}
10     target_ulong tce = args[2];                                                          {'linevul': 15, 'codebert': 12, 'devign': 14, 'regvd': 11, 'vulberta_mlp': 23}
12     VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);                  {'linevul': 3, 'codebert': 5, 'devign': 4, 'regvd': 1, 'vulberta_mlp': 10}
14     VIOsPAPR_RTCE *rtce;                                                                 {'linevul': 10, 'codebert': 9, 'devign': 15, 'regvd': 12, 'vulberta_mlp': 14}
18     if (!dev) {                                                                          {'linevul': 17, 'codebert': 15, 'devign': 7, 'regvd': 19, 'vulberta_mlp': 4}
20         hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn);              {'linevul': 4, 'codebert': 8, 'devign': 2, 'regvd': 3, 'vulberta_mlp': 9}
22         return H_PARAMETER;                                                              {'linevul': 13, 'codebert': 10, 'devign': 17, 'regvd': 15, 'vulberta_mlp': 3}
24     }                                                                                    {'linevul': 20, 'codebert': 16, 'devign': 47, 'regvd': 23, 'vulberta_mlp': 0}
28     ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);                                              {'linevul': 8, 'codebert': 4, 'devign': 10, 'regvd': 8, 'vulberta_mlp': 20}
32 #ifdef DEBUG_TCE                                                                         {'linevul': 18, 'codebert': 3, 'devign': 40, 'regvd': 17, 'vulberta_mlp': 11}
34     fprintf(stderr, "spapr_vio_put_tce on %s  ioba 0x" TARGET_FMT_lx                     {'linevul': 2, 'codebert': 6, 'devign': 3, 'regvd': 5, 'vulberta_mlp': 5}
36             "  TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce);                     {'linevul': 1, 'codebert': 2, 'devign': 0, 'regvd': 4, 'vulberta_mlp': 18}
38 #endif                                                                                   {'linevul': 21, 'codebert': 7, 'devign': 36, 'regvd': 20, 'vulberta_mlp': 24}
42     if (ioba >= dev->rtce_window_size) {                                                 {'linevul': 9, 'codebert': 1, 'devign': 5, 'regvd': 7, 'vulberta_mlp': 16}
44         hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba);                 {'linevul': 5, 'codebert': -1, 'devign': 1, 'regvd': 2, 'vulberta_mlp': 7}
46         return H_PARAMETER;                                                              {'linevul': 12, 'codebert': -1, 'devign': 16, 'regvd': 14, 'vulberta_mlp': 6}
48     }                                                                                    {'linevul': 19, 'codebert': -1, 'devign': 29, 'regvd': 22, 'vulberta_mlp': 2}
52     rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);                         {'linevul': 6, 'codebert': -1, 'devign': 6, 'regvd': 0, 'vulberta_mlp': 19}
54     rtce->tce = tce;                                                                     {'linevul': 16, 'codebert': -1, 'devign': 11, 'regvd': 18, 'vulberta_mlp': 22}
58     return H_SUCCESS;                                                                    {'linevul': -1, 'codebert': -1, 'devign': 18, 'regvd': 16, 'vulberta_mlp': 15}
60 }                                                                                        {'linevul': -1, 'codebert': -1, 'devign': 20, 'regvd': 21, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,
12     VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
20         hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn);
34     fprintf(stderr, "spapr_vio_put_tce on %s  ioba 0x" TARGET_FMT_lx
36             "  TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce);
42     if (ioba >= dev->rtce_window_size) {
44         hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba);
--------------------------------------------------------------------------------------------------------------
Example ids:  1338 project:  FFmpeg commit id:  1c495b0bf690995c45f79f4f19500921e14ec78a Number of lines:  21
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void sd_1d97_int(int *p, int i0, int i1)                                                         {'linevul': 8, 'codebert': 0, 'PLBART': 4, 'devign': 6, 'regvd': 6, 'vulberta_cnn': 1, 'vulberta_mlp': 4}
2 {                                                                                                       {'linevul': 18, 'codebert': 8, 'PLBART': 14, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 13, 'vulberta_mlp': 20}
4     int i;                                                                                              {'linevul': 16, 'codebert': 7, 'PLBART': 7, 'devign': 16, 'regvd': 15, 'vulberta_cnn': 10, 'vulberta_mlp': 10}
8     if (i1 <= i0 + 1) {                                                                                 {'linevul': 12, 'codebert': 9, 'PLBART': 6, 'devign': 7, 'regvd': 12, 'vulberta_cnn': 2, 'vulberta_mlp': 18}
10         if (i0 == 1)                                                                                   {'linevul': 11, 'codebert': 15, 'PLBART': 9, 'devign': 12, 'regvd': 13, 'vulberta_cnn': 7, 'vulberta_mlp': 13}
12             p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;                                                  {'linevul': 3, 'codebert': 2, 'PLBART': 1, 'devign': 14, 'regvd': 5, 'vulberta_cnn': 20, 'vulberta_mlp': 12}
14         else                                                                                           {'linevul': 15, 'codebert': 16, 'PLBART': 10, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 12, 'vulberta_mlp': 9}
16             p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;                                                  {'linevul': 4, 'codebert': 3, 'PLBART': 2, 'devign': 15, 'regvd': 4, 'vulberta_cnn': 8, 'vulberta_mlp': 7}
18         return;                                                                                        {'linevul': 14, 'codebert': 12, 'PLBART': 13, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 6, 'vulberta_mlp': 19}
20     }                                                                                                  {'linevul': 17, 'codebert': 5, 'PLBART': 12, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 9, 'vulberta_mlp': 8}
24     extend97_int(p, i0, i1);                                                                           {'linevul': 10, 'codebert': 1, 'PLBART': 5, 'devign': 5, 'regvd': 7, 'vulberta_cnn': 18, 'vulberta_mlp': 5}
26     i0++; i1++;                                                                                        {'linevul': 13, 'codebert': 13, 'PLBART': 8, 'devign': 4, 'regvd': 14, 'vulberta_cnn': 5, 'vulberta_mlp': 16}
30     for (i = i0/2 - 2; i < i1/2 + 1; i++)                                                              {'linevul': 6, 'codebert': 10, 'PLBART': 3, 'devign': 2, 'regvd': 10, 'vulberta_cnn': 3, 'vulberta_mlp': 2}
32         p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;              {'linevul': 0, 'codebert': 4, 'PLBART': 0, 'devign': 9, 'regvd': 0, 'vulberta_cnn': 16, 'vulberta_mlp': 11}
34     for (i = i0/2 - 1; i < i1/2 + 1; i++)                                                              {'linevul': 5, 'codebert': 11, 'PLBART': 11, 'devign': 1, 'regvd': 9, 'vulberta_cnn': 4, 'vulberta_mlp': 3}
36         p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;              {'linevul': 2, 'codebert': 6, 'PLBART': -1, 'devign': 8, 'regvd': 1, 'vulberta_cnn': 17, 'vulberta_mlp': 17}
38     for (i = i0/2 - 1; i < i1/2; i++)                                                                  {'linevul': 7, 'codebert': 14, 'PLBART': -1, 'devign': 0, 'regvd': 8, 'vulberta_cnn': 0, 'vulberta_mlp': 1}
40         p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;              {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 3, 'vulberta_cnn': 15, 'vulberta_mlp': 15}
42     for (i = i0/2; i < i1/2; i++)                                                                      {'linevul': 9, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 11, 'vulberta_mlp': 6}
44         p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 2, 'vulberta_cnn': 14, 'vulberta_mlp': 14}
46 }                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 19, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void sd_1d97_int(int *p, int i0, int i1)
8     if (i1 <= i0 + 1) {
12             p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;
16             p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;
24     extend97_int(p, i0, i1);
30     for (i = i0/2 - 2; i < i1/2 + 1; i++)
32         p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
34     for (i = i0/2 - 1; i < i1/2 + 1; i++)
36         p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
38     for (i = i0/2 - 1; i < i1/2; i++)
--------------------------------------------------------------------------------------------------------------
Example ids:  1404 project:  FFmpeg commit id:  a28cccf6d62dc770757491510c248ed632a836ce Number of lines:  43
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_mlp']
0 static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)               {'linevul': 0, 'codebert': 0, 'PLBART': 0, 'devign': 0, 'regvd': 2, 'vulberta_mlp': 11}
2 {                                                                                                                                                      {'linevul': 22, 'codebert': 7, 'PLBART': 9, 'devign': -1, 'regvd': 36, 'vulberta_mlp': 35}
4     int   band, result=0, numSubbands, lastTonal, numBands;                                                                                            {'linevul': 6, 'codebert': 3, 'PLBART': 2, 'devign': 3, 'regvd': 15, 'vulberta_mlp': 2}
8     if (codingMode == JOINT_STEREO && channelNum == 1) {                                                                                               {'linevul': 8, 'codebert': 10, 'PLBART': 3, 'devign': 10, 'regvd': 18, 'vulberta_mlp': 33}
10         if (get_bits(gb,2) != 3) {                                                                                                                    {'linevul': 9, 'codebert': 9, 'PLBART': 5, 'devign': 14, 'regvd': 20, 'vulberta_mlp': 12}
12             av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n");                                                                                {'linevul': 3, 'codebert': 1, 'PLBART': 1, 'devign': -1, 'regvd': 8, 'vulberta_mlp': 15}
14             return -1;                                                                                                                                {'linevul': 14, 'codebert': 17, 'PLBART': 6, 'devign': 8, 'regvd': 33, 'vulberta_mlp': 34}
16         }                                                                                                                                             {'linevul': 18, 'codebert': 18, 'PLBART': 7, 'devign': -1, 'regvd': 42, 'vulberta_mlp': 10}
18     } else {                                                                                                                                          {'linevul': 20, 'codebert': 16, 'PLBART': 8, 'devign': -1, 'regvd': 35, 'vulberta_mlp': 23}
20         if (get_bits(gb,6) != 0x28) {                                                                                                                 {'linevul': 7, 'codebert': 11, 'PLBART': 4, 'devign': 13, 'regvd': 19, 'vulberta_mlp': 25}
22             av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n");                                                                                     {'linevul': 5, 'codebert': 2, 'PLBART': -1, 'devign': -1, 'regvd': 7, 'vulberta_mlp': 4}
24             return -1;                                                                                                                                {'linevul': 15, 'codebert': 15, 'PLBART': -1, 'devign': 7, 'regvd': 32, 'vulberta_mlp': 19}
26         }                                                                                                                                             {'linevul': 19, 'codebert': 14, 'PLBART': -1, 'devign': -1, 'regvd': 41, 'vulberta_mlp': 1}
28     }                                                                                                                                                 {'linevul': 21, 'codebert': 13, 'PLBART': -1, 'devign': -1, 'regvd': 40, 'vulberta_mlp': 9}
32     /* number of coded QMF bands */                                                                                                                   {'linevul': 16, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_mlp': -1}
34     pSnd->bandsCoded = get_bits(gb,2);                                                                                                                {'linevul': 12, 'codebert': 6, 'PLBART': -1, 'devign': 9, 'regvd': 5, 'vulberta_mlp': 5}
38     result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);                                                         {'linevul': 1, 'codebert': 4, 'PLBART': -1, 'devign': 4, 'regvd': 1, 'vulberta_mlp': 13}
40     if (result) return result;                                                                                                                        {'linevul': 17, 'codebert': 12, 'PLBART': -1, 'devign': 6, 'regvd': 27, 'vulberta_mlp': 24}
44     pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);                                                             {'linevul': 4, 'codebert': 5, 'PLBART': -1, 'devign': 5, 'regvd': 0, 'vulberta_mlp': 27}
46     if (pSnd->numComponents == -1) return -1;                                                                                                         {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 10, 'vulberta_mlp': 20}
50     numSubbands = decodeSpectrum (gb, pSnd->spectrum);                                                                                                {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 3, 'vulberta_mlp': 8}
54     /* Merge the decoded spectrum and tonal components. */                                                                                            {'linevul': 13, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_mlp': -1}
56     lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);                                                           {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 4, 'vulberta_mlp': 28}
62     /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_mlp': -1}
64     numBands = (subbandTab[numSubbands] - 1) >> 8;                                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 17, 'regvd': 11, 'vulberta_mlp': 32}
66     if (lastTonal >= 0)                                                                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 25, 'vulberta_mlp': 29}
68         numBands = FFMAX((lastTonal + 256) >> 8, numBands);                                                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 20, 'regvd': 14, 'vulberta_mlp': 18}
74     /* Reconstruct time domain samples. */                                                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_mlp': -1}
76     for (band=0; band<4; band++) {                                                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 1, 'regvd': 26, 'vulberta_mlp': 31}
78         /* Perform the IMDCT step without overlapping. */                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_mlp': -1}
80         if (band <= numBands) {                                                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 22, 'vulberta_mlp': 17}
82             IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 6, 'vulberta_mlp': 3}
84         } else                                                                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 37, 'vulberta_mlp': 26}
86             memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 9, 'vulberta_mlp': 30}
90         /* gain compensation and overlapping */                                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_mlp': -1}
92         gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 12, 'vulberta_mlp': 14}
94                                     &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_mlp': 16}
96                                     &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_mlp': 21}
98     }                                                                                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 39, 'vulberta_mlp': 7}
102     /* Swap the gain control buffers for the next frame. */                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_mlp': -1}
104     pSnd->gcBlkSwitch ^= 1;                                                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 23, 'vulberta_mlp': 0}
108     return 0;                                                                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 34, 'vulberta_mlp': 22}
110 }                                                                                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 38, 'vulberta_mlp': 6}
-----------------------
Highlighted lines: 
0 static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)
4     int   band, result=0, numSubbands, lastTonal, numBands;
12             av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n");
22             av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n");
34     pSnd->bandsCoded = get_bits(gb,2);
38     result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);
44     pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);
--------------------------------------------------------------------------------------------------------------
Example ids:  3322 project:  qemu commit id:  25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0 Number of lines:  28
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn']
0 qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,               {'linevul': 2, 'codebert': 0, 'PLBART': 0, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 20}
2                     size_t offset, size_t bytes, bool do_send)                     {'linevul': 1, 'codebert': 1, 'PLBART': 2, 'devign': 1, 'regvd': 8, 'vulberta_cnn': 22}
4 {                                                                                  {'linevul': 26, 'codebert': 2, 'PLBART': 15, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 5}
6     size_t done = 0;                                                               {'linevul': 21, 'codebert': 7, 'PLBART': 4, 'devign': 9, 'regvd': 14, 'vulberta_cnn': 11}
8     ssize_t ret;                                                                   {'linevul': 22, 'codebert': 4, 'PLBART': 14, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 3}
10     while (done < bytes) {                                                        {'linevul': 20, 'codebert': 10, 'PLBART': 8, 'devign': 2, 'regvd': 10, 'vulberta_cnn': 12}
12         ret = iov_send_recv(sockfd, iov,                                          {'linevul': 5, 'codebert': 3, 'PLBART': 1, 'devign': -1, 'regvd': 3, 'vulberta_cnn': 16}
14                             offset + done, bytes - done, do_send);                {'linevul': 0, 'codebert': 9, 'PLBART': 3, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 7}
16         if (ret > 0) {                                                            {'linevul': 17, 'codebert': 13, 'PLBART': 10, 'devign': 8, 'regvd': 12, 'vulberta_cnn': 15}
18             done += ret;                                                          {'linevul': 15, 'codebert': 12, 'PLBART': 11, 'devign': 7, 'regvd': 17, 'vulberta_cnn': 14}
20         } else if (ret < 0) {                                                     {'linevul': 14, 'codebert': 15, 'PLBART': 6, 'devign': 4, 'regvd': 7, 'vulberta_cnn': 19}
22             if (errno == EAGAIN) {                                                {'linevul': 9, 'codebert': 5, 'PLBART': 7, 'devign': 10, 'regvd': 15, 'vulberta_cnn': 4}
24                 qemu_coroutine_yield();                                           {'linevul': 4, 'codebert': 6, 'PLBART': 9, 'devign': 14, 'regvd': 9, 'vulberta_cnn': 17}
26             } else if (done == 0) {                                               {'linevul': 11, 'codebert': 14, 'PLBART': 5, 'devign': 6, 'regvd': 6, 'vulberta_cnn': 6}
28                 return -1;                                                        {'linevul': 12, 'codebert': 16, 'PLBART': 13, 'devign': 15, 'regvd': 19, 'vulberta_cnn': 13}
30             } else {                                                              {'linevul': 16, 'codebert': 18, 'PLBART': 12, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 1}
32                 break;                                                            {'linevul': 13, 'codebert': 19, 'PLBART': -1, 'devign': 12, 'regvd': 23, 'vulberta_cnn': 10}
34             }                                                                     {'linevul': 19, 'codebert': 17, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 9}
36         } else if (ret == 0 && !do_send) {                                        {'linevul': 10, 'codebert': 11, 'PLBART': -1, 'devign': 3, 'regvd': 0, 'vulberta_cnn': 21}
38             /* write (send) should never return 0.                                {'linevul': 8, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 4, 'vulberta_cnn': -1}
40              * read (recv) returns 0 for end-of-file (-data).                     {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 2, 'vulberta_cnn': -1}
42              * In both cases there's little point retrying,                       {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_cnn': -1}
44              * but we do for write anyway, just in case */                        {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': -1}
46             break;                                                                {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 22, 'vulberta_cnn': 8}
48         }                                                                         {'linevul': 23, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 2}
50     }                                                                             {'linevul': 25, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 0}
52     return done;                                                                  {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 18, 'vulberta_cnn': 18}
54 }                                                                                 {'linevul': 27, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 23}
-----------------------
Highlighted lines: 
0 qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
2                     size_t offset, size_t bytes, bool do_send)
12         ret = iov_send_recv(sockfd, iov,
14                             offset + done, bytes - done, do_send);
22             if (errno == EAGAIN) {
24                 qemu_coroutine_yield();
26             } else if (done == 0) {
--------------------------------------------------------------------------------------------------------------
Example ids:  3722 project:  FFmpeg commit id:  dae7ff04160901a30a35af05f2f149b289c4f0b1 Number of lines:  24
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void decode_mclms(WmallDecodeCtx *s)                                                      {'linevul': 10, 'codebert': 0, 'PLBART': 4, 'devign': 10, 'regvd': 10, 'vulberta_cnn': 9, 'vulberta_mlp': 6}
2 {                                                                                                {'linevul': 23, 'codebert': 10, 'PLBART': 11, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 7, 'vulberta_mlp': 20}
4     s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;                                              {'linevul': 4, 'codebert': 9, 'PLBART': 0, 'devign': 15, 'regvd': 1, 'vulberta_cnn': 1, 'vulberta_mlp': 2}
6     s->mclms_scaling = get_bits(&s->gb, 4);                                                      {'linevul': 6, 'codebert': 5, 'PLBART': 6, 'devign': 11, 'regvd': 6, 'vulberta_cnn': 0, 'vulberta_mlp': 7}
8     if(get_bits1(&s->gb)) {                                                                      {'linevul': 12, 'codebert': 13, 'PLBART': 5, 'devign': 8, 'regvd': 11, 'vulberta_cnn': 3, 'vulberta_mlp': 8}
10 	// mclms_send_coef                                                                             {'linevul': 13, 'codebert': 4, 'PLBART': 7, 'devign': -1, 'regvd': 14, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
12 	int i;                                                                                         {'linevul': 19, 'codebert': 19, 'PLBART': 10, 'devign': 16, 'regvd': 17, 'vulberta_cnn': 6, 'vulberta_mlp': 22}
14 	int send_coef_bits;                                                                            {'linevul': 14, 'codebert': 14, 'PLBART': 8, 'devign': 9, 'regvd': 12, 'vulberta_cnn': 16, 'vulberta_mlp': 18}
16 	int cbits = av_log2(s->mclms_scaling + 1);                                                     {'linevul': 7, 'codebert': 3, 'PLBART': 1, 'devign': 6, 'regvd': 4, 'vulberta_cnn': 18, 'vulberta_mlp': 9}
18 	assert(cbits == my_log2(s->mclms_scaling + 1));                                                {'linevul': 5, 'codebert': 8, 'PLBART': 3, 'devign': 14, 'regvd': 3, 'vulberta_cnn': 2, 'vulberta_mlp': 4}
20 	if(1 << cbits < s->mclms_scaling + 1)                                                          {'linevul': 9, 'codebert': 12, 'PLBART': 2, 'devign': 5, 'regvd': 8, 'vulberta_cnn': 5, 'vulberta_mlp': 10}
22 	    cbits++;                                                                                   {'linevul': 16, 'codebert': 15, 'PLBART': 12, 'devign': 4, 'regvd': 15, 'vulberta_cnn': 15, 'vulberta_mlp': 17}
26 	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;                                    {'linevul': 3, 'codebert': 11, 'PLBART': 9, 'devign': 3, 'regvd': 7, 'vulberta_cnn': 8, 'vulberta_mlp': 5}
30 	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {                      {'linevul': 1, 'codebert': 7, 'PLBART': -1, 'devign': 0, 'regvd': 5, 'vulberta_cnn': 19, 'vulberta_mlp': 15}
32 	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);                                     {'linevul': 2, 'codebert': 2, 'PLBART': -1, 'devign': 13, 'regvd': 2, 'vulberta_cnn': 21, 'vulberta_mlp': 1}
34 	}                                                                                              {'linevul': 21, 'codebert': 21, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 10, 'vulberta_mlp': 0}
38 	for(i = 0; i < s->num_channels; i++) {                                                         {'linevul': 8, 'codebert': 6, 'PLBART': -1, 'devign': 1, 'regvd': 9, 'vulberta_cnn': 20, 'vulberta_mlp': 14}
40 	    int c;                                                                                     {'linevul': 15, 'codebert': 20, 'PLBART': -1, 'devign': 12, 'regvd': 16, 'vulberta_cnn': 14, 'vulberta_mlp': 16}
42 	    for(c = 0; c < i; c++) {                                                                   {'linevul': 11, 'codebert': 18, 'PLBART': -1, 'devign': 2, 'regvd': 13, 'vulberta_cnn': 13, 'vulberta_mlp': 21}
44 		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);              {'linevul': 0, 'codebert': 1, 'PLBART': -1, 'devign': 7, 'regvd': 0, 'vulberta_cnn': 17, 'vulberta_mlp': 11}
46 	    }                                                                                          {'linevul': 17, 'codebert': 22, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 4, 'vulberta_mlp': 13}
48 	}                                                                                              {'linevul': 20, 'codebert': 23, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 12, 'vulberta_mlp': 12}
50     }                                                                                           {'linevul': 18, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 11, 'vulberta_mlp': 19}
52 }                                                                                               {'linevul': 22, 'codebert': 17, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 22, 'vulberta_mlp': 3}
-----------------------
Highlighted lines: 
0 static void decode_mclms(WmallDecodeCtx *s)
4     s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
6     s->mclms_scaling = get_bits(&s->gb, 4);
8     if(get_bits1(&s->gb)) {
16 	int cbits = av_log2(s->mclms_scaling + 1);
18 	assert(cbits == my_log2(s->mclms_scaling + 1));
20 	if(1 << cbits < s->mclms_scaling + 1)
26 	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
30 	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
32 	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
38 	for(i = 0; i < s->num_channels; i++) {
44 		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
--------------------------------------------------------------------------------------------------------------
Example ids:  4009 project:  FFmpeg commit id:  6f1b2967712e25e4c39c506862982b3011e06532 Number of lines:  49
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,                         {'linevul': 3, 'codebert': 1, 'PLBART': 0, 'devign': 3, 'regvd': 7, 'vulberta_cnn': 42, 'vulberta_mlp': 24}
2                                     const uint8_t *src, const uint8_t *src_end,               {'linevul': 0, 'codebert': 14, 'PLBART': 2, 'devign': 24, 'regvd': 16, 'vulberta_cnn': 22, 'vulberta_mlp': 18}
4                                     int width, int esc_count)                                 {'linevul': 1, 'codebert': 13, 'PLBART': 6, 'devign': 22, 'regvd': 22, 'vulberta_cnn': 43, 'vulberta_mlp': 6}
6 {                                                                                             {'linevul': 26, 'codebert': 15, 'PLBART': 10, 'devign': -1, 'regvd': 42, 'vulberta_cnn': 24, 'vulberta_mlp': 35}
8     int i = 0;                                                                                {'linevul': 22, 'codebert': 18, 'PLBART': 9, 'devign': 20, 'regvd': 37, 'vulberta_cnn': 30, 'vulberta_mlp': 48}
10     int count;                                                                               {'linevul': 23, 'codebert': 17, 'PLBART': 11, 'devign': 33, 'regvd': 38, 'vulberta_cnn': 26, 'vulberta_mlp': 44}
12     uint8_t zero_run = 0;                                                                    {'linevul': 17, 'codebert': 16, 'PLBART': 7, 'devign': 1, 'regvd': 18, 'vulberta_cnn': 2, 'vulberta_mlp': 43}
14     const uint8_t *src_start = src;                                                          {'linevul': 15, 'codebert': 12, 'PLBART': 4, 'devign': 23, 'regvd': 17, 'vulberta_cnn': 17, 'vulberta_mlp': 41}
16     uint8_t mask1 = -(esc_count < 2);                                                        {'linevul': 9, 'codebert': 3, 'PLBART': 1, 'devign': 11, 'regvd': 5, 'vulberta_cnn': 41, 'vulberta_mlp': 27}
18     uint8_t mask2 = -(esc_count < 3);                                                        {'linevul': 8, 'codebert': 2, 'PLBART': 8, 'devign': 10, 'regvd': 6, 'vulberta_cnn': 3, 'vulberta_mlp': 8}
20     uint8_t *end = dst + (width - 2);                                                        {'linevul': 11, 'codebert': 11, 'PLBART': 5, 'devign': 9, 'regvd': 4, 'vulberta_cnn': 21, 'vulberta_mlp': 0}
24     avpriv_request_sample(l->avctx, "zero_run_line");                                        {'linevul': 5, 'codebert': 9, 'PLBART': 3, 'devign': 17, 'regvd': 3, 'vulberta_cnn': 46, 'vulberta_mlp': 2}
26     return AVERROR_PATCHWELCOME;                                                             {'linevul': 14, 'codebert': 10, 'PLBART': 12, 'devign': 34, 'regvd': 27, 'vulberta_cnn': 6, 'vulberta_mlp': 1}
30 output_zeros:                                                                                {'linevul': 24, 'codebert': 0, 'PLBART': -1, 'devign': 38, 'regvd': 36, 'vulberta_cnn': 10, 'vulberta_mlp': 12}
32     if (l->zeros_rem) {                                                                      {'linevul': 16, 'codebert': 6, 'PLBART': -1, 'devign': 29, 'regvd': 10, 'vulberta_cnn': 5, 'vulberta_mlp': 7}
34         count = FFMIN(l->zeros_rem, width - i);                                              {'linevul': 4, 'codebert': 5, 'PLBART': -1, 'devign': 14, 'regvd': 1, 'vulberta_cnn': 0, 'vulberta_mlp': 9}
36         if (end - dst < count) {                                                             {'linevul': 13, 'codebert': 4, 'PLBART': -1, 'devign': 7, 'regvd': 13, 'vulberta_cnn': 15, 'vulberta_mlp': 22}
38             av_log(l->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n");                   {'linevul': 2, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 40, 'vulberta_mlp': 4}
40             return AVERROR_INVALIDDATA;                                                      {'linevul': 6, 'codebert': 7, 'PLBART': -1, 'devign': 32, 'regvd': 29, 'vulberta_cnn': 37, 'vulberta_mlp': 39}
42         }                                                                                    {'linevul': 21, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 48, 'vulberta_cnn': 31, 'vulberta_mlp': 34}
46         memset(dst, 0, count);                                                               {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 36, 'regvd': 19, 'vulberta_cnn': 4, 'vulberta_mlp': 40}
48         l->zeros_rem -= count;                                                               {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 12, 'vulberta_cnn': 32, 'vulberta_mlp': 19}
50         dst += count;                                                                        {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': 26, 'regvd': 26, 'vulberta_cnn': 12, 'vulberta_mlp': 25}
52     }                                                                                        {'linevul': 25, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 47, 'vulberta_cnn': 14, 'vulberta_mlp': 11}
56     while (dst < end) {                                                                      {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 21, 'vulberta_cnn': 44, 'vulberta_mlp': 15}
58         i = 0;                                                                               {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': 30, 'regvd': 39, 'vulberta_cnn': 29, 'vulberta_mlp': 45}
60         while (!zero_run && dst + i < end) {                                                 {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 8, 'vulberta_cnn': 45, 'vulberta_mlp': 37}
62             i++;                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 25, 'regvd': 40, 'vulberta_cnn': 28, 'vulberta_mlp': 47}
64             if (i+2 >= src_end - src)                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 28, 'regvd': 9, 'vulberta_cnn': 1, 'vulberta_mlp': 36}
66                 return AVERROR_INVALIDDATA;                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 31, 'regvd': 28, 'vulberta_cnn': 35, 'vulberta_mlp': 33}
68             zero_run =                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 35, 'vulberta_cnn': 9, 'vulberta_mlp': 42}
70                 !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_cnn': 16, 'vulberta_mlp': 13}
72         }                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 46, 'vulberta_cnn': 18, 'vulberta_mlp': 32}
74         if (zero_run) {                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 20, 'vulberta_cnn': 36, 'vulberta_mlp': 38}
76             zero_run = 0;                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 24, 'vulberta_cnn': 27, 'vulberta_mlp': 46}
78             i += esc_count;                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 23, 'vulberta_cnn': 11, 'vulberta_mlp': 3}
80             memcpy(dst, src, i);                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 15, 'vulberta_cnn': 7, 'vulberta_mlp': 26}
82             dst += i;                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 31, 'vulberta_cnn': 20, 'vulberta_mlp': 20}
84             l->zeros_rem = lag_calc_zero_run(src[i]);                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 2, 'vulberta_cnn': 47, 'vulberta_mlp': 16}
88             src += i + 1;                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 32, 'vulberta_cnn': 8, 'vulberta_mlp': 23}
90             goto output_zeros;                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 37, 'regvd': 33, 'vulberta_cnn': 34, 'vulberta_mlp': 14}
92         } else {                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 41, 'vulberta_cnn': 13, 'vulberta_mlp': 31}
94             memcpy(dst, src, i);                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 33, 'vulberta_mlp': 21}
96             src += i;                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 34, 'vulberta_cnn': 25, 'vulberta_mlp': 17}
98             dst += i;                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 30, 'vulberta_cnn': 39, 'vulberta_mlp': 30}
100         }                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 45, 'vulberta_cnn': 23, 'vulberta_mlp': 29}
102     }                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 44, 'vulberta_cnn': 19, 'vulberta_mlp': 28}
104     return  src - src_start;                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 35, 'regvd': 25, 'vulberta_cnn': 38, 'vulberta_mlp': 5}
106 }                                                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 43, 'vulberta_cnn': 48, 'vulberta_mlp': 10}
-----------------------
Highlighted lines: 
0 static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,
16     uint8_t mask1 = -(esc_count < 2);
18     uint8_t mask2 = -(esc_count < 3);
20     uint8_t *end = dst + (width - 2);
24     avpriv_request_sample(l->avctx, "zero_run_line");
34         count = FFMIN(l->zeros_rem, width - i);
38             av_log(l->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n");
--------------------------------------------------------------------------------------------------------------
Example ids:  4815 project:  qemu commit id:  b3f7f0c5e6449be7275f1762bccbfa2177395a3b Number of lines:  44
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void colo_process_checkpoint(MigrationState *s)                                        {'linevul': 12, 'codebert': 1, 'PLBART': 2, 'devign': 1, 'regvd': 10, 'vulberta_cnn': 3, 'vulberta_mlp': 1}
1 {                                                                                             {'linevul': 26, 'codebert': 0, 'PLBART': 10, 'devign': -1, 'regvd': 43, 'vulberta_cnn': 24, 'vulberta_mlp': 6}
2     QIOChannelBuffer *bioc;                                                                   {'linevul': 17, 'codebert': 2, 'PLBART': 5, 'devign': 4, 'regvd': 33, 'vulberta_cnn': 17, 'vulberta_mlp': 7}
3     QEMUFile *fb = NULL;                                                                      {'linevul': 16, 'codebert': 7, 'PLBART': 6, 'devign': 0, 'regvd': 35, 'vulberta_cnn': 13, 'vulberta_mlp': 30}
4     int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);               {'linevul': 2, 'codebert': 11, 'PLBART': 1, 'devign': 3, 'regvd': 0, 'vulberta_cnn': 12, 'vulberta_mlp': 16}
5     Error *local_err = NULL;                                                                  {'linevul': 18, 'codebert': 16, 'PLBART': 7, 'devign': 2, 'regvd': 30, 'vulberta_cnn': 26, 'vulberta_mlp': 37}
6     int ret;                                                                                  {'linevul': 23, 'codebert': 18, 'PLBART': 9, 'devign': 8, 'regvd': 39, 'vulberta_cnn': 35, 'vulberta_mlp': 35}
7     failover_init_state();                                                                    {'linevul': 19, 'codebert': 20, 'PLBART': 8, 'devign': 6, 'regvd': 20, 'vulberta_cnn': 23, 'vulberta_mlp': 10}
8     s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);                    {'linevul': 1, 'codebert': 10, 'PLBART': 0, 'devign': 5, 'regvd': 4, 'vulberta_cnn': 5, 'vulberta_mlp': 32}
9     if (!s->rp_state.from_dst_file) {                                                         {'linevul': 9, 'codebert': 4, 'PLBART': 3, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 4, 'vulberta_mlp': 2}
10         error_report("Open QEMUFile from_dst_file failed");                                  {'linevul': 7, 'codebert': 5, 'PLBART': 4, 'devign': -1, 'regvd': 3, 'vulberta_cnn': 38, 'vulberta_mlp': 12}
11     /*                                                                                       {'linevul': 25, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 40, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
12      * Wait for Secondary finish loading VM states and enter COLO                            {'linevul': 13, 'codebert': 15, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
13      * restore.                                                                              {'linevul': 22, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 37, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
14      */                                                                                      {'linevul': 24, 'codebert': 17, 'PLBART': -1, 'devign': -1, 'regvd': 41, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
15     colo_receive_check_message(s->rp_state.from_dst_file,                                    {'linevul': 4, 'codebert': 13, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 11, 'vulberta_mlp': 4}
16                        COLO_MESSAGE_CHECKPOINT_READY, &local_err);                           {'linevul': 0, 'codebert': 6, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 33, 'vulberta_mlp': 27}
17     if (local_err) {                                                                         {'linevul': 20, 'codebert': 14, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 34, 'vulberta_mlp': 15}
18     bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);                                    {'linevul': 6, 'codebert': 12, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 30, 'vulberta_mlp': 3}
19     fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));                                       {'linevul': 5, 'codebert': 9, 'PLBART': -1, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 20, 'vulberta_mlp': 17}
20     object_unref(OBJECT(bioc));                                                              {'linevul': 15, 'codebert': 3, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 0, 'vulberta_mlp': 25}
21     qemu_mutex_lock_iothread();                                                              {'linevul': 14, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 16, 'vulberta_mlp': 29}
22     vm_start();                                                                              {'linevul': 21, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 22, 'vulberta_mlp': 38}
23     qemu_mutex_unlock_iothread();                                                            {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 9, 'vulberta_mlp': 24}
24     trace_colo_vm_state_change("stop", "run");                                               {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_cnn': 15, 'vulberta_mlp': 9}
25     while (s->state == MIGRATION_STATUS_COLO) {                                              {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 14, 'vulberta_mlp': 23}
26         current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);                                   {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 1, 'vulberta_mlp': 14}
27         if (current_time - checkpoint_time <                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 7, 'vulberta_mlp': 5}
28             s->parameters.x_checkpoint_delay) {                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 6, 'vulberta_mlp': 13}
29             int64_t delay_ms;                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 31, 'vulberta_mlp': 33}
30             delay_ms = s->parameters.x_checkpoint_delay -                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 10, 'vulberta_mlp': 28}
31                        (current_time - checkpoint_time);                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 29, 'vulberta_mlp': 31}
32             g_usleep(delay_ms * 1000);                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 19, 'vulberta_mlp': 18}
33         ret = colo_do_checkpoint_transaction(s, bioc, fb);                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 6, 'vulberta_cnn': 37, 'vulberta_mlp': 11}
34         if (ret < 0) {                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 36, 'vulberta_cnn': 36, 'vulberta_mlp': 0}
35         checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 8, 'vulberta_mlp': 19}
36 out:                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 42, 'vulberta_cnn': 21, 'vulberta_mlp': 22}
37     /* Throw the unreported error message after exited from loop */                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 34, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
38     if (local_err) {                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 27, 'vulberta_mlp': 21}
39         error_report_err(local_err);                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 18, 'vulberta_mlp': 26}
40     if (fb) {                                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 38, 'vulberta_cnn': 25, 'vulberta_mlp': 36}
41         qemu_fclose(fb);                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 32, 'vulberta_mlp': 20}
42     if (s->rp_state.from_dst_file) {                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 28, 'vulberta_mlp': 34}
43         qemu_fclose(s->rp_state.from_dst_file);                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 7, 'vulberta_cnn': 2, 'vulberta_mlp': 8}
-----------------------
Highlighted lines: 
0 static void colo_process_checkpoint(MigrationState *s)
2     QIOChannelBuffer *bioc;
4     int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
8     s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
9     if (!s->rp_state.from_dst_file) {
10         error_report("Open QEMUFile from_dst_file failed");
43         qemu_fclose(s->rp_state.from_dst_file);
--------------------------------------------------------------------------------------------------------------
Example ids:  5905 project:  FFmpeg commit id:  d6945aeee419a8417b8019c7c92227e12e45b7ad Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_mlp']
0 static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)               {'linevul': 0, 'codebert': 0, 'PLBART': 0, 'devign': 1, 'regvd': 0, 'vulberta_mlp': 15}
2 {                                                                                              {'linevul': 18, 'codebert': 15, 'PLBART': 16, 'devign': -1, 'regvd': 17, 'vulberta_mlp': 19}
4     int i;                                                                                     {'linevul': 16, 'codebert': 6, 'PLBART': 14, 'devign': 15, 'regvd': 16, 'vulberta_mlp': 18}
6     pixel *dst = (pixel *) _dst;                                                               {'linevul': 12, 'codebert': 2, 'PLBART': 3, 'devign': 4, 'regvd': 3, 'vulberta_mlp': 17}
8     dctcoef *src = (dctcoef *) _src;                                                           {'linevul': 2, 'codebert': 1, 'PLBART': 2, 'devign': 5, 'regvd': 2, 'vulberta_mlp': 16}
10     stride /= sizeof(pixel);                                                                  {'linevul': 15, 'codebert': 4, 'PLBART': 10, 'devign': 14, 'regvd': 4, 'vulberta_mlp': 1}
14     for (i = 0; i < 8; i++) {                                                                 {'linevul': 11, 'codebert': 8, 'PLBART': 1, 'devign': 0, 'regvd': 13, 'vulberta_mlp': 11}
16         dst[0] += src[0];                                                                     {'linevul': 10, 'codebert': 11, 'PLBART': 7, 'devign': 12, 'regvd': 5, 'vulberta_mlp': 10}
18         dst[1] += src[1];                                                                     {'linevul': 9, 'codebert': 9, 'PLBART': 11, 'devign': 7, 'regvd': 10, 'vulberta_mlp': 7}
20         dst[2] += src[2];                                                                     {'linevul': 8, 'codebert': 10, 'PLBART': 6, 'devign': 10, 'regvd': 11, 'vulberta_mlp': 6}
22         dst[3] += src[3];                                                                     {'linevul': 7, 'codebert': 13, 'PLBART': 12, 'devign': 8, 'regvd': 12, 'vulberta_mlp': 3}
24         dst[4] += src[4];                                                                     {'linevul': 6, 'codebert': 17, 'PLBART': 13, 'devign': 11, 'regvd': 9, 'vulberta_mlp': 4}
26         dst[5] += src[5];                                                                     {'linevul': 5, 'codebert': 16, 'PLBART': 4, 'devign': 13, 'regvd': 7, 'vulberta_mlp': 9}
28         dst[6] += src[6];                                                                     {'linevul': 4, 'codebert': 14, 'PLBART': 8, 'devign': 9, 'regvd': 6, 'vulberta_mlp': 12}
30         dst[7] += src[7];                                                                     {'linevul': 3, 'codebert': 12, 'PLBART': 5, 'devign': 6, 'regvd': 8, 'vulberta_mlp': 13}
34         dst += stride;                                                                        {'linevul': 13, 'codebert': 7, 'PLBART': 15, 'devign': 2, 'regvd': 14, 'vulberta_mlp': 8}
36         src += 8;                                                                             {'linevul': 14, 'codebert': 18, 'PLBART': 9, 'devign': 3, 'regvd': 15, 'vulberta_mlp': 2}
38     }                                                                                         {'linevul': 17, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_mlp': 14}
42     memset(_src, 0, sizeof(dctcoef) * 64);                                                    {'linevul': 1, 'codebert': 3, 'PLBART': -1, 'devign': 16, 'regvd': 1, 'vulberta_mlp': 0}
44 }                                                                                             {'linevul': 19, 'codebert': 5, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_mlp': 5}
-----------------------
Highlighted lines: 
0 static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)
6     pixel *dst = (pixel *) _dst;
8     dctcoef *src = (dctcoef *) _src;
18         dst[1] += src[1];
26         dst[5] += src[5];
28         dst[6] += src[6];
30         dst[7] += src[7];
42     memset(_src, 0, sizeof(dctcoef) * 64);
--------------------------------------------------------------------------------------------------------------
Example ids:  6108 project:  qemu commit id:  2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3 Number of lines:  33
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,                      {'linevul': 6, 'codebert': 1, 'PLBART': 0, 'regvd': 5, 'vulberta_cnn': 29, 'vulberta_mlp': 22}
2                                      const void *match_data, hwaddr *load_addr)               {'linevul': 0, 'codebert': 0, 'PLBART': 6, 'regvd': 16, 'vulberta_cnn': 4, 'vulberta_mlp': 30}
4 {                                                                                             {'linevul': 25, 'codebert': 14, 'PLBART': 11, 'regvd': 29, 'vulberta_cnn': 11, 'vulberta_mlp': 11}
6     BostonState *s = BOSTON(opaque);                                                          {'linevul': 14, 'codebert': 3, 'PLBART': 4, 'regvd': 13, 'vulberta_cnn': 18, 'vulberta_mlp': 8}
8     MachineState *machine = s->mach;                                                          {'linevul': 15, 'codebert': 8, 'PLBART': 5, 'regvd': 19, 'vulberta_cnn': 5, 'vulberta_mlp': 15}
10     const char *cmdline;                                                                     {'linevul': 19, 'codebert': 12, 'PLBART': 9, 'regvd': 21, 'vulberta_cnn': 20, 'vulberta_mlp': 24}
12     int err;                                                                                 {'linevul': 22, 'codebert': 15, 'PLBART': 10, 'regvd': 28, 'vulberta_cnn': 13, 'vulberta_mlp': 31}
14     void *fdt;                                                                               {'linevul': 21, 'codebert': 11, 'PLBART': 8, 'regvd': 22, 'vulberta_cnn': 21, 'vulberta_mlp': 32}
16     size_t fdt_sz, ram_low_sz, ram_high_sz;                                                  {'linevul': 5, 'codebert': 7, 'PLBART': 1, 'regvd': 11, 'vulberta_cnn': 6, 'vulberta_mlp': 25}
20     fdt_sz = fdt_totalsize(fdt_orig) * 2;                                                    {'linevul': 8, 'codebert': 6, 'PLBART': 2, 'regvd': 7, 'vulberta_cnn': 0, 'vulberta_mlp': 9}
22     fdt = g_malloc0(fdt_sz);                                                                 {'linevul': 13, 'codebert': 2, 'PLBART': 7, 'regvd': 9, 'vulberta_cnn': 26, 'vulberta_mlp': 14}
26     err = fdt_open_into(fdt_orig, fdt, fdt_sz);                                              {'linevul': 4, 'codebert': 10, 'PLBART': 3, 'regvd': 3, 'vulberta_cnn': 2, 'vulberta_mlp': 18}
28     if (err) {                                                                               {'linevul': 20, 'codebert': 16, 'PLBART': -1, 'regvd': 25, 'vulberta_cnn': 19, 'vulberta_mlp': 27}
30         fprintf(stderr, "unable to open FDT\n");                                             {'linevul': 9, 'codebert': 13, 'PLBART': -1, 'regvd': 8, 'vulberta_cnn': 7, 'vulberta_mlp': 7}
32         return NULL;                                                                         {'linevul': 18, 'codebert': 18, 'PLBART': -1, 'regvd': 27, 'vulberta_cnn': 12, 'vulberta_mlp': 29}
34     }                                                                                        {'linevul': 24, 'codebert': 19, 'PLBART': -1, 'regvd': 32, 'vulberta_cnn': 10, 'vulberta_mlp': 10}
38     cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])                        {'linevul': 10, 'codebert': 4, 'PLBART': -1, 'regvd': 12, 'vulberta_cnn': 1, 'vulberta_mlp': 17}
40             ? machine->kernel_cmdline : " ";                                                 {'linevul': 12, 'codebert': 9, 'PLBART': -1, 'regvd': 18, 'vulberta_cnn': 24, 'vulberta_mlp': 16}
42     err = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs", cmdline);                      {'linevul': 1, 'codebert': 5, 'PLBART': -1, 'regvd': 0, 'vulberta_cnn': 22, 'vulberta_mlp': 2}
44     if (err < 0) {                                                                           {'linevul': 17, 'codebert': 17, 'PLBART': -1, 'regvd': 23, 'vulberta_cnn': 8, 'vulberta_mlp': 23}
46         fprintf(stderr, "couldn't set /chosen/bootargs\n");                                  {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'regvd': 6, 'vulberta_cnn': 30, 'vulberta_mlp': 0}
48         return NULL;                                                                         {'linevul': 16, 'codebert': -1, 'PLBART': -1, 'regvd': 26, 'vulberta_cnn': 3, 'vulberta_mlp': 28}
50     }                                                                                        {'linevul': 23, 'codebert': -1, 'PLBART': -1, 'regvd': 31, 'vulberta_cnn': 16, 'vulberta_mlp': 4}
54     ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);                                       {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'regvd': 1, 'vulberta_cnn': 17, 'vulberta_mlp': 12}
56     ram_high_sz = machine->ram_size - ram_low_sz;                                            {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'regvd': 14, 'vulberta_cnn': 32, 'vulberta_mlp': 21}
58     qemu_fdt_setprop_sized_cells(fdt, "/memory@0", "reg",                                    {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'regvd': 2, 'vulberta_cnn': 28, 'vulberta_mlp': 5}
60                                  1, 0x00000000, 1, ram_low_sz,                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 20, 'vulberta_cnn': 14, 'vulberta_mlp': 20}
62                                  1, 0x90000000, 1, ram_high_sz);                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 17, 'vulberta_cnn': 23, 'vulberta_mlp': 6}
66     fdt = g_realloc(fdt, fdt_totalsize(fdt));                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 4, 'vulberta_cnn': 9, 'vulberta_mlp': 13}
68     qemu_fdt_dumpdtb(fdt, fdt_sz);                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 10, 'vulberta_cnn': 15, 'vulberta_mlp': 19}
72     s->fdt_base = *load_addr;                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 15, 'vulberta_cnn': 27, 'vulberta_mlp': 26}
76     return fdt;                                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 24, 'vulberta_cnn': 25, 'vulberta_mlp': 3}
78 }                                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 30, 'vulberta_cnn': 31, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,
2                                      const void *match_data, hwaddr *load_addr)
16     size_t fdt_sz, ram_low_sz, ram_high_sz;
20     fdt_sz = fdt_totalsize(fdt_orig) * 2;
26     err = fdt_open_into(fdt_orig, fdt, fdt_sz);
30         fprintf(stderr, "unable to open FDT\n");
42     err = qemu_fdt_setprop_string(fdt, "/chosen", "bootargs", cmdline);
--------------------------------------------------------------------------------------------------------------
Example ids:  6727 project:  FFmpeg commit id:  221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4 Number of lines:  37
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)                           {'linevul': 7, 'codebert': 5, 'PLBART': 0, 'devign': 1, 'regvd': 9, 'vulberta_cnn': 12, 'vulberta_mlp': 5}
2 {                                                                                                          {'linevul': 20, 'codebert': 16, 'PLBART': 9, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 20, 'vulberta_mlp': 34}
4     YADIFContext *s = ctx->priv;                                                                           {'linevul': 14, 'codebert': 1, 'PLBART': 6, 'devign': 12, 'regvd': 20, 'vulberta_cnn': 29, 'vulberta_mlp': 31}
6     ThreadData *td  = arg;                                                                                 {'linevul': 17, 'codebert': 8, 'PLBART': 8, 'devign': 3, 'regvd': 26, 'vulberta_cnn': 11, 'vulberta_mlp': 32}
8     int refs = s->cur->linesize[td->plane];                                                                {'linevul': 11, 'codebert': 4, 'PLBART': 3, 'devign': 13, 'regvd': 11, 'vulberta_cnn': 21, 'vulberta_mlp': 11}
10     int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;                                              {'linevul': 6, 'codebert': 0, 'PLBART': 1, 'devign': 14, 'regvd': 1, 'vulberta_cnn': 18, 'vulberta_mlp': 12}
12     int pix_3 = 3 * df;                                                                                   {'linevul': 16, 'codebert': 2, 'PLBART': 7, 'devign': 15, 'regvd': 25, 'vulberta_cnn': 16, 'vulberta_mlp': 25}
14     int slice_h = td->h / nb_jobs;                                                                        {'linevul': 13, 'codebert': 6, 'PLBART': 4, 'devign': 8, 'regvd': 8, 'vulberta_cnn': 14, 'vulberta_mlp': 18}
16     int slice_start = jobnr * slice_h;                                                                    {'linevul': 15, 'codebert': 14, 'PLBART': 5, 'devign': 11, 'regvd': 15, 'vulberta_cnn': 5, 'vulberta_mlp': 22}
18     int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;                             {'linevul': 2, 'codebert': 3, 'PLBART': 2, 'devign': 2, 'regvd': 0, 'vulberta_cnn': 31, 'vulberta_mlp': 20}
20     int y;                                                                                                {'linevul': 18, 'codebert': 18, 'PLBART': -1, 'devign': 16, 'regvd': 29, 'vulberta_cnn': 7, 'vulberta_mlp': 29}
24     /* filtering reads 3 pixels to the left/right; to avoid invalid reads,                                {'linevul': 10, 'codebert': 10, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
26      * we need to call the c variant which avoids this for border pixels                                  {'linevul': 12, 'codebert': 13, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 15, 'vulberta_mlp': 33}
28      */                                                                                                   {'linevul': 19, 'codebert': 17, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
30     for (y = slice_start; y < slice_end; y++) {                                                           {'linevul': 9, 'codebert': 15, 'PLBART': -1, 'devign': 0, 'regvd': 12, 'vulberta_cnn': 1, 'vulberta_mlp': 28}
32         if ((y ^ td->parity) & 1) {                                                                       {'linevul': 8, 'codebert': 7, 'PLBART': -1, 'devign': 6, 'regvd': 19, 'vulberta_cnn': 4, 'vulberta_mlp': 2}
34             uint8_t *prev = &s->prev->data[td->plane][y * refs];                                          {'linevul': 5, 'codebert': 12, 'PLBART': -1, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 28, 'vulberta_mlp': 8}
36             uint8_t *cur  = &s->cur ->data[td->plane][y * refs];                                          {'linevul': 3, 'codebert': 11, 'PLBART': -1, 'devign': 5, 'regvd': 2, 'vulberta_cnn': 3, 'vulberta_mlp': 6}
38             uint8_t *next = &s->next->data[td->plane][y * refs];                                          {'linevul': 4, 'codebert': 9, 'PLBART': -1, 'devign': 4, 'regvd': 5, 'vulberta_cnn': 17, 'vulberta_mlp': 10}
40             uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 3, 'vulberta_cnn': 9, 'vulberta_mlp': 9}
42             int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;                                       {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 26}
44             s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 8, 'vulberta_mlp': 13}
46                            next + pix_3, td->w - 6,                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 23, 'vulberta_mlp': 27}
48                            y + 1 < td->h ? refs : -refs,                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 33, 'vulberta_mlp': 17}
50                            y ? -refs : refs,                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 24, 'vulberta_mlp': 19}
52                            td->parity ^ td->tff, mode);                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 22, 'vulberta_mlp': 23}
54             s->filter_edges(dst, prev, cur, next, td->w,                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 2, 'vulberta_mlp': 7}
56                             y + 1 < td->h ? refs : -refs,                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 0, 'vulberta_mlp': 30}
58                             y ? -refs : refs,                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 25, 'vulberta_mlp': 24}
60                             td->parity ^ td->tff, mode);                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 32, 'vulberta_mlp': 4}
62         } else {                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 26, 'vulberta_mlp': 15}
64             memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 30, 'vulberta_mlp': 16}
66                    &s->cur->data[td->plane][y * refs], td->w * df);                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 6, 'vulberta_mlp': 21}
68         }                                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 10, 'vulberta_mlp': 3}
70     }                                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 19, 'vulberta_mlp': 14}
72     return 0;                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 17, 'regvd': 31, 'vulberta_cnn': 27, 'vulberta_mlp': 1}
74 }                                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 34, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)
10     int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;
14     int slice_h = td->h / nb_jobs;
18     int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;
32         if ((y ^ td->parity) & 1) {
34             uint8_t *prev = &s->prev->data[td->plane][y * refs];
36             uint8_t *cur  = &s->cur ->data[td->plane][y * refs];
38             uint8_t *next = &s->next->data[td->plane][y * refs];
40             uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];
--------------------------------------------------------------------------------------------------------------
Example ids:  7174 project:  FFmpeg commit id:  7f526efd17973ec6d2204f7a47b6923e2be31363 Number of lines:  37
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)               {'linevul': 0, 'codebert': 0, 'PLBART': 0, 'devign': 7, 'regvd': 7, 'vulberta_cnn': 0, 'vulberta_mlp': 26}
2 {                                                                                                                        {'linevul': 22, 'codebert': 7, 'PLBART': 9, 'devign': 72, 'regvd': 33, 'vulberta_cnn': 15, 'vulberta_mlp': 14}
4 #if defined (HAVE_MMX2) || defined (HAVE_3DNOW)                                                                          {'linevul': 8, 'codebert': 2, 'PLBART': 4, 'devign': 16, 'regvd': 21, 'vulberta_cnn': 27, 'vulberta_mlp': 11}
6 	asm volatile(                                                                                                           {'linevul': 21, 'codebert': 1, 'PLBART': 8, 'devign': 26, 'regvd': 28, 'vulberta_cnn': 19, 'vulberta_mlp': 29}
8 		"movq "MANGLE(bm01010101)", %%mm4\n\t"                                                                                 {'linevul': 5, 'codebert': 6, 'PLBART': 2, 'devign': 8, 'regvd': 6, 'vulberta_cnn': 24, 'vulberta_mlp': 5}
10 		"mov %0, %%"REG_a"		\n\t"                                                                                             {'linevul': 9, 'codebert': 8, 'PLBART': 5, 'devign': 15, 'regvd': 14, 'vulberta_cnn': 21, 'vulberta_mlp': 3}
12 		"1:				\n\t"                                                                                                          {'linevul': 20, 'codebert': 15, 'PLBART': 7, 'devign': 28, 'regvd': 24, 'vulberta_cnn': 18, 'vulberta_mlp': 35}
14 		"movq (%1, %%"REG_a",4), %%mm0	\n\t"                                                                                  {'linevul': 4, 'codebert': 9, 'PLBART': 3, 'devign': 2, 'regvd': 2, 'vulberta_cnn': 4, 'vulberta_mlp': 15}
16 		"movq 8(%1, %%"REG_a",4), %%mm1	\n\t"                                                                                 {'linevul': 2, 'codebert': 11, 'PLBART': 1, 'devign': 4, 'regvd': 1, 'vulberta_cnn': 31, 'vulberta_mlp': 16}
18 		"movq (%2, %%"REG_a",4), %%mm2	\n\t"                                                                                  {'linevul': 3, 'codebert': 12, 'PLBART': 6, 'devign': 5, 'regvd': 3, 'vulberta_cnn': 33, 'vulberta_mlp': 10}
20 		"movq 8(%2, %%"REG_a",4), %%mm3	\n\t"                                                                                 {'linevul': 1, 'codebert': 10, 'PLBART': -1, 'devign': 3, 'regvd': 0, 'vulberta_cnn': 30, 'vulberta_mlp': 23}
22 		PAVGB(%%mm2, %%mm0)                                                                                                   {'linevul': 18, 'codebert': 5, 'PLBART': -1, 'devign': 9, 'regvd': 19, 'vulberta_cnn': 2, 'vulberta_mlp': 36}
24 		PAVGB(%%mm3, %%mm1)                                                                                                   {'linevul': 19, 'codebert': 4, 'PLBART': -1, 'devign': 10, 'regvd': 20, 'vulberta_cnn': 36, 'vulberta_mlp': 32}
26 		"psrlw $8, %%mm0		\n\t"                                                                                               {'linevul': 14, 'codebert': 13, 'PLBART': -1, 'devign': 23, 'regvd': 12, 'vulberta_cnn': 5, 'vulberta_mlp': 33}
28 		"psrlw $8, %%mm1		\n\t"                                                                                               {'linevul': 17, 'codebert': 16, 'PLBART': -1, 'devign': 25, 'regvd': 10, 'vulberta_cnn': 9, 'vulberta_mlp': 34}
30 		"packuswb %%mm1, %%mm0		\n\t"                                                                                         {'linevul': 11, 'codebert': 3, 'PLBART': -1, 'devign': 20, 'regvd': 8, 'vulberta_cnn': 26, 'vulberta_mlp': 20}
32 		"movq %%mm0, %%mm1		\n\t"                                                                                             {'linevul': 13, 'codebert': 14, 'PLBART': -1, 'devign': 19, 'regvd': 15, 'vulberta_cnn': 17, 'vulberta_mlp': 28}
34 		"psrlw $8, %%mm0		\n\t"                                                                                               {'linevul': 16, 'codebert': 17, 'PLBART': -1, 'devign': 22, 'regvd': 11, 'vulberta_cnn': 7, 'vulberta_mlp': 31}
36 		"pand %%mm4, %%mm1		\n\t"                                                                                             {'linevul': 15, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 13, 'vulberta_cnn': 14, 'vulberta_mlp': 22}
38 		"packuswb %%mm0, %%mm0		\n\t"                                                                                         {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 17, 'vulberta_cnn': 12, 'vulberta_mlp': 27}
40 		"packuswb %%mm1, %%mm1		\n\t"                                                                                         {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 16, 'vulberta_cnn': 25, 'vulberta_mlp': 6}
42 		"movd %%mm0, (%4, %%"REG_a")	\n\t"                                                                                    {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 1, 'regvd': 5, 'vulberta_cnn': 28, 'vulberta_mlp': 8}
44 		"movd %%mm1, (%3, %%"REG_a")	\n\t"                                                                                    {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 4, 'vulberta_cnn': 13, 'vulberta_mlp': 24}
46 		"add $4, %%"REG_a"		\n\t"                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 18, 'vulberta_cnn': 20, 'vulberta_mlp': 30}
48 		" js 1b				\n\t"                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 48, 'regvd': 25, 'vulberta_cnn': 32, 'vulberta_mlp': 1}
50 		: : "g" ((long)-width), "r" (src1+width*4), "r" (src2+width*4), "r" (dstU+width), "r" (dstV+width)                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 9, 'vulberta_cnn': 3, 'vulberta_mlp': 25}
52 		: "%"REG_a                                                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 17, 'regvd': 26, 'vulberta_cnn': 16, 'vulberta_mlp': 18}
54 	);                                                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 31, 'vulberta_cnn': 10, 'vulberta_mlp': 2}
56 #else                                                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 43, 'regvd': 34, 'vulberta_cnn': 11, 'vulberta_mlp': 4}
58 	int i;                                                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 41, 'regvd': 29, 'vulberta_cnn': 29, 'vulberta_mlp': 0}
60 	for(i=0; i<width; i++)                                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 27, 'vulberta_cnn': 6, 'vulberta_mlp': 17}
62 	{                                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 38, 'regvd': 32, 'vulberta_cnn': 22, 'vulberta_mlp': 7}
64 		dstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 23, 'vulberta_cnn': 1, 'vulberta_mlp': 12}
66 		dstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 22, 'vulberta_cnn': 35, 'vulberta_mlp': 21}
68 	}                                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 34, 'regvd': -1, 'vulberta_cnn': 23, 'vulberta_mlp': 13}
70 #endif                                                                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 32, 'regvd': 30, 'vulberta_cnn': 8, 'vulberta_mlp': 9}
72 }                                                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 30, 'regvd': -1, 'vulberta_cnn': 34, 'vulberta_mlp': 19}
-----------------------
Highlighted lines: 
0 static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
8 		"movq "MANGLE(bm01010101)", %%mm4\n\t"
10 		"mov %0, %%"REG_a"		\n\t"
14 		"movq (%1, %%"REG_a",4), %%mm0	\n\t"
16 		"movq 8(%1, %%"REG_a",4), %%mm1	\n\t"
18 		"movq (%2, %%"REG_a",4), %%mm2	\n\t"
42 		"movd %%mm0, (%4, %%"REG_a")	\n\t"
--------------------------------------------------------------------------------------------------------------
Example ids:  7191 project:  qemu commit id:  a890643958f03aaa344290700093b280cb606c28 Number of lines:  41
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static bool qht_insert__locked(struct qht *ht, struct qht_map *map,                           {'linevul': 6, 'codebert': 0, 'PLBART': 0, 'devign': 9, 'regvd': 5, 'vulberta_cnn': 3, 'vulberta_mlp': 9}
2                                struct qht_bucket *head, void *p, uint32_t hash,               {'linevul': 0, 'codebert': 1, 'PLBART': 4, 'devign': 5, 'regvd': 9, 'vulberta_cnn': 15, 'vulberta_mlp': 10}
4                                bool *needs_resize)                                            {'linevul': 1, 'codebert': 3, 'PLBART': 7, 'devign': 18, 'regvd': 20, 'vulberta_cnn': 33, 'vulberta_mlp': 17}
6 {                                                                                             {'linevul': 27, 'codebert': 13, 'PLBART': 15, 'devign': -1, 'regvd': 34, 'vulberta_cnn': 26, 'vulberta_mlp': 30}
8     struct qht_bucket *b = head;                                                              {'linevul': 13, 'codebert': 4, 'PLBART': 2, 'devign': 2, 'regvd': 15, 'vulberta_cnn': 16, 'vulberta_mlp': 8}
10     struct qht_bucket *prev = NULL;                                                          {'linevul': 15, 'codebert': 5, 'PLBART': 6, 'devign': 3, 'regvd': 12, 'vulberta_cnn': 20, 'vulberta_mlp': 25}
12     struct qht_bucket *new = NULL;                                                           {'linevul': 14, 'codebert': 7, 'PLBART': 8, 'devign': 1, 'regvd': 14, 'vulberta_cnn': 6, 'vulberta_mlp': 16}
14     int i;                                                                                   {'linevul': 25, 'codebert': 14, 'PLBART': 9, 'devign': 29, 'regvd': 27, 'vulberta_cnn': 24, 'vulberta_mlp': 24}
18     do {                                                                                     {'linevul': 26, 'codebert': 15, 'PLBART': 10, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 5, 'vulberta_mlp': 36}
20         for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {                                           {'linevul': 3, 'codebert': 2, 'PLBART': 1, 'devign': 6, 'regvd': 13, 'vulberta_cnn': 36, 'vulberta_mlp': 34}
22             if (b->pointers[i]) {                                                            {'linevul': 8, 'codebert': 6, 'PLBART': 5, 'devign': 8, 'regvd': 16, 'vulberta_cnn': 13, 'vulberta_mlp': 15}
24                 if (unlikely(b->pointers[i] == p)) {                                         {'linevul': 2, 'codebert': 8, 'PLBART': 3, 'devign': 0, 'regvd': 10, 'vulberta_cnn': 19, 'vulberta_mlp': 21}
26                     return false;                                                            {'linevul': 7, 'codebert': 16, 'PLBART': 12, 'devign': 30, 'regvd': 29, 'vulberta_cnn': 1, 'vulberta_mlp': 32}
28                 }                                                                            {'linevul': 11, 'codebert': 17, 'PLBART': 14, 'devign': -1, 'regvd': 40, 'vulberta_cnn': 11, 'vulberta_mlp': 5}
30             } else {                                                                         {'linevul': 17, 'codebert': 19, 'PLBART': 11, 'devign': -1, 'regvd': 31, 'vulberta_cnn': 30, 'vulberta_mlp': 23}
32                 goto found;                                                                  {'linevul': 9, 'codebert': 10, 'PLBART': 13, 'devign': 31, 'regvd': 30, 'vulberta_cnn': 28, 'vulberta_mlp': 29}
34             }                                                                                {'linevul': 19, 'codebert': 20, 'PLBART': -1, 'devign': -1, 'regvd': 39, 'vulberta_cnn': 27, 'vulberta_mlp': 2}
36         }                                                                                    {'linevul': 22, 'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 38, 'vulberta_cnn': 12, 'vulberta_mlp': 13}
38         prev = b;                                                                            {'linevul': 20, 'codebert': 12, 'PLBART': -1, 'devign': 17, 'regvd': 24, 'vulberta_cnn': 8, 'vulberta_mlp': 38}
40         b = b->next;                                                                         {'linevul': 18, 'codebert': 11, 'PLBART': -1, 'devign': 11, 'regvd': 23, 'vulberta_cnn': 21, 'vulberta_mlp': 20}
42     } while (b);                                                                             {'linevul': 21, 'codebert': 9, 'PLBART': -1, 'devign': 20, 'regvd': 19, 'vulberta_cnn': 9, 'vulberta_mlp': 19}
46     b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));                                         {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 0, 'vulberta_cnn': 4, 'vulberta_mlp': 1}
48     memset(b, 0, sizeof(*b));                                                                {'linevul': 16, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 11, 'vulberta_cnn': 22, 'vulberta_mlp': 4}
50     new = b;                                                                                 {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 25, 'vulberta_cnn': 23, 'vulberta_mlp': 28}
52     i = 0;                                                                                   {'linevul': 23, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 26, 'vulberta_cnn': 18, 'vulberta_mlp': 37}
54     atomic_inc(&map->n_added_buckets);                                                       {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 4, 'vulberta_cnn': 0, 'vulberta_mlp': 3}
56     if (unlikely(qht_map_needs_resize(map)) && needs_resize) {                               {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': 23, 'regvd': 7, 'vulberta_cnn': 32, 'vulberta_mlp': 7}
58         *needs_resize = true;                                                                {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 17, 'vulberta_cnn': 10, 'vulberta_mlp': 31}
60     }                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 37, 'vulberta_cnn': 25, 'vulberta_mlp': 27}
64  found:                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 32, 'vulberta_cnn': 29, 'vulberta_mlp': 33}
66     /* found an empty key: acquire the seqlock and write */                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 26, 'regvd': 18, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
68     seqlock_write_begin(&head->sequence);                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 2, 'vulberta_cnn': 34, 'vulberta_mlp': 11}
70     if (new) {                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 22, 'vulberta_cnn': 35, 'vulberta_mlp': 35}
72         atomic_rcu_set(&prev->next, b);                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 3, 'vulberta_cnn': 31, 'vulberta_mlp': 18}
74     }                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 36, 'vulberta_cnn': 17, 'vulberta_mlp': 12}
76     b->hashes[i] = hash;                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 21, 'vulberta_cnn': 37, 'vulberta_mlp': 22}
78     /* smp_wmb() implicit in seqlock_write_begin.  */                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 8, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
80     atomic_set(&b->pointers[i], p);                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 1, 'vulberta_cnn': 2, 'vulberta_mlp': 26}
82     seqlock_write_end(&head->sequence);                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 25, 'regvd': 6, 'vulberta_cnn': 14, 'vulberta_mlp': 14}
84     return true;                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 28, 'regvd': 28, 'vulberta_cnn': 7, 'vulberta_mlp': 6}
86 }                                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 35, 'vulberta_cnn': 38, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static bool qht_insert__locked(struct qht *ht, struct qht_map *map,
2                                struct qht_bucket *head, void *p, uint32_t hash,
8     struct qht_bucket *b = head;
12     struct qht_bucket *new = NULL;
20         for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {
22             if (b->pointers[i]) {
24                 if (unlikely(b->pointers[i] == p)) {
46     b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));
--------------------------------------------------------------------------------------------------------------
Example ids:  8124 project:  FFmpeg commit id:  ab80d3fb3a7595db44fc143c80f8c2a3480fe28d Number of lines:  23
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'vulberta_cnn', 'vulberta_mlp']
0 yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],                                     {'linevul': 7, 'codebert': 0, 'PLBART': 0, 'devign': 9, 'vulberta_cnn': 20, 'vulberta_mlp': 15}
2             const int16_t *ubuf[2], const int16_t *vbuf[2],                           {'linevul': 5, 'codebert': 1, 'PLBART': 2, 'devign': 10, 'vulberta_cnn': 21, 'vulberta_mlp': 4}
4             const int16_t *abuf[2], uint8_t *dest, int dstW,                          {'linevul': 2, 'codebert': 4, 'PLBART': 7, 'devign': 4, 'vulberta_cnn': 6, 'vulberta_mlp': 11}
6             int yalpha, int uvalpha, int y)                                           {'linevul': 9, 'codebert': 9, 'PLBART': 5, 'devign': 7, 'vulberta_cnn': 14, 'vulberta_mlp': 21}
8 {                                                                                     {'linevul': 22, 'codebert': 13, 'PLBART': 10, 'devign': -1, 'vulberta_cnn': 4, 'vulberta_mlp': 20}
10     int hasAlpha = abuf[0] && abuf[1];                                               {'linevul': 13, 'codebert': 5, 'PLBART': 8, 'devign': 1, 'vulberta_cnn': 18, 'vulberta_mlp': 14}
12     const int16_t *buf0  = buf[0],  *buf1  = buf[1],                                 {'linevul': 6, 'codebert': 3, 'PLBART': 3, 'devign': -1, 'vulberta_cnn': 5, 'vulberta_mlp': 7}
14                   *abuf0 = hasAlpha ? abuf[0] : NULL,                                {'linevul': 4, 'codebert': 8, 'PLBART': 1, 'devign': 16, 'vulberta_cnn': 2, 'vulberta_mlp': 9}
16                   *abuf1 = hasAlpha ? abuf[1] : NULL;                                {'linevul': 3, 'codebert': 6, 'PLBART': 4, 'devign': 15, 'vulberta_cnn': 16, 'vulberta_mlp': 13}
18     int  yalpha1 = 4096 - yalpha;                                                    {'linevul': 15, 'codebert': 10, 'PLBART': 6, 'devign': 2, 'vulberta_cnn': 15, 'vulberta_mlp': 22}
20     int i;                                                                           {'linevul': 19, 'codebert': 15, 'PLBART': -1, 'devign': 17, 'vulberta_cnn': 8, 'vulberta_mlp': 1}
24     for (i = 0; i < dstW; i++) {                                                     {'linevul': 14, 'codebert': 11, 'PLBART': 9, 'devign': 3, 'vulberta_cnn': 0, 'vulberta_mlp': 16}
26         int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;                {'linevul': 1, 'codebert': 7, 'PLBART': -1, 'devign': 0, 'vulberta_cnn': 3, 'vulberta_mlp': 8}
28         int A;                                                                       {'linevul': 17, 'codebert': 14, 'PLBART': -1, 'devign': 12, 'vulberta_cnn': 11, 'vulberta_mlp': 0}
32         Y = av_clip_uint8(Y);                                                        {'linevul': 12, 'codebert': 2, 'PLBART': -1, 'devign': 11, 'vulberta_cnn': 17, 'vulberta_mlp': 2}
36         if (hasAlpha) {                                                              {'linevul': 16, 'codebert': 12, 'PLBART': -1, 'devign': 14, 'vulberta_cnn': 7, 'vulberta_mlp': 19}
38             A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'vulberta_cnn': 19, 'vulberta_mlp': 12}
40             A = av_clip_uint8(A);                                                    {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'vulberta_cnn': 13, 'vulberta_mlp': 18}
42         }                                                                            {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'vulberta_cnn': 12, 'vulberta_mlp': 6}
46         dest[i * 2    ] = Y;                                                         {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'vulberta_cnn': 10, 'vulberta_mlp': 10}
48         dest[i * 2 + 1] = hasAlpha ? A : 255;                                        {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'vulberta_cnn': 1, 'vulberta_mlp': 3}
50     }                                                                                {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'vulberta_cnn': 9, 'vulberta_mlp': 17}
52 }                                                                                    {'linevul': 21, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'vulberta_cnn': 22, 'vulberta_mlp': 5}
-----------------------
Highlighted lines: 
0 yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
2             const int16_t *ubuf[2], const int16_t *vbuf[2],
4             const int16_t *abuf[2], uint8_t *dest, int dstW,
6             int yalpha, int uvalpha, int y)
12     const int16_t *buf0  = buf[0],  *buf1  = buf[1],
14                   *abuf0 = hasAlpha ? abuf[0] : NULL,
26         int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
48         dest[i * 2 + 1] = hasAlpha ? A : 255;
--------------------------------------------------------------------------------------------------------------
Example ids:  9178 project:  FFmpeg commit id:  44ac13eed49593f4f8efdb72ab0d5b48e05aa305 Number of lines:  32
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,                            {'linevul': 1, 'codebert': 0, 'PLBART': 0, 'devign': 6, 'regvd': 3, 'vulberta_cnn': 30, 'vulberta_mlp': 23}
2                              int max_size)                                                                  {'linevul': 3, 'codebert': 13, 'PLBART': 11, 'devign': 11, 'regvd': 20, 'vulberta_cnn': 16, 'vulberta_mlp': 2}
4 {                                                                                                           {'linevul': 23, 'codebert': 10, 'PLBART': 13, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 21, 'vulberta_mlp': 30}
6     uint32_t mrk;                                                                                           {'linevul': 19, 'codebert': 15, 'PLBART': 6, 'devign': 4, 'regvd': 15, 'vulberta_cnn': 26, 'vulberta_mlp': 29}
8     int i, tmp;                                                                                             {'linevul': 22, 'codebert': 18, 'PLBART': 12, 'devign': 20, 'regvd': 25, 'vulberta_cnn': 29, 'vulberta_mlp': 31}
10     const uint16_t *ssrc = (const uint16_t *) src;                                                         {'linevul': 7, 'codebert': 11, 'PLBART': 2, 'devign': 17, 'regvd': 2, 'vulberta_cnn': 25, 'vulberta_mlp': 24}
12     uint16_t *sdst = (uint16_t *) dst;                                                                     {'linevul': 11, 'codebert': 14, 'PLBART': 4, 'devign': 15, 'regvd': 9, 'vulberta_cnn': 10, 'vulberta_mlp': 14}
14     PutBitContext pb;                                                                                      {'linevul': 21, 'codebert': 3, 'PLBART': 9, 'devign': 21, 'regvd': 26, 'vulberta_cnn': 4, 'vulberta_mlp': 27}
18     if ((unsigned) src_size > (unsigned) max_size)                                                         {'linevul': 12, 'codebert': 9, 'PLBART': 1, 'devign': 10, 'regvd': 12, 'vulberta_cnn': 14, 'vulberta_mlp': 1}
20         src_size = max_size;                                                                               {'linevul': 15, 'codebert': 16, 'PLBART': 8, 'devign': 13, 'regvd': 14, 'vulberta_cnn': 1, 'vulberta_mlp': 3}
24     mrk = AV_RB32(src);                                                                                    {'linevul': 16, 'codebert': 6, 'PLBART': 5, 'devign': 2, 'regvd': 7, 'vulberta_cnn': 22, 'vulberta_mlp': 26}
26     switch (mrk) {                                                                                         {'linevul': 20, 'codebert': 12, 'PLBART': 10, 'devign': 5, 'regvd': 22, 'vulberta_cnn': 24, 'vulberta_mlp': 20}
28     case DCA_SYNCWORD_CORE_BE:                                                                             {'linevul': 14, 'codebert': 2, 'PLBART': 3, 'devign': 25, 'regvd': 23, 'vulberta_cnn': 27, 'vulberta_mlp': 4}
30         memcpy(dst, src, src_size);                                                                        {'linevul': 10, 'codebert': 1, 'PLBART': 7, 'devign': 14, 'regvd': 6, 'vulberta_cnn': 7, 'vulberta_mlp': 7}
32         return src_size;                                                                                   {'linevul': 18, 'codebert': 20, 'PLBART': -1, 'devign': 8, 'regvd': 17, 'vulberta_cnn': 20, 'vulberta_mlp': 21}
34     case DCA_SYNCWORD_CORE_LE:                                                                             {'linevul': 13, 'codebert': 7, 'PLBART': -1, 'devign': 26, 'regvd': 24, 'vulberta_cnn': 28, 'vulberta_mlp': 22}
36         for (i = 0; i < (src_size + 1) >> 1; i++)                                                          {'linevul': 5, 'codebert': 17, 'PLBART': -1, 'devign': 1, 'regvd': 8, 'vulberta_cnn': 9, 'vulberta_mlp': 18}
38             *sdst++ = av_bswap16(*ssrc++);                                                                 {'linevul': 4, 'codebert': 4, 'PLBART': -1, 'devign': 9, 'regvd': 1, 'vulberta_cnn': 0, 'vulberta_mlp': 17}
40         return src_size;                                                                                   {'linevul': 17, 'codebert': 19, 'PLBART': -1, 'devign': 7, 'regvd': 16, 'vulberta_cnn': 12, 'vulberta_mlp': 19}
42     case DCA_SYNCWORD_CORE_14B_BE:                                                                         {'linevul': 9, 'codebert': 5, 'PLBART': -1, 'devign': 27, 'regvd': 18, 'vulberta_cnn': 13, 'vulberta_mlp': 10}
44     case DCA_SYNCWORD_CORE_14B_LE:                                                                         {'linevul': 8, 'codebert': 8, 'PLBART': -1, 'devign': 16, 'regvd': 21, 'vulberta_cnn': 2, 'vulberta_mlp': 5}
46         init_put_bits(&pb, dst, max_size);                                                                 {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 5, 'vulberta_cnn': 15, 'vulberta_mlp': 0}
48         for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {                                              {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 4, 'vulberta_cnn': 6, 'vulberta_mlp': 13}
50             tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 0, 'vulberta_cnn': 23, 'vulberta_mlp': 12}
52             put_bits(&pb, 14, tmp);                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 10, 'vulberta_cnn': 8, 'vulberta_mlp': 6}
54         }                                                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_cnn': 18, 'vulberta_mlp': 9}
56         flush_put_bits(&pb);                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 13, 'vulberta_cnn': 3, 'vulberta_mlp': 11}
58         return (put_bits_count(&pb) + 7) >> 3;                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 23, 'regvd': 11, 'vulberta_cnn': 11, 'vulberta_mlp': 8}
60     default:                                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 27, 'vulberta_cnn': 19, 'vulberta_mlp': 16}
62         return AVERROR_INVALIDDATA;                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 19, 'vulberta_cnn': 17, 'vulberta_mlp': 25}
64     }                                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_cnn': 5, 'vulberta_mlp': 28}
66 }                                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 31, 'vulberta_mlp': 15}
-----------------------
Highlighted lines: 
0 int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,
24     mrk = AV_RB32(src);
30         memcpy(dst, src, src_size);
36         for (i = 0; i < (src_size + 1) >> 1; i++)
38             *sdst++ = av_bswap16(*ssrc++);
44     case DCA_SYNCWORD_CORE_14B_LE:
48         for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {
--------------------------------------------------------------------------------------------------------------
Example ids:  9189 project:  qemu commit id:  b21da4e504fbdb907543a918b190783dc896d8e1 Number of lines:  22
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,                  {'linevul': 3, 'codebert': 5, 'PLBART': 0, 'devign': 0, 'regvd': 0, 'vulberta_cnn': 10, 'vulberta_mlp': 7}
1                                unsigned int epid)                                      {'linevul': 0, 'codebert': 11, 'PLBART': 10, 'devign': 3, 'regvd': 16, 'vulberta_cnn': 4, 'vulberta_mlp': 21}
2 {                                                                                      {'linevul': 21, 'codebert': 17, 'PLBART': 11, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 9, 'vulberta_mlp': 20}
3     XHCISlot *slot;                                                                    {'linevul': 17, 'codebert': 20, 'PLBART': 7, 'devign': 7, 'regvd': 17, 'vulberta_cnn': 17, 'vulberta_mlp': 10}
4     XHCIEPContext *epctx;                                                              {'linevul': 16, 'codebert': 19, 'PLBART': 8, 'devign': 8, 'regvd': 15, 'vulberta_cnn': 15, 'vulberta_mlp': 9}
5     int i;                                                                             {'linevul': 20, 'codebert': 21, 'PLBART': 9, 'devign': 6, 'regvd': 20, 'vulberta_cnn': 13, 'vulberta_mlp': 19}
6     trace_usb_xhci_ep_disable(slotid, epid);                                           {'linevul': 6, 'codebert': 8, 'PLBART': 3, 'devign': 1, 'regvd': 4, 'vulberta_cnn': 19, 'vulberta_mlp': 15}
7     assert(slotid >= 1 && slotid <= xhci->numslots);                                   {'linevul': 5, 'codebert': 1, 'PLBART': 2, 'devign': 2, 'regvd': 3, 'vulberta_cnn': 5, 'vulberta_mlp': 13}
8     assert(epid >= 1 && epid <= 31);                                                   {'linevul': 15, 'codebert': 0, 'PLBART': 6, 'devign': 5, 'regvd': 13, 'vulberta_cnn': 12, 'vulberta_mlp': 17}
9     slot = &xhci->slots[slotid-1];                                                     {'linevul': 8, 'codebert': 13, 'PLBART': 4, 'devign': 4, 'regvd': 7, 'vulberta_cnn': 3, 'vulberta_mlp': 6}
10     if (!slot->eps[epid-1]) {                                                         {'linevul': 12, 'codebert': 2, 'PLBART': 5, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 21, 'vulberta_mlp': 5}
11         DPRINTF("xhci: slot %d ep %d already disabled\n", slotid, epid);              {'linevul': 1, 'codebert': 7, 'PLBART': 1, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 1, 'vulberta_mlp': 11}
12         return CC_SUCCESS;                                                            {'linevul': 14, 'codebert': 6, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 11, 'vulberta_mlp': 0}
13     xhci_ep_nuke_xfers(xhci, slotid, epid);                                           {'linevul': 4, 'codebert': 4, 'PLBART': -1, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 2, 'vulberta_mlp': 2}
14     epctx = slot->eps[epid-1];                                                        {'linevul': 11, 'codebert': 9, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 18, 'vulberta_mlp': 12}
15     if (epctx->nr_pstreams) {                                                         {'linevul': 10, 'codebert': 3, 'PLBART': -1, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 8, 'vulberta_mlp': 8}
16         xhci_free_streams(epctx);                                                     {'linevul': 7, 'codebert': 14, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 16, 'vulberta_mlp': 4}
17     xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);                                {'linevul': 2, 'codebert': 10, 'PLBART': -1, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 7, 'vulberta_mlp': 3}
18     timer_free(epctx->kick_timer);                                                    {'linevul': 13, 'codebert': 12, 'PLBART': -1, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 20, 'vulberta_mlp': 18}
19     g_free(epctx);                                                                    {'linevul': 19, 'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 6, 'vulberta_mlp': 16}
20     slot->eps[epid-1] = NULL;                                                         {'linevul': 9, 'codebert': 15, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_cnn': 14, 'vulberta_mlp': 14}
21     return CC_SUCCESS;                                                                {'linevul': 18, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 0, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
6     trace_usb_xhci_ep_disable(slotid, epid);
7     assert(slotid >= 1 && slotid <= xhci->numslots);
9     slot = &xhci->slots[slotid-1];
10     if (!slot->eps[epid-1]) {
11         DPRINTF("xhci: slot %d ep %d already disabled\n", slotid, epid);
13     xhci_ep_nuke_xfers(xhci, slotid, epid);
17     xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
--------------------------------------------------------------------------------------------------------------
Example ids:  9347 project:  FFmpeg commit id:  0f34c0789f855f04dce518ffc93a01bb943ba1aa Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,               {'linevul': 10, 'codebert': 0, 'PLBART': 0, 'devign': 1, 'regvd': 7, 'vulberta_cnn': 1, 'vulberta_mlp': 10}
2                       int *x, int *y, int *plane, int bits_per_plane)                       {'linevul': 0, 'codebert': 6, 'PLBART': 5, 'devign': 2, 'regvd': 8, 'vulberta_cnn': 21, 'vulberta_mlp': 12}
4 {                                                                                           {'linevul': 22, 'codebert': 14, 'PLBART': 10, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 10, 'vulberta_mlp': 27}
6     uint8_t *d;                                                                             {'linevul': 20, 'codebert': 5, 'PLBART': 6, 'devign': 20, 'regvd': 17, 'vulberta_cnn': 8, 'vulberta_mlp': 28}
8     int shift = *plane * bits_per_plane;                                                    {'linevul': 17, 'codebert': 13, 'PLBART': 4, 'devign': 3, 'regvd': 6, 'vulberta_cnn': 6, 'vulberta_mlp': 6}
10     unsigned mask  = ((1 << bits_per_plane) - 1) << shift;                                 {'linevul': 11, 'codebert': 12, 'PLBART': 3, 'devign': 5, 'regvd': 0, 'vulberta_cnn': 3, 'vulberta_mlp': 5}
12     value   <<= shift;                                                                     {'linevul': 19, 'codebert': 15, 'PLBART': 7, 'devign': 14, 'regvd': 18, 'vulberta_cnn': 19, 'vulberta_mlp': 14}
16     while (run > 0) {                                                                      {'linevul': 18, 'codebert': 16, 'PLBART': 8, 'devign': 8, 'regvd': 19, 'vulberta_cnn': 25, 'vulberta_mlp': 24}
18         int j;                                                                             {'linevul': 21, 'codebert': 18, 'PLBART': 9, 'devign': 21, 'regvd': 20, 'vulberta_cnn': 23, 'vulberta_mlp': 26}
20         for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {                          {'linevul': 1, 'codebert': 11, 'PLBART': 1, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 0, 'vulberta_mlp': 2}
22             d = frame->data[0] + *y * frame->linesize[0];                                  {'linevul': 2, 'codebert': 3, 'PLBART': 2, 'devign': 18, 'regvd': 3, 'vulberta_cnn': 27, 'vulberta_mlp': 16}
24             d[*x] |= (value >> j) & mask;                                                  {'linevul': 7, 'codebert': 7, 'PLBART': -1, 'devign': 4, 'regvd': 2, 'vulberta_cnn': 26, 'vulberta_mlp': 13}
26             *x += 1;                                                                       {'linevul': 16, 'codebert': 17, 'PLBART': -1, 'devign': 9, 'regvd': 15, 'vulberta_cnn': 13, 'vulberta_mlp': 9}
28             if (*x == s->width) {                                                          {'linevul': 14, 'codebert': 2, 'PLBART': -1, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 22, 'vulberta_mlp': 22}
30                 *y -= 1;                                                                   {'linevul': 13, 'codebert': 1, 'PLBART': -1, 'devign': 11, 'regvd': 12, 'vulberta_cnn': 12, 'vulberta_mlp': 11}
32                 *x = 0;                                                                    {'linevul': 15, 'codebert': 9, 'PLBART': -1, 'devign': 15, 'regvd': 16, 'vulberta_cnn': 16, 'vulberta_mlp': 20}
34                 if (*y < 0) {                                                              {'linevul': 12, 'codebert': 4, 'PLBART': -1, 'devign': 10, 'regvd': 13, 'vulberta_cnn': 2, 'vulberta_mlp': 21}
36                    *y = s->height - 1;                                                     {'linevul': 6, 'codebert': 10, 'PLBART': -1, 'devign': 16, 'regvd': 9, 'vulberta_cnn': 24, 'vulberta_mlp': 19}
38                    *plane += 1;                                                            {'linevul': 9, 'codebert': 8, 'PLBART': -1, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 14, 'vulberta_mlp': 3}
40                    if (*plane >= s->nb_planes)                                             {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 7, 'vulberta_mlp': 8}
42                        return;                                                             {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 22, 'vulberta_cnn': 9, 'vulberta_mlp': 7}
44                    value <<= bits_per_plane;                                               {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 17, 'regvd': 10, 'vulberta_cnn': 18, 'vulberta_mlp': 1}
46                    mask  <<= bits_per_plane;                                               {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 11, 'vulberta_cnn': 20, 'vulberta_mlp': 4}
48                 }                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 15, 'vulberta_mlp': 18}
50             }                                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 5, 'vulberta_mlp': 25}
52         }                                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 17, 'vulberta_mlp': 15}
54         run--;                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 21, 'vulberta_cnn': 4, 'vulberta_mlp': 23}
56     }                                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 11, 'vulberta_mlp': 0}
58 }                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 28, 'vulberta_mlp': 17}
-----------------------
Highlighted lines: 
0 static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,
2                       int *x, int *y, int *plane, int bits_per_plane)
8     int shift = *plane * bits_per_plane;
10     unsigned mask  = ((1 << bits_per_plane) - 1) << shift;
20         for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
22             d = frame->data[0] + *y * frame->linesize[0];
24             d[*x] |= (value >> j) & mask;
40                    if (*plane >= s->nb_planes)
--------------------------------------------------------------------------------------------------------------
Example ids:  10355 project:  qemu commit id:  3a661f1eabf7e8db66e28489884d9b54aacb94ea Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'PLBART', 'devign', 'regvd', 'vulberta_mlp']
0 static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,                         {'linevul': 4, 'PLBART': 2, 'devign': 7, 'regvd': 3, 'vulberta_mlp': 3}
2                                        const uint8_t *key, size_t nkey,               {'linevul': 0, 'PLBART': 1, 'devign': 2, 'regvd': 13, 'vulberta_mlp': 17}
4                                        Error **errp)                                  {'linevul': 1, 'PLBART': 8, 'devign': 12, 'regvd': 16, 'vulberta_mlp': 18}
6 {                                                                                     {'linevul': 18, 'PLBART': 11, 'devign': -1, 'regvd': 18, 'vulberta_mlp': 7}
8     QCryptoCipherBuiltin *ctxt;                                                       {'linevul': 13, 'PLBART': 7, 'devign': 13, 'regvd': 10, 'vulberta_mlp': 10}
12     if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {                                   {'linevul': 5, 'PLBART': 0, 'devign': 1, 'regvd': 9, 'vulberta_mlp': 2}
14         error_setg(errp, "Unsupported cipher mode %d", cipher->mode);                {'linevul': 2, 'PLBART': 4, 'devign': -1, 'regvd': 2, 'vulberta_mlp': 9}
16         return -1;                                                                   {'linevul': 15, 'PLBART': 9, 'devign': 15, 'regvd': 14, 'vulberta_mlp': 16}
18     }                                                                                {'linevul': 17, 'PLBART': 10, 'devign': -1, 'regvd': 19, 'vulberta_mlp': 11}
22     ctxt = g_new0(QCryptoCipherBuiltin, 1);                                          {'linevul': 11, 'PLBART': 5, 'devign': 4, 'regvd': 1, 'vulberta_mlp': 6}
26     ctxt->state.desrfb.key = g_new0(uint8_t, nkey);                                  {'linevul': 3, 'PLBART': 3, 'devign': 0, 'regvd': 0, 'vulberta_mlp': 13}
28     memcpy(ctxt->state.desrfb.key, key, nkey);                                       {'linevul': 9, 'PLBART': 6, 'devign': 3, 'regvd': 8, 'vulberta_mlp': 14}
30     ctxt->state.desrfb.nkey = nkey;                                                  {'linevul': 12, 'PLBART': -1, 'devign': 5, 'regvd': 11, 'vulberta_mlp': 19}
35     ctxt->free = qcrypto_cipher_free_des_rfb;                                        {'linevul': 10, 'PLBART': -1, 'devign': 11, 'regvd': 6, 'vulberta_mlp': 8}
37     ctxt->setiv = qcrypto_cipher_setiv_des_rfb;                                      {'linevul': 8, 'PLBART': -1, 'devign': 10, 'regvd': 5, 'vulberta_mlp': 4}
39     ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;                                  {'linevul': 7, 'PLBART': -1, 'devign': 8, 'regvd': 4, 'vulberta_mlp': 1}
41     ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;                                  {'linevul': 6, 'PLBART': -1, 'devign': 9, 'regvd': 7, 'vulberta_mlp': 0}
45     cipher->opaque = ctxt;                                                           {'linevul': 14, 'PLBART': -1, 'devign': 6, 'regvd': 12, 'vulberta_mlp': 15}
49     return 0;                                                                        {'linevul': 16, 'PLBART': -1, 'devign': 14, 'regvd': 15, 'vulberta_mlp': 12}
51 }                                                                                    {'linevul': 19, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_mlp': 5}
-----------------------
Highlighted lines: 
0 static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,
12     if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {
14         error_setg(errp, "Unsupported cipher mode %d", cipher->mode);
22     ctxt = g_new0(QCryptoCipherBuiltin, 1);
26     ctxt->state.desrfb.key = g_new0(uint8_t, nkey);
28     memcpy(ctxt->state.desrfb.key, key, nkey);
39     ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;
41     ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;
--------------------------------------------------------------------------------------------------------------
Example ids:  10723 project:  FFmpeg commit id:  5a446bc88e49cc6400d0c646ca1eb540a727c9de Number of lines:  21
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void vc1_v_overlap_c(uint8_t* src, int stride)               {'linevul': 1, 'codebert': 0, 'PLBART': 2, 'devign': 4, 'regvd': 2, 'vulberta_cnn': 11, 'vulberta_mlp': 3}
2 {                                                                   {'linevul': 19, 'codebert': 14, 'PLBART': 16, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 2, 'vulberta_mlp': 6}
4     int i;                                                          {'linevul': 17, 'codebert': 7, 'PLBART': 13, 'devign': 17, 'regvd': 17, 'vulberta_cnn': 1, 'vulberta_mlp': 20}
6     int a, b, c, d;                                                 {'linevul': 13, 'codebert': 1, 'PLBART': 7, 'devign': 13, 'regvd': 13, 'vulberta_cnn': 13, 'vulberta_mlp': 8}
8     int d1, d2;                                                     {'linevul': 14, 'codebert': 5, 'PLBART': 12, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 18, 'vulberta_mlp': 16}
10     int rnd = 1;                                                   {'linevul': 15, 'codebert': 6, 'PLBART': 14, 'devign': 9, 'regvd': 12, 'vulberta_cnn': 15, 'vulberta_mlp': 19}
12     for(i = 0; i < 8; i++) {                                       {'linevul': 8, 'codebert': 8, 'PLBART': 5, 'devign': 0, 'regvd': 10, 'vulberta_cnn': 16, 'vulberta_mlp': 18}
14         a = src[-2*stride];                                        {'linevul': 6, 'codebert': 13, 'PLBART': 8, 'devign': 5, 'regvd': 1, 'vulberta_cnn': 5, 'vulberta_mlp': 12}
16         b = src[-stride];                                          {'linevul': 9, 'codebert': 10, 'PLBART': 6, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 12, 'vulberta_mlp': 10}
18         c = src[0];                                                {'linevul': 12, 'codebert': 18, 'PLBART': 15, 'devign': 16, 'regvd': 11, 'vulberta_cnn': 14, 'vulberta_mlp': 17}
20         d = src[stride];                                           {'linevul': 11, 'codebert': 16, 'PLBART': 9, 'devign': 10, 'regvd': 8, 'vulberta_cnn': 19, 'vulberta_mlp': 11}
22         d1 = (a - d + 3 + rnd) >> 3;                               {'linevul': 2, 'codebert': 3, 'PLBART': 3, 'devign': 15, 'regvd': 7, 'vulberta_cnn': 17, 'vulberta_mlp': 0}
24         d2 = (a - d + b - c + 4 - rnd) >> 3;                       {'linevul': 0, 'codebert': 2, 'PLBART': 0, 'devign': 11, 'regvd': 3, 'vulberta_cnn': 6, 'vulberta_mlp': 2}
28         src[-2*stride] = a - d1;                                   {'linevul': 3, 'codebert': 11, 'PLBART': 1, 'devign': 1, 'regvd': 0, 'vulberta_cnn': 4, 'vulberta_mlp': 14}
30         src[-stride] = b - d2;                                     {'linevul': 4, 'codebert': 19, 'PLBART': 11, 'devign': 2, 'regvd': 4, 'vulberta_cnn': 3, 'vulberta_mlp': 4}
32         src[0] = c + d2;                                           {'linevul': 7, 'codebert': 9, 'PLBART': 4, 'devign': 7, 'regvd': 9, 'vulberta_cnn': 0, 'vulberta_mlp': 9}
34         src[stride] = d + d1;                                      {'linevul': 5, 'codebert': 12, 'PLBART': 10, 'devign': 3, 'regvd': 6, 'vulberta_cnn': 10, 'vulberta_mlp': 7}
36         src++;                                                     {'linevul': 16, 'codebert': 17, 'PLBART': 17, 'devign': 8, 'regvd': 15, 'vulberta_cnn': 7, 'vulberta_mlp': 1}
38         rnd = !rnd;                                                {'linevul': 10, 'codebert': 15, 'PLBART': 18, 'devign': 14, 'regvd': 16, 'vulberta_cnn': 9, 'vulberta_mlp': 13}
40     }                                                              {'linevul': 18, 'codebert': 4, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 8, 'vulberta_mlp': 15}
42 }                                                                  {'linevul': 20, 'codebert': 20, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 20, 'vulberta_mlp': 5}
-----------------------
Highlighted lines: 
0 static void vc1_v_overlap_c(uint8_t* src, int stride)
12     for(i = 0; i < 8; i++) {
14         a = src[-2*stride];
16         b = src[-stride];
22         d1 = (a - d + 3 + rnd) >> 3;
24         d2 = (a - d + b - c + 4 - rnd) >> 3;
28         src[-2*stride] = a - d1;
30         src[-stride] = b - d2;
32         src[0] = c + d2;
34         src[stride] = d + d1;
--------------------------------------------------------------------------------------------------------------
Example ids:  10727 project:  qemu commit id:  b4ba67d9a702507793c2724e56f98e9b0f7be02b Number of lines:  25
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,                            {'linevul': 7, 'codebert': 0, 'PLBART': 0, 'devign': 12, 'regvd': 6, 'vulberta_cnn': 0, 'vulberta_mlp': 13}
2                                         QGuestAllocator *alloc, uint16_t entry)                {'linevul': 2, 'codebert': 2, 'PLBART': 6, 'devign': 13, 'regvd': 19, 'vulberta_cnn': 16, 'vulberta_mlp': 6}
4 {                                                                                              {'linevul': 17, 'codebert': 13, 'PLBART': 10, 'devign': 59, 'regvd': 23, 'vulberta_cnn': 7, 'vulberta_mlp': 21}
6     uint16_t vector;                                                                           {'linevul': 14, 'codebert': 10, 'PLBART': 7, 'devign': 21, 'regvd': 21, 'vulberta_cnn': 5, 'vulberta_mlp': 12}
8     uint32_t control;                                                                          {'linevul': 15, 'codebert': 11, 'PLBART': 9, 'devign': 22, 'regvd': 20, 'vulberta_cnn': 11, 'vulberta_mlp': 24}
10     void *addr;                                                                               {'linevul': 16, 'codebert': 9, 'PLBART': 8, 'devign': 20, 'regvd': 22, 'vulberta_cnn': 14, 'vulberta_mlp': 22}
14     g_assert(d->pdev->msix_enabled);                                                          {'linevul': 11, 'codebert': 7, 'PLBART': 5, 'devign': 14, 'regvd': 12, 'vulberta_cnn': 8, 'vulberta_mlp': 0}
16     addr = d->pdev->msix_table + (entry * 16);                                                {'linevul': 9, 'codebert': 6, 'PLBART': 4, 'devign': 11, 'regvd': 7, 'vulberta_cnn': 18, 'vulberta_mlp': 4}
20     g_assert_cmpint(entry, >=, 0);                                                            {'linevul': 12, 'codebert': 4, 'PLBART': 1, 'devign': 8, 'regvd': 14, 'vulberta_cnn': 6, 'vulberta_mlp': 23}
22     g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));                                 {'linevul': 6, 'codebert': 1, 'PLBART': 2, 'devign': 2, 'regvd': 3, 'vulberta_cnn': 10, 'vulberta_mlp': 15}
24     d->config_msix_entry = entry;                                                             {'linevul': 13, 'codebert': 15, 'PLBART': 3, 'devign': 18, 'regvd': 18, 'vulberta_cnn': 21, 'vulberta_mlp': 16}
28     d->config_msix_data = 0x12345678;                                                         {'linevul': 10, 'codebert': 14, 'PLBART': -1, 'devign': 19, 'regvd': 16, 'vulberta_cnn': 19, 'vulberta_mlp': 19}
30     d->config_msix_addr = guest_alloc(alloc, 4);                                              {'linevul': 8, 'codebert': 3, 'PLBART': -1, 'devign': 9, 'regvd': 10, 'vulberta_cnn': 13, 'vulberta_mlp': 7}
34     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,                                 {'linevul': 4, 'codebert': 5, 'PLBART': -1, 'devign': 5, 'regvd': 9, 'vulberta_cnn': 3, 'vulberta_mlp': 5}
36                                                     d->config_msix_addr & ~0UL);              {'linevul': 0, 'codebert': 12, 'PLBART': -1, 'devign': 17, 'regvd': 15, 'vulberta_cnn': 17, 'vulberta_mlp': 14}
38     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,                                 {'linevul': 5, 'codebert': 8, 'PLBART': -1, 'devign': 4, 'regvd': 8, 'vulberta_cnn': 20, 'vulberta_mlp': 11}
40                                             (d->config_msix_addr >> 32) & ~0UL);              {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 11, 'vulberta_cnn': 4, 'vulberta_mlp': 8}
42     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);                 {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 1, 'regvd': 0, 'vulberta_cnn': 1, 'vulberta_mlp': 9}
46     control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 23, 'vulberta_mlp': 10}
48     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 5, 'vulberta_cnn': 9, 'vulberta_mlp': 2}
50                                         control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 17, 'vulberta_cnn': 12, 'vulberta_mlp': 1}
54     qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 2, 'vulberta_cnn': 22, 'vulberta_mlp': 20}
56     vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 15, 'vulberta_mlp': 17}
58     g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 13, 'vulberta_cnn': 2, 'vulberta_mlp': 18}
60 }                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': -1, 'vulberta_cnn': 24, 'vulberta_mlp': 3}
-----------------------
Highlighted lines: 
0 void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,
2                                         QGuestAllocator *alloc, uint16_t entry)
14     g_assert(d->pdev->msix_enabled);
16     addr = d->pdev->msix_table + (entry * 16);
20     g_assert_cmpint(entry, >=, 0);
22     g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));
30     d->config_msix_addr = guest_alloc(alloc, 4);
34     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,
38     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,
42     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);
48     qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,
--------------------------------------------------------------------------------------------------------------
Example ids:  10801 project:  qemu commit id:  d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0 Number of lines:  68
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)               {'linevul': 3, 'codebert': 5, 'PLBART': 0, 'devign': 3, 'regvd': 3, 'vulberta_cnn': 48, 'vulberta_mlp': 18}
2 {                                                                                             {'linevul': 26, 'codebert': 15, 'PLBART': 7, 'devign': 148, 'regvd': 58, 'vulberta_cnn': 31, 'vulberta_mlp': 10}
4     AHCICmdHdr *cmd = ad->cur_cmd;                                                            {'linevul': 10, 'codebert': 2, 'PLBART': 5, 'devign': 29, 'regvd': 21, 'vulberta_cnn': 54, 'vulberta_mlp': 63}
6     uint32_t opts = le32_to_cpu(cmd->opts);                                                   {'linevul': 8, 'codebert': 7, 'PLBART': 4, 'devign': 16, 'regvd': 7, 'vulberta_cnn': 6, 'vulberta_mlp': 42}
8     uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;                                   {'linevul': 6, 'codebert': 4, 'PLBART': 2, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 57, 'vulberta_mlp': 23}
10     int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;                                   {'linevul': 5, 'codebert': 1, 'PLBART': 3, 'devign': 37, 'regvd': 9, 'vulberta_cnn': 4, 'vulberta_mlp': 25}
12     dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));                             {'linevul': 4, 'codebert': 3, 'PLBART': 1, 'devign': 18, 'regvd': 0, 'vulberta_cnn': 53, 'vulberta_mlp': 22}
14     dma_addr_t real_prdt_len = prdt_len;                                                     {'linevul': 9, 'codebert': 9, 'PLBART': 6, 'devign': 40, 'regvd': 23, 'vulberta_cnn': 52, 'vulberta_mlp': 36}
16     uint8_t *prdt;                                                                           {'linevul': 19, 'codebert': 14, 'PLBART': -1, 'devign': 46, 'regvd': 29, 'vulberta_cnn': 33, 'vulberta_mlp': 62}
18     int i;                                                                                   {'linevul': 23, 'codebert': 21, 'PLBART': -1, 'devign': 53, 'regvd': 51, 'vulberta_cnn': 22, 'vulberta_mlp': 61}
20     int r = 0;                                                                               {'linevul': 22, 'codebert': 19, 'PLBART': -1, 'devign': 28, 'regvd': 45, 'vulberta_cnn': 44, 'vulberta_mlp': 41}
22     int sum = 0;                                                                             {'linevul': 21, 'codebert': 18, 'PLBART': -1, 'devign': 20, 'regvd': 39, 'vulberta_cnn': 38, 'vulberta_mlp': 40}
24     int off_idx = -1;                                                                        {'linevul': 14, 'codebert': 17, 'PLBART': -1, 'devign': 17, 'regvd': 30, 'vulberta_cnn': 47, 'vulberta_mlp': 60}
26     int off_pos = -1;                                                                        {'linevul': 18, 'codebert': 16, 'PLBART': -1, 'devign': 31, 'regvd': 28, 'vulberta_cnn': 27, 'vulberta_mlp': 45}
28     int tbl_entry_size;                                                                      {'linevul': 17, 'codebert': 6, 'PLBART': -1, 'devign': 44, 'regvd': 37, 'vulberta_cnn': 10, 'vulberta_mlp': 39}
30     IDEBus *bus = &ad->port;                                                                 {'linevul': 13, 'codebert': 8, 'PLBART': -1, 'devign': 33, 'regvd': 26, 'vulberta_cnn': 25, 'vulberta_mlp': 15}
32     BusState *qbus = BUS(bus);                                                               {'linevul': 12, 'codebert': 10, 'PLBART': -1, 'devign': 32, 'regvd': 31, 'vulberta_cnn': 55, 'vulberta_mlp': 48}
36     if (!sglist_alloc_hint) {                                                                {'linevul': 11, 'codebert': 13, 'PLBART': -1, 'devign': 23, 'regvd': 24, 'vulberta_cnn': 51, 'vulberta_mlp': 17}
38         DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts);                   {'linevul': 1, 'codebert': 0, 'PLBART': -1, 'devign': 6, 'regvd': 1, 'vulberta_cnn': 3, 'vulberta_mlp': 4}
40         return -1;                                                                           {'linevul': 16, 'codebert': 20, 'PLBART': -1, 'devign': 36, 'regvd': 48, 'vulberta_cnn': 14, 'vulberta_mlp': 35}
42     }                                                                                        {'linevul': 25, 'codebert': 12, 'PLBART': -1, 'devign': 126, 'regvd': 67, 'vulberta_cnn': 36, 'vulberta_mlp': 59}
46     /* map PRDT */                                                                           {'linevul': 20, 'codebert': 11, 'PLBART': -1, 'devign': 122, 'regvd': 52, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
48     if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,                           {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 5, 'vulberta_cnn': 63, 'vulberta_mlp': 13}
50                                 DMA_DIRECTION_TO_DEVICE))){                                  {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 52, 'regvd': 44, 'vulberta_cnn': 8, 'vulberta_mlp': 12}
52         DPRINTF(ad->port_no, "map failed\n");                                                {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 6, 'vulberta_cnn': 13, 'vulberta_mlp': 5}
54         return -1;                                                                           {'linevul': 15, 'codebert': -1, 'PLBART': -1, 'devign': 35, 'regvd': 47, 'vulberta_cnn': 50, 'vulberta_mlp': 20}
56     }                                                                                        {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': 116, 'regvd': 66, 'vulberta_cnn': 16, 'vulberta_mlp': 8}
60     if (prdt_len < real_prdt_len) {                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 32, 'vulberta_cnn': 2, 'vulberta_mlp': 28}
62         DPRINTF(ad->port_no, "mapped less than expected\n");                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 2, 'vulberta_cnn': 9, 'vulberta_mlp': 6}
64         r = -1;                                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 42, 'regvd': 50, 'vulberta_cnn': 21, 'vulberta_mlp': 58}
66         goto out;                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 48, 'regvd': 55, 'vulberta_cnn': 40, 'vulberta_mlp': 57}
68     }                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 108, 'regvd': 65, 'vulberta_cnn': 23, 'vulberta_mlp': 56}
72     /* Get entries in the PRDT, init a qemu sglist accordingly */                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 25, 'regvd': 35, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
74     if (sglist_alloc_hint > 0) {                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 26, 'regvd': 22, 'vulberta_cnn': 59, 'vulberta_mlp': 31}
76         AHCI_SG *tbl = (AHCI_SG *)prdt;                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 30, 'regvd': 13, 'vulberta_cnn': 37, 'vulberta_mlp': 27}
78         sum = 0;                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 50, 'regvd': 46, 'vulberta_cnn': 41, 'vulberta_mlp': 34}
80         for (i = 0; i < sglist_alloc_hint; i++) {                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 11, 'vulberta_cnn': 43, 'vulberta_mlp': 43}
82             /* flags_size is zero-based */                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 99, 'regvd': 42, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
84             tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 17, 'vulberta_cnn': 56, 'vulberta_mlp': 33}
86             if (offset <= (sum + tbl_entry_size)) {                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 25, 'vulberta_cnn': 7, 'vulberta_mlp': 37}
88                 off_idx = i;                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 39, 'regvd': 43, 'vulberta_cnn': 39, 'vulberta_mlp': 55}
90                 off_pos = offset - sum;                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 38, 'regvd': 36, 'vulberta_cnn': 58, 'vulberta_mlp': 54}
92                 break;                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 54, 'regvd': 56, 'vulberta_cnn': 29, 'vulberta_mlp': 53}
94             }                                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 92, 'regvd': 64, 'vulberta_cnn': 15, 'vulberta_mlp': 52}
96             sum += tbl_entry_size;                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 49, 'regvd': 34, 'vulberta_cnn': 24, 'vulberta_mlp': 44}
98         }                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 89, 'regvd': 63, 'vulberta_cnn': 17, 'vulberta_mlp': 9}
100         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 1, 'regvd': 15, 'vulberta_cnn': 49, 'vulberta_mlp': 29}
102             DPRINTF(ad->port_no, "%s: Incorrect offset! "                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 16, 'vulberta_cnn': 18, 'vulberta_mlp': 3}
104                             "off_idx: %d, off_pos: %d\n",                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 38, 'vulberta_cnn': 35, 'vulberta_mlp': 26}
106                             __func__, off_idx, off_pos);                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 33, 'vulberta_cnn': 11, 'vulberta_mlp': 47}
108             r = -1;                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 41, 'regvd': 49, 'vulberta_cnn': 46, 'vulberta_mlp': 19}
110             goto out;                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 47, 'regvd': 54, 'vulberta_cnn': 26, 'vulberta_mlp': 51}
112         }                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 81, 'regvd': 62, 'vulberta_cnn': 32, 'vulberta_mlp': 50}
116         qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 10, 'vulberta_cnn': 1, 'vulberta_mlp': 16}
118                          ad->hba->as);                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 34, 'regvd': 40, 'vulberta_cnn': 60, 'vulberta_mlp': 0}
120         qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 14, 'vulberta_cnn': 34, 'vulberta_mlp': 21}
122                         le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 18, 'vulberta_cnn': 45, 'vulberta_mlp': 24}
126         for (i = off_idx + 1; i < sglist_alloc_hint; i++) {                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 8, 'vulberta_cnn': 12, 'vulberta_mlp': 14}
128             /* flags_size is zero-based */                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 70, 'regvd': 41, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
130             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 20, 'vulberta_cnn': 5, 'vulberta_mlp': 32}
132                             le32_to_cpu(tbl[i].flags_size) + 1);                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 45, 'regvd': 27, 'vulberta_cnn': 61, 'vulberta_mlp': 11}
134         }                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 66, 'regvd': 61, 'vulberta_cnn': 30, 'vulberta_mlp': 2}
136     }                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 64, 'regvd': 60, 'vulberta_cnn': 20, 'vulberta_mlp': 7}
140 out:                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 43, 'regvd': 57, 'vulberta_cnn': 28, 'vulberta_mlp': 49}
142     dma_memory_unmap(ad->hba->as, prdt, prdt_len,                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 12, 'vulberta_cnn': 0, 'vulberta_mlp': 46}
144                      DMA_DIRECTION_TO_DEVICE, prdt_len);                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 19, 'vulberta_cnn': 42, 'vulberta_mlp': 38}
146     return r;                                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 51, 'regvd': 53, 'vulberta_cnn': 19, 'vulberta_mlp': 30}
148 }                                                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 56, 'regvd': 59, 'vulberta_cnn': 62, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)
6     uint32_t opts = le32_to_cpu(cmd->opts);
8     uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;
10     int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;
12     dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));
38         DPRINTF(ad->port_no, "no sg list given by guest: 0x%08x\n", opts);
52         DPRINTF(ad->port_no, "map failed\n");
62         DPRINTF(ad->port_no, "mapped less than expected\n");
--------------------------------------------------------------------------------------------------------------
Example ids:  11383 project:  FFmpeg commit id:  3df2be9fa7365646f22a93cfde1e4097467f498e Number of lines:  30
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,                            {'linevul': 8, 'codebert': 0, 'PLBART': 0, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 7}
2                                     AVPacket *pkt, uint64_t display_duration)                  {'linevul': 0, 'codebert': 2, 'PLBART': 4, 'regvd': 13, 'vulberta_cnn': 8, 'vulberta_mlp': 20}
4 {                                                                                              {'linevul': 21, 'codebert': 10, 'PLBART': 10, 'regvd': 27, 'vulberta_cnn': 14, 'vulberta_mlp': 27}
6     char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;                                {'linevul': 2, 'codebert': 1, 'PLBART': 1, 'regvd': 4, 'vulberta_cnn': 27, 'vulberta_mlp': 13}
8     for (; *ptr!=',' && ptr<end-1; ptr++);                                                     {'linevul': 15, 'codebert': 6, 'PLBART': 3, 'regvd': 3, 'vulberta_cnn': 9, 'vulberta_mlp': 29}
10     if (*ptr == ',')                                                                          {'linevul': 20, 'codebert': 9, 'PLBART': 8, 'regvd': 10, 'vulberta_cnn': 11, 'vulberta_mlp': 23}
12         layer = ++ptr;                                                                        {'linevul': 18, 'codebert': 3, 'PLBART': 9, 'regvd': 23, 'vulberta_cnn': 23, 'vulberta_mlp': 17}
14     for (; *ptr!=',' && ptr<end-1; ptr++);                                                    {'linevul': 14, 'codebert': 5, 'PLBART': 5, 'regvd': 2, 'vulberta_cnn': 4, 'vulberta_mlp': 24}
16     if (*ptr == ',') {                                                                        {'linevul': 19, 'codebert': 8, 'PLBART': 6, 'regvd': 9, 'vulberta_cnn': 1, 'vulberta_mlp': 26}
18         int64_t end_pts = pkt->pts + display_duration;                                        {'linevul': 5, 'codebert': 4, 'PLBART': 2, 'regvd': 8, 'vulberta_cnn': 17, 'vulberta_mlp': 11}
20         int sc = matroska->time_scale * pkt->pts / 10000000;                                  {'linevul': 3, 'codebert': 7, 'PLBART': 7, 'regvd': 1, 'vulberta_cnn': 26, 'vulberta_mlp': 15}
22         int ec = matroska->time_scale * end_pts  / 10000000;                                  {'linevul': 4, 'codebert': 11, 'PLBART': -1, 'regvd': 0, 'vulberta_cnn': 28, 'vulberta_mlp': 16}
24         int sh, sm, ss, eh, em, es, len;                                                      {'linevul': 12, 'codebert': 12, 'PLBART': -1, 'regvd': 20, 'vulberta_cnn': 7, 'vulberta_mlp': 25}
26         sh = sc/360000;  sc -= 360000*sh;                                                     {'linevul': 13, 'codebert': 16, 'PLBART': -1, 'regvd': 14, 'vulberta_cnn': 3, 'vulberta_mlp': 9}
28         sm = sc/  6000;  sc -=   6000*sm;                                                     {'linevul': 9, 'codebert': 14, 'PLBART': -1, 'regvd': 18, 'vulberta_cnn': 21, 'vulberta_mlp': 19}
30         ss = sc/   100;  sc -=    100*ss;                                                     {'linevul': 7, 'codebert': 15, 'PLBART': -1, 'regvd': 16, 'vulberta_cnn': 19, 'vulberta_mlp': 14}
32         eh = ec/360000;  ec -= 360000*eh;                                                     {'linevul': 11, 'codebert': 13, 'PLBART': -1, 'regvd': 19, 'vulberta_cnn': 2, 'vulberta_mlp': 2}
34         em = ec/  6000;  ec -=   6000*em;                                                     {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'regvd': 21, 'vulberta_cnn': 25, 'vulberta_mlp': 3}
36         es = ec/   100;  ec -=    100*es;                                                     {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'regvd': 15, 'vulberta_cnn': 10, 'vulberta_mlp': 18}
38         *ptr++ = '\0';                                                                        {'linevul': 17, 'codebert': -1, 'PLBART': -1, 'regvd': 12, 'vulberta_cnn': 24, 'vulberta_mlp': 28}
40         len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;                                    {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'regvd': 6, 'vulberta_cnn': 5, 'vulberta_mlp': 12}
42         if (!(line = av_malloc(len)))                                                         {'linevul': 16, 'codebert': -1, 'PLBART': -1, 'regvd': 25, 'vulberta_cnn': 22, 'vulberta_mlp': 6}
44             return;                                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 26, 'vulberta_cnn': 20, 'vulberta_mlp': 5}
46         snprintf(line,len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s",              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 22, 'vulberta_cnn': 18, 'vulberta_mlp': 8}
48                  layer, sh, sm, ss, sc, eh, em, es, ec, ptr);                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 5, 'vulberta_cnn': 0, 'vulberta_mlp': 21}
50         av_free(pkt->data);                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 17, 'vulberta_cnn': 6, 'vulberta_mlp': 10}
52         pkt->data = line;                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 24, 'vulberta_cnn': 16, 'vulberta_mlp': 22}
54         pkt->size = strlen(line);                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': 11, 'vulberta_cnn': 12, 'vulberta_mlp': 4}
56     }                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': -1, 'vulberta_cnn': 15, 'vulberta_mlp': 1}
58 }                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'regvd': -1, 'vulberta_cnn': 29, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,
2                                     AVPacket *pkt, uint64_t display_duration)
6     char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;
8     for (; *ptr!=',' && ptr<end-1; ptr++);
14     for (; *ptr!=',' && ptr<end-1; ptr++);
16     if (*ptr == ',') {
18         int64_t end_pts = pkt->pts + display_duration;
20         int sc = matroska->time_scale * pkt->pts / 10000000;
--------------------------------------------------------------------------------------------------------------
Example ids:  11433 project:  FFmpeg commit id:  8ce803db51a28eb662b6271b2b223e0312bdb3d2 Number of lines:  31
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 paint_mouse_pointer(XImage *image, struct x11_grab *s)                                                               {'linevul': 8, 'codebert': 0, 'devign': 2, 'regvd': 11, 'vulberta_cnn': 13, 'vulberta_mlp': 8}
2 {                                                                                                                    {'linevul': 22, 'codebert': 1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 14, 'vulberta_mlp': 30}
4     int x_off = s->x_off;                                                                                            {'linevul': 12, 'codebert': 3, 'devign': 10, 'regvd': 13, 'vulberta_cnn': 26, 'vulberta_mlp': 26}
6     int y_off = s->y_off;                                                                                            {'linevul': 14, 'codebert': 10, 'devign': 13, 'regvd': 15, 'vulberta_cnn': 20, 'vulberta_mlp': 25}
8     int width = s->width;                                                                                            {'linevul': 19, 'codebert': 14, 'devign': 17, 'regvd': 21, 'vulberta_cnn': 1, 'vulberta_mlp': 29}
10     int height = s->height;                                                                                         {'linevul': 18, 'codebert': 13, 'devign': 18, 'regvd': 23, 'vulberta_cnn': 3, 'vulberta_mlp': 24}
12     Display *dpy = s->dpy;                                                                                          {'linevul': 15, 'codebert': 8, 'devign': 19, 'regvd': 18, 'vulberta_cnn': 5, 'vulberta_mlp': 9}
14     XFixesCursorImage *xcim;                                                                                        {'linevul': 16, 'codebert': 4, 'devign': 25, 'regvd': 16, 'vulberta_cnn': 6, 'vulberta_mlp': 15}
16     int x, y;                                                                                                       {'linevul': 20, 'codebert': 19, 'devign': 24, 'regvd': 24, 'vulberta_cnn': 16, 'vulberta_mlp': 28}
18     int line, column;                                                                                               {'linevul': 21, 'codebert': 18, 'devign': 20, 'regvd': 25, 'vulberta_cnn': 19, 'vulberta_mlp': 27}
20     int to_line, to_column;                                                                                         {'linevul': 17, 'codebert': 20, 'devign': 7, 'regvd': 20, 'vulberta_cnn': 12, 'vulberta_mlp': 23}
22     int image_addr, xcim_addr;                                                                                      {'linevul': 13, 'codebert': 11, 'devign': 22, 'regvd': 12, 'vulberta_cnn': 24, 'vulberta_mlp': 22}
26     xcim = XFixesGetCursorImage(dpy);                                                                               {'linevul': 9, 'codebert': 2, 'devign': 4, 'regvd': 10, 'vulberta_cnn': 8, 'vulberta_mlp': 1}
30     x = xcim->x - xcim->xhot;                                                                                       {'linevul': 11, 'codebert': 15, 'devign': 14, 'regvd': 19, 'vulberta_cnn': 27, 'vulberta_mlp': 19}
32     y = xcim->y - xcim->yhot;                                                                                       {'linevul': 10, 'codebert': 17, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 17, 'vulberta_mlp': 17}
36     to_line = FFMIN((y + xcim->height), (height + y_off));                                                          {'linevul': 7, 'codebert': 5, 'devign': 9, 'regvd': 1, 'vulberta_cnn': 7, 'vulberta_mlp': 14}
38     to_column = FFMIN((x + xcim->width), (width + x_off));                                                          {'linevul': 6, 'codebert': 7, 'devign': 8, 'regvd': 5, 'vulberta_cnn': 23, 'vulberta_mlp': 11}
42     for (line = FFMAX(y, y_off); line < to_line; line++) {                                                          {'linevul': 5, 'codebert': 9, 'devign': 1, 'regvd': 9, 'vulberta_cnn': 10, 'vulberta_mlp': 2}
44         for (column = FFMAX(x, x_off); column < to_column; column++) {                                              {'linevul': 4, 'codebert': 12, 'devign': 0, 'regvd': 8, 'vulberta_cnn': 28, 'vulberta_mlp': 20}
46             xcim_addr = (line - y) * xcim->width + column - x;                                                      {'linevul': 3, 'codebert': 16, 'devign': 3, 'regvd': 6, 'vulberta_cnn': 4, 'vulberta_mlp': 16}
50             if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel              {'linevul': 1, 'codebert': 6, 'devign': 6, 'regvd': 3, 'vulberta_cnn': 0, 'vulberta_mlp': 3}
52                 image_addr = ((line - y_off) * width + column - x_off) * 4;                                         {'linevul': 2, 'codebert': -1, 'devign': 5, 'regvd': 0, 'vulberta_cnn': 9, 'vulberta_mlp': 12}
56                 image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);                            {'linevul': 0, 'codebert': -1, 'devign': 15, 'regvd': 7, 'vulberta_cnn': 2, 'vulberta_mlp': 7}
58                 image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);                          {'linevul': -1, 'codebert': -1, 'devign': 11, 'regvd': 4, 'vulberta_cnn': 29, 'vulberta_mlp': 21}
60                 image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);                         {'linevul': -1, 'codebert': -1, 'devign': 16, 'regvd': 2, 'vulberta_cnn': 22, 'vulberta_mlp': 10}
62             }                                                                                                       {'linevul': -1, 'codebert': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 11, 'vulberta_mlp': 6}
64         }                                                                                                           {'linevul': -1, 'codebert': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 15, 'vulberta_mlp': 5}
66     }                                                                                                               {'linevul': -1, 'codebert': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 18, 'vulberta_mlp': 4}
70     XFree(xcim);                                                                                                    {'linevul': -1, 'codebert': -1, 'devign': 21, 'regvd': 17, 'vulberta_cnn': 21, 'vulberta_mlp': 18}
72     xcim = NULL;                                                                                                    {'linevul': -1, 'codebert': -1, 'devign': 23, 'regvd': 22, 'vulberta_cnn': 25, 'vulberta_mlp': 13}
74 }                                                                                                                   {'linevul': -1, 'codebert': -1, 'devign': -1, 'regvd': -1, 'vulberta_cnn': 30, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 paint_mouse_pointer(XImage *image, struct x11_grab *s)
26     xcim = XFixesGetCursorImage(dpy);
36     to_line = FFMIN((y + xcim->height), (height + y_off));
38     to_column = FFMIN((x + xcim->width), (width + x_off));
42     for (line = FFMAX(y, y_off); line < to_line; line++) {
46             xcim_addr = (line - y) * xcim->width + column - x;
50             if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel
52                 image_addr = ((line - y_off) * width + column - x_off) * 4;
56                 image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);
--------------------------------------------------------------------------------------------------------------
Example ids:  12083 project:  qemu commit id:  6350b0904615cc0531cc3059ea34db5c009c88aa Number of lines:  25
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_mlp']
0 static void set_int8(Object *obj, Visitor *v, void *opaque,                  {'linevul': 7, 'codebert': 1, 'PLBART': 1, 'devign': 6, 'regvd': 3, 'vulberta_mlp': 20}
2                      const char *name, Error **errp)                         {'linevul': 2, 'codebert': 8, 'PLBART': 5, 'devign': 5, 'regvd': 12, 'vulberta_mlp': 13}
4 {                                                                            {'linevul': 24, 'codebert': 16, 'PLBART': 13, 'devign': 51, 'regvd': 20, 'vulberta_mlp': 22}
6     DeviceState *dev = DEVICE(obj);                                          {'linevul': 11, 'codebert': 4, 'PLBART': 6, 'devign': 11, 'regvd': 8, 'vulberta_mlp': 23}
8     Property *prop = opaque;                                                 {'linevul': 18, 'codebert': 6, 'PLBART': 8, 'devign': 13, 'regvd': 14, 'vulberta_mlp': 9}
10     int8_t *ptr = qdev_get_prop_ptr(dev, prop);                             {'linevul': 4, 'codebert': 3, 'PLBART': 3, 'devign': 4, 'regvd': 0, 'vulberta_mlp': 2}
12     Error *local_err = NULL;                                                {'linevul': 13, 'codebert': 15, 'PLBART': 7, 'devign': 14, 'regvd': 10, 'vulberta_mlp': 19}
14     int64_t value;                                                          {'linevul': 17, 'codebert': 17, 'PLBART': 9, 'devign': 15, 'regvd': 16, 'vulberta_mlp': 21}
18     if (dev->state != DEV_STATE_CREATED) {                                  {'linevul': 10, 'codebert': 11, 'PLBART': 4, 'devign': 9, 'regvd': 5, 'vulberta_mlp': 15}
20         error_set(errp, QERR_PERMISSION_DENIED);                            {'linevul': 3, 'codebert': 10, 'PLBART': 2, 'devign': 8, 'regvd': 2, 'vulberta_mlp': 16}
22         return;                                                             {'linevul': 16, 'codebert': 22, 'PLBART': 11, 'devign': 18, 'regvd': 19, 'vulberta_mlp': 24}
24     }                                                                       {'linevul': 22, 'codebert': 20, 'PLBART': 12, 'devign': 39, 'regvd': 24, 'vulberta_mlp': 3}
28     visit_type_int(v, &value, name, &local_err);                            {'linevul': 8, 'codebert': 2, 'PLBART': 0, 'devign': 3, 'regvd': 1, 'vulberta_mlp': 6}
30     if (local_err) {                                                        {'linevul': 14, 'codebert': 19, 'PLBART': 10, 'devign': 12, 'regvd': 11, 'vulberta_mlp': 4}
32         error_propagate(errp, local_err);                                   {'linevul': 9, 'codebert': 14, 'PLBART': -1, 'devign': 2, 'regvd': 4, 'vulberta_mlp': 1}
34         return;                                                             {'linevul': 15, 'codebert': 23, 'PLBART': -1, 'devign': 17, 'regvd': 18, 'vulberta_mlp': 10}
36     }                                                                       {'linevul': 21, 'codebert': 24, 'PLBART': -1, 'devign': 31, 'regvd': 23, 'vulberta_mlp': 18}
38     if (value > prop->info->min && value <= prop->info->max) {              {'linevul': 6, 'codebert': 12, 'PLBART': -1, 'devign': 1, 'regvd': 6, 'vulberta_mlp': 11}
40         *ptr = value;                                                       {'linevul': 12, 'codebert': 5, 'PLBART': -1, 'devign': 16, 'regvd': 15, 'vulberta_mlp': 0}
42     } else {                                                                {'linevul': 19, 'codebert': 21, 'PLBART': -1, 'devign': 27, 'regvd': 17, 'vulberta_mlp': 8}
44         error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,                   {'linevul': 1, 'codebert': 0, 'PLBART': -1, 'devign': 10, 'regvd': 7, 'vulberta_mlp': 14}
46                   dev->id?:"", name, value, prop->info->min,                {'linevul': 0, 'codebert': 7, 'PLBART': -1, 'devign': 0, 'regvd': 9, 'vulberta_mlp': 12}
48                   prop->info->max);                                         {'linevul': 5, 'codebert': 13, 'PLBART': -1, 'devign': 7, 'regvd': 13, 'vulberta_mlp': 5}
50     }                                                                       {'linevul': 20, 'codebert': 9, 'PLBART': -1, 'devign': 22, 'regvd': 22, 'vulberta_mlp': 17}
52 }                                                                           {'linevul': 23, 'codebert': 18, 'PLBART': -1, 'devign': 20, 'regvd': 21, 'vulberta_mlp': 7}
-----------------------
Highlighted lines: 
0 static void set_int8(Object *obj, Visitor *v, void *opaque,
2                      const char *name, Error **errp)
10     int8_t *ptr = qdev_get_prop_ptr(dev, prop);
20         error_set(errp, QERR_PERMISSION_DENIED);
28     visit_type_int(v, &value, name, &local_err);
32         error_propagate(errp, local_err);
46                   dev->id?:"", name, value, prop->info->min,
--------------------------------------------------------------------------------------------------------------
Example ids:  12499 project:  qemu commit id:  f3c7d0389fe8a2792fd4c1cf151b885de03c8f62 Number of lines:  24
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,                      {'linevul': 5, 'codebert': 2, 'PLBART': 0, 'devign': 7, 'regvd': 5, 'vulberta_cnn': 21, 'vulberta_mlp': 12}
2                 BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],                    {'linevul': 0, 'codebert': 3, 'PLBART': 3, 'devign': 0, 'regvd': 10, 'vulberta_cnn': 8, 'vulberta_mlp': 1}
4                 omap_clk fclk, omap_clk iclk)                                          {'linevul': 4, 'codebert': 5, 'PLBART': 4, 'devign': 2, 'regvd': 12, 'vulberta_cnn': 17, 'vulberta_mlp': 7}
6 {                                                                                      {'linevul': 23, 'codebert': 11, 'PLBART': 12, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 13, 'vulberta_mlp': 0}
8     struct omap_mmc_s *s = (struct omap_mmc_s *)                                       {'linevul': 7, 'codebert': 7, 'PLBART': 1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 6, 'vulberta_mlp': 5}
10             g_malloc0(sizeof(struct omap_mmc_s));                                     {'linevul': 6, 'codebert': 0, 'PLBART': 2, 'devign': -1, 'regvd': 3, 'vulberta_cnn': 11, 'vulberta_mlp': 16}
14     s->irq = irq;                                                                     {'linevul': 16, 'codebert': 14, 'PLBART': 9, 'devign': 5, 'regvd': 14, 'vulberta_cnn': 12, 'vulberta_mlp': 18}
16     s->dma = dma;                                                                     {'linevul': 15, 'codebert': 15, 'PLBART': 8, 'devign': 10, 'regvd': 15, 'vulberta_cnn': 2, 'vulberta_mlp': 2}
18     s->clk = fclk;                                                                    {'linevul': 13, 'codebert': 16, 'PLBART': 6, 'devign': 8, 'regvd': 13, 'vulberta_cnn': 5, 'vulberta_mlp': 20}
20     s->lines = 4;                                                                     {'linevul': 19, 'codebert': 17, 'PLBART': 10, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 20, 'vulberta_mlp': 8}
22     s->rev = 2;                                                                       {'linevul': 18, 'codebert': 18, 'PLBART': 11, 'devign': 14, 'regvd': 18, 'vulberta_cnn': 14, 'vulberta_mlp': 21}
26     omap_mmc_reset(s);                                                                {'linevul': 11, 'codebert': 12, 'PLBART': 7, 'devign': 11, 'regvd': 9, 'vulberta_cnn': 15, 'vulberta_mlp': 17}
30     memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc",              {'linevul': 2, 'codebert': 4, 'PLBART': 5, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 18, 'vulberta_mlp': 19}
32                           omap_l4_region_size(ta, 0));                                {'linevul': 1, 'codebert': 6, 'PLBART': -1, 'devign': -1, 'regvd': 4, 'vulberta_cnn': 3, 'vulberta_mlp': 9}
34     omap_l4_attach(ta, 0, &s->iomem);                                                 {'linevul': 8, 'codebert': 8, 'PLBART': -1, 'devign': 9, 'regvd': 1, 'vulberta_cnn': 1, 'vulberta_mlp': 15}
38     /* Instantiate the storage */                                                     {'linevul': 17, 'codebert': 9, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
40     s->card = sd_init(bd, false);                                                     {'linevul': 10, 'codebert': 1, 'PLBART': -1, 'devign': 4, 'regvd': 6, 'vulberta_cnn': 10, 'vulberta_mlp': 6}
42     if (s->card == NULL) {                                                            {'linevul': 12, 'codebert': 10, 'PLBART': -1, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 4, 'vulberta_mlp': 22}
44         exit(1);                                                                      {'linevul': 14, 'codebert': 13, 'PLBART': -1, 'devign': 15, 'regvd': 19, 'vulberta_cnn': 16, 'vulberta_mlp': 10}
46     }                                                                                 {'linevul': 21, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 9, 'vulberta_mlp': 4}
50     s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];                         {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 1, 'regvd': 0, 'vulberta_cnn': 0, 'vulberta_mlp': 14}
52     sd_set_cb(s->card, NULL, s->cdet);                                                {'linevul': 9, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 7, 'vulberta_cnn': 19, 'vulberta_mlp': 13}
56     return s;                                                                         {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 20, 'vulberta_cnn': 7, 'vulberta_mlp': 11}
58 }                                                                                     {'linevul': 22, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 22, 'vulberta_mlp': 3}
-----------------------
Highlighted lines: 
0 struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
2                 BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
4                 omap_clk fclk, omap_clk iclk)
8     struct omap_mmc_s *s = (struct omap_mmc_s *)
10             g_malloc0(sizeof(struct omap_mmc_s));
30     memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc",
32                           omap_l4_region_size(ta, 0));
34     omap_l4_attach(ta, 0, &s->iomem);
40     s->card = sd_init(bd, false);
50     s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
--------------------------------------------------------------------------------------------------------------
Example ids:  12548 project:  qemu commit id:  c508277335e3b6b20cf18e6ea3a35c1fa835c64a Number of lines:  27
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void vmxnet3_update_mcast_filters(VMXNET3State *s)                                    {'linevul': 10, 'codebert': 6, 'PLBART': 1, 'devign': 8, 'regvd': 9, 'vulberta_cnn': 5, 'vulberta_mlp': 23}
2 {                                                                                            {'linevul': 20, 'codebert': 7, 'PLBART': 9, 'devign': 60, 'regvd': 22, 'vulberta_cnn': 13, 'vulberta_mlp': 26}
4     uint16_t list_bytes =                                                                    {'linevul': 15, 'codebert': 9, 'PLBART': 7, 'devign': 18, 'regvd': 16, 'vulberta_cnn': 20, 'vulberta_mlp': 21}
6         VMXNET3_READ_DRV_SHARED16(s->drv_shmem,                                              {'linevul': 6, 'codebert': 4, 'PLBART': 2, 'devign': 14, 'regvd': 11, 'vulberta_cnn': 0, 'vulberta_mlp': 8}
8                                   devRead.rxFilterConf.mfTableLen);                          {'linevul': 1, 'codebert': 2, 'PLBART': 6, 'devign': 16, 'regvd': 18, 'vulberta_cnn': 4, 'vulberta_mlp': 19}
12     s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);                              {'linevul': 7, 'codebert': 8, 'PLBART': 0, 'devign': 1, 'regvd': 4, 'vulberta_cnn': 24, 'vulberta_mlp': 15}
16     s->mcast_list = g_realloc(s->mcast_list, list_bytes);                                   {'linevul': 8, 'codebert': 5, 'PLBART': 3, 'devign': 3, 'regvd': 7, 'vulberta_cnn': 12, 'vulberta_mlp': 22}
18     if (!s->mcast_list) {                                                                   {'linevul': 14, 'codebert': 10, 'PLBART': 5, 'devign': 5, 'regvd': 10, 'vulberta_cnn': 14, 'vulberta_mlp': 13}
20         if (s->mcast_list_len == 0) {                                                       {'linevul': 11, 'codebert': 11, 'PLBART': 8, 'devign': 4, 'regvd': 8, 'vulberta_cnn': 10, 'vulberta_mlp': 14}
22             VMW_CFPRN("Current multicast list is empty");                                   {'linevul': 9, 'codebert': 0, 'PLBART': 4, 'devign': 10, 'regvd': 5, 'vulberta_cnn': 22, 'vulberta_mlp': 6}
24         } else {                                                                            {'linevul': 17, 'codebert': 15, 'PLBART': -1, 'devign': 21, 'regvd': 20, 'vulberta_cnn': 18, 'vulberta_mlp': 3}
26             VMW_ERPRN("Failed to allocate multicast list of %d elements",                   {'linevul': 5, 'codebert': 1, 'PLBART': -1, 'devign': 12, 'regvd': 3, 'vulberta_cnn': 25, 'vulberta_mlp': 24}
28                       s->mcast_list_len);                                                   {'linevul': 4, 'codebert': 12, 'PLBART': -1, 'devign': 11, 'regvd': 14, 'vulberta_cnn': 1, 'vulberta_mlp': 5}
30         }                                                                                   {'linevul': 18, 'codebert': 17, 'PLBART': -1, 'devign': 43, 'regvd': 26, 'vulberta_cnn': 9, 'vulberta_mlp': 1}
32         s->mcast_list_len = 0;                                                              {'linevul': 12, 'codebert': 13, 'PLBART': -1, 'devign': 9, 'regvd': 13, 'vulberta_cnn': 17, 'vulberta_mlp': 11}
34     } else {                                                                                {'linevul': 19, 'codebert': 14, 'PLBART': -1, 'devign': 20, 'regvd': 19, 'vulberta_cnn': 11, 'vulberta_mlp': 2}
36         int i;                                                                              {'linevul': 16, 'codebert': 16, 'PLBART': -1, 'devign': 19, 'regvd': 21, 'vulberta_cnn': 19, 'vulberta_mlp': 16}
38         hwaddr mcast_list_pa =                                                              {'linevul': 13, 'codebert': 3, 'PLBART': -1, 'devign': 17, 'regvd': 15, 'vulberta_cnn': 15, 'vulberta_mlp': 9}
40             VMXNET3_READ_DRV_SHARED64(s->drv_shmem,                                         {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 12, 'vulberta_cnn': 6, 'vulberta_mlp': 10}
42                                       devRead.rxFilterConf.mfTablePA);                      {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 17, 'vulberta_cnn': 23, 'vulberta_mlp': 25}
46         pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);              {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 2, 'vulberta_cnn': 2, 'vulberta_mlp': 20}
50         VMW_CFPRN("Current multicast list len is %d:", s->mcast_list_len);                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 0, 'vulberta_cnn': 7, 'vulberta_mlp': 18}
52         for (i = 0; i < s->mcast_list_len; i++) {                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 6, 'vulberta_cnn': 21, 'vulberta_mlp': 17}
54             VMW_CFPRN("\t" MAC_FMT, MAC_ARG(s->mcast_list[i].a));                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 1, 'vulberta_cnn': 8, 'vulberta_mlp': 12}
56         }                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 25, 'vulberta_cnn': 16, 'vulberta_mlp': 4}
58     }                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 25, 'regvd': 24, 'vulberta_cnn': 3, 'vulberta_mlp': 7}
60 }                                                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 23, 'regvd': 23, 'vulberta_cnn': 26, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void vmxnet3_update_mcast_filters(VMXNET3State *s)
6         VMXNET3_READ_DRV_SHARED16(s->drv_shmem,
8                                   devRead.rxFilterConf.mfTableLen);
12     s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);
16     s->mcast_list = g_realloc(s->mcast_list, list_bytes);
22             VMW_CFPRN("Current multicast list is empty");
46         pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);
--------------------------------------------------------------------------------------------------------------
Example ids:  13114 project:  qemu commit id:  187337f8b0ec0813dd3876d1efe37d415fb81c2e Number of lines:  22
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 void pl011_init(uint32_t base, qemu_irq irq,                                       {'linevul': 7, 'codebert': 2, 'PLBART': 3, 'devign': 3, 'regvd': 3, 'vulberta_cnn': 13, 'vulberta_mlp': 6}
2                 CharDriverState *chr)                                              {'linevul': 6, 'codebert': 1, 'PLBART': 7, 'devign': 2, 'regvd': 18, 'vulberta_cnn': 3, 'vulberta_mlp': 15}
4 {                                                                                  {'linevul': 20, 'codebert': 7, 'PLBART': 13, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 9, 'vulberta_mlp': 17}
6     int iomemtype;                                                                 {'linevul': 18, 'codebert': 9, 'PLBART': 11, 'devign': 13, 'regvd': 17, 'vulberta_cnn': 15, 'vulberta_mlp': 16}
8     pl011_state *s;                                                                {'linevul': 15, 'codebert': 5, 'PLBART': 8, 'devign': 14, 'regvd': 7, 'vulberta_cnn': 6, 'vulberta_mlp': 11}
12     s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));                         {'linevul': 3, 'codebert': 0, 'PLBART': 0, 'devign': 0, 'regvd': 0, 'vulberta_cnn': 18, 'vulberta_mlp': 7}
14     iomemtype = cpu_register_io_memory(0, pl011_readfn,                           {'linevul': 4, 'codebert': 6, 'PLBART': 2, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 12, 'vulberta_mlp': 3}
16                                        pl011_writefn, s);                         {'linevul': 0, 'codebert': 10, 'PLBART': 12, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 2, 'vulberta_mlp': 9}
18     cpu_register_physical_memory(base, 0x00000fff, iomemtype);                    {'linevul': 5, 'codebert': 3, 'PLBART': 1, 'devign': 10, 'regvd': 2, 'vulberta_cnn': 4, 'vulberta_mlp': 2}
20     s->base = base;                                                               {'linevul': 16, 'codebert': 16, 'PLBART': 5, 'devign': 5, 'regvd': 14, 'vulberta_cnn': 0, 'vulberta_mlp': 13}
22     s->irq = irq;                                                                 {'linevul': 14, 'codebert': 17, 'PLBART': 9, 'devign': 11, 'regvd': 10, 'vulberta_cnn': 10, 'vulberta_mlp': 20}
24     s->chr = chr;                                                                 {'linevul': 13, 'codebert': 13, 'PLBART': 10, 'devign': 1, 'regvd': 13, 'vulberta_cnn': 1, 'vulberta_mlp': 14}
26     s->read_trigger = 1;                                                          {'linevul': 12, 'codebert': 14, 'PLBART': 6, 'devign': 4, 'regvd': 8, 'vulberta_cnn': 11, 'vulberta_mlp': 18}
28     s->ifl = 0x12;                                                                {'linevul': 9, 'codebert': 19, 'PLBART': 4, 'devign': 12, 'regvd': 9, 'vulberta_cnn': 7, 'vulberta_mlp': 19}
30     s->cr = 0x300;                                                                {'linevul': 11, 'codebert': 18, 'PLBART': -1, 'devign': 9, 'regvd': 11, 'vulberta_cnn': 17, 'vulberta_mlp': 10}
32     s->flags = 0x90;                                                              {'linevul': 10, 'codebert': 15, 'PLBART': -1, 'devign': 6, 'regvd': 12, 'vulberta_cnn': 16, 'vulberta_mlp': 12}
34     if (chr){                                                                     {'linevul': 17, 'codebert': 8, 'PLBART': -1, 'devign': 8, 'regvd': 15, 'vulberta_cnn': 8, 'vulberta_mlp': 8}
36         qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,              {'linevul': 1, 'codebert': 4, 'PLBART': -1, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 19, 'vulberta_mlp': 4}
38                               pl011_event, s);                                    {'linevul': 2, 'codebert': 12, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 5, 'vulberta_mlp': 1}
40     }                                                                             {'linevul': 19, 'codebert': 21, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 14, 'vulberta_mlp': 5}
42     /* ??? Save/restore.  */                                                      {'linevul': 8, 'codebert': 11, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
44 }                                                                                 {'linevul': 21, 'codebert': 20, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 20, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 void pl011_init(uint32_t base, qemu_irq irq,
2                 CharDriverState *chr)
8     pl011_state *s;
12     s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
14     iomemtype = cpu_register_io_memory(0, pl011_readfn,
16                                        pl011_writefn, s);
18     cpu_register_physical_memory(base, 0x00000fff, iomemtype);
28     s->ifl = 0x12;
34     if (chr){ 
36         qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
38                               pl011_event, s);
--------------------------------------------------------------------------------------------------------------
Example ids:  13739 project:  qemu commit id:  b71706d122838d9656e1a6dae80e22401babdf37 Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn']
0 static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,               {'linevul': 5, 'codebert': 0, 'PLBART': 0, 'devign': 0, 'regvd': 3, 'vulberta_cnn': 24}
2                                   size_t *count)                                            {'linevul': 0, 'codebert': 1, 'PLBART': 11, 'devign': 1, 'regvd': 17, 'vulberta_cnn': 5}
4 {                                                                                           {'linevul': 25, 'codebert': 3, 'PLBART': 12, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 17}
6     GIOStatus status;                                                                       {'linevul': 20, 'codebert': 9, 'PLBART': 8, 'devign': 2, 'regvd': 18, 'vulberta_cnn': 3}
8     OVERLAPPED ov = {0};                                                                    {'linevul': 18, 'codebert': 10, 'PLBART': 5, 'devign': 3, 'regvd': 10, 'vulberta_cnn': 20}
10     BOOL ret;                                                                              {'linevul': 23, 'codebert': 17, 'PLBART': 10, 'devign': 6, 'regvd': 21, 'vulberta_cnn': 21}
12     DWORD written;                                                                         {'linevul': 22, 'codebert': 2, 'PLBART': 9, 'devign': 4, 'regvd': 23, 'vulberta_cnn': 2}
16     ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);                                     {'linevul': 12, 'codebert': 14, 'PLBART': 1, 'devign': 7, 'regvd': 4, 'vulberta_cnn': 25}
18     ret = WriteFile(c->handle, buf, size, &written, &ov);                                  {'linevul': 7, 'codebert': 7, 'PLBART': 2, 'devign': 5, 'regvd': 1, 'vulberta_cnn': 12}
20     if (!ret) {                                                                            {'linevul': 21, 'codebert': 11, 'PLBART': 6, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 18}
22         if (GetLastError() == ERROR_IO_PENDING) {                                          {'linevul': 6, 'codebert': 8, 'PLBART': 4, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 16}
24             /* write is pending */                                                         {'linevul': 14, 'codebert': 15, 'PLBART': 7, 'devign': -1, 'regvd': 22, 'vulberta_cnn': -1}
26             ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);                     {'linevul': 2, 'codebert': 12, 'PLBART': 3, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 23}
28             if (!ret) {                                                                    {'linevul': 15, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 19}
30                 if (!GetLastError()) {                                                     {'linevul': 9, 'codebert': 5, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_cnn': 10}
32                     status = G_IO_STATUS_AGAIN;                                            {'linevul': 1, 'codebert': 6, 'PLBART': -1, 'devign': -1, 'regvd': 5, 'vulberta_cnn': 1}
34                 } else {                                                                   {'linevul': 13, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 13}
36                     status = G_IO_STATUS_ERROR;                                            {'linevul': 3, 'codebert': 4, 'PLBART': -1, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 4}
39             } else {                                                                       {'linevul': 16, 'codebert': 13, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 15}
41                 /* write is complete */                                                    {'linevul': 11, 'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': -1}
43                 status = G_IO_STATUS_NORMAL;                                               {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 7, 'vulberta_cnn': 8}
45                 *count = written;                                                          {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 6}
48         } else {                                                                           {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 7}
50             status = G_IO_STATUS_ERROR;                                                    {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 22}
53     } else {                                                                               {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 9}
55         /* write returned immediately */                                                   {'linevul': 17, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': -1}
57         status = G_IO_STATUS_NORMAL;                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 11}
59         *count = written;                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 14}
68     return status;                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 0}
-----------------------
Highlighted lines: 
0 static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
2                                   size_t *count)
6     GIOStatus status;
12     DWORD written;
18     ret = WriteFile(c->handle, buf, size, &written, &ov);
22         if (GetLastError() == ERROR_IO_PENDING) {
32                     status = G_IO_STATUS_AGAIN;
36                     status = G_IO_STATUS_ERROR;
--------------------------------------------------------------------------------------------------------------
Example ids:  14014 project:  FFmpeg commit id:  4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816 Number of lines:  22
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn']
0 static int update_dimensions(VP8Context *s, int width, int height)                                                 {'linevul': 13, 'codebert': 3, 'PLBART': 2, 'devign': 0, 'regvd': 11, 'vulberta_cnn': 4}
2 {                                                                                                                  {'linevul': 17, 'codebert': 14, 'PLBART': 9, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 7}
4     if (width  != s->avctx->width ||                                                                               {'linevul': 15, 'codebert': 13, 'PLBART': 7, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 12}
6         height != s->avctx->height) {                                                                              {'linevul': 14, 'codebert': 9, 'PLBART': 5, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 6}
8         if (av_image_check_size(width, height, 0, s->avctx))                                                       {'linevul': 7, 'codebert': 5, 'PLBART': 1, 'devign': 3, 'regvd': 8, 'vulberta_cnn': 3}
10             return AVERROR_INVALIDDATA;                                                                           {'linevul': 12, 'codebert': 7, 'PLBART': 6, 'devign': 14, 'regvd': 17, 'vulberta_cnn': 2}
14         vp8_decode_flush_impl(s->avctx, 1, 0, 1);                                                                 {'linevul': 6, 'codebert': 4, 'PLBART': 3, 'devign': 12, 'regvd': 9, 'vulberta_cnn': 16}
18         avcodec_set_dimensions(s->avctx, width, height);                                                          {'linevul': 8, 'codebert': 1, 'PLBART': 4, 'devign': 10, 'regvd': 7, 'vulberta_cnn': 13}
20     }                                                                                                             {'linevul': 16, 'codebert': 10, 'PLBART': 10, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 11}
24     s->mb_width  = (s->avctx->coded_width +15) / 16;                                                              {'linevul': 9, 'codebert': 0, 'PLBART': 0, 'devign': 4, 'regvd': 5, 'vulberta_cnn': 17}
26     s->mb_height = (s->avctx->coded_height+15) / 16;                                                              {'linevul': 10, 'codebert': 2, 'PLBART': 8, 'devign': 9, 'regvd': 6, 'vulberta_cnn': 14}
30     s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));              {'linevul': 0, 'codebert': 6, 'PLBART': -1, 'devign': 1, 'regvd': 0, 'vulberta_cnn': 0}
32     s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));                             {'linevul': 3, 'codebert': 8, 'PLBART': -1, 'devign': 6, 'regvd': 4, 'vulberta_cnn': 18}
34     s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);                                                       {'linevul': 5, 'codebert': 11, 'PLBART': -1, 'devign': 2, 'regvd': 3, 'vulberta_cnn': 19}
36     s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));                                     {'linevul': 1, 'codebert': 12, 'PLBART': -1, 'devign': 7, 'regvd': 2, 'vulberta_cnn': 10}
38     s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));                              {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 1, 'vulberta_cnn': 9}
42     if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||                              {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 20}
44         !s->top_nnz || !s->top_border)                                                                            {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 8}
46         return AVERROR(ENOMEM);                                                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 15}
50     s->macroblocks        = s->macroblocks_base + 1;                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 13, 'vulberta_cnn': 5}
54     return 0;                                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 18, 'vulberta_cnn': 1}
56 }                                                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 21}
-----------------------
Highlighted lines: 
0 static int update_dimensions(VP8Context *s, int width, int height)
8         if (av_image_check_size(width, height, 0, s->avctx))
14         vp8_decode_flush_impl(s->avctx, 1, 0, 1);
18         avcodec_set_dimensions(s->avctx, width, height);
24     s->mb_width  = (s->avctx->coded_width +15) / 16;
26     s->mb_height = (s->avctx->coded_height+15) / 16;
30     s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
32     s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
38     s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
--------------------------------------------------------------------------------------------------------------
Example ids:  14665 project:  FFmpeg commit id:  01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1 Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void picmemset(PicContext *s, AVFrame *frame, int value, int run,               {'linevul': 10, 'codebert': 0, 'PLBART': 1, 'devign': 1, 'regvd': 7, 'vulberta_cnn': 3, 'vulberta_mlp': 10}
2                       int *x, int *y, int *plane, int bits_per_plane)                  {'linevul': 0, 'codebert': 4, 'PLBART': 5, 'devign': 2, 'regvd': 8, 'vulberta_cnn': 26, 'vulberta_mlp': 14}
4 {                                                                                      {'linevul': 22, 'codebert': 9, 'PLBART': 11, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 9, 'vulberta_mlp': 28}
6     uint8_t *d;                                                                        {'linevul': 20, 'codebert': 3, 'PLBART': 6, 'devign': 20, 'regvd': 16, 'vulberta_cnn': 21, 'vulberta_mlp': 25}
8     int shift = *plane * bits_per_plane;                                               {'linevul': 17, 'codebert': 13, 'PLBART': 4, 'devign': 4, 'regvd': 6, 'vulberta_cnn': 1, 'vulberta_mlp': 9}
10     int mask  = ((1 << bits_per_plane) - 1) << shift;                                 {'linevul': 11, 'codebert': 15, 'PLBART': 3, 'devign': 3, 'regvd': 1, 'vulberta_cnn': 24, 'vulberta_mlp': 5}
12     value   <<= shift;                                                                {'linevul': 19, 'codebert': 11, 'PLBART': 8, 'devign': 17, 'regvd': 18, 'vulberta_cnn': 16, 'vulberta_mlp': 15}
16     while (run > 0) {                                                                 {'linevul': 18, 'codebert': 17, 'PLBART': 7, 'devign': 7, 'regvd': 19, 'vulberta_cnn': 20, 'vulberta_mlp': 24}
18         int j;                                                                        {'linevul': 21, 'codebert': 18, 'PLBART': 10, 'devign': 21, 'regvd': 20, 'vulberta_cnn': 6, 'vulberta_mlp': 27}
20         for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {                     {'linevul': 1, 'codebert': 14, 'PLBART': 0, 'devign': 0, 'regvd': 0, 'vulberta_cnn': 0, 'vulberta_mlp': 3}
22             d = frame->data[0] + *y * frame->linesize[0];                             {'linevul': 2, 'codebert': 5, 'PLBART': 2, 'devign': 16, 'regvd': 3, 'vulberta_cnn': 27, 'vulberta_mlp': 18}
24             d[*x] |= (value >> j) & mask;                                             {'linevul': 7, 'codebert': 7, 'PLBART': 9, 'devign': 5, 'regvd': 2, 'vulberta_cnn': 22, 'vulberta_mlp': 12}
26             *x += 1;                                                                  {'linevul': 16, 'codebert': 16, 'PLBART': -1, 'devign': 10, 'regvd': 15, 'vulberta_cnn': 2, 'vulberta_mlp': 6}
28             if (*x == s->width) {                                                     {'linevul': 13, 'codebert': 2, 'PLBART': -1, 'devign': 8, 'regvd': 4, 'vulberta_cnn': 12, 'vulberta_mlp': 22}
30                 *y -= 1;                                                              {'linevul': 14, 'codebert': 1, 'PLBART': -1, 'devign': 11, 'regvd': 13, 'vulberta_cnn': 14, 'vulberta_mlp': 11}
32                 *x = 0;                                                               {'linevul': 15, 'codebert': 10, 'PLBART': -1, 'devign': 15, 'regvd': 17, 'vulberta_cnn': 18, 'vulberta_mlp': 21}
34                 if (*y < 0) {                                                         {'linevul': 12, 'codebert': 6, 'PLBART': -1, 'devign': 9, 'regvd': 12, 'vulberta_cnn': 4, 'vulberta_mlp': 19}
36                    *y = s->height - 1;                                                {'linevul': 6, 'codebert': 12, 'PLBART': -1, 'devign': 18, 'regvd': 9, 'vulberta_cnn': 15, 'vulberta_mlp': 20}
38                    *plane += 1;                                                       {'linevul': 9, 'codebert': 8, 'PLBART': -1, 'devign': 12, 'regvd': 14, 'vulberta_cnn': 13, 'vulberta_mlp': 2}
40                    if (*plane >= s->nb_planes)                                        {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 8, 'vulberta_mlp': 7}
42                        return;                                                        {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 22, 'vulberta_cnn': 23, 'vulberta_mlp': 8}
44                    value <<= bits_per_plane;                                          {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 10, 'vulberta_cnn': 7, 'vulberta_mlp': 1}
46                    mask  <<= bits_per_plane;                                          {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 11, 'vulberta_cnn': 25, 'vulberta_mlp': 4}
48                 }                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 11, 'vulberta_mlp': 17}
50             }                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 5, 'vulberta_mlp': 26}
52         }                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 17, 'vulberta_mlp': 13}
54         run--;                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 21, 'vulberta_cnn': 10, 'vulberta_mlp': 23}
56     }                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 19, 'vulberta_mlp': 0}
58 }                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 28, 'vulberta_mlp': 16}
-----------------------
Highlighted lines: 
0 static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
2                       int *x, int *y, int *plane, int bits_per_plane)
8     int shift = *plane * bits_per_plane;
10     int mask  = ((1 << bits_per_plane) - 1) << shift;
20         for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
22             d = frame->data[0] + *y * frame->linesize[0];
24             d[*x] |= (value >> j) & mask;
40                    if (*plane >= s->nb_planes)
--------------------------------------------------------------------------------------------------------------
Example ids:  14680 project:  qemu commit id:  523b018dde3b7650fe5401d0499b30cf2f117515 Number of lines:  22
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)                                           {'linevul': 7, 'codebert': 7, 'PLBART': 0, 'devign': 0, 'regvd': 13, 'vulberta_cnn': 0, 'vulberta_mlp': 5}
1 {                                                                                                    {'linevul': 17, 'codebert': 13, 'PLBART': 8, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 11, 'vulberta_mlp': 20}
2     struct vhost_vring_addr *vra = &vmsg->payload.addr;                                              {'linevul': 9, 'codebert': 9, 'PLBART': 2, 'devign': 1, 'regvd': 12, 'vulberta_cnn': 16, 'vulberta_mlp': 21}
3     unsigned int index = vra->index;                                                                 {'linevul': 16, 'codebert': 12, 'PLBART': 7, 'devign': 9, 'regvd': 19, 'vulberta_cnn': 7, 'vulberta_mlp': 10}
4     VubrVirtq *vq = &dev->vq[index];                                                                 {'linevul': 13, 'codebert': 8, 'PLBART': 4, 'devign': 2, 'regvd': 16, 'vulberta_cnn': 4, 'vulberta_mlp': 6}
5     DPRINT("vhost_vring_addr:\n");                                                                   {'linevul': 14, 'codebert': 0, 'PLBART': 3, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 14, 'vulberta_mlp': 3}
6     DPRINT("    index:  %d\n", vra->index);                                                          {'linevul': 12, 'codebert': 1, 'PLBART': 5, 'devign': -1, 'regvd': 11, 'vulberta_cnn': 6, 'vulberta_mlp': 2}
7     DPRINT("    flags:  %d\n", vra->flags);                                                          {'linevul': 11, 'codebert': 2, 'PLBART': 6, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 5, 'vulberta_mlp': 7}
8     DPRINT("    desc_user_addr:   0x%016llx\n", vra->desc_user_addr);                                {'linevul': 6, 'codebert': 3, 'PLBART': 1, 'devign': 13, 'regvd': 5, 'vulberta_cnn': 13, 'vulberta_mlp': 14}
9     DPRINT("    used_user_addr:   0x%016llx\n", vra->used_user_addr);                                {'linevul': 5, 'codebert': 4, 'PLBART': -1, 'devign': 12, 'regvd': 6, 'vulberta_cnn': 17, 'vulberta_mlp': 18}
10     DPRINT("    avail_user_addr:  0x%016llx\n", vra->avail_user_addr);                              {'linevul': 4, 'codebert': 6, 'PLBART': -1, 'devign': 11, 'regvd': 2, 'vulberta_cnn': 19, 'vulberta_mlp': 15}
11     DPRINT("    log_guest_addr:   0x%016llx\n", vra->log_guest_addr);                               {'linevul': 3, 'codebert': 5, 'PLBART': -1, 'devign': 10, 'regvd': 4, 'vulberta_cnn': 18, 'vulberta_mlp': 19}
12     vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);                 {'linevul': 1, 'codebert': 10, 'PLBART': -1, 'devign': 5, 'regvd': 1, 'vulberta_cnn': 12, 'vulberta_mlp': 13}
13     vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);                 {'linevul': 2, 'codebert': 11, 'PLBART': -1, 'devign': 3, 'regvd': 3, 'vulberta_cnn': 9, 'vulberta_mlp': 11}
14     vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 0, 'vulberta_cnn': 1, 'vulberta_mlp': 16}
15     vq->log_guest_addr = vra->log_guest_addr;                                                       {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 17, 'vulberta_cnn': 15, 'vulberta_mlp': 17}
16     DPRINT("Setting virtq addresses:\n");                                                           {'linevul': 15, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 20, 'vulberta_mlp': 0}
17     DPRINT("    vring_desc  at %p\n", vq->desc);                                                    {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 21, 'vulberta_mlp': 4}
18     DPRINT("    vring_used  at %p\n", vq->used);                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 8, 'vulberta_mlp': 8}
19     DPRINT("    vring_avail at %p\n", vq->avail);                                                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 7, 'vulberta_cnn': 10, 'vulberta_mlp': 12}
20     vq->last_used_index = vq->used->idx;                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 18, 'vulberta_cnn': 3, 'vulberta_mlp': 9}
21     return 0;                                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 20, 'vulberta_cnn': 2, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)
2     struct vhost_vring_addr *vra = &vmsg->payload.addr;
4     VubrVirtq *vq = &dev->vq[index];
6     DPRINT("    index:  %d\n", vra->index);
7     DPRINT("    flags:  %d\n", vra->flags);
8     DPRINT("    desc_user_addr:   0x%016llx\n", vra->desc_user_addr);
13     vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);
14     vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);
21     return 0;
--------------------------------------------------------------------------------------------------------------
Example ids:  15589 project:  FFmpeg commit id:  ae4c9ddebc32eaacbd62681d776881e59ca6e6f7 Number of lines:  23
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 void compute_images_mse_16bit(PSNRContext *s,                                                   {'linevul': 16, 'codebert': 0, 'PLBART': 2, 'devign': 17, 'regvd': 11, 'vulberta_cnn': 11, 'vulberta_mlp': 9}
2                         const uint8_t *main_data[4], const int main_linesizes[4],               {'linevul': 1, 'codebert': 10, 'PLBART': 1, 'devign': 10, 'regvd': 2, 'vulberta_cnn': 13, 'vulberta_mlp': 8}
4                         const uint8_t *ref_data[4], const int ref_linesizes[4],                 {'linevul': 0, 'codebert': 8, 'PLBART': 5, 'devign': 9, 'regvd': 4, 'vulberta_cnn': 2, 'vulberta_mlp': 14}
6                         int w, int h, double mse[4])                                            {'linevul': 2, 'codebert': 4, 'PLBART': 7, 'devign': 4, 'regvd': 12, 'vulberta_cnn': 7, 'vulberta_mlp': 17}
8 {                                                                                               {'linevul': 21, 'codebert': 5, 'PLBART': 9, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 3, 'vulberta_mlp': 15}
10     int i, c, j;                                                                               {'linevul': 18, 'codebert': 12, 'PLBART': 8, 'devign': 18, 'regvd': 18, 'vulberta_cnn': 17, 'vulberta_mlp': 22}
14     for (c = 0; c < s->nb_components; c++) {                                                   {'linevul': 10, 'codebert': 1, 'PLBART': 3, 'devign': 0, 'regvd': 9, 'vulberta_cnn': 14, 'vulberta_mlp': 19}
16         const int outw = s->planewidth[c];                                                     {'linevul': 12, 'codebert': 3, 'PLBART': 4, 'devign': 3, 'regvd': 8, 'vulberta_cnn': 18, 'vulberta_mlp': 10}
18         const int outh = s->planeheight[c];                                                    {'linevul': 15, 'codebert': 2, 'PLBART': 6, 'devign': 6, 'regvd': 10, 'vulberta_cnn': 20, 'vulberta_mlp': 13}
20         const uint16_t *main_line = (uint16_t *)main_data[c];                                  {'linevul': 5, 'codebert': 7, 'PLBART': 0, 'devign': 11, 'regvd': 0, 'vulberta_cnn': 21, 'vulberta_mlp': 4}
22         const uint16_t *ref_line = (uint16_t *)ref_data[c];                                    {'linevul': 4, 'codebert': 6, 'PLBART': -1, 'devign': 12, 'regvd': 1, 'vulberta_cnn': 19, 'vulberta_mlp': 12}
24         const int ref_linesize = ref_linesizes[c] / 2;                                         {'linevul': 9, 'codebert': 11, 'PLBART': -1, 'devign': 16, 'regvd': 5, 'vulberta_cnn': 0, 'vulberta_mlp': 0}
26         const int main_linesize = main_linesizes[c] / 2;                                       {'linevul': 8, 'codebert': 13, 'PLBART': -1, 'devign': 14, 'regvd': 3, 'vulberta_cnn': 16, 'vulberta_mlp': 1}
28         uint64_t m = 0;                                                                        {'linevul': 17, 'codebert': 15, 'PLBART': -1, 'devign': 7, 'regvd': 14, 'vulberta_cnn': 15, 'vulberta_mlp': 21}
32         for (i = 0; i < outh; i++) {                                                           {'linevul': 11, 'codebert': 14, 'PLBART': -1, 'devign': 1, 'regvd': 15, 'vulberta_cnn': 5, 'vulberta_mlp': 3}
34             for (j = 0; j < outw; j++)                                                         {'linevul': 7, 'codebert': 9, 'PLBART': -1, 'devign': 2, 'regvd': 16, 'vulberta_cnn': 1, 'vulberta_mlp': 16}
36                 m += pow2(main_line[j] - ref_line[j]);                                         {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 6, 'vulberta_cnn': 6, 'vulberta_mlp': 20}
38             ref_line += ref_linesize;                                                          {'linevul': 14, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 17, 'vulberta_cnn': 8, 'vulberta_mlp': 18}
40             main_line += main_linesize;                                                        {'linevul': 13, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 13, 'vulberta_cnn': 9, 'vulberta_mlp': 11}
42         }                                                                                      {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 12, 'vulberta_mlp': 7}
44         mse[c] = m / (double)(outw * outh);                                                    {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 7, 'vulberta_cnn': 4, 'vulberta_mlp': 5}
46     }                                                                                          {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 10, 'vulberta_mlp': 6}
48 }                                                                                              {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 22, 'vulberta_mlp': 2}
-----------------------
Highlighted lines: 
2                         const uint8_t *main_data[4], const int main_linesizes[4],
4                         const uint8_t *ref_data[4], const int ref_linesizes[4],
6                         int w, int h, double mse[4])
14     for (c = 0; c < s->nb_components; c++) {
16         const int outw = s->planewidth[c];
20         const uint16_t *main_line = (uint16_t *)main_data[c];
24         const int ref_linesize = ref_linesizes[c] / 2;
34             for (j = 0; j < outw; j++)
36                 m += pow2(main_line[j] - ref_line[j]);
44         mse[c] = m / (double)(outw * outh);
--------------------------------------------------------------------------------------------------------------
Example ids:  16216 project:  qemu commit id:  73d60fa5fae60c8e07e1f295d8c7fd5d04320160 Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void get_sensor_evt_status(IPMIBmcSim *ibs,                                   {'linevul': 10, 'codebert': 0, 'PLBART': 0, 'devign': 13, 'regvd': 6, 'vulberta_cnn': 0, 'vulberta_mlp': 0}
2                                   uint8_t *cmd, unsigned int cmd_len,                {'linevul': 1, 'codebert': 12, 'PLBART': 3, 'devign': 6, 'regvd': 13, 'vulberta_cnn': 2, 'vulberta_mlp': 17}
4                                   uint8_t *rsp, unsigned int *rsp_len,               {'linevul': 0, 'codebert': 11, 'PLBART': 7, 'devign': 2, 'regvd': 12, 'vulberta_cnn': 12, 'vulberta_mlp': 16}
6                                   unsigned int max_rsp_len)                          {'linevul': 2, 'codebert': 9, 'PLBART': 10, 'devign': 7, 'regvd': 15, 'vulberta_cnn': 5, 'vulberta_mlp': 19}
8 {                                                                                    {'linevul': 19, 'codebert': 14, 'PLBART': 12, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 9, 'vulberta_mlp': 15}
10     IPMISensor *sens;                                                               {'linevul': 15, 'codebert': 1, 'PLBART': 5, 'devign': 11, 'regvd': 14, 'vulberta_cnn': 1, 'vulberta_mlp': 13}
14     IPMI_CHECK_CMD_LEN(3);                                                          {'linevul': 14, 'codebert': 7, 'PLBART': 9, 'devign': 12, 'regvd': 11, 'vulberta_cnn': 11, 'vulberta_mlp': 6}
16     if ((cmd[2] > MAX_SENSORS) ||                                                   {'linevul': 12, 'codebert': 10, 'PLBART': 6, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 16, 'vulberta_mlp': 18}
18         !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {                          {'linevul': 3, 'codebert': 5, 'PLBART': 1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 4, 'vulberta_mlp': 2}
20         rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;                                     {'linevul': 5, 'codebert': 6, 'PLBART': 2, 'devign': 1, 'regvd': 8, 'vulberta_cnn': 17, 'vulberta_mlp': 9}
22         return;                                                                     {'linevul': 16, 'codebert': 15, 'PLBART': 11, 'devign': 14, 'regvd': 16, 'vulberta_cnn': 13, 'vulberta_mlp': 1}
24     }                                                                               {'linevul': 17, 'codebert': 13, 'PLBART': 13, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 6, 'vulberta_mlp': 3}
26     sens = ibs->sensors + cmd[2];                                                   {'linevul': 13, 'codebert': 8, 'PLBART': 4, 'devign': 5, 'regvd': 10, 'vulberta_cnn': 3, 'vulberta_mlp': 11}
28     IPMI_ADD_RSP_DATA(sens->reading);                                               {'linevul': 11, 'codebert': 3, 'PLBART': 8, 'devign': 8, 'regvd': 7, 'vulberta_cnn': 18, 'vulberta_mlp': 5}
30     IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));                            {'linevul': 4, 'codebert': 2, 'PLBART': -1, 'devign': 10, 'regvd': 5, 'vulberta_cnn': 7, 'vulberta_mlp': 12}
32     IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);                                  {'linevul': 9, 'codebert': 4, 'PLBART': -1, 'devign': 9, 'regvd': 4, 'vulberta_cnn': 15, 'vulberta_mlp': 14}
34     IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);                           {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 2, 'vulberta_cnn': 8, 'vulberta_mlp': 8}
36     IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);                                {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 3, 'vulberta_cnn': 10, 'vulberta_mlp': 4}
38     IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);                         {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 14, 'vulberta_mlp': 7}
40 }                                                                                   {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 19, 'vulberta_mlp': 10}
-----------------------
Highlighted lines: 
0 static void get_sensor_evt_status(IPMIBmcSim *ibs,
2                                   uint8_t *cmd, unsigned int cmd_len,
6                                   unsigned int max_rsp_len)
18         !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
20         rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
26     sens = ibs->sensors + cmd[2];
28     IPMI_ADD_RSP_DATA(sens->reading);
30     IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
32     IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
34     IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
36     IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
38     IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
--------------------------------------------------------------------------------------------------------------
Example ids:  17353 project:  FFmpeg commit id:  eb9fb508b0e09d85d234fe694333b2005e1d7a7e Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void matroska_add_index_entries(MatroskaDemuxContext *matroska)                         {'linevul': 7, 'codebert': 6, 'PLBART': 0, 'devign': 2, 'regvd': 3, 'vulberta_cnn': 27, 'vulberta_mlp': 12}
2 {                                                                                              {'linevul': 22, 'codebert': 19, 'PLBART': 12, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 12, 'vulberta_mlp': 26}
4     EbmlList *index_list;                                                                      {'linevul': 16, 'codebert': 13, 'PLBART': 7, 'devign': 12, 'regvd': 16, 'vulberta_cnn': 25, 'vulberta_mlp': 23}
6     MatroskaIndex *index;                                                                      {'linevul': 18, 'codebert': 16, 'PLBART': 8, 'devign': 13, 'regvd': 17, 'vulberta_cnn': 0, 'vulberta_mlp': 19}
8     int index_scale = 1;                                                                       {'linevul': 17, 'codebert': 17, 'PLBART': 6, 'devign': 10, 'regvd': 18, 'vulberta_cnn': 21, 'vulberta_mlp': 27}
10     int i, j;                                                                                 {'linevul': 20, 'codebert': 18, 'PLBART': 10, 'devign': 11, 'regvd': 22, 'vulberta_cnn': 18, 'vulberta_mlp': 28}
14     if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)                                             {'linevul': 9, 'codebert': 0, 'PLBART': 1, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 19, 'vulberta_mlp': 7}
16         return;                                                                               {'linevul': 19, 'codebert': 3, 'PLBART': 11, 'devign': 14, 'regvd': 23, 'vulberta_cnn': 13, 'vulberta_mlp': 13}
20     index_list = &matroska->index;                                                            {'linevul': 15, 'codebert': 4, 'PLBART': 4, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 26, 'vulberta_mlp': 22}
22     index      = index_list->elem;                                                            {'linevul': 13, 'codebert': 11, 'PLBART': 9, 'devign': 4, 'regvd': 15, 'vulberta_cnn': 7, 'vulberta_mlp': 16}
24     if (index_list->nb_elem &&                                                                {'linevul': 14, 'codebert': 9, 'PLBART': 5, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 23, 'vulberta_mlp': 21}
26         index[0].time > 1E14 / matroska->time_scale) {                                        {'linevul': 5, 'codebert': 1, 'PLBART': 2, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 8, 'vulberta_mlp': 17}
28         av_log(matroska->ctx, AV_LOG_WARNING, "Working around broken index.\n");              {'linevul': 2, 'codebert': 2, 'PLBART': 3, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 20, 'vulberta_mlp': 4}
30         index_scale = matroska->time_scale;                                                   {'linevul': 12, 'codebert': 12, 'PLBART': -1, 'devign': 9, 'regvd': 6, 'vulberta_cnn': 1, 'vulberta_mlp': 20}
32     }                                                                                         {'linevul': 21, 'codebert': 5, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 17, 'vulberta_mlp': 2}
34     for (i = 0; i < index_list->nb_elem; i++) {                                               {'linevul': 8, 'codebert': 8, 'PLBART': -1, 'devign': 1, 'regvd': 4, 'vulberta_cnn': 4, 'vulberta_mlp': 25}
36         EbmlList *pos_list    = &index[i].pos;                                                {'linevul': 6, 'codebert': 10, 'PLBART': -1, 'devign': 7, 'regvd': 9, 'vulberta_cnn': 22, 'vulberta_mlp': 10}
38         MatroskaIndexPos *pos = pos_list->elem;                                               {'linevul': 10, 'codebert': 15, 'PLBART': -1, 'devign': 8, 'regvd': 8, 'vulberta_cnn': 9, 'vulberta_mlp': 3}
40         for (j = 0; j < pos_list->nb_elem; j++) {                                             {'linevul': 4, 'codebert': 14, 'PLBART': -1, 'devign': 0, 'regvd': 2, 'vulberta_cnn': 5, 'vulberta_mlp': 15}
42             MatroskaTrack *track = matroska_find_track_by_num(matroska,                       {'linevul': 1, 'codebert': 7, 'PLBART': -1, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 2, 'vulberta_mlp': 14}
44                                                               pos[j].track);                  {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 20, 'vulberta_cnn': 11, 'vulberta_mlp': 18}
46             if (track && track->stream)                                                       {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 19, 'vulberta_cnn': 15, 'vulberta_mlp': 24}
48                 av_add_index_entry(track->stream,                                             {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 24, 'vulberta_mlp': 11}
50                                    pos[j].pos + matroska->segment_start,                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 7, 'vulberta_cnn': 14, 'vulberta_mlp': 8}
52                                    index[i].time / index_scale, 0, 0,                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 3, 'vulberta_mlp': 1}
54                                    AVINDEX_KEYFRAME);                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 16, 'vulberta_mlp': 9}
56         }                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 10, 'vulberta_mlp': 6}
58     }                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 6, 'vulberta_mlp': 5}
60 }                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 28, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void matroska_add_index_entries(MatroskaDemuxContext *matroska)
14     if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)
20     index_list = &matroska->index;
26         index[0].time > 1E14 / matroska->time_scale) {
28         av_log(matroska->ctx, AV_LOG_WARNING, "Working around broken index.\n");
34     for (i = 0; i < index_list->nb_elem; i++) {
38         MatroskaIndexPos *pos = pos_list->elem;
40         for (j = 0; j < pos_list->nb_elem; j++) {
--------------------------------------------------------------------------------------------------------------
Example ids:  17877 project:  FFmpeg commit id:  bacc4b6e8173fa944c24f297435dc507a60efb10 Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)                      {'linevul': 4, 'codebert': 0, 'PLBART': 1, 'devign': 5, 'regvd': 8, 'vulberta_cnn': 2, 'vulberta_mlp': 9}
2 {                                                                                       {'linevul': 19, 'codebert': 13, 'PLBART': 11, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 10, 'vulberta_mlp': 5}
4     int ich, i;                                                                         {'linevul': 16, 'codebert': 14, 'PLBART': 8, 'devign': 12, 'regvd': 15, 'vulberta_cnn': 7, 'vulberta_mlp': 7}
6     int order        = s->mclms_order;                                                  {'linevul': 10, 'codebert': 6, 'PLBART': 4, 'devign': 11, 'regvd': 12, 'vulberta_cnn': 6, 'vulberta_mlp': 10}
8     int num_channels = s->num_channels;                                                 {'linevul': 13, 'codebert': 7, 'PLBART': 6, 'devign': 10, 'regvd': 11, 'vulberta_cnn': 18, 'vulberta_mlp': 18}
12     for (ich = 0; ich < num_channels; ich++) {                                         {'linevul': 9, 'codebert': 10, 'PLBART': 2, 'devign': 0, 'regvd': 9, 'vulberta_cnn': 15, 'vulberta_mlp': 4}
14         pred[ich] = 0;                                                                 {'linevul': 14, 'codebert': 12, 'PLBART': 9, 'devign': 4, 'regvd': 13, 'vulberta_cnn': 13, 'vulberta_mlp': 11}
16         if (!s->is_channel_coded[ich])                                                 {'linevul': 12, 'codebert': 1, 'PLBART': 5, 'devign': 8, 'regvd': 10, 'vulberta_cnn': 4, 'vulberta_mlp': 17}
18             continue;                                                                  {'linevul': 15, 'codebert': 11, 'PLBART': 10, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 12, 'vulberta_mlp': 16}
20         for (i = 0; i < order * num_channels; i++)                                     {'linevul': 7, 'codebert': 9, 'PLBART': 3, 'devign': 2, 'regvd': 7, 'vulberta_cnn': 17, 'vulberta_mlp': 6}
22             pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *                    {'linevul': 2, 'codebert': 5, 'PLBART': 0, 'devign': -1, 'regvd': 3, 'vulberta_cnn': 8, 'vulberta_mlp': 2}
24                          s->mclms_coeffs[i + order * num_channels * ich];              {'linevul': 1, 'codebert': 4, 'PLBART': 7, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 11, 'vulberta_mlp': 3}
26         for (i = 0; i < ich; i++)                                                      {'linevul': 11, 'codebert': 15, 'PLBART': -1, 'devign': 1, 'regvd': 14, 'vulberta_cnn': 5, 'vulberta_mlp': 14}
28             pred[ich] += s->channel_residues[i][icoef] *                               {'linevul': 3, 'codebert': 2, 'PLBART': -1, 'devign': 7, 'regvd': 5, 'vulberta_cnn': 16, 'vulberta_mlp': 15}
30                          s->mclms_coeffs_cur[i + num_channels * ich];                  {'linevul': 0, 'codebert': 3, 'PLBART': -1, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 14, 'vulberta_mlp': 12}
32         pred[ich] += 1 << s->mclms_scaling - 1;                                        {'linevul': 6, 'codebert': 8, 'PLBART': -1, 'devign': 3, 'regvd': 2, 'vulberta_cnn': 1, 'vulberta_mlp': 8}
34         pred[ich] >>= s->mclms_scaling;                                                {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 6, 'vulberta_cnn': 3, 'vulberta_mlp': 19}
36         s->channel_residues[ich][icoef] += pred[ich];                                  {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 4, 'vulberta_cnn': 0, 'vulberta_mlp': 13}
38     }                                                                                  {'linevul': 17, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 9, 'vulberta_mlp': 1}
40 }                                                                                      {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 19, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
12     for (ich = 0; ich < num_channels; ich++) {
16         if (!s->is_channel_coded[ich])
20         for (i = 0; i < order * num_channels; i++)
22             pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
24                          s->mclms_coeffs[i + order * num_channels * ich];
28             pred[ich] += s->channel_residues[i][icoef] *
32         pred[ich] += 1 << s->mclms_scaling - 1;
34         pred[ich] >>= s->mclms_scaling;
36         s->channel_residues[ich][icoef] += pred[ich];
--------------------------------------------------------------------------------------------------------------
Example ids:  18438 project:  FFmpeg commit id:  38d553322891c8e47182f05199d19888422167dc Number of lines:  24
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 int av_image_alloc(uint8_t *pointers[4], int linesizes[4],                                        {'linevul': 8, 'codebert': 3, 'PLBART': 2, 'devign': 10, 'regvd': 5, 'vulberta_cnn': 19, 'vulberta_mlp': 6}
2                    int w, int h, enum PixelFormat pix_fmt, int align)                             {'linevul': 0, 'codebert': 4, 'PLBART': 4, 'devign': 0, 'regvd': 9, 'vulberta_cnn': 16, 'vulberta_mlp': 17}
4 {                                                                                                 {'linevul': 23, 'codebert': 7, 'PLBART': 11, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 3, 'vulberta_mlp': 20}
6     int i, ret;                                                                                   {'linevul': 18, 'codebert': 14, 'PLBART': 8, 'devign': 18, 'regvd': 15, 'vulberta_cnn': 4, 'vulberta_mlp': 23}
8     uint8_t *buf;                                                                                 {'linevul': 17, 'codebert': 5, 'PLBART': 7, 'devign': 20, 'regvd': 12, 'vulberta_cnn': 7, 'vulberta_mlp': 19}
12     if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)                                          {'linevul': 6, 'codebert': 6, 'PLBART': 1, 'devign': 13, 'regvd': 4, 'vulberta_cnn': 13, 'vulberta_mlp': 12}
14         return ret;                                                                              {'linevul': 16, 'codebert': 19, 'PLBART': 10, 'devign': 7, 'regvd': 20, 'vulberta_cnn': 5, 'vulberta_mlp': 22}
16     if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)                              {'linevul': 5, 'codebert': 8, 'PLBART': 0, 'devign': 12, 'regvd': 2, 'vulberta_cnn': 1, 'vulberta_mlp': 5}
18         return ret;                                                                              {'linevul': 15, 'codebert': 20, 'PLBART': 9, 'devign': 6, 'regvd': 19, 'vulberta_cnn': 15, 'vulberta_mlp': 21}
22     for (i = 0; i < 4; i++)                                                                      {'linevul': 10, 'codebert': 18, 'PLBART': 6, 'devign': 2, 'regvd': 11, 'vulberta_cnn': 0, 'vulberta_mlp': 13}
24         linesizes[i] = FFALIGN(linesizes[i], align);                                             {'linevul': 7, 'codebert': 13, 'PLBART': 3, 'devign': 11, 'regvd': 8, 'vulberta_cnn': 18, 'vulberta_mlp': 18}
28     if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)               {'linevul': 3, 'codebert': 11, 'PLBART': 5, 'devign': 9, 'regvd': 1, 'vulberta_cnn': 14, 'vulberta_mlp': 3}
30         return ret;                                                                              {'linevul': 14, 'codebert': 17, 'PLBART': -1, 'devign': 5, 'regvd': 18, 'vulberta_cnn': 8, 'vulberta_mlp': 7}
32     buf = av_malloc(ret + align);                                                                {'linevul': 11, 'codebert': 2, 'PLBART': -1, 'devign': 15, 'regvd': 7, 'vulberta_cnn': 17, 'vulberta_mlp': 0}
34     if (!buf)                                                                                    {'linevul': 19, 'codebert': 12, 'PLBART': -1, 'devign': 14, 'regvd': 14, 'vulberta_cnn': 10, 'vulberta_mlp': 10}
36         return AVERROR(ENOMEM);                                                                  {'linevul': 9, 'codebert': 10, 'PLBART': -1, 'devign': 1, 'regvd': 13, 'vulberta_cnn': 9, 'vulberta_mlp': 4}
38     if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {              {'linevul': 2, 'codebert': 1, 'PLBART': -1, 'devign': 8, 'regvd': 0, 'vulberta_cnn': 20, 'vulberta_mlp': 1}
40         av_free(buf);                                                                            {'linevul': 12, 'codebert': 9, 'PLBART': -1, 'devign': 17, 'regvd': 10, 'vulberta_cnn': 6, 'vulberta_mlp': 8}
42         return ret;                                                                              {'linevul': 13, 'codebert': 16, 'PLBART': -1, 'devign': 4, 'regvd': 17, 'vulberta_cnn': 12, 'vulberta_mlp': 16}
44     }                                                                                            {'linevul': 21, 'codebert': 15, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 2, 'vulberta_mlp': 15}
46     if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)                                     {'linevul': 1, 'codebert': 0, 'PLBART': -1, 'devign': 16, 'regvd': 6, 'vulberta_cnn': 21, 'vulberta_mlp': 11}
48         ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);                                 {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 3, 'vulberta_cnn': 22, 'vulberta_mlp': 9}
52     return ret;                                                                                  {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 16, 'vulberta_cnn': 11, 'vulberta_mlp': 2}
54 }                                                                                                {'linevul': 22, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 23, 'vulberta_mlp': 14}
-----------------------
Highlighted lines: 
0 int av_image_alloc(uint8_t *pointers[4], int linesizes[4],
2                    int w, int h, enum PixelFormat pix_fmt, int align)
12     if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
16     if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)
28     if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)
36         return AVERROR(ENOMEM);
38     if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {
--------------------------------------------------------------------------------------------------------------
Example ids:  19403 project:  qemu commit id:  7d1b0095bff7157e856d1d0e6c4295641ced2752 Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)               {'linevul': 1, 'codebert': 2, 'PLBART': 1, 'regvd': 0, 'vulberta_cnn': 2, 'vulberta_mlp': 14}
2 {                                                                                         {'linevul': 19, 'codebert': 14, 'PLBART': 15, 'regvd': 16, 'vulberta_cnn': 11, 'vulberta_mlp': 13}
4     int rd = (insn >> 0) & 0xf;                                                           {'linevul': 7, 'codebert': 8, 'PLBART': 5, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 12}
6     TCGv tmp;                                                                             {'linevul': 14, 'codebert': 5, 'PLBART': 9, 'regvd': 11, 'vulberta_cnn': 0, 'vulberta_mlp': 7}
10     if (insn & (1 << 8)) {                                                               {'linevul': 9, 'codebert': 13, 'PLBART': 6, 'regvd': 10, 'vulberta_cnn': 17, 'vulberta_mlp': 15}
12         if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {                            {'linevul': 0, 'codebert': 3, 'PLBART': 0, 'regvd': 6, 'vulberta_cnn': 12, 'vulberta_mlp': 9}
14             return 1;                                                                    {'linevul': 8, 'codebert': 15, 'PLBART': 11, 'regvd': 13, 'vulberta_cnn': 6, 'vulberta_mlp': 19}
16         } else {                                                                         {'linevul': 11, 'codebert': 19, 'PLBART': 10, 'regvd': 15, 'vulberta_cnn': 8, 'vulberta_mlp': 6}
18             tmp = iwmmxt_load_creg(rd);                                                  {'linevul': 3, 'codebert': 4, 'PLBART': 4, 'regvd': 4, 'vulberta_cnn': 7, 'vulberta_mlp': 1}
20         }                                                                                {'linevul': 13, 'codebert': 18, 'PLBART': 13, 'regvd': 19, 'vulberta_cnn': 10, 'vulberta_mlp': 0}
22     } else {                                                                             {'linevul': 16, 'codebert': 17, 'PLBART': 12, 'regvd': 14, 'vulberta_cnn': 14, 'vulberta_mlp': 3}
24         tmp = new_tmp();                                                                 {'linevul': 10, 'codebert': 7, 'PLBART': 8, 'regvd': 8, 'vulberta_cnn': 1, 'vulberta_mlp': 8}
26         iwmmxt_load_reg(cpu_V0, rd);                                                     {'linevul': 4, 'codebert': 0, 'PLBART': 3, 'regvd': 2, 'vulberta_cnn': 15, 'vulberta_mlp': 5}
28         tcg_gen_trunc_i64_i32(tmp, cpu_V0);                                              {'linevul': 2, 'codebert': 1, 'PLBART': 2, 'regvd': 1, 'vulberta_cnn': 18, 'vulberta_mlp': 4}
30     }                                                                                    {'linevul': 17, 'codebert': 16, 'PLBART': 14, 'regvd': 18, 'vulberta_cnn': 9, 'vulberta_mlp': 2}
32     tcg_gen_andi_i32(tmp, tmp, mask);                                                    {'linevul': 5, 'codebert': 10, 'PLBART': 7, 'regvd': 5, 'vulberta_cnn': 5, 'vulberta_mlp': 11}
34     tcg_gen_mov_i32(dest, tmp);                                                          {'linevul': 6, 'codebert': 9, 'PLBART': -1, 'regvd': 3, 'vulberta_cnn': 4, 'vulberta_mlp': 10}
36     dead_tmp(tmp);                                                                       {'linevul': 12, 'codebert': 6, 'PLBART': -1, 'regvd': 9, 'vulberta_cnn': 3, 'vulberta_mlp': 17}
38     return 0;                                                                            {'linevul': 15, 'codebert': 11, 'PLBART': -1, 'regvd': 12, 'vulberta_cnn': 16, 'vulberta_mlp': 18}
40 }                                                                                        {'linevul': 18, 'codebert': 12, 'PLBART': -1, 'regvd': 17, 'vulberta_cnn': 19, 'vulberta_mlp': 16}
-----------------------
Highlighted lines: 
0 static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
4     int rd = (insn >> 0) & 0xf;
6     TCGv tmp;
12         if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
18             tmp = iwmmxt_load_creg(rd);
24         tmp = new_tmp();
26         iwmmxt_load_reg(cpu_V0, rd);
28         tcg_gen_trunc_i64_i32(tmp, cpu_V0);
32     tcg_gen_andi_i32(tmp, tmp, mask);
34     tcg_gen_mov_i32(dest, tmp);
--------------------------------------------------------------------------------------------------------------
Example ids:  19827 project:  FFmpeg commit id:  2162b862eba5aadb59c0cf7cc304c67f4a5fb946 Number of lines:  26
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int huff_build10(VLC *vlc, uint8_t *len)                                       {'linevul': 7, 'codebert': 1, 'PLBART': 1, 'devign': 10, 'regvd': 3, 'vulberta_cnn': 12, 'vulberta_mlp': 16}
2 {                                                                                     {'linevul': 25, 'codebert': 12, 'PLBART': 15, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 10, 'vulberta_mlp': 6}
4     HuffEntry he[1024];                                                               {'linevul': 18, 'codebert': 7, 'PLBART': 12, 'devign': 12, 'regvd': 10, 'vulberta_cnn': 19, 'vulberta_mlp': 5}
6     uint32_t codes[1024];                                                             {'linevul': 17, 'codebert': 11, 'PLBART': 6, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 15, 'vulberta_mlp': 15}
8     uint8_t bits[1024];                                                               {'linevul': 16, 'codebert': 16, 'PLBART': 10, 'devign': 11, 'regvd': 7, 'vulberta_cnn': 20, 'vulberta_mlp': 13}
10     uint16_t syms[1024];                                                             {'linevul': 15, 'codebert': 6, 'PLBART': 9, 'devign': 9, 'regvd': 6, 'vulberta_cnn': 6, 'vulberta_mlp': 7}
12     uint32_t code;                                                                   {'linevul': 19, 'codebert': 15, 'PLBART': 7, 'devign': 13, 'regvd': 18, 'vulberta_cnn': 4, 'vulberta_mlp': 20}
14     int i;                                                                           {'linevul': 21, 'codebert': 21, 'PLBART': -1, 'devign': 17, 'regvd': 20, 'vulberta_cnn': 16, 'vulberta_mlp': 25}
18     for (i = 0; i < 1024; i++) {                                                     {'linevul': 13, 'codebert': 17, 'PLBART': 5, 'devign': 4, 'regvd': 13, 'vulberta_cnn': 24, 'vulberta_mlp': 23}
20         he[i].sym = 1023 - i;                                                        {'linevul': 11, 'codebert': 0, 'PLBART': 3, 'devign': 5, 'regvd': 8, 'vulberta_cnn': 2, 'vulberta_mlp': 22}
22         he[i].len = len[i];                                                          {'linevul': 12, 'codebert': 13, 'PLBART': 8, 'devign': 7, 'regvd': 15, 'vulberta_cnn': 9, 'vulberta_mlp': 21}
26     }                                                                                {'linevul': 23, 'codebert': 22, 'PLBART': 14, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 3, 'vulberta_mlp': 11}
28     AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);                                   {'linevul': 4, 'codebert': 4, 'PLBART': 0, 'devign': 16, 'regvd': 2, 'vulberta_cnn': 7, 'vulberta_mlp': 3}
32     code = 1;                                                                        {'linevul': 20, 'codebert': 18, 'PLBART': 13, 'devign': 14, 'regvd': 21, 'vulberta_cnn': 17, 'vulberta_mlp': 14}
34     for (i = 1023; i >= 0; i--) {                                                    {'linevul': 10, 'codebert': 19, 'PLBART': 4, 'devign': 1, 'regvd': 12, 'vulberta_cnn': 8, 'vulberta_mlp': 24}
36         codes[i] = code >> (32 - he[i].len);                                         {'linevul': 6, 'codebert': 10, 'PLBART': 2, 'devign': 2, 'regvd': 4, 'vulberta_cnn': 11, 'vulberta_mlp': 18}
38         bits[i]  = he[i].len;                                                        {'linevul': 9, 'codebert': 14, 'PLBART': 11, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 5, 'vulberta_mlp': 19}
40         syms[i]  = he[i].sym;                                                        {'linevul': 8, 'codebert': 2, 'PLBART': -1, 'devign': 8, 'regvd': 14, 'vulberta_cnn': 0, 'vulberta_mlp': 12}
42         code += 0x80000000u >> (he[i].len - 1);                                      {'linevul': 5, 'codebert': 8, 'PLBART': -1, 'devign': 0, 'regvd': 1, 'vulberta_cnn': 13, 'vulberta_mlp': 4}
44     }                                                                                {'linevul': 22, 'codebert': 20, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 14, 'vulberta_mlp': 10}
48     ff_free_vlc(vlc);                                                                {'linevul': 14, 'codebert': 5, 'PLBART': -1, 'devign': 15, 'regvd': 19, 'vulberta_cnn': 18, 'vulberta_mlp': 2}
50     return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,                    {'linevul': 3, 'codebert': 3, 'PLBART': -1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 23, 'vulberta_mlp': 17}
52                               bits,  sizeof(*bits),  sizeof(*bits),                  {'linevul': 1, 'codebert': 9, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 22, 'vulberta_mlp': 9}
54                               codes, sizeof(*codes), sizeof(*codes),                 {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 21, 'vulberta_mlp': 8}
56                               syms,  sizeof(*syms),  sizeof(*syms), 0);              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 1, 'vulberta_mlp': 1}
58 }                                                                                    {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 25, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static int huff_build10(VLC *vlc, uint8_t *len)
10     uint16_t syms[1024];
20         he[i].sym = 1023 - i;
28     AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
36         codes[i] = code >> (32 - he[i].len);
40         syms[i]  = he[i].sym;
42         code += 0x80000000u >> (he[i].len - 1);
56                               syms,  sizeof(*syms),  sizeof(*syms), 0);
--------------------------------------------------------------------------------------------------------------
Example ids:  20835 project:  qemu commit id:  b4ba67d9a702507793c2724e56f98e9b0f7be02b Number of lines:  25
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void test_tco1_status_bits(void)                                                   {'linevul': 8, 'codebert': 2, 'PLBART': 3, 'devign': 13, 'regvd': 16, 'vulberta_cnn': 3, 'vulberta_mlp': 21}
2 {                                                                                         {'linevul': 24, 'codebert': 5, 'PLBART': 15, 'devign': 54, 'regvd': 23, 'vulberta_cnn': 12, 'vulberta_mlp': 11}
4     TestData d;                                                                           {'linevul': 21, 'codebert': 14, 'PLBART': 12, 'devign': 19, 'regvd': 20, 'vulberta_cnn': 4, 'vulberta_mlp': 4}
6     uint16_t ticks = 8;                                                                   {'linevul': 13, 'codebert': 18, 'PLBART': 6, 'devign': 20, 'regvd': 17, 'vulberta_cnn': 5, 'vulberta_mlp': 15}
8     uint16_t val;                                                                         {'linevul': 19, 'codebert': 15, 'PLBART': 14, 'devign': 22, 'regvd': 18, 'vulberta_cnn': 7, 'vulberta_mlp': 23}
10     int ret;                                                                             {'linevul': 22, 'codebert': 21, 'PLBART': 16, 'devign': 21, 'regvd': 22, 'vulberta_cnn': 13, 'vulberta_mlp': 22}
14     d.args = NULL;                                                                       {'linevul': 18, 'codebert': 20, 'PLBART': 7, 'devign': 17, 'regvd': 21, 'vulberta_cnn': 17, 'vulberta_mlp': 20}
16     d.noreboot = true;                                                                   {'linevul': 12, 'codebert': 17, 'PLBART': 10, 'devign': 16, 'regvd': 19, 'vulberta_cnn': 10, 'vulberta_mlp': 24}
18     test_init(&d);                                                                       {'linevul': 17, 'codebert': 8, 'PLBART': 11, 'devign': 8, 'regvd': 13, 'vulberta_cnn': 18, 'vulberta_mlp': 19}
22     stop_tco(&d);                                                                        {'linevul': 16, 'codebert': 7, 'PLBART': 8, 'devign': 9, 'regvd': 9, 'vulberta_cnn': 8, 'vulberta_mlp': 2}
24     clear_tco_status(&d);                                                                {'linevul': 10, 'codebert': 3, 'PLBART': 5, 'devign': 7, 'regvd': 12, 'vulberta_cnn': 21, 'vulberta_mlp': 16}
26     reset_on_second_timeout(false);                                                      {'linevul': 9, 'codebert': 19, 'PLBART': 1, 'devign': 6, 'regvd': 8, 'vulberta_cnn': 1, 'vulberta_mlp': 5}
28     set_tco_timeout(&d, ticks);                                                          {'linevul': 7, 'codebert': 10, 'PLBART': 13, 'devign': 5, 'regvd': 7, 'vulberta_cnn': 16, 'vulberta_mlp': 3}
30     load_tco(&d);                                                                        {'linevul': 15, 'codebert': 12, 'PLBART': 9, 'devign': 10, 'regvd': 14, 'vulberta_cnn': 9, 'vulberta_mlp': 14}
32     start_tco(&d);                                                                       {'linevul': 14, 'codebert': 16, 'PLBART': 4, 'devign': 12, 'regvd': 15, 'vulberta_cnn': 14, 'vulberta_mlp': 13}
34     clock_step(ticks * TCO_TICK_NSEC);                                                   {'linevul': 6, 'codebert': 4, 'PLBART': 2, 'devign': 18, 'regvd': 6, 'vulberta_cnn': 2, 'vulberta_mlp': 7}
38     qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);                                {'linevul': 3, 'codebert': 11, 'PLBART': 0, 'devign': 3, 'regvd': 4, 'vulberta_cnn': 11, 'vulberta_mlp': 9}
40     qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);                               {'linevul': 2, 'codebert': 13, 'PLBART': -1, 'devign': 4, 'regvd': 3, 'vulberta_cnn': 20, 'vulberta_mlp': 12}
42     val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);                                {'linevul': 5, 'codebert': 9, 'PLBART': -1, 'devign': 1, 'regvd': 1, 'vulberta_cnn': 23, 'vulberta_mlp': 6}
44     ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;                        {'linevul': 1, 'codebert': 1, 'PLBART': -1, 'devign': 14, 'regvd': 5, 'vulberta_cnn': 22, 'vulberta_mlp': 8}
46     g_assert(ret == 1);                                                                  {'linevul': 11, 'codebert': 0, 'PLBART': -1, 'devign': 15, 'regvd': 10, 'vulberta_cnn': 15, 'vulberta_mlp': 0}
48     qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);                                {'linevul': 4, 'codebert': 6, 'PLBART': -1, 'devign': 2, 'regvd': 2, 'vulberta_cnn': 0, 'vulberta_mlp': 17}
50     g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);              {'linevul': 0, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 0, 'vulberta_cnn': 19, 'vulberta_mlp': 10}
52     qtest_end();                                                                         {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 11, 'vulberta_cnn': 6, 'vulberta_mlp': 18}
54 }                                                                                        {'linevul': 23, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 24, 'vulberta_cnn': 24, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static void test_tco1_status_bits(void)
22     stop_tco(&d);
26     reset_on_second_timeout(false);
28     set_tco_timeout(&d, ticks);
34     clock_step(ticks * TCO_TICK_NSEC);
38     qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
42     val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
44     ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
48     qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
--------------------------------------------------------------------------------------------------------------
Example ids:  21296 project:  qemu commit id:  1ee24514aed34760fb2863d98bea3a1b705d9c9f Number of lines:  20
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)               {'linevul': 0, 'codebert': 0, 'PLBART': 0, 'devign': 0, 'regvd': 0, 'vulberta_cnn': 0, 'vulberta_mlp': 16}
2 {                                                                                      {'linevul': 19, 'codebert': 17, 'PLBART': 11, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 8, 'vulberta_mlp': 17}
4     NvmeNamespace *ns;                                                                 {'linevul': 14, 'codebert': 5, 'PLBART': 8, 'devign': 12, 'regvd': 11, 'vulberta_cnn': 1, 'vulberta_mlp': 19}
6     uint32_t nsid = le32_to_cpu(cmd->nsid);                                            {'linevul': 6, 'codebert': 2, 'PLBART': 1, 'devign': 7, 'regvd': 3, 'vulberta_cnn': 15, 'vulberta_mlp': 18}
10     if (nsid == 0 || nsid > n->num_namespaces) {                                      {'linevul': 7, 'codebert': 12, 'PLBART': 2, 'devign': 2, 'regvd': 2, 'vulberta_cnn': 4, 'vulberta_mlp': 10}
12         return NVME_INVALID_NSID | NVME_DNR;                                          {'linevul': 3, 'codebert': 8, 'PLBART': 3, 'devign': 15, 'regvd': 7, 'vulberta_cnn': 9, 'vulberta_mlp': 1}
14     }                                                                                 {'linevul': 17, 'codebert': 18, 'PLBART': 12, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 5, 'vulberta_mlp': 4}
18     ns = &n->namespaces[nsid - 1];                                                    {'linevul': 9, 'codebert': 16, 'PLBART': 5, 'devign': 3, 'regvd': 8, 'vulberta_cnn': 17, 'vulberta_mlp': 8}
20     switch (cmd->opcode) {                                                            {'linevul': 13, 'codebert': 11, 'PLBART': 9, 'devign': 1, 'regvd': 14, 'vulberta_cnn': 16, 'vulberta_mlp': 6}
22     case NVME_CMD_FLUSH:                                                              {'linevul': 11, 'codebert': 13, 'PLBART': 7, 'devign': 13, 'regvd': 12, 'vulberta_cnn': 10, 'vulberta_mlp': 3}
24         return nvme_flush(n, ns, cmd, req);                                           {'linevul': 5, 'codebert': 4, 'PLBART': 4, 'devign': 4, 'regvd': 4, 'vulberta_cnn': 2, 'vulberta_mlp': 9}
26     case NVME_CMD_WRITE_ZEROS:                                                        {'linevul': 8, 'codebert': 10, 'PLBART': 6, 'devign': 5, 'regvd': 9, 'vulberta_cnn': 13, 'vulberta_mlp': 5}
28         return nvme_write_zeros(n, ns, cmd, req);                                     {'linevul': 2, 'codebert': 7, 'PLBART': 10, 'devign': 8, 'regvd': 1, 'vulberta_cnn': 7, 'vulberta_mlp': 13}
30     case NVME_CMD_WRITE:                                                              {'linevul': 10, 'codebert': 14, 'PLBART': -1, 'devign': 14, 'regvd': 10, 'vulberta_cnn': 18, 'vulberta_mlp': 2}
32     case NVME_CMD_READ:                                                               {'linevul': 12, 'codebert': 15, 'PLBART': -1, 'devign': 9, 'regvd': 13, 'vulberta_cnn': 12, 'vulberta_mlp': 12}
34         return nvme_rw(n, ns, cmd, req);                                              {'linevul': 4, 'codebert': 9, 'PLBART': -1, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 3, 'vulberta_mlp': 15}
36     default:                                                                          {'linevul': 15, 'codebert': 19, 'PLBART': -1, 'devign': 10, 'regvd': 15, 'vulberta_cnn': 11, 'vulberta_mlp': 7}
38         return NVME_INVALID_OPCODE | NVME_DNR;                                        {'linevul': 1, 'codebert': 6, 'PLBART': -1, 'devign': 11, 'regvd': 6, 'vulberta_cnn': 14, 'vulberta_mlp': 0}
40     }                                                                                 {'linevul': 16, 'codebert': 1, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 6, 'vulberta_mlp': 14}
42 }                                                                                     {'linevul': 18, 'codebert': 3, 'PLBART': -1, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 19, 'vulberta_mlp': 11}
-----------------------
Highlighted lines: 
0 static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
6     uint32_t nsid = le32_to_cpu(cmd->nsid);
10     if (nsid == 0 || nsid > n->num_namespaces) {
12         return NVME_INVALID_NSID | NVME_DNR;
18     ns = &n->namespaces[nsid - 1];
24         return nvme_flush(n, ns, cmd, req);
26     case NVME_CMD_WRITE_ZEROS:
28         return nvme_write_zeros(n, ns, cmd, req);
34         return nvme_rw(n, ns, cmd, req);
38         return NVME_INVALID_OPCODE | NVME_DNR;
--------------------------------------------------------------------------------------------------------------
Example ids:  22065 project:  qemu commit id:  b3a6a2e0417c78ec5491347eb85a7d125a5fefdc Number of lines:  34
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )                                 {'linevul': 4, 'codebert': 0, 'PLBART': 1, 'regvd': 8, 'vulberta_cnn': 16, 'vulberta_mlp': 7}
2 {                                                                                              {'linevul': 33, 'codebert': 1, 'PLBART': 13, 'regvd': 28, 'vulberta_cnn': 11, 'vulberta_mlp': 33}
4     flag aSign;                                                                                {'linevul': 24, 'codebert': 6, 'PLBART': 11, 'regvd': 22, 'vulberta_cnn': 7, 'vulberta_mlp': 32}
6     int16 aExp, shiftCount;                                                                    {'linevul': 18, 'codebert': 10, 'PLBART': 8, 'regvd': 18, 'vulberta_cnn': 25, 'vulberta_mlp': 14}
8     uint64_t aSig, savedASig;                                                                  {'linevul': 10, 'codebert': 7, 'PLBART': 4, 'regvd': 17, 'vulberta_cnn': 3, 'vulberta_mlp': 18}
10     int32 z;                                                                                  {'linevul': 25, 'codebert': 16, 'PLBART': 12, 'regvd': 24, 'vulberta_cnn': 24, 'vulberta_mlp': 5}
12     a = float64_squash_input_denormal(a STATUS_VAR);                                          {'linevul': 5, 'codebert': 2, 'PLBART': 0, 'regvd': 4, 'vulberta_cnn': 4, 'vulberta_mlp': 9}
16     aSig = extractFloat64Frac( a );                                                           {'linevul': 9, 'codebert': 3, 'PLBART': 6, 'regvd': 7, 'vulberta_cnn': 1, 'vulberta_mlp': 17}
18     aExp = extractFloat64Exp( a );                                                            {'linevul': 15, 'codebert': 12, 'PLBART': 5, 'regvd': 10, 'vulberta_cnn': 8, 'vulberta_mlp': 19}
20     aSign = extractFloat64Sign( a );                                                          {'linevul': 14, 'codebert': 13, 'PLBART': 7, 'regvd': 6, 'vulberta_cnn': 23, 'vulberta_mlp': 16}
22     if ( 0x41E < aExp ) {                                                                     {'linevul': 13, 'codebert': 22, 'PLBART': 2, 'regvd': 16, 'vulberta_cnn': 20, 'vulberta_mlp': 15}
24         if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;                                           {'linevul': 2, 'codebert': 14, 'PLBART': 3, 'regvd': 2, 'vulberta_cnn': 27, 'vulberta_mlp': 31}
26         goto invalid;                                                                         {'linevul': 22, 'codebert': 9, 'PLBART': 10, 'regvd': 23, 'vulberta_cnn': 15, 'vulberta_mlp': 29}
28     }                                                                                         {'linevul': 30, 'codebert': 19, 'PLBART': 14, 'regvd': 33, 'vulberta_cnn': 12, 'vulberta_mlp': 23}
30     else if ( aExp < 0x3FF ) {                                                                {'linevul': 12, 'codebert': 18, 'PLBART': 9, 'regvd': 14, 'vulberta_cnn': 32, 'vulberta_mlp': 26}
32         if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;              {'linevul': 0, 'codebert': 4, 'PLBART': -1, 'regvd': 0, 'vulberta_cnn': 2, 'vulberta_mlp': 3}
34         return 0;                                                                             {'linevul': 21, 'codebert': 17, 'PLBART': -1, 'regvd': 25, 'vulberta_cnn': 10, 'vulberta_mlp': 20}
36     }                                                                                         {'linevul': 29, 'codebert': 21, 'PLBART': -1, 'regvd': 32, 'vulberta_cnn': 14, 'vulberta_mlp': 1}
38     aSig |= LIT64( 0x0010000000000000 );                                                      {'linevul': 8, 'codebert': 8, 'PLBART': -1, 'regvd': 5, 'vulberta_cnn': 30, 'vulberta_mlp': 2}
40     shiftCount = 0x433 - aExp;                                                                {'linevul': 17, 'codebert': 24, 'PLBART': -1, 'regvd': 15, 'vulberta_cnn': 0, 'vulberta_mlp': 10}
42     savedASig = aSig;                                                                         {'linevul': 20, 'codebert': 25, 'PLBART': -1, 'regvd': 20, 'vulberta_cnn': 9, 'vulberta_mlp': 27}
44     aSig >>= shiftCount;                                                                      {'linevul': 19, 'codebert': 20, 'PLBART': -1, 'regvd': 19, 'vulberta_cnn': 17, 'vulberta_mlp': 8}
46     z = aSig;                                                                                 {'linevul': 23, 'codebert': 26, 'PLBART': -1, 'regvd': 21, 'vulberta_cnn': 19, 'vulberta_mlp': 25}
48     if ( aSign ) z = - z;                                                                     {'linevul': 16, 'codebert': 23, 'PLBART': -1, 'regvd': 12, 'vulberta_cnn': 28, 'vulberta_mlp': 30}
50     if ( ( z < 0 ) ^ aSign ) {                                                                {'linevul': 11, 'codebert': 11, 'PLBART': -1, 'regvd': 13, 'vulberta_cnn': 29, 'vulberta_mlp': 11}
52  invalid:                                                                                     {'linevul': 31, 'codebert': 15, 'PLBART': -1, 'regvd': 26, 'vulberta_cnn': 18, 'vulberta_mlp': 12}
54         float_raise( float_flag_invalid STATUS_VAR);                                          {'linevul': 6, 'codebert': 5, 'PLBART': -1, 'regvd': 9, 'vulberta_cnn': 26, 'vulberta_mlp': 4}
56         return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;                                     {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'regvd': 1, 'vulberta_cnn': 31, 'vulberta_mlp': 24}
58     }                                                                                         {'linevul': 28, 'codebert': -1, 'PLBART': -1, 'regvd': 31, 'vulberta_cnn': 6, 'vulberta_mlp': 22}
60     if ( ( aSig<<shiftCount ) != savedASig ) {                                                {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'regvd': 11, 'vulberta_cnn': 22, 'vulberta_mlp': 13}
62         STATUS(float_exception_flags) |= float_flag_inexact;                                  {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'regvd': 3, 'vulberta_cnn': 5, 'vulberta_mlp': 0}
64     }                                                                                         {'linevul': 27, 'codebert': -1, 'PLBART': -1, 'regvd': 30, 'vulberta_cnn': 13, 'vulberta_mlp': 21}
66     return z;                                                                                 {'linevul': 26, 'codebert': -1, 'PLBART': -1, 'regvd': 27, 'vulberta_cnn': 21, 'vulberta_mlp': 28}
70 }                                                                                             {'linevul': 32, 'codebert': -1, 'PLBART': -1, 'regvd': 29, 'vulberta_cnn': 33, 'vulberta_mlp': 6}
-----------------------
Highlighted lines: 
0 int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
12     a = float64_squash_input_denormal(a STATUS_VAR);
16     aSig = extractFloat64Frac( a );
32         if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
38     aSig |= LIT64( 0x0010000000000000 );
54         float_raise( float_flag_invalid STATUS_VAR);
62         STATUS(float_exception_flags) |= float_flag_inexact;
--------------------------------------------------------------------------------------------------------------
Example ids:  22741 project:  qemu commit id:  40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4 Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_mlp']
0 int unix_start_incoming_migration(const char *path)                                           {'linevul': 7, 'codebert': 0, 'PLBART': 2, 'devign': 15, 'regvd': 7, 'vulberta_mlp': 24}
2 {                                                                                             {'linevul': 28, 'codebert': 6, 'PLBART': 11, 'devign': -1, 'regvd': 28, 'vulberta_mlp': 25}
4     struct sockaddr_un un;                                                                    {'linevul': 18, 'codebert': 3, 'PLBART': 8, 'devign': 14, 'regvd': 13, 'vulberta_mlp': 16}
6     int sock;                                                                                 {'linevul': 21, 'codebert': 17, 'PLBART': 10, 'devign': 17, 'regvd': 17, 'vulberta_mlp': 28}
10     dprintf("Attempting to start an incoming migration\n");                                  {'linevul': 9, 'codebert': 1, 'PLBART': 4, 'devign': -1, 'regvd': 9, 'vulberta_mlp': 12}
14     sock = socket(PF_UNIX, SOCK_STREAM, 0);                                                  {'linevul': 6, 'codebert': 9, 'PLBART': 3, 'devign': 9, 'regvd': 6, 'vulberta_mlp': 7}
16     if (sock < 0) {                                                                          {'linevul': 15, 'codebert': 18, 'PLBART': 9, 'devign': 2, 'regvd': 15, 'vulberta_mlp': 21}
18         fprintf(stderr, "Could not open unix socket: %s\n", strerror(errno));                {'linevul': 2, 'codebert': 11, 'PLBART': 0, 'devign': 3, 'regvd': 2, 'vulberta_mlp': 10}
20         return -EINVAL;                                                                      {'linevul': 13, 'codebert': 20, 'PLBART': 7, 'devign': 8, 'regvd': 19, 'vulberta_mlp': 22}
22     }                                                                                        {'linevul': 25, 'codebert': 19, 'PLBART': 12, 'devign': -1, 'regvd': 27, 'vulberta_mlp': 18}
26     memset(&un, 0, sizeof(un));                                                              {'linevul': 11, 'codebert': 4, 'PLBART': 5, 'devign': 19, 'regvd': 8, 'vulberta_mlp': 8}
28     un.sun_family = AF_UNIX;                                                                 {'linevul': 10, 'codebert': 5, 'PLBART': 6, 'devign': 4, 'regvd': 14, 'vulberta_mlp': 15}
30     snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);                                  {'linevul': 5, 'codebert': 7, 'PLBART': 1, 'devign': -1, 'regvd': 3, 'vulberta_mlp': 23}
34     unlink(un.sun_path);                                                                     {'linevul': 14, 'codebert': 12, 'PLBART': -1, 'devign': 16, 'regvd': 10, 'vulberta_mlp': 17}
36     if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {                                {'linevul': 4, 'codebert': 2, 'PLBART': -1, 'devign': 1, 'regvd': 5, 'vulberta_mlp': 13}
38         fprintf(stderr, "bind(unix:%s): %s\n", un.sun_path, strerror(errno));                {'linevul': 1, 'codebert': 10, 'PLBART': -1, 'devign': 12, 'regvd': 1, 'vulberta_mlp': 3}
40         goto err;                                                                            {'linevul': 17, 'codebert': 16, 'PLBART': -1, 'devign': 6, 'regvd': 22, 'vulberta_mlp': 6}
42     }                                                                                        {'linevul': 24, 'codebert': 21, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_mlp': 1}
44     if (listen(sock, 1) < 0) {                                                               {'linevul': 8, 'codebert': 13, 'PLBART': -1, 'devign': 0, 'regvd': 12, 'vulberta_mlp': 26}
46         fprintf(stderr, "listen(unix:%s): %s\n", un.sun_path, strerror(errno));              {'linevul': 0, 'codebert': 15, 'PLBART': -1, 'devign': 11, 'regvd': 0, 'vulberta_mlp': 20}
48         goto err;                                                                            {'linevul': 16, 'codebert': 14, 'PLBART': -1, 'devign': 5, 'regvd': 21, 'vulberta_mlp': 27}
50     }                                                                                        {'linevul': 23, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_mlp': 4}
54     qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,                   {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 4, 'vulberta_mlp': 19}
56 			 (void *)(unsigned long)sock);                                                            {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 11, 'vulberta_mlp': 9}
60     return 0;                                                                                {'linevul': 22, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 20, 'vulberta_mlp': 5}
64 err:                                                                                         {'linevul': 26, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 23, 'vulberta_mlp': 11}
66     close(sock);                                                                             {'linevul': 20, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 16, 'vulberta_mlp': 2}
70     return -EINVAL;                                                                          {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 18, 'vulberta_mlp': 14}
72 }                                                                                            {'linevul': 27, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 int unix_start_incoming_migration(const char *path)
10     dprintf("Attempting to start an incoming migration\n");
14     sock = socket(PF_UNIX, SOCK_STREAM, 0);
18         fprintf(stderr, "Could not open unix socket: %s\n", strerror(errno));
26     memset(&un, 0, sizeof(un));
30     snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);
36     if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
--------------------------------------------------------------------------------------------------------------
Example ids:  23339 project:  qemu commit id:  fc40787abcf8452b8f50d92b7a13243a12972c7a Number of lines:  36
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,               {'linevul': 10, 'codebert': 0, 'PLBART': 0, 'devign': 22, 'regvd': 22, 'vulberta_cnn': 7, 'vulberta_mlp': 1}
2                         target_ulong arg2, int mem_idx)                     {'linevul': 0, 'codebert': 3, 'PLBART': 8, 'devign': 25, 'regvd': 24, 'vulberta_cnn': 14, 'vulberta_mlp': 2}
4 {                                                                           {'linevul': 22, 'codebert': 1, 'PLBART': 10, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 23, 'vulberta_mlp': 29}
6     uint64_t tmp;                                                           {'linevul': 17, 'codebert': 2, 'PLBART': 7, 'devign': 26, 'regvd': 25, 'vulberta_cnn': 19, 'vulberta_mlp': 35}
10     tmp = do_lbu(env, arg2, mem_idx);                                      {'linevul': 11, 'codebert': 4, 'PLBART': 4, 'devign': 23, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 31}
12     arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);                   {'linevul': 9, 'codebert': 6, 'PLBART': 2, 'devign': 4, 'regvd': 11, 'vulberta_cnn': 4, 'vulberta_mlp': 3}
16     if (GET_LMASK64(arg2) <= 6) {                                          {'linevul': 16, 'codebert': 14, 'PLBART': 5, 'devign': 13, 'regvd': 19, 'vulberta_cnn': 32, 'vulberta_mlp': 14}
18         tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);                   {'linevul': 4, 'codebert': 5, 'PLBART': 1, 'devign': 19, 'regvd': 0, 'vulberta_cnn': 3, 'vulberta_mlp': 30}
20         arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);               {'linevul': 8, 'codebert': 11, 'PLBART': 3, 'devign': 0, 'regvd': 13, 'vulberta_cnn': 21, 'vulberta_mlp': 18}
22     }                                                                      {'linevul': 18, 'codebert': 16, 'PLBART': 11, 'devign': -1, 'regvd': 35, 'vulberta_cnn': 15, 'vulberta_mlp': 28}
26     if (GET_LMASK64(arg2) <= 5) {                                          {'linevul': 15, 'codebert': 13, 'PLBART': 6, 'devign': 9, 'regvd': 14, 'vulberta_cnn': 1, 'vulberta_mlp': 17}
28         tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);                   {'linevul': 3, 'codebert': 7, 'PLBART': 9, 'devign': 21, 'regvd': 6, 'vulberta_cnn': 33, 'vulberta_mlp': 20}
30         arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);               {'linevul': 7, 'codebert': 10, 'PLBART': -1, 'devign': 1, 'regvd': 12, 'vulberta_cnn': 31, 'vulberta_mlp': 27}
32     }                                                                      {'linevul': 21, 'codebert': 17, 'PLBART': -1, 'devign': -1, 'regvd': 34, 'vulberta_cnn': 16, 'vulberta_mlp': 26}
36     if (GET_LMASK64(arg2) <= 4) {                                          {'linevul': 14, 'codebert': 9, 'PLBART': -1, 'devign': 12, 'regvd': 18, 'vulberta_cnn': 28, 'vulberta_mlp': 15}
38         tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);                   {'linevul': 2, 'codebert': 8, 'PLBART': -1, 'devign': 18, 'regvd': 2, 'vulberta_cnn': 35, 'vulberta_mlp': 7}
40         arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);               {'linevul': 6, 'codebert': 12, 'PLBART': -1, 'devign': 6, 'regvd': 8, 'vulberta_cnn': 2, 'vulberta_mlp': 10}
42     }                                                                      {'linevul': 20, 'codebert': 15, 'PLBART': -1, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 12, 'vulberta_mlp': 25}
46     if (GET_LMASK64(arg2) <= 3) {                                          {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 15, 'vulberta_cnn': 9, 'vulberta_mlp': 21}
48         tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);                   {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 20, 'regvd': 3, 'vulberta_cnn': 24, 'vulberta_mlp': 13}
50         arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);               {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 9, 'vulberta_cnn': 0, 'vulberta_mlp': 12}
52     }                                                                      {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 10, 'vulberta_mlp': 6}
56     if (GET_LMASK64(arg2) <= 2) {                                          {'linevul': 13, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 17, 'vulberta_cnn': 27, 'vulberta_mlp': 24}
58         tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 15, 'regvd': 1, 'vulberta_cnn': 8, 'vulberta_mlp': 16}
60         arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 3, 'regvd': 16, 'vulberta_cnn': 11, 'vulberta_mlp': 23}
62     }                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_cnn': 17, 'vulberta_mlp': 5}
66     if (GET_LMASK64(arg2) <= 1) {                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 10, 'vulberta_cnn': 26, 'vulberta_mlp': 33}
68         tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 4, 'vulberta_cnn': 30, 'vulberta_mlp': 11}
70         arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 21, 'vulberta_cnn': 6, 'vulberta_mlp': 19}
72     }                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_cnn': 20, 'vulberta_mlp': 22}
76     if (GET_LMASK64(arg2) == 0) {                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 20, 'vulberta_cnn': 22, 'vulberta_mlp': 32}
78         tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);                   {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 17, 'regvd': 5, 'vulberta_cnn': 18, 'vulberta_mlp': 34}
80         arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 23, 'vulberta_cnn': 5, 'vulberta_mlp': 8}
82     }                                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 25, 'vulberta_mlp': 4}
86     return arg1;                                                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 24, 'regvd': 26, 'vulberta_cnn': 29, 'vulberta_mlp': 9}
88 }                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 34, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,
2                         target_ulong arg2, int mem_idx)
12     arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);
18         tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);
28         tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);
38         tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);
40         arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);
50         arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);
--------------------------------------------------------------------------------------------------------------
Example ids:  23888 project:  qemu commit id:  fbeadf50f2f965741def823036b086bbc2999b1f Number of lines:  42
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,               {'linevul': 2, 'codebert': 0, 'PLBART': 0, 'devign': 15, 'regvd': 12, 'vulberta_cnn': 7, 'vulberta_mlp': 8}
2 				 unsigned long offset)                                                                    {'linevul': 24, 'codebert': 8, 'PLBART': 12, 'devign': 4, 'regvd': 27, 'vulberta_cnn': 22, 'vulberta_mlp': 4}
4 {                                                                                             {'linevul': 37, 'codebert': 10, 'PLBART': 14, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 15, 'vulberta_mlp': 18}
6     const unsigned long *p = addr + BITOP_WORD(offset);                                       {'linevul': 6, 'codebert': 1, 'PLBART': 1, 'devign': 0, 'regvd': 2, 'vulberta_cnn': 39, 'vulberta_mlp': 29}
8     unsigned long result = offset & ~(BITS_PER_LONG-1);                                       {'linevul': 1, 'codebert': 5, 'PLBART': 2, 'devign': 1, 'regvd': 1, 'vulberta_cnn': 5, 'vulberta_mlp': 9}
10     unsigned long tmp;                                                                       {'linevul': 30, 'codebert': 6, 'PLBART': 11, 'devign': 29, 'regvd': 23, 'vulberta_cnn': 30, 'vulberta_mlp': 17}
14     if (offset >= size) {                                                                    {'linevul': 20, 'codebert': 13, 'PLBART': 7, 'devign': 3, 'regvd': 11, 'vulberta_cnn': 0, 'vulberta_mlp': 36}
16         return size;                                                                         {'linevul': 22, 'codebert': 22, 'PLBART': 10, 'devign': 30, 'regvd': 28, 'vulberta_cnn': 25, 'vulberta_mlp': 24}
18     }                                                                                        {'linevul': 33, 'codebert': 24, 'PLBART': 13, 'devign': -1, 'regvd': 41, 'vulberta_cnn': 6, 'vulberta_mlp': 16}
20     size -= result;                                                                          {'linevul': 31, 'codebert': 11, 'PLBART': 9, 'devign': 18, 'regvd': 21, 'vulberta_cnn': 35, 'vulberta_mlp': 21}
22     offset %= BITS_PER_LONG;                                                                 {'linevul': 17, 'codebert': 9, 'PLBART': 4, 'devign': 5, 'regvd': 15, 'vulberta_cnn': 14, 'vulberta_mlp': 1}
24     if (offset) {                                                                            {'linevul': 25, 'codebert': 15, 'PLBART': 8, 'devign': 17, 'regvd': 20, 'vulberta_cnn': 3, 'vulberta_mlp': 28}
26         tmp = *(p++);                                                                        {'linevul': 16, 'codebert': 2, 'PLBART': 5, 'devign': 16, 'regvd': 9, 'vulberta_cnn': 28, 'vulberta_mlp': 22}
28         tmp |= ~0UL >> (BITS_PER_LONG - offset);                                             {'linevul': 0, 'codebert': 3, 'PLBART': 3, 'devign': 6, 'regvd': 0, 'vulberta_cnn': 19, 'vulberta_mlp': 23}
30         if (size < BITS_PER_LONG) {                                                          {'linevul': 5, 'codebert': 14, 'PLBART': 6, 'devign': 20, 'regvd': 5, 'vulberta_cnn': 18, 'vulberta_mlp': 34}
32             goto found_first;                                                                {'linevul': 15, 'codebert': 18, 'PLBART': -1, 'devign': 31, 'regvd': 26, 'vulberta_cnn': 10, 'vulberta_mlp': 15}
34         }                                                                                    {'linevul': 29, 'codebert': 25, 'PLBART': -1, 'devign': -1, 'regvd': 40, 'vulberta_cnn': 17, 'vulberta_mlp': 5}
36         if (~tmp) {                                                                          {'linevul': 19, 'codebert': 7, 'PLBART': -1, 'devign': 21, 'regvd': 17, 'vulberta_cnn': 24, 'vulberta_mlp': 39}
38             goto found_middle;                                                               {'linevul': 13, 'codebert': 20, 'PLBART': -1, 'devign': 25, 'regvd': 25, 'vulberta_cnn': 29, 'vulberta_mlp': 20}
40         }                                                                                    {'linevul': 28, 'codebert': 23, 'PLBART': -1, 'devign': -1, 'regvd': 39, 'vulberta_cnn': 9, 'vulberta_mlp': 14}
42         size -= BITS_PER_LONG;                                                               {'linevul': 9, 'codebert': 17, 'PLBART': -1, 'devign': 8, 'regvd': 8, 'vulberta_cnn': 8, 'vulberta_mlp': 19}
44         result += BITS_PER_LONG;                                                             {'linevul': 11, 'codebert': 16, 'PLBART': -1, 'devign': 11, 'regvd': 14, 'vulberta_cnn': 16, 'vulberta_mlp': 27}
46     }                                                                                        {'linevul': 36, 'codebert': 26, 'PLBART': -1, 'devign': -1, 'regvd': 38, 'vulberta_cnn': 21, 'vulberta_mlp': 33}
48     while (size & ~(BITS_PER_LONG-1)) {                                                      {'linevul': 4, 'codebert': 12, 'PLBART': -1, 'devign': 14, 'regvd': 4, 'vulberta_cnn': 40, 'vulberta_mlp': 25}
50         if (~(tmp = *(p++))) {                                                               {'linevul': 7, 'codebert': 4, 'PLBART': -1, 'devign': 2, 'regvd': 6, 'vulberta_cnn': 1, 'vulberta_mlp': 11}
52             goto found_middle;                                                               {'linevul': 14, 'codebert': 21, 'PLBART': -1, 'devign': 24, 'regvd': 24, 'vulberta_cnn': 36, 'vulberta_mlp': 6}
54         }                                                                                    {'linevul': 27, 'codebert': 27, 'PLBART': -1, 'devign': -1, 'regvd': 37, 'vulberta_cnn': 23, 'vulberta_mlp': 13}
56         result += BITS_PER_LONG;                                                             {'linevul': 12, 'codebert': 19, 'PLBART': -1, 'devign': 10, 'regvd': 13, 'vulberta_cnn': 4, 'vulberta_mlp': 12}
58         size -= BITS_PER_LONG;                                                               {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 7, 'regvd': 7, 'vulberta_cnn': 26, 'vulberta_mlp': 10}
60     }                                                                                        {'linevul': 35, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 36, 'vulberta_cnn': 11, 'vulberta_mlp': 41}
62     if (!size) {                                                                             {'linevul': 26, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 19, 'vulberta_cnn': 27, 'vulberta_mlp': 38}
64         return result;                                                                       {'linevul': 21, 'codebert': -1, 'PLBART': -1, 'devign': 28, 'regvd': 31, 'vulberta_cnn': 33, 'vulberta_mlp': 32}
66     }                                                                                        {'linevul': 34, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 35, 'vulberta_cnn': 13, 'vulberta_mlp': 40}
68     tmp = *p;                                                                                {'linevul': 23, 'codebert': -1, 'PLBART': -1, 'devign': 27, 'regvd': 22, 'vulberta_cnn': 2, 'vulberta_mlp': 26}
72 found_first:                                                                                 {'linevul': 32, 'codebert': -1, 'PLBART': -1, 'devign': 26, 'regvd': 30, 'vulberta_cnn': 34, 'vulberta_mlp': 31}
74     tmp |= ~0UL << size;                                                                     {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 16, 'vulberta_cnn': 32, 'vulberta_mlp': 35}
76     if (tmp == ~0UL) {	/* Are any bits zero? */                                              {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 3, 'vulberta_cnn': 38, 'vulberta_mlp': 0}
78         return result + size;	/* Nope. */                                                    {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 18, 'vulberta_cnn': 31, 'vulberta_mlp': 37}
80     }                                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 34, 'vulberta_cnn': 20, 'vulberta_mlp': 30}
82 found_middle:                                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 23, 'regvd': 29, 'vulberta_cnn': 12, 'vulberta_mlp': 2}
84     return result + ffz(tmp);                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 10, 'vulberta_cnn': 37, 'vulberta_mlp': 3}
86 }                                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 41, 'vulberta_mlp': 7}
-----------------------
Highlighted lines: 
0 unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
6     const unsigned long *p = addr + BITOP_WORD(offset);
8     unsigned long result = offset & ~(BITS_PER_LONG-1);
22     offset %= BITS_PER_LONG;
28         tmp |= ~0UL >> (BITS_PER_LONG - offset);
42         size -= BITS_PER_LONG;
50         if (~(tmp = *(p++))) {
--------------------------------------------------------------------------------------------------------------
Example ids:  24400 project:  FFmpeg commit id:  439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2 Number of lines:  34
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn']
0 static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                            {'linevul': 11, 'codebert': 4, 'PLBART': 2, 'devign': 2, 'regvd': 7, 'vulberta_cnn': 26}
2                         const AVFrame *frame, int *got_packet_ptr)                         {'linevul': 3, 'codebert': 0, 'PLBART': 4, 'devign': 3, 'regvd': 14, 'vulberta_cnn': 25}
4 {                                                                                          {'linevul': 22, 'codebert': 2, 'PLBART': 11, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 15}
6     NellyMoserEncodeContext *s = avctx->priv_data;                                         {'linevul': 12, 'codebert': 3, 'PLBART': 3, 'devign': 11, 'regvd': 15, 'vulberta_cnn': 19}
8     int ret;                                                                               {'linevul': 20, 'codebert': 10, 'PLBART': 9, 'devign': 24, 'regvd': 28, 'vulberta_cnn': 23}
12     if (s->last_frame)                                                                    {'linevul': 15, 'codebert': 6, 'PLBART': 6, 'devign': 5, 'regvd': 16, 'vulberta_cnn': 12}
14         return 0;                                                                         {'linevul': 16, 'codebert': 1, 'PLBART': 10, 'devign': 9, 'regvd': 24, 'vulberta_cnn': 30}
18     memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));              {'linevul': 2, 'codebert': 5, 'PLBART': 0, 'devign': 25, 'regvd': 1, 'vulberta_cnn': 4}
20     if (frame) {                                                                          {'linevul': 18, 'codebert': 15, 'PLBART': 7, 'devign': 18, 'regvd': 22, 'vulberta_cnn': 24}
22         memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],                                    {'linevul': 5, 'codebert': 7, 'PLBART': 1, 'devign': 17, 'regvd': 4, 'vulberta_cnn': 2}
24                frame->nb_samples * sizeof(*s->buf));                                      {'linevul': 8, 'codebert': 9, 'PLBART': 5, 'devign': 16, 'regvd': 11, 'vulberta_cnn': 22}
26         if (frame->nb_samples < NELLY_SAMPLES) {                                          {'linevul': 9, 'codebert': 11, 'PLBART': 8, 'devign': 6, 'regvd': 5, 'vulberta_cnn': 8}
28             memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,                         {'linevul': 4, 'codebert': 8, 'PLBART': -1, 'devign': 15, 'regvd': 3, 'vulberta_cnn': 1}
30                    (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));                {'linevul': 0, 'codebert': 12, 'PLBART': -1, 'devign': 14, 'regvd': 2, 'vulberta_cnn': 0}
32             if (frame->nb_samples >= NELLY_BUF_LEN)                                       {'linevul': 6, 'codebert': 13, 'PLBART': -1, 'devign': 7, 'regvd': 9, 'vulberta_cnn': 5}
34                 s->last_frame = 1;                                                        {'linevul': 10, 'codebert': 14, 'PLBART': -1, 'devign': 1, 'regvd': 18, 'vulberta_cnn': 16}
36         }                                                                                 {'linevul': 17, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 33, 'vulberta_cnn': 14}
38         if ((ret = ff_af_queue_add(&s->afq, frame) < 0))                                  {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 8, 'vulberta_cnn': 29}
40             return ret;                                                                   {'linevul': 14, 'codebert': -1, 'PLBART': -1, 'devign': 20, 'regvd': 27, 'vulberta_cnn': 20}
42     } else {                                                                              {'linevul': 19, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 9}
44         memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));               {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 23, 'regvd': 0, 'vulberta_cnn': 6}
46         s->last_frame = 1;                                                                {'linevul': 13, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 17, 'vulberta_cnn': 21}
48     }                                                                                     {'linevul': 21, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 32, 'vulberta_cnn': 10}
52     if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 6, 'vulberta_cnn': 31}
54         av_log(avctx, AV_LOG_ERROR, "Error getting output packet\n");                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 13, 'vulberta_cnn': 17}
56         return ret;                                                                       {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 26, 'vulberta_cnn': 13}
58     }                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 31, 'vulberta_cnn': 18}
60     encode_block(s, avpkt->data, avpkt->size);                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 22, 'regvd': 12, 'vulberta_cnn': 28}
64     /* Get the next frame pts/duration */                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 19, 'vulberta_cnn': -1}
66     ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,                           {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 12, 'regvd': 10, 'vulberta_cnn': 3}
68                        &avpkt->duration);                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 7}
72     *got_packet_ptr = 1;                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 21, 'regvd': 20, 'vulberta_cnn': 11}
74     return 0;                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 23, 'vulberta_cnn': 27}
76 }                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 30, 'vulberta_cnn': 32}
-----------------------
Highlighted lines: 
0 static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
2                         const AVFrame *frame, int *got_packet_ptr)
18     memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));
22         memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],
26         if (frame->nb_samples < NELLY_SAMPLES) {
28             memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,
32             if (frame->nb_samples >= NELLY_BUF_LEN)
--------------------------------------------------------------------------------------------------------------
Example ids:  24559 project:  qemu commit id:  09b9418c6d085a0728372aa760ebd10128a020b1 Number of lines:  30
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int get_monitor_def(target_long *pval, const char *name)               {'linevul': 15, 'codebert': 6, 'PLBART': 0, 'devign': 4, 'regvd': 3, 'vulberta_cnn': 6, 'vulberta_mlp': 9}
2 {                                                                             {'linevul': 22, 'codebert': 14, 'PLBART': 15, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 9, 'vulberta_mlp': 27}
4     const MonitorDef *md;                                                     {'linevul': 20, 'codebert': 10, 'PLBART': 8, 'devign': 17, 'regvd': 10, 'vulberta_cnn': 15, 'vulberta_mlp': 1}
6     void *ptr;                                                                {'linevul': 21, 'codebert': 4, 'PLBART': 7, 'devign': 18, 'regvd': 12, 'vulberta_cnn': 0, 'vulberta_mlp': 29}
10     for(md = monitor_defs; md->name != NULL; md++) {                         {'linevul': 9, 'codebert': 9, 'PLBART': 3, 'devign': 0, 'regvd': 2, 'vulberta_cnn': 28, 'vulberta_mlp': 16}
12         if (compare_cmd(name, md->name)) {                                   {'linevul': 8, 'codebert': 11, 'PLBART': 1, 'devign': 10, 'regvd': 6, 'vulberta_cnn': 17, 'vulberta_mlp': 18}
14             if (md->get_value) {                                             {'linevul': 16, 'codebert': 7, 'PLBART': 9, 'devign': 8, 'regvd': 8, 'vulberta_cnn': 19, 'vulberta_mlp': 24}
16                 *pval = md->get_value(md, md->offset);                       {'linevul': 2, 'codebert': 8, 'PLBART': 2, 'devign': 1, 'regvd': 1, 'vulberta_cnn': 3, 'vulberta_mlp': 8}
18             } else {                                                         {'linevul': 19, 'codebert': 13, 'PLBART': 12, 'devign': -1, 'regvd': 19, 'vulberta_cnn': 4, 'vulberta_mlp': 7}
20                 CPUState *env = mon_get_cpu();                               {'linevul': 4, 'codebert': 5, 'PLBART': 5, 'devign': 15, 'regvd': 7, 'vulberta_cnn': 13, 'vulberta_mlp': 10}
22                 if (!env)                                                    {'linevul': 17, 'codebert': 2, 'PLBART': 10, 'devign': 11, 'regvd': 13, 'vulberta_cnn': 14, 'vulberta_mlp': 20}
24                     return -2;                                               {'linevul': 6, 'codebert': 1, 'PLBART': 14, 'devign': 22, 'regvd': 16, 'vulberta_cnn': 10, 'vulberta_mlp': 0}
26                 ptr = (uint8_t *)env + md->offset;                           {'linevul': 3, 'codebert': 0, 'PLBART': 4, 'devign': 12, 'regvd': 0, 'vulberta_cnn': 12, 'vulberta_mlp': 13}
28                 switch(md->type) {                                           {'linevul': 7, 'codebert': 12, 'PLBART': 6, 'devign': 3, 'regvd': 9, 'vulberta_cnn': 26, 'vulberta_mlp': 28}
30                 case MD_I32:                                                 {'linevul': 14, 'codebert': 17, 'PLBART': 11, 'devign': 20, 'regvd': 14, 'vulberta_cnn': 18, 'vulberta_mlp': 12}
32                     *pval = *(int32_t *)ptr;                                 {'linevul': 0, 'codebert': 3, 'PLBART': 13, 'devign': 13, 'regvd': 5, 'vulberta_cnn': 5, 'vulberta_mlp': 6}
34                     break;                                                   {'linevul': 13, 'codebert': 15, 'PLBART': -1, 'devign': 7, 'regvd': 22, 'vulberta_cnn': 23, 'vulberta_mlp': 3}
36                 case MD_TLONG:                                               {'linevul': 12, 'codebert': 16, 'PLBART': -1, 'devign': 21, 'regvd': 15, 'vulberta_cnn': 24, 'vulberta_mlp': 17}
38                     *pval = *(target_long *)ptr;                             {'linevul': 1, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 4, 'vulberta_cnn': 27, 'vulberta_mlp': 11}
40                     break;                                                   {'linevul': 11, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 21, 'vulberta_cnn': 1, 'vulberta_mlp': 19}
42                 default:                                                     {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': 19, 'regvd': 23, 'vulberta_cnn': 20, 'vulberta_mlp': 23}
44                     *pval = 0;                                               {'linevul': 5, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 11, 'vulberta_cnn': 21, 'vulberta_mlp': 14}
46                     break;                                                   {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 5, 'regvd': 20, 'vulberta_cnn': 7, 'vulberta_mlp': 4}
48                 }                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 11, 'vulberta_mlp': 26}
50             }                                                                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 16, 'vulberta_mlp': 21}
52             return 0;                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 18, 'vulberta_cnn': 22, 'vulberta_mlp': 25}
54         }                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 8, 'vulberta_mlp': 5}
56     }                                                                        {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 2, 'vulberta_mlp': 15}
58     return -1;                                                               {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 16, 'regvd': 17, 'vulberta_cnn': 25, 'vulberta_mlp': 22}
60 }                                                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 29, 'vulberta_mlp': 2}
-----------------------
Highlighted lines: 
0 static int get_monitor_def(target_long *pval, const char *name)
10     for(md = monitor_defs; md->name != NULL; md++) {
14             if (md->get_value) {
16                 *pval = md->get_value(md, md->offset);
20                 CPUState *env = mon_get_cpu();
26                 ptr = (uint8_t *)env + md->offset;
28                 switch(md->type) {
32                     *pval = *(int32_t *)ptr;
--------------------------------------------------------------------------------------------------------------
Example ids:  24621 project:  FFmpeg commit id:  2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac Number of lines:  22
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){               {'linevul': 4, 'codebert': 0, 'PLBART': 1, 'regvd': 7, 'vulberta_cnn': 18, 'vulberta_mlp': 13}
2     int i;                                                                   {'linevul': 17, 'codebert': 16, 'PLBART': 12, 'regvd': 17, 'vulberta_cnn': 5, 'vulberta_mlp': 19}
4     int dc0, dc2;                                                            {'linevul': 16, 'codebert': 11, 'PLBART': 10, 'regvd': 15, 'vulberta_cnn': 14, 'vulberta_mlp': 15}
6     pixel4 dc0splat, dc2splat;                                               {'linevul': 12, 'codebert': 3, 'PLBART': 2, 'regvd': 9, 'vulberta_cnn': 4, 'vulberta_mlp': 16}
8     pixel *src = (pixel*)_src;                                               {'linevul': 13, 'codebert': 1, 'PLBART': 7, 'regvd': 12, 'vulberta_cnn': 10, 'vulberta_mlp': 18}
10     stride /= sizeof(pixel);                                                {'linevul': 15, 'codebert': 2, 'PLBART': 8, 'regvd': 14, 'vulberta_cnn': 15, 'vulberta_mlp': 3}
14     dc0=dc2=0;                                                              {'linevul': 14, 'codebert': 15, 'PLBART': 9, 'regvd': 16, 'vulberta_cnn': 0, 'vulberta_mlp': 21}
16     for(i=0;i<4; i++){                                                      {'linevul': 11, 'codebert': 18, 'PLBART': 5, 'regvd': 11, 'vulberta_cnn': 17, 'vulberta_mlp': 5}
18         dc0+= src[-1+i*stride];                                             {'linevul': 8, 'codebert': 17, 'PLBART': 4, 'regvd': 8, 'vulberta_cnn': 19, 'vulberta_mlp': 4}
20         dc2+= src[-1+(i+4)*stride];                                         {'linevul': 7, 'codebert': 12, 'PLBART': 6, 'regvd': 2, 'vulberta_cnn': 1, 'vulberta_mlp': 8}
22     }                                                                       {'linevul': 18, 'codebert': 20, 'PLBART': 13, 'regvd': 21, 'vulberta_cnn': 7, 'vulberta_mlp': 7}
24     dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);                                {'linevul': 0, 'codebert': 4, 'PLBART': 0, 'regvd': 3, 'vulberta_cnn': 11, 'vulberta_mlp': 12}
26     dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);                                {'linevul': 1, 'codebert': 5, 'PLBART': -1, 'regvd': 6, 'vulberta_cnn': 9, 'vulberta_mlp': 10}
30     for(i=0; i<4; i++){                                                     {'linevul': 10, 'codebert': 19, 'PLBART': 3, 'regvd': 10, 'vulberta_cnn': 20, 'vulberta_mlp': 20}
32         ((pixel4*)(src+i*stride))[0]=                                       {'linevul': 5, 'codebert': 9, 'PLBART': 11, 'regvd': 5, 'vulberta_cnn': 3, 'vulberta_mlp': 6}
34         ((pixel4*)(src+i*stride))[1]= dc0splat;                             {'linevul': 2, 'codebert': 7, 'PLBART': -1, 'regvd': 0, 'vulberta_cnn': 2, 'vulberta_mlp': 11}
36     }                                                                       {'linevul': 20, 'codebert': 21, 'PLBART': -1, 'regvd': 20, 'vulberta_cnn': 6, 'vulberta_mlp': 1}
38     for(i=4; i<8; i++){                                                     {'linevul': 9, 'codebert': 14, 'PLBART': -1, 'regvd': 13, 'vulberta_cnn': 8, 'vulberta_mlp': 17}
40         ((pixel4*)(src+i*stride))[0]=                                       {'linevul': 6, 'codebert': 8, 'PLBART': -1, 'regvd': 4, 'vulberta_cnn': 12, 'vulberta_mlp': 14}
42         ((pixel4*)(src+i*stride))[1]= dc2splat;                             {'linevul': 3, 'codebert': 10, 'PLBART': -1, 'regvd': 1, 'vulberta_cnn': 16, 'vulberta_mlp': 9}
44     }                                                                       {'linevul': 19, 'codebert': 6, 'PLBART': -1, 'regvd': 19, 'vulberta_cnn': 13, 'vulberta_mlp': 2}
46 }                                                                           {'linevul': 21, 'codebert': 13, 'PLBART': -1, 'regvd': 18, 'vulberta_cnn': 21, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
6     pixel4 dc0splat, dc2splat;
18         dc0+= src[-1+i*stride];
20         dc2+= src[-1+(i+4)*stride];
24     dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
26     dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
32         ((pixel4*)(src+i*stride))[0]=
34         ((pixel4*)(src+i*stride))[1]= dc0splat;
--------------------------------------------------------------------------------------------------------------
Example ids:  24732 project:  FFmpeg commit id:  93c39db5f1544d1220488cfeb93bfe812a52f374 Number of lines:  31
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static int aiff_read_packet(AVFormatContext *s,                                                                                         {'linevul': 11, 'codebert': 5, 'PLBART': 3, 'devign': 3, 'regvd': 5, 'vulberta_cnn': 4, 'vulberta_mlp': 19}
1                             AVPacket *pkt)                                                                                              {'linevul': 1, 'codebert': 10, 'PLBART': 11, 'devign': 7, 'regvd': 22, 'vulberta_cnn': 20, 'vulberta_mlp': 3}
2 {                                                                                                                                       {'linevul': 28, 'codebert': 20, 'PLBART': 13, 'devign': -1, 'regvd': 30, 'vulberta_cnn': 12, 'vulberta_mlp': 27}
3     AVStream *st = s->streams[0];                                                                                                       {'linevul': 13, 'codebert': 14, 'PLBART': 5, 'devign': 4, 'regvd': 13, 'vulberta_cnn': 22, 'vulberta_mlp': 14}
4     AIFFInputContext *aiff = s->priv_data;                                                                                              {'linevul': 7, 'codebert': 6, 'PLBART': 2, 'devign': 2, 'regvd': 7, 'vulberta_cnn': 27, 'vulberta_mlp': 24}
5     int64_t max_size;                                                                                                                   {'linevul': 19, 'codebert': 17, 'PLBART': 8, 'devign': 5, 'regvd': 17, 'vulberta_cnn': 14, 'vulberta_mlp': 7}
6     int res, size;                                                                                                                      {'linevul': 26, 'codebert': 18, 'PLBART': 10, 'devign': 6, 'regvd': 23, 'vulberta_cnn': 19, 'vulberta_mlp': 17}
7     /* calculate size of remaining data */                                                                                              {'linevul': 21, 'codebert': 15, 'PLBART': 6, 'devign': -1, 'regvd': 21, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
8     max_size = aiff->data_end - avio_tell(s->pb);                                                                                       {'linevul': 3, 'codebert': 4, 'PLBART': 0, 'devign': 1, 'regvd': 3, 'vulberta_cnn': 13, 'vulberta_mlp': 8}
9     if (max_size <= 0)                                                                                                                  {'linevul': 20, 'codebert': 2, 'PLBART': 12, 'devign': 0, 'regvd': 11, 'vulberta_cnn': 11, 'vulberta_mlp': 13}
10         return AVERROR_EOF;                                                                                                            {'linevul': 15, 'codebert': 0, 'PLBART': 7, 'devign': 8, 'regvd': 20, 'vulberta_cnn': 17, 'vulberta_mlp': 15}
11     /* Now for that packet */                                                                                                          {'linevul': 23, 'codebert': 1, 'PLBART': 9, 'devign': -1, 'regvd': 25, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
12     switch (st->codecpar->codec_id) {                                                                                                  {'linevul': 9, 'codebert': 3, 'PLBART': 4, 'devign': -1, 'regvd': 12, 'vulberta_cnn': 16, 'vulberta_mlp': 16}
13     case AV_CODEC_ID_ADPCM_IMA_QT:                                                                                                     {'linevul': 4, 'codebert': 9, 'PLBART': 1, 'devign': -1, 'regvd': 14, 'vulberta_cnn': 7, 'vulberta_mlp': 22}
14     case AV_CODEC_ID_GSM:                                                                                                              {'linevul': 14, 'codebert': 11, 'PLBART': -1, 'devign': -1, 'regvd': 18, 'vulberta_cnn': 15, 'vulberta_mlp': 21}
15     case AV_CODEC_ID_QDM2:                                                                                                             {'linevul': 12, 'codebert': 7, 'PLBART': -1, 'devign': -1, 'regvd': 15, 'vulberta_cnn': 24, 'vulberta_mlp': 6}
16     case AV_CODEC_ID_QCELP:                                                                                                            {'linevul': 10, 'codebert': 12, 'PLBART': -1, 'devign': -1, 'regvd': 16, 'vulberta_cnn': 25, 'vulberta_mlp': 12}
17         size = st->codecpar->block_align;                                                                                              {'linevul': 6, 'codebert': 16, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 8, 'vulberta_mlp': 23}
18         break;                                                                                                                         {'linevul': 25, 'codebert': 21, 'PLBART': -1, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 10, 'vulberta_mlp': 26}
19     default:                                                                                                                           {'linevul': 27, 'codebert': 22, 'PLBART': -1, 'devign': -1, 'regvd': 29, 'vulberta_cnn': 18, 'vulberta_mlp': 25}
20         size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;              {'linevul': 0, 'codebert': 13, 'PLBART': -1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 3, 'vulberta_mlp': 9}
21     size = FFMIN(max_size, size);                                                                                                      {'linevul': 16, 'codebert': 19, 'PLBART': -1, 'devign': -1, 'regvd': 9, 'vulberta_cnn': 1, 'vulberta_mlp': 2}
22     res = av_get_packet(s->pb, pkt, size);                                                                                             {'linevul': 5, 'codebert': 8, 'PLBART': -1, 'devign': -1, 'regvd': 2, 'vulberta_cnn': 26, 'vulberta_mlp': 1}
23     if (res < 0)                                                                                                                       {'linevul': 24, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 23, 'vulberta_mlp': 4}
24         return res;                                                                                                                    {'linevul': 22, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 9, 'vulberta_mlp': 11}
25     if (size >= st->codecpar->block_align)                                                                                             {'linevul': 8, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 4, 'vulberta_cnn': 6, 'vulberta_mlp': 18}
26         pkt->flags &= ~AV_PKT_FLAG_CORRUPT;                                                                                            {'linevul': 2, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 6, 'vulberta_cnn': 2, 'vulberta_mlp': 5}
27     /* Only one stream in an AIFF file */                                                                                              {'linevul': 17, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 19, 'vulberta_cnn': -1, 'vulberta_mlp': -1}
28     pkt->stream_index = 0;                                                                                                             {'linevul': 18, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 10, 'vulberta_cnn': 5, 'vulberta_mlp': 20}
29     pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;                                                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 1, 'vulberta_cnn': 21, 'vulberta_mlp': 10}
30     return 0;                                                                                                                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 0, 'vulberta_mlp': 0}
-----------------------
Highlighted lines: 
0 static int aiff_read_packet(AVFormatContext *s,
4     AIFFInputContext *aiff = s->priv_data;
8     max_size = aiff->data_end - avio_tell(s->pb);
13     case AV_CODEC_ID_ADPCM_IMA_QT:
20         size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
22     res = av_get_packet(s->pb, pkt, size);
26         pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
--------------------------------------------------------------------------------------------------------------
Example ids:  25181 project:  FFmpeg commit id:  0409d333115e623b5ccdbb364d64ca2a52fd8467 Number of lines:  24
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,               {'linevul': 1, 'codebert': 0, 'PLBART': 0, 'devign': 4, 'regvd': 1, 'vulberta_cnn': 22, 'vulberta_mlp': 8}
2                                        int16_t *src2,                                                                          {'linevul': 3, 'codebert': 4, 'PLBART': 8, 'devign': 15, 'regvd': 14, 'vulberta_cnn': 16, 'vulberta_mlp': 14}
4                                        int height, int denom, int wx0, int wx1,                                                {'linevul': 2, 'codebert': 9, 'PLBART': 1, 'devign': 3, 'regvd': 16, 'vulberta_cnn': 14, 'vulberta_mlp': 17}
6                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)                                  {'linevul': 0, 'codebert': 8, 'PLBART': 3, 'devign': 1, 'regvd': 7, 'vulberta_cnn': 10, 'vulberta_mlp': 19}
8 {                                                                                                                              {'linevul': 16, 'codebert': 12, 'PLBART': 9, 'devign': -1, 'regvd': 21, 'vulberta_cnn': 11, 'vulberta_mlp': 13}
10     int x, y;                                                                                                                 {'linevul': 15, 'codebert': 11, 'PLBART': 7, 'devign': 18, 'regvd': 20, 'vulberta_cnn': 4, 'vulberta_mlp': 21}
12     pixel *src = (pixel *)_src;                                                                                               {'linevul': 14, 'codebert': 3, 'PLBART': 5, 'devign': 12, 'regvd': 11, 'vulberta_cnn': 21, 'vulberta_mlp': 23}
14     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);                                                                        {'linevul': 8, 'codebert': 5, 'PLBART': 2, 'devign': 7, 'regvd': 5, 'vulberta_cnn': 1, 'vulberta_mlp': 15}
16     pixel *dst          = (pixel *)_dst;                                                                                      {'linevul': 5, 'codebert': 2, 'PLBART': 4, 'devign': 13, 'regvd': 9, 'vulberta_cnn': 2, 'vulberta_mlp': 20}
18     ptrdiff_t dststride = _dststride / sizeof(pixel);                                                                         {'linevul': 9, 'codebert': 6, 'PLBART': 6, 'devign': 8, 'regvd': 6, 'vulberta_cnn': 0, 'vulberta_mlp': 6}
20     const int8_t *filter = ff_hevc_epel_filters[mx - 1];                                                                      {'linevul': 4, 'codebert': 1, 'PLBART': -1, 'devign': 17, 'regvd': 4, 'vulberta_cnn': 19, 'vulberta_mlp': 11}
22     int shift = 14 + 1 - BIT_DEPTH;                                                                                           {'linevul': 13, 'codebert': 7, 'PLBART': -1, 'devign': 16, 'regvd': 10, 'vulberta_cnn': 8, 'vulberta_mlp': 16}
24     int log2Wd = denom + shift - 1;                                                                                           {'linevul': 11, 'codebert': 10, 'PLBART': -1, 'devign': 5, 'regvd': 12, 'vulberta_cnn': 7, 'vulberta_mlp': 9}
28     ox0     = ox0 * (1 << (BIT_DEPTH - 8));                                                                                   {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 2, 'vulberta_cnn': 6, 'vulberta_mlp': 2}
30     ox1     = ox1 * (1 << (BIT_DEPTH - 8));                                                                                   {'linevul': 6, 'codebert': -1, 'PLBART': -1, 'devign': 14, 'regvd': 3, 'vulberta_cnn': 15, 'vulberta_mlp': 0}
32     for (y = 0; y < height; y++) {                                                                                            {'linevul': 12, 'codebert': -1, 'PLBART': -1, 'devign': 0, 'regvd': 15, 'vulberta_cnn': 20, 'vulberta_mlp': 18}
34         for (x = 0; x < width; x++)                                                                                           {'linevul': 10, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 13, 'vulberta_cnn': 17, 'vulberta_mlp': 22}
36             dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +                          {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 0, 'vulberta_cnn': 18, 'vulberta_mlp': 4}
38                                     ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));                                            {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 8, 'vulberta_cnn': 5, 'vulberta_mlp': 5}
40         src  += srcstride;                                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 18, 'vulberta_cnn': 9, 'vulberta_mlp': 7}
42         dst  += dststride;                                                                                                    {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 9, 'regvd': 19, 'vulberta_cnn': 12, 'vulberta_mlp': 3}
44         src2 += MAX_PB_SIZE;                                                                                                  {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 17, 'vulberta_cnn': 3, 'vulberta_mlp': 10}
46     }                                                                                                                         {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 23, 'vulberta_cnn': 13, 'vulberta_mlp': 12}
48 }                                                                                                                             {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 22, 'vulberta_cnn': 23, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
4                                        int height, int denom, int wx0, int wx1,
6                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)
14     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
16     pixel *dst          = (pixel *)_dst;
18     ptrdiff_t dststride = _dststride / sizeof(pixel);
28     ox0     = ox0 * (1 << (BIT_DEPTH - 8));
--------------------------------------------------------------------------------------------------------------
Example ids:  27081 project:  FFmpeg commit id:  c23acbaed40101c677dfcfbbfe0d2c230a8e8f44 Number of lines:  29
Original lines: 
Predicted Correctly by :  ['linevul', 'codebert', 'PLBART', 'devign', 'regvd', 'vulberta_cnn', 'vulberta_mlp']
0 void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)               {'linevul': 1, 'codebert': 0, 'PLBART': 0, 'devign': 15, 'regvd': 8, 'vulberta_cnn': 21, 'vulberta_mlp': 8}
2 {                                                                                      {'linevul': 21, 'codebert': 6, 'PLBART': 11, 'devign': -1, 'regvd': 28, 'vulberta_cnn': 6, 'vulberta_mlp': 28}
4     int i;                                                                             {'linevul': 19, 'codebert': 13, 'PLBART': 10, 'devign': 22, 'regvd': 23, 'vulberta_cnn': 16, 'vulberta_mlp': 27}
6     INIT_CLIP                                                                          {'linevul': 18, 'codebert': 4, 'PLBART': 9, 'devign': -1, 'regvd': 24, 'vulberta_cnn': 12, 'vulberta_mlp': 15}
8     pixel *dst = (pixel*)_dst;                                                         {'linevul': 15, 'codebert': 1, 'PLBART': 5, 'devign': -1, 'regvd': 17, 'vulberta_cnn': 5, 'vulberta_mlp': 26}
10     dctcoef *block = (dctcoef*)_block;                                                {'linevul': 12, 'codebert': 2, 'PLBART': 4, 'devign': 17, 'regvd': 19, 'vulberta_cnn': 1, 'vulberta_mlp': 12}
12     stride /= sizeof(pixel);                                                          {'linevul': 17, 'codebert': 3, 'PLBART': 8, 'devign': 20, 'regvd': 18, 'vulberta_cnn': 17, 'vulberta_mlp': 0}
16     block[0] += 1 << 5;                                                               {'linevul': 16, 'codebert': 5, 'PLBART': 7, 'devign': 19, 'regvd': 22, 'vulberta_cnn': 14, 'vulberta_mlp': 25}
20     for(i=0; i<4; i++){                                                               {'linevul': 13, 'codebert': 12, 'PLBART': 6, 'devign': 1, 'regvd': 21, 'vulberta_cnn': 26, 'vulberta_mlp': 13}
22         const int z0=  block[i + 4*0]     +  block[i + 4*2];                          {'linevul': 5, 'codebert': 7, 'PLBART': 1, 'devign': 5, 'regvd': 12, 'vulberta_cnn': 18, 'vulberta_mlp': 23}
24         const int z1=  block[i + 4*0]     -  block[i + 4*2];                          {'linevul': 2, 'codebert': 11, 'PLBART': 3, 'devign': 7, 'regvd': 10, 'vulberta_cnn': 4, 'vulberta_mlp': 16}
26         const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];                          {'linevul': 6, 'codebert': 10, 'PLBART': 2, 'devign': 14, 'regvd': 4, 'vulberta_cnn': 3, 'vulberta_mlp': 18}
28         const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);                      {'linevul': 0, 'codebert': 9, 'PLBART': -1, 'devign': 12, 'regvd': 7, 'vulberta_cnn': 24, 'vulberta_mlp': 17}
32         block[i + 4*0]= z0 + z3;                                                      {'linevul': 8, 'codebert': 17, 'PLBART': -1, 'devign': 9, 'regvd': 14, 'vulberta_cnn': 19, 'vulberta_mlp': 20}
34         block[i + 4*1]= z1 + z2;                                                      {'linevul': 11, 'codebert': 16, 'PLBART': -1, 'devign': 21, 'regvd': 16, 'vulberta_cnn': 9, 'vulberta_mlp': 11}
36         block[i + 4*2]= z1 - z2;                                                      {'linevul': 10, 'codebert': 14, 'PLBART': -1, 'devign': 16, 'regvd': 15, 'vulberta_cnn': 10, 'vulberta_mlp': 10}
38         block[i + 4*3]= z0 - z3;                                                      {'linevul': 9, 'codebert': 15, 'PLBART': -1, 'devign': 3, 'regvd': 13, 'vulberta_cnn': 23, 'vulberta_mlp': 24}
40     }                                                                                 {'linevul': 20, 'codebert': 18, 'PLBART': -1, 'devign': -1, 'regvd': 27, 'vulberta_cnn': 13, 'vulberta_mlp': 5}
44     for(i=0; i<4; i++){                                                               {'linevul': 14, 'codebert': 8, 'PLBART': -1, 'devign': 0, 'regvd': 20, 'vulberta_cnn': 7, 'vulberta_mlp': 19}
46         const int z0=  block[0 + 4*i]     +  block[2 + 4*i];                          {'linevul': 3, 'codebert': -1, 'PLBART': -1, 'devign': 4, 'regvd': 11, 'vulberta_cnn': 15, 'vulberta_mlp': 9}
48         const int z1=  block[0 + 4*i]     -  block[2 + 4*i];                          {'linevul': 4, 'codebert': -1, 'PLBART': -1, 'devign': 6, 'regvd': 9, 'vulberta_cnn': 2, 'vulberta_mlp': 21}
50         const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];                          {'linevul': 7, 'codebert': -1, 'PLBART': -1, 'devign': 13, 'regvd': 3, 'vulberta_cnn': 11, 'vulberta_mlp': 22}
52         const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);                      {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 11, 'regvd': 6, 'vulberta_cnn': 22, 'vulberta_mlp': 14}
56         dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 8, 'regvd': 1, 'vulberta_cnn': 8, 'vulberta_mlp': 7}
58         dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 18, 'regvd': 5, 'vulberta_cnn': 27, 'vulberta_mlp': 4}
60         dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 10, 'regvd': 2, 'vulberta_cnn': 25, 'vulberta_mlp': 3}
62         dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));                {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': 2, 'regvd': 0, 'vulberta_cnn': 0, 'vulberta_mlp': 6}
64     }                                                                                 {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 26, 'vulberta_cnn': 20, 'vulberta_mlp': 2}
66 }                                                                                     {'linevul': -1, 'codebert': -1, 'PLBART': -1, 'devign': -1, 'regvd': 25, 'vulberta_cnn': 28, 'vulberta_mlp': 1}
-----------------------
Highlighted lines: 
0 void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)
22         const int z0=  block[i + 4*0]     +  block[i + 4*2];
24         const int z1=  block[i + 4*0]     -  block[i + 4*2];
26         const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];
48         const int z1=  block[0 + 4*i]     -  block[2 + 4*i];
56         dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));
62         dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));
--------------------------------------------------------------------------------------------------------------
53
