/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import { FormElement, HTMLElementWithRipple } from '@material/mwc-base/form-element.js';
import { MDCRadioAdapter } from '@material/radio/adapter.js';
import MDCRadioFoundation from '@material/radio/foundation.js';
/**
 * @fires checked
 */
export declare class RadioBase extends FormElement {
    protected mdcRoot: HTMLElement;
    protected formElement: HTMLInputElement;
    protected rippleElement: HTMLElementWithRipple;
    private _checked;
    global: boolean;
    get checked(): boolean;
    /**
     * We define our own getter/setter for `checked` because we need to track
     * changes to it synchronously.
     *
     * The order in which the `checked` property is set across radio buttons
     * within the same group is very important. However, we can't rely on
     * UpdatingElement's `updated` callback to observe these changes (which is
     * also what the `@observer` decorator uses), because it batches changes to
     * all properties.
     *
     * Consider:
     *
     *   radio1.disabled = true;
     *   radio2.checked = true;
     *   radio1.checked = true;
     *
     * In this case we'd first see all changes for radio1, and then for radio2,
     * and we couldn't tell that radio1 was the most recently checked.
     */
    set checked(checked: boolean);
    disabled: boolean;
    value: string;
    _handleUpdatedValue(newValue: string): void;
    name: string;
    protected mdcFoundationClass: typeof MDCRadioFoundation;
    protected mdcFoundation: MDCRadioFoundation;
    private _selectionController?;
    connectedCallback(): void;
    disconnectedCallback(): void;
    focusNative(): void;
    get ripple(): import("@material/mwc-base/utils").RippleInterface | undefined;
    protected createAdapter(): MDCRadioAdapter;
    private _changeHandler;
    private _focusHandler;
    private _clickHandler;
    protected render(): import("lit-element").TemplateResult;
    protected firstUpdated(): void;
}
declare class SelectionSet {
    selected: RadioBase | null;
    ordered: RadioBase[] | null;
    readonly set: Set<RadioBase>;
}
/**
 * Only one <input type="radio" name="group"> per group name can be checked at
 * once. However, the scope of "name" is the document/shadow root, so built-in
 * de-selection does not occur when two radio buttons are in different shadow
 * roots. This class bridges the checked state of radio buttons with the same
 * group name across different shadow roots.
 */
export declare class SelectionController {
    private sets;
    private focusedSet;
    private mouseIsDown;
    private updating;
    static getController(element: HTMLElement | HTMLElement & {
        global: boolean;
    }): SelectionController;
    constructor(element: Node);
    protected keyDownHandler(e: KeyboardEvent): void;
    protected mousedownHandler(): void;
    protected mouseupHandler(): void;
    has(element: RadioBase): boolean;
    previous(element: RadioBase): void;
    next(element: RadioBase): void;
    select(element: RadioBase): void;
    /**
     * Helps to track the focused selection group and if it changes, focuses
     * the selected item in the group. This matches native radio button behavior.
     */
    focus(element: RadioBase): void;
    getOrdered(element: RadioBase): RadioBase[];
    getSet(name: string): SelectionSet;
    register(element: RadioBase): void;
    unregister(element: RadioBase): void;
    update(element: RadioBase): void;
}
export {};
