INFO:source.sentence_prediction:[input] dictionary: 50005 types
INFO:source.sentence_prediction:[label] dictionary: 12 types
INFO:fairseq.models.bart.model:Registering classification head: sentence_classification_head
INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ get _ wav _ header ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Codec Context ▁* codec , ▁int ▁size , ▁int ▁big _ endian ) ▁{ ▁int ▁id ; ▁uint 64_ t ▁bitrate ; ▁if ▁( size ▁< ▁14 ) ▁{ ▁av priv _ request _ sample ( codec , ▁" wav ▁header ▁size ▁< ▁14 "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁codec -> codec _ type ▁= ▁AV MEDIA _ TYPE _ AU DIO ; ▁if ▁(! big _ endian ) ▁{ ▁id ▁= ▁av io _ rl 16 ( pb ); ▁if ▁( id ▁!= ▁0 x 01 65 ) ▁{ ▁codec -> channels ▁= ▁av io _ rl 16 ( pb ); ▁codec ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁xen _9 p fs _ connect ( struct ▁X en Device ▁* x end ev ) ▁{ ▁int ▁i ; ▁X en 9 p fs Dev ▁* x en _9 pd ev ▁= ▁container _ of ( x end ev , ▁X en 9 p fs Dev , ▁x end ev ); ▁V 9 fs State ▁* s ▁= ▁& x en _9 pd ev -> state ; ▁Q emu Opts ▁* fs dev ; ▁if ▁( x en store _ read _ fe _ int ( & x en _9 pd ev -> x end ev , ▁" num - r ings ", ▁& x en _9 pd ev -> num _ r ings ) ▁== ▁-1 ▁|| ▁xen _9 pd ev -> num _ r ings ▁> ▁MAX _ RING S ▁|| ▁xen _9 pd ev -> num _ r ings ▁< ▁1) ▁{ ▁return ▁-1; ▁} ▁xen _9 pd e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sub frame _ count _ exact ( F la c Encode Context ▁* s , ▁F la c Sub frame ▁* sub , ▁int ▁pred _ order ) ▁{ ▁int ▁p , ▁p order , ▁p size ; ▁int ▁i , ▁part _ end ; ▁int ▁count ▁= ▁0; ▁/* ▁sub frame ▁header ▁*/ ▁count ▁+= ▁8 ; ▁/* ▁sub frame ▁*/ ▁if ▁( sub -> type ▁== ▁F LA C _ SUB FRAME _ CONST ANT ) ▁{ ▁count ▁+= ▁sub -> ob its ; ▁} ▁else ▁if ▁( sub -> type ▁== ▁F LA C _ SUB FRAME _ VER B AT IM ) ▁{ ▁count ▁+= ▁s -> frame . block size ▁* ▁sub -> ob its ; ▁} ▁else ▁{ ▁/* ▁warm - up ▁samples ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ sp ap r _ init ( Q EM UM achine Init Args ▁* args ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁args -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁args -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁args -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁args -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁args -> init rd _ filename ; ▁const ▁char ▁* boot _ device ▁= ▁args -> boot _ order ; ▁Power PC CPU ▁* cpu ; ▁CP UP PC State ▁* env ; ▁P CI Host State ▁* ph 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg 1_ decode _ sequence ( AV Codec Context ▁* av ctx , ▁U INT 8 ▁* buf , ▁int ▁buf _ size ) ▁{ ▁M peg 1 Context ▁* s 1 ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& s 1 -> mpeg _ enc _ ctx ; ▁int ▁width , ▁height , ▁i , ▁v , ▁j ; ▁float ▁aspect ; ▁init _ get _ bits ( & s -> gb , ▁buf , ▁buf _ size ); ▁width ▁= ▁get _ bits ( & s -> gb , ▁12 ); ▁height ▁= ▁get _ bits ( & s -> gb , ▁12 ); ▁s -> aspect _ ratio _ info = ▁get _ bits ( & s -> gb , ▁4 ); ▁if (! s -> mpeg 2 ){ ▁aspect 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁d rc _ set _ un usable ( s P AP R DR Connector ▁* d rc ) ▁{ ▁d rc -> allocation _ state ▁= ▁SP AP R _ DR _ AL LOCATION _ STATE _ UN US ABLE ; ▁if ▁( d rc -> await ing _ release ) ▁{ ▁uint 32_ t ▁d rc _ index ▁= ▁sp ap r _ d rc _ index ( d rc ); ▁trace _ sp ap r _ d rc _ set _ allocation _ state _ final izing ( d rc _ index ); ▁sp ap r _ d rc _ detach ( d rc ); ▁} ▁return ▁RT AS _ OUT _ SUCCESS ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ read _ request ( SC S ID isk Req ▁* r ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁r -> req . dev ); ▁uint 32_ t ▁n ; ▁if ▁( r -> sect or _ count ▁== ▁( uint 32_ t ) -1) ▁{ ▁D PRI NT F (" Read ▁buf _ len =% z d \ n ", ▁r -> io v . io v _ len ); ▁r -> sect or _ count ▁= ▁0; ▁sc si _ req _ data ( & r -> req , ▁r -> io v . io v _ len ); ▁return ; ▁} ▁D PRI NT F (" Read ▁sector _ count =% d \ n ", ▁r -> sect or _ count ); ▁if ▁( r -> sect or _ count ▁== 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁lm 32_ ev r _ init ( Machine State ▁* machine ) ▁{ ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁L M 32 CPU ▁* cpu ; ▁CP UL M 32 State ▁* env ; ▁Drive Info ▁* d info ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ph ys _ ram ▁= ▁g _ new ( Memory Region , ▁1); ▁qemu _ irq ▁irq [ 32 ]; ▁Reset Info ▁* reset _ info ; ▁int ▁i ; ▁/* ▁memory ▁map ▁*/ ▁hw addr ▁flash _ base ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁aio _ write _ f ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁char ▁* p ; ▁int ▁count ▁= ▁0; ▁int ▁nr _ io v , ▁i , ▁c ; ▁int ▁pattern ▁= ▁0 x cd ; ▁struct ▁aio _ ctx ▁* ctx ▁= ▁cal loc (1, ▁sizeof ( struct ▁aio _ ctx )); ▁Block Driver A IO CB ▁* ac b ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" C q P : ")) ▁!= ▁EOF ) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' C ': ▁ctx -> C flag ▁= ▁1; ▁break ; ▁case ▁' q ': ▁ctx -> q flag ▁= ▁1; ▁break ; ▁case ▁' P ': ▁pattern ▁= ▁at oi ( opt arg ); ▁break ; ▁default : ▁return ▁command _ u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vc 1_ inv _ trans _8 x 8_ dc _ c ( uint 8_ t ▁* dest , ▁int ▁lines ize , ▁D CT E LE M ▁* block ) ▁{ ▁int ▁i ; ▁int ▁dc ▁= ▁block [0]; ▁const ▁uint 8_ t ▁* cm ; ▁dc ▁= ▁(3 ▁* ▁dc ▁+ ▁1) ▁>> ▁1; ▁dc ▁= ▁(3 ▁* ▁dc ▁+ ▁16 ) ▁>> ▁5; ▁cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ▁+ ▁dc ; ▁for ( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++){ ▁dest [0] ▁= ▁cm [ dest [0] ]; ▁dest [1] ▁= ▁cm [ dest [1] ]; ▁dest [2] ▁= ▁cm [ dest [2] ]; ▁dest [3] ▁= ▁cm [ dest [3] ]; ▁dest [4] ▁= ▁cm [ dest [4] ]; ▁dest [5] ▁= ▁cm [ dest

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ parse _ ext ents ( const ▁char ▁* desc , ▁Block Driver State ▁* bs , ▁const ▁char ▁* desc _ file _ path ) ▁{ ▁int ▁ret ; ▁char ▁access [ 11 ]; ▁char ▁type [ 11 ]; ▁char ▁fname [ 512 ]; ▁const ▁char ▁* p ▁= ▁desc ; ▁int 64_ t ▁sector s ▁= ▁0; ▁int 64_ t ▁flat _ offset ; ▁char ▁extent _ path [ PATH _ MAX ]; ▁Block Driver State ▁* extent _ file ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁while ▁(* p ) ▁{ ▁/* ▁parse ▁extent ▁line : ▁* ▁R W ▁[ size ▁in ▁sector s ] ▁FL AT ▁" file - name . v mdk " 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ rem atrix ing _ strategy ( AC 3 Encode Context ▁* s ) ▁{ ▁int ▁nb _ co efs ; ▁int ▁blk , ▁b nd , ▁i ; ▁AC 3 Block ▁* block , ▁* block 0; ▁s -> num _ rem atrix ing _ b ands ▁= ▁4; ▁if ▁( s -> rem atrix ing ▁& ▁AC 3_ RE M AT RI X ING _ IS _ STATIC ) ▁return ; ▁nb _ co efs ▁= ▁FF MIN ( s -> nb _ co efs [0], ▁s -> nb _ co efs [1]); ▁for ▁( blk ▁= ▁0; ▁blk ▁< ▁AC 3_ MAX _ BLOCK S ; ▁blk ++) ▁{ ▁block ▁= ▁& s -> blocks [ blk ]; ▁block -> new _ rem atrix ing _ strategy ▁= ▁! blk ; ▁for ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁OP PRO TO ▁op _ ud iv _ T 1_ T 0( void ) ▁{ ▁uint 64_ t ▁x 0; ▁uint 32_ t ▁x 1; ▁x 0 ▁= ▁T 0 ▁| ▁(( uint 64_ t ) ▁( env -> y ) ▁<< ▁32 ); ▁x 1 ▁= ▁T 1; ▁x 0 ▁= ▁x 0 ▁/ ▁x 1; ▁if ▁( x 0 ▁> ▁0 xffffffff ) ▁{ ▁T 0 ▁= ▁0 xffffffff ; ▁T 1 ▁= ▁1; ▁} ▁else ▁{ ▁T 0 ▁= ▁x 0; ▁T 1 ▁= ▁0; ▁FOR CE _ RET ();

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ x 86_ init _ mm u ( CPU X 86 State ▁* env ) ▁{ ▁a 20 _ enabled ▁= ▁1; ▁a 20 _ mask ▁= ▁0 xffffffff ; ▁last _ pg _ state ▁= ▁-1; ▁cpu _ x 86_ update _ cr 0( env ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ cpu _ self ( void ▁* env ) ▁{ ▁return ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁net _ v host _ link _ down ( V host User State ▁* s , ▁bool ▁link _ down ) ▁{ ▁s -> nc . link _ down ▁= ▁link _ down ; ▁if ▁( s -> nc . peer ) ▁{ ▁s -> nc . peer -> link _ down ▁= ▁link _ down ; ▁} ▁if ▁( s -> nc . info -> link _ status _ changed ) ▁{ ▁s -> nc . info -> link _ status _ changed ( & s -> nc ); ▁} ▁if ▁( s -> nc . peer ▁&& ▁s -> nc . peer -> info -> link _ status _ changed ) ▁{ ▁s -> nc . peer -> info -> link _ status _ changed ( s -> nc . peer ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rv 34 _ decode _ mv ( RV 34 Dec Context ▁* r , ▁int ▁block _ type ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& r -> s ; ▁Get Bit Context ▁* gb ▁= ▁& s -> gb ; ▁int ▁i , ▁j , ▁k , ▁l ; ▁int ▁mv _ pos ▁= ▁s -> mb _ x ▁* ▁2 ▁+ ▁s -> mb _ y ▁* ▁2 ▁* ▁s -> b 8_ stride ; ▁int ▁next _ bt ; ▁mem set ( r -> dm v , ▁0, ▁sizeof ( r -> dm v )); ▁for ( i ▁= ▁0; ▁i ▁< ▁num _ m vs [ block _ type ]; ▁i ++){ ▁r -> dm v [ i ][0] ▁= ▁sv q 3_ get _ se _ g ol omb ( gb ); ▁r -> dm v [ i ][1] ▁= ▁sv q 3_ get _ se _ g ol omb

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mirror _ start _ job ( Block Driver State ▁* bs , ▁Block Driver State ▁* target , ▁const ▁char ▁* rep laces , ▁int 64_ t ▁speed , ▁uint 32_ t ▁granularity , ▁int 64_ t ▁buf _ size , ▁Block dev OnError ▁on _ source _ error , ▁Block dev OnError ▁on _ target _ error , ▁bool ▁un map , ▁Block Completion Func ▁* cb , ▁void ▁* op aque , ▁Error ▁** err p , ▁const ▁Block Job Driver ▁* driver , ▁bool ▁is _ none _ mode , ▁Block Driver State ▁* base ) ▁{ ▁M irror Block Job ▁* s ; ▁if ▁( gr anularity ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁START _ TEST ( q int _ get _ int _ test ) ▁{ ▁Q Int ▁* q i ; ▁const ▁int ▁value ▁= ▁123456 ; ▁q i ▁= ▁q int _ from _ int ( value ); ▁fail _ unless ( q int _ get _ int ( q i ) ▁== ▁value ); ▁Q DE CRE F ( q i ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ code _ table ( C LL C Context ▁* ctx , ▁Get Bit Context ▁* gb , ▁V LC ▁* vlc ) ▁{ ▁uint 8_ t ▁symbols [ 256 ]; ▁uint 8_ t ▁bits [ 256 ]; ▁uint 16_ t ▁codes [ 256 ]; ▁int ▁num _ l ens , ▁num _ codes , ▁num _ codes _ sum , ▁prefix ; ▁int ▁i , ▁j , ▁count ; ▁prefix ▁= ▁0; ▁count ▁= ▁0; ▁num _ codes _ sum ▁= ▁0; ▁num _ l ens ▁= ▁get _ bits ( gb , ▁5 ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁num _ l ens ; ▁i ++) ▁{ ▁num _ codes ▁= ▁get _ bits ( gb , ▁9 ); ▁num _ codes _ sum ▁+= ▁num _ codes ; ▁if ▁( num 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁c bs _ h 26 5_ read _ nal _ unit ( C oded Bit stream Context ▁* ctx , ▁Coded Bit stream Unit ▁* unit ) ▁{ ▁Bit stream Context ▁bc ; ▁int ▁err ; ▁err ▁= ▁bit stream _ init ( & bc , ▁unit -> data , ▁8 ▁* ▁unit -> data _ size ); ▁if ▁( err ▁< ▁0) ▁return ▁err ; ▁switch ▁( unit -> type ) ▁{ ▁case ▁HE VC _ NAL _ V PS : ▁{ ▁H 265 Raw V PS ▁* v ps ; ▁v ps ▁= ▁av _ m alloc z ( size of (* v ps )); ▁if ▁(! v ps ) ▁return ▁A VER ROR ( EN O ME M ); ▁err ▁= ▁c bs _ h 26 5_ read _ v ps ( ctx , ▁& bc , ▁v 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q pa _ audio _ f ini ▁( void ▁* op aque ) ▁{ ▁( void ) ▁opaque ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb re dir _ bulk _ packet ( void ▁* priv , ▁uint 32_ t ▁id , ▁struct ▁usb _ re dir _ bulk _ packet _ header ▁* bulk _ packet , ▁uint 8_ t ▁* data , ▁int ▁data _ len ) ▁{ ▁USB Red ir Device ▁* dev ▁= ▁priv ; ▁uint 8_ t ▁ep ▁= ▁bulk _ packet -> endpoint ; ▁int ▁len ▁= ▁bulk _ packet -> length ; ▁Async UR B ▁* aur b ; ▁D PRI NT F (" bulk - in ▁status ▁% d ▁ep ▁%02 X ▁len ▁% d ▁id ▁% u \ n ", ▁bulk _ packet -> status , ▁ep , ▁len , ▁id ); ▁a urb ▁= ▁async _ find ( dev , ▁id ); ▁if ▁(! aur b ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁h ev c _ init _ context ( AV Codec Context ▁* av ctx ) ▁{ ▁HE VC Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁s -> av ctx ▁= ▁av ctx ; ▁s -> HE V Cl c ▁= ▁av _ m alloc z ( size of ( HE VC Local Context )); ▁if ▁(! s -> HE V Cl c ) ▁goto ▁fail ; ▁s -> HE V Cl c List [0] ▁= ▁s -> HE V Cl c ; ▁s -> sList [0] ▁= ▁s ; ▁s -> c ab ac _ state ▁= ▁av _ m alloc ( HE VC _ CONTEXT S ); ▁if ▁(! s -> c ab ac _ state ) ▁goto ▁fail ; ▁s -> output _ frame ▁= ▁av _ frame _ alloc (); ▁if ▁(!

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ pl te _ chunk ( AV Codec Context ▁* av ctx , ▁PNG Dec Context ▁* s , ▁uint 32_ t ▁length ) ▁{ ▁int ▁n , ▁i , ▁r , ▁g , ▁b ; ▁if ▁(( length ▁% ▁3) ▁!= ▁0 ▁|| ▁length ▁> ▁256 ▁* ▁3) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁/* ▁read ▁the ▁palette ▁*/ ▁n ▁= ▁length ▁/ ▁3; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁n ; ▁i ++) ▁{ ▁r ▁= ▁by test ream 2_ get _ byte ( & s -> gb ); ▁g ▁= ▁by test ream 2_ get _ byte ( & s -> gb ); ▁b ▁= ▁by test ream 2_ get _ byte ( & s -> gb ); ▁s -> palette [ i ] ▁= ▁(0 xFF U ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Mem Tx Result ▁v td _ mem _ ir _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁value , ▁unsigned ▁size , ▁Mem Tx Attrs ▁attrs ) ▁{ ▁int ▁ret ▁= ▁0; ▁M SI Message ▁from ▁= ▁{0 }, ▁to ▁= ▁{0 }; ▁from . address ▁= ▁( uint 64_ t ) ▁addr ▁+ ▁V TD _ INTER R UP T _ ADDR _ FIRST ; ▁from . data ▁= ▁( uint 32_ t ) ▁value ; ▁ret ▁= ▁v td _ interrupt _ re map _ m si ( op aque , ▁& from , ▁& to ); ▁if ▁( ret ) ▁{ ▁/* ▁TODO : ▁report ▁error ▁*/ ▁V TD _ DP RI NT F ( GENER AL , ▁" int ▁rem ap ▁fail ▁fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st _ flush _ trace _ buffer ( void ) ▁{ ▁if ▁( trace _ file _ enabled ) ▁{ ▁flush _ trace _ file (); ▁} ▁/* ▁Dis card ▁written ▁trace ▁records ▁*/ ▁trace _ idx ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁V irt IO Device ▁* virt io _ blk _ init ( Device State ▁* dev , ▁Block Conf ▁* conf , ▁char ▁** serial ) ▁{ ▁V irt IO Block ▁* s ; ▁int ▁cy l ind ers , ▁heads , ▁secs ; ▁static ▁int ▁virt io _ blk _ id ; ▁Drive Info ▁* d info ; ▁if ▁(! conf -> bs ) ▁{ ▁error _ report (" virt io - blk - pc i : ▁drive ▁property ▁not ▁set "); ▁return ▁NULL ; ▁} ▁if ▁(! b dr v _ is _ insert ed ( conf -> bs )) ▁{ ▁error _ report (" Device ▁needs ▁media , ▁but ▁drive ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁(! * serial ) ▁{ ▁/* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁size _ t ▁header _ ext _ add ( char ▁* buf , ▁uint 32_ t ▁magic , ▁const ▁void ▁* s , ▁size _ t ▁len , ▁size _ t ▁buf len ) ▁{ ▁Q C ow Extension ▁* ext _ back ing _ fmt ▁= ▁( Q C ow Extension *) ▁buf ; ▁size _ t ▁ext _ len ▁= ▁sizeof ( Q C ow Extension ) ▁+ ▁(( len ▁+ ▁7) ▁& ▁~ 7 ); ▁if ▁( buf len ▁< ▁ext _ len ) ▁{ ▁return ▁- EN OS PC ; ▁} ▁* ext _ back ing _ fmt ▁= ▁( Q C ow Extension ) ▁{ ▁. magic ▁= ▁cpu _ to _ be 32 ( magic ), ▁. len ▁= ▁cpu _ to _ be 32 ( len ), ▁}; ▁mem c py ( buf ▁+ ▁size

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ str f ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁AV Stream ▁* st ; ▁if ▁( c -> fc -> nb _ streams ▁< ▁1) ▁return ▁0; ▁if ▁( atom . size ▁<= ▁40 ) ▁return ▁0; ▁st ▁= ▁c -> fc -> streams [ c -> fc -> nb _ streams -1 ]; ▁if ▁(( uint 64_ t ) atom . size ▁> ▁(1 << 30 )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁av _ free ( st -> codec -> ex tr ad ata ); ▁st -> codec -> ex tr ad ata ▁= ▁av _ m alloc z ( atom . size ▁- ▁40 ▁+ ▁FF _ INPUT _ BUFFER _ P ADDING _ SIZ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mem _ begin ( Memory Listener ▁* listener ) ▁{ ▁Address Space Dispatch ▁* d ▁= ▁container _ of ( listener , ▁Address Space Dispatch , ▁listener ); ▁d -> ph ys _ map . ptr ▁= ▁PH Y S _ MAP _ NODE _ N IL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁tight _ palette _ buf 2 rgb ( int ▁b pp , ▁const ▁uint 8_ t ▁* buf ) ▁{ ▁uint 32_ t ▁rgb ▁= ▁0; ▁if ▁( b pp ▁== ▁3 2) ▁{ ▁rgb ▁|= ▁(( buf [0] ▁& ▁~ 1) ▁| ▁! (( buf [4] ▁>> ▁3) ▁& ▁1)) ▁<< ▁24 ; ▁rgb ▁|= ▁(( buf [1] ▁& ▁~ 1) ▁| ▁! (( buf [4] ▁>> ▁2) ▁& ▁1)) ▁<< ▁16 ; ▁rgb ▁|= ▁(( buf [2] ▁& ▁~ 1) ▁| ▁! (( buf [4] ▁>> ▁1) ▁& ▁1)) ▁<< ▁8 ; ▁rgb ▁|= ▁(( buf [3] ▁& ▁~ 1) ▁| ▁! (( buf [4] ▁>> ▁0) ▁& ▁1)) ▁<< ▁0; ▁} ▁if ▁( b pp ▁== ▁16 ) ▁{ ▁rgb ▁|= ▁(( buf [0] ▁& ▁~ 1) ▁| ▁! (( buf [2] ▁>> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁net _ init _ tap ( const ▁Net dev ▁* net dev , ▁const ▁char ▁* name , ▁Net Client State ▁* peer , ▁Error ▁** err p ) ▁{ ▁const ▁Net dev Tap Options ▁* tap ; ▁int ▁fd , ▁v net _ hdr ▁= ▁0, ▁i ▁= ▁0, ▁queues ; ▁/* ▁for ▁the ▁no - fd , ▁no - helper ▁case ▁*/ ▁const ▁char ▁* script ▁= ▁NULL ; ▁/* ▁suppress ▁wrong ▁" un init ' d ▁use " ▁gcc ▁warning ▁*/ ▁const ▁char ▁* down script ▁= ▁NULL ; ▁Error ▁* err ▁= ▁NULL ; ▁const ▁char ▁* v host fd name ; ▁char ▁if name [ 128 ]; ▁assert ( net dev -> type ▁== ▁N

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁stream _ start ( const ▁char ▁* job _ id , ▁Block Driver State ▁* bs , ▁Block Driver State ▁* base , ▁const ▁char ▁* back ing _ file _ str , ▁int 64_ t ▁speed , ▁Block dev OnError ▁on _ error , ▁Block Completion Func ▁* cb , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁Stream Block Job ▁* s ; ▁s ▁= ▁block _ job _ create ( job _ id , ▁& stream _ job _ driver , ▁bs , ▁speed , ▁cb , ▁opaque , ▁err p ); ▁if ▁(! s ) ▁{ ▁return ; ▁} ▁s -> base ▁= ▁base ; ▁s -> back ing _ file _ str ▁= ▁g _ str dup ( back in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁attribute _ align _ arg ▁av codec _ decode _ video 2( AV Codec Context ▁* av ctx , ▁AV Frame ▁* picture , ▁int ▁* got _ picture _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁int ▁ret ; ▁* got _ picture _ ptr ▁= ▁0; ▁if ▁(( av ctx -> coded _ width ▁|| ▁av ctx -> coded _ height ) ▁&& ▁av _ image _ check _ size ( av ctx -> coded _ width , ▁av ctx -> coded _ height , ▁0, ▁av ctx )) ▁return ▁-1; ▁av ctx -> pk t ▁= ▁av pk t ; ▁apply _ param _ change ( av ctx , ▁av pk t ); ▁if ▁(( av ctx -> codec -> capabilities ▁& 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁o map _ gp io _ init ( Sys Bus Device ▁* s bd ) ▁{ ▁Device State ▁* dev ▁= ▁DEVICE ( s bd ); ▁struct ▁o map _ gp if _ s ▁* s ▁= ▁O MAP 1_ G PIO ( dev ); ▁if ▁(! s -> cl k ) ▁{ ▁hw _ error (" om ap - gp io : ▁cl k ▁not ▁connected \ n "); ▁} ▁q dev _ init _ gp io _ in ( dev , ▁o map _ gp io _ set , ▁16 ); ▁q dev _ init _ gp io _ out ( dev , ▁s -> om ap 1. handler , ▁16 ); ▁sys bus _ init _ irq ( s bd , ▁& s -> om ap 1. irq ); ▁memory _ region _ init _ io ( & s -> iom em , ▁OBJECT ( s ), ▁& om 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁o map _ m cb sp _ i 2 s _ attach ( struct ▁o map _ m cb sp _ s ▁* s , ▁I 2 S Codec ▁* slave ) ▁{ ▁s -> codec ▁= ▁slave ; ▁slave -> rx _ sw allow ▁= ▁qemu _ allocate _ ir qs ( om ap _ m cb sp _ i 2 s _ sw allow , ▁s , ▁1) [0]; ▁slave -> tx _ start ▁= ▁qemu _ allocate _ ir qs ( om ap _ m cb sp _ i 2 s _ start , ▁s , ▁1) [0]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁float x 80 _ eq ( float x 80 ▁a , ▁float x 80 ▁b , ▁float _ status ▁* status ) ▁{ ▁if ▁( ▁( ▁( ▁extract Float x 80 Exp ( ▁a ▁) ▁== ▁0 x 7 FFF ▁) ▁&& ▁( uint 64_ t ) ▁( ▁extract Float x 80 F rac ( ▁a ▁) << 1 ▁) ▁) ▁|| ▁( ▁( ▁extract Float x 80 Exp ( ▁b ▁) ▁== ▁0 x 7 FFF ▁) ▁&& ▁( uint 64_ t ) ▁( ▁extract Float x 80 F rac ( ▁b ▁) << 1 ▁) ▁) ▁) ▁{ ▁float _ raise ( float _ flag _ invalid , ▁status ); ▁return ▁0; ▁} ▁return ▁( ▁a . low ▁== ▁b . low ▁) ▁&& ▁( ▁( ▁a . high ▁== ▁b . high ▁) ▁|| ▁( ▁( ▁a . l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁json _ lexer _ init ( JSON Lexer ▁* lexer , ▁JSON Lexer Emitter ▁func ) ▁{ ▁lexer -> emit ▁= ▁func ; ▁lexer -> state ▁= ▁IN _ START ; ▁lexer -> token ▁= ▁q string _ new (); ▁lexer -> x ▁= ▁lexer -> y ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Driver A IO CB ▁* pa io _ submit ( Block Driver State ▁* bs , ▁int ▁fd , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque , ▁int ▁type ) ▁{ ▁struct ▁qemu _ pa i oc b ▁* ac b ; ▁ac b ▁= ▁qemu _ a io _ get ( & raw _ a io _ pool , ▁bs , ▁cb , ▁opaque ); ▁if ▁(! ac b ) ▁return ▁NULL ; ▁ac b -> a io _ type ▁= ▁type ; ▁ac b -> a io _ f ild es ▁= ▁fd ; ▁ac b -> ev _ sign o ▁= ▁SIG USR 2; ▁ac b -> async _ context _ id ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁crypto _ open ( URL Context ▁* h , ▁const ▁char ▁* uri , ▁int ▁flags ) ▁{ ▁const ▁char ▁* nested _ url ; ▁int ▁ret ; ▁Crypto Context ▁* c ▁= ▁h -> priv _ data ; ▁if ▁(! av _ str start ( uri , ▁" crypto + ", ▁& nested _ url ) ▁&& ▁! av _ str start ( uri , ▁" crypto :", ▁& nested _ url )) ▁{ ▁av _ log ( h , ▁AV _ LOG _ ERROR , ▁" Unsupported ▁url ▁% s \ n ", ▁uri ); ▁ret ▁= ▁A VER ROR ( E IN VAL ); ▁goto ▁err ; ▁} ▁if ▁( c -> key len ▁< ▁BLOCKSIZE ▁|| ▁c -> iv len ▁< ▁BLOCKSIZE ) ▁{ ▁av _ log 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ alloc _ entries ( AV Codec Context ▁* av ctx , ▁int ▁count ) ▁{ ▁int ▁i ; ▁if ▁( av ctx -> active _ thread _ type ▁& ▁FF _ THREAD _ S LI CE ) ▁{ ▁Slice Thread Context ▁* p ▁= ▁av ctx -> internal -> thread _ ctx ; ▁p -> thread _ count ▁= ▁av ctx -> thread _ count ; ▁p -> entries ▁= ▁av _ m alloc z _ array ( count , ▁sizeof ( int )); ▁if ▁(! p -> entries ) ▁{ ▁return ▁A VER ROR ( EN O ME M ); ▁} ▁p -> entries _ count ▁= ▁count ; ▁p -> progress _ mut ex ▁= ▁av _ m alloc _ array ( p -> thread _ cou

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁flo ppy _ pro be _ device ( const ▁char ▁* filename ) ▁{ ▁int ▁fd , ▁ret ; ▁int ▁prio ▁= ▁0; ▁struct ▁flo ppy _ struct ▁fd param ; ▁struct ▁stat ▁st ; ▁if ▁( str start ( filename , ▁"/ dev / fd ", ▁NULL ) ▁&& ▁! str start ( filename , ▁"/ dev / fd set /", ▁NULL )) ▁{ ▁prio ▁= ▁50 ; ▁} ▁fd ▁= ▁qemu _ open ( filename , ▁O _ RD ONLY ▁| ▁O _ NON BLOCK ); ▁if ▁( fd ▁< ▁0) ▁{ ▁goto ▁out ; ▁} ▁ret ▁= ▁f stat ( fd , ▁& st ); ▁if ▁( ret ▁== ▁-1 ▁|| ▁! S _ IS BL K ( st . st _ mode )) ▁{ ▁goto ▁out c ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sun 4 uv _ init ( ram _ addr _ t ▁RAM _ size , ▁const ▁char ▁* boot _ devices , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model , ▁const ▁struct ▁hw def ▁* hw def ) ▁{ ▁CPU State ▁* env ; ▁char ▁* filename ; ▁m 48 t 59 _ t ▁* nv ram ; ▁int ▁ret , ▁linux _ boot ; ▁unsigned ▁int ▁i ; ▁ram _ addr _ t ▁ram _ offset , ▁prom _ offset ; ▁long ▁init rd _ size , ▁kernel _ size ; ▁P CI Bus ▁* pc i _ bus , ▁* pc i 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁f pu _ init ▁( CP UM IP S State ▁* env , ▁const ▁m ips _ def _ t ▁* def ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁M IP S _ F PU _ MAX ; ▁i ++) ▁env -> fp us [ i ]. f cr 0 ▁= ▁def -> CP 1_ f cr 0; ▁mem c py ( & env -> active _ f pu , ▁& env -> fp us [0], ▁sizeof ( env -> active _ f pu )); ▁if ▁( env -> user _ mode _ only ) ▁{ ▁if ▁( env -> CP 0_ Config 1 ▁& ▁(1 ▁<< ▁CP 0 C 1_ FP )) ▁env -> h flags ▁|= ▁M IP S _ H FLAG _ F PU ; ▁# if def ▁TARGET _ M IP S 64 ▁if ▁( env -> active _ f pu . f cr 0 ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁bf i _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data , ▁* buf _ end ▁= ▁av pk t -> data ▁+ ▁av pk t -> size ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁B FI Context ▁* bf i ▁= ▁av ctx -> priv _ data ; ▁uint 8_ t ▁* dst ▁= ▁bf i -> dst ; ▁uint 8_ t ▁* src , ▁* dst _ offset , ▁colour 1, ▁colour 2; ▁uint 8_ t ▁* frame _ end ▁= ▁bf i -> dst ▁+ ▁av ctx -> width ▁* ▁av ctx -> height ; ▁uint 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Device State ▁* q dev _ device _ add ( Q emu Opts ▁* opts ) ▁{ ▁Object Class ▁* oc ; ▁Device Class ▁* dc ; ▁const ▁char ▁* driver , ▁* path , ▁* id ; ▁Device State ▁* dev ; ▁Bus State ▁* bus ▁= ▁NULL ; ▁Error ▁* err ▁= ▁NULL ; ▁driver ▁= ▁qemu _ opt _ get ( opts , ▁" driver "); ▁if ▁(! driver ) ▁{ ▁q error _ report ( Q ERR _ MISS ING _ PARAMETER , ▁" driver "); ▁return ▁NULL ; ▁} ▁/* ▁find ▁driver ▁*/ ▁oc ▁= ▁object _ class _ by _ name ( driver ); ▁if ▁(! oc ) ▁{ ▁const ▁char ▁* typ ename ▁= ▁find _ typ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁thread _ pool _ submit ( ThreadPool Func ▁* func , ▁void ▁* arg ) ▁{ ▁thread _ pool _ submit _ a io ( func , ▁arg , ▁NULL , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pl 06 1_ register _ devices ( void ) ▁{ ▁sys bus _ register _ dev (" pl 06 1", ▁sizeof ( pl 06 1_ state ), ▁pl 06 1_ init _ arm ); ▁sys bus _ register _ dev (" pl 06 1_ l um inary ", ▁sizeof ( pl 06 1_ state ), ▁pl 06 1_ init _ l um inary ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ exec ( CPU State ▁* cpu ) ▁{ ▁CPU Class ▁* cc ▁= ▁CPU _ GET _ CLASS ( cpu ); ▁int ▁ret ; ▁Sync Clock s ▁sc ; ▁/* ▁replay _ interrupt ▁may ▁need ▁current _ cpu ▁*/ ▁current _ cpu ▁= ▁cpu ; ▁if ▁( cpu _ handle _ h alt ( cpu )) ▁{ ▁return ▁EX CP _ H AL TED ; ▁} ▁rc u _ read _ lock (); ▁cc -> cpu _ exec _ enter ( cpu ); ▁/* ▁Calculate ▁difference ▁between ▁guest ▁clock ▁and ▁host ▁clock . ▁* ▁This ▁delay ▁includes ▁the ▁delay ▁of ▁the ▁last ▁cycle , ▁so ▁* ▁what ▁we ▁have ▁to ▁do ▁is ▁sleep ▁until

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁copy _ ir b _ to _ guest ( IR B ▁* dest , ▁const ▁IR B ▁* src , ▁PM C W ▁* pm cw ) ▁{ ▁int ▁i ; ▁uint 16_ t ▁st ctl ▁= ▁src -> sc sw . ctrl ▁& ▁S CS W _ CT RL _ MASK _ ST CT L ; ▁uint 16_ t ▁act l ▁= ▁src -> sc sw . ctrl ▁& ▁S CS W _ CT RL _ MASK _ ACT L ; ▁copy _ sc sw _ to _ guest ( & dest -> sc sw , ▁& src -> sc sw ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( dest -> es w ); ▁i ++) ▁{ ▁dest -> es w [ i ] ▁= ▁cpu _ to _ be 32 ( src -> es w [ i ]); ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( de

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁process _ input _ packet ( InputStream ▁* ist , ▁const ▁AV Packet ▁* pk t ) ▁{ ▁int ▁i ; ▁int ▁got _ output ; ▁AV Packet ▁av pk t ; ▁if ▁( ist -> next _ d ts ▁== ▁AV _ NO PT S _ VALUE ) ▁ist -> next _ d ts ▁= ▁ist -> last _ d ts ; ▁if ▁( pk t ▁== ▁NULL ) ▁{ ▁/* ▁EOF ▁handling ▁*/ ▁av _ init _ packet ( & av pk t ); ▁av pk t . data ▁= ▁NULL ; ▁av pk t . size ▁= ▁0; ▁goto ▁handle _ eof ; ▁} ▁else ▁{ ▁av pk t ▁= ▁* pk t ; ▁} ▁if ▁( pk t -> d ts ▁!= ▁AV _ NO PT S _ VALUE ) ▁ist -> next _ d ts ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁target _ ulong ▁dis as _ ins n ( Dis as Context ▁* s , ▁CPU State ▁* cpu ) ▁{ ▁CPU X 86 State ▁* env ▁= ▁cpu -> env _ ptr ; ▁int ▁b , ▁prefixes ; ▁int ▁shift ; ▁TC G Mem Op ▁ot , ▁a flag , ▁df lag ; ▁int ▁mod rm , ▁reg , ▁rm , ▁mod , ▁op , ▁op reg , ▁val ; ▁target _ ulong ▁next _ e ip , ▁t val ; ▁int ▁rex _ w , ▁rex _ r ; ▁target _ ulong ▁pc _ start ▁= ▁s -> base . pc _ next ; ▁s -> pc _ start ▁= ▁s -> pc ▁= ▁pc _ start ; ▁prefixes ▁= ▁0; ▁s -> override ▁= ▁-1; ▁rex _ w ▁= ▁-1; ▁rex _ r ▁= ▁0; ▁#

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁iscsi _ open ( Block Driver State ▁* bs , ▁const ▁char ▁* filename , ▁int ▁flags ) ▁{ ▁I sc si L un ▁* is cs il un ▁= ▁bs -> op aque ; ▁struct ▁iscsi _ context ▁* isc si ▁= ▁NULL ; ▁struct ▁iscsi _ url ▁* isc si _ url ▁= ▁NULL ; ▁struct ▁I sc si Task ▁task ; ▁char ▁* init iator _ name ▁= ▁NULL ; ▁int ▁ret ; ▁if ▁(( B DR V _ SE CTOR _ SIZE ▁% ▁512 ) ▁!= ▁0) ▁{ ▁error _ report (" i SC SI : ▁Invalid ▁B DR V _ SE CTOR _ SIZE . ▁" ▁" B DR V _ SE CTOR _ SIZE ( % l ld ) ▁is ▁not ▁a ▁multiple ▁" ▁" 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm x net 3_ rx _ need _ c sum _ calculate ( struct ▁V mx net Rx P kt ▁* pk t , ▁const ▁void ▁* pk t _ data , ▁size _ t ▁pkt _ len ) ▁{ ▁struct ▁virt io _ net _ hdr ▁* vh dr ; ▁bool ▁is ip 4, ▁is ip 6, ▁ist cp , ▁is ud p ; ▁uint 8_ t ▁* data ; ▁int ▁len ; ▁if ▁(! vm x net _ rx _ pk t _ has _ virt _ hdr ( pk t )) ▁{ ▁return ; ▁} ▁v hdr ▁= ▁vm x net _ rx _ pk t _ get _ vh dr ( pk t ); ▁if ▁(! VM X NET _ FLAG _ IS _ SET ( vh dr -> flags , ▁VI RT IO _ NET _ H DR _ F _ NE ED S _ CS UM )) ▁{ ▁retu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Command InfoList ▁* q mp _ query _ commands ( Error ▁** err p ) ▁{ ▁Command InfoList ▁* list ▁= ▁NULL ; ▁q mp _ for _ each _ command ( & q mp _ commands , ▁query _ commands _ cb , ▁& list ); ▁return ▁list ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ blocks ( AL S Dec Context ▁* ctx , ▁unsigned ▁int ▁ra _ frame , ▁unsigned ▁int ▁c , ▁const ▁unsigned ▁int ▁* div _ blocks , ▁unsigned ▁int ▁* js _ blocks ) ▁{ ▁AL SS pec ific Config ▁* s conf ▁= ▁& ctx -> s conf ; ▁unsigned ▁int ▁offset ▁= ▁0; ▁unsigned ▁int ▁b ; ▁A LS Block Data ▁bd [2] ▁= ▁{ ▁{ ▁0 ▁} ▁}; ▁bd [0]. ra _ block ▁= ▁ra _ frame ; ▁bd [0]. const _ block ▁= ▁ctx -> const _ block ; ▁bd [0]. shift _ ls bs ▁= ▁ctx -> shift _ ls bs ; ▁bd [0]. opt _ order ▁= ▁ctx -> opt _ orde

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ f ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁struct ▁time val ▁t 1, ▁t 2; ▁int ▁C flag ▁= ▁0, ▁p flag ▁= ▁0, ▁q flag ▁= ▁0, ▁b flag ▁= ▁0; ▁int ▁c , ▁cnt ; ▁char ▁* buf ; ▁int 64_ t ▁offset ; ▁int ▁count ; ▁/* ▁Some ▁compilers ▁get ▁confused ▁and ▁warn ▁if ▁this ▁is ▁not ▁initialized . ▁*/ ▁int ▁total ▁= ▁0; ▁int ▁pattern ▁= ▁0 x cd ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" b Cp P : q ")) ▁!= ▁EOF ) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' b ': ▁b flag ▁= ▁1; ▁break ; ▁case ▁' C ': ▁C flag ▁= ▁1;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lib open jpeg _ copy _ packed 12 ( AV Codec Context ▁* av ctx , ▁const ▁AV Frame ▁* frame , ▁op j _ image _ t ▁* image ) ▁{ ▁int ▁comp no ; ▁int ▁x , ▁y ; ▁int ▁* image _ line ; ▁int ▁frame _ index ; ▁const ▁int ▁num com ps ▁= ▁image -> num com ps ; ▁uint 16_ t ▁* frame _ ptr ▁= ▁( uint 16_ t ▁* ) frame -> data [0]; ▁for ▁( comp no ▁= ▁0; ▁comp no ▁< ▁num com ps ; ▁++ comp no ) ▁{ ▁if ▁( image -> com ps [ comp no ]. w ▁> ▁frame -> lines ize [0] ▁/ ▁num com ps ) ▁{ ▁av _ log ( av ctx , ▁AV _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁build _ feed _ streams ( void ) ▁{ ▁FF Stream ▁* stream , ▁* feed ; ▁int ▁i ; ▁/* ▁gather ▁all ▁streams ▁*/ ▁for ( stream ▁= ▁first _ stream ; ▁stream ▁!= ▁NULL ; ▁stream ▁= ▁stream -> next ) ▁{ ▁feed ▁= ▁stream -> feed ; ▁if ▁( feed ) ▁{ ▁if ▁(! stream -> is _ feed ) ▁{ ▁/* ▁we ▁handle ▁a ▁stream ▁coming ▁from ▁a ▁feed ▁*/ ▁for ( i =0; i < stream -> nb _ streams ; i ++) ▁stream -> feed _ streams [ i ] ▁= ▁add _ av _ stream ( feed , ▁stream -> streams [ i ]); ▁} ▁} ▁} ▁/* ▁gather ▁all ▁stre

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ interrupt 64 ( CPU X 86 State ▁* env , ▁int ▁int no , ▁int ▁is _ int , ▁int ▁error _ code , ▁target _ ulong ▁next _ e ip , ▁int ▁is _ hw ) ▁{ ▁Segment Cache ▁* dt ; ▁target _ ulong ▁ptr ; ▁int ▁type , ▁d pl , ▁selector , ▁c pl , ▁ist ; ▁int ▁has _ error _ code , ▁new _ stack ; ▁uint 32_ t ▁e 1, ▁e 2, ▁e 3, ▁ss ; ▁target _ ulong ▁old _ e ip , ▁es p , ▁offset ; ▁has _ error _ code ▁= ▁0; ▁if ▁(! is _ int ▁&& ▁! is _ hw ) ▁{ ▁has _ error _ code ▁= ▁exception _ has _ error _ code ( int no 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁palette 8 to b gr 24 ( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁long ▁num _ pixels , ▁const ▁uint 8_ t ▁* palette ) ▁{ ▁long ▁i ; ▁/* ▁writes ▁1 ▁byte ▁o ▁much ▁and ▁might ▁cause ▁alignment ▁issues ▁on ▁some ▁architecture s ? ▁for ( i =0; ▁i < num _ pixels ; ▁i ++) ▁(( un signed ▁* )( & dst [ i * 3] )) ▁= ▁(( un signed ▁* ) palette )[ ▁src [ i ] ▁]; ▁*/ ▁for ( i =0; ▁i < num _ pixels ; ▁i ++) ▁{ ▁// FIX ME ▁slow ? ▁dst [0] = ▁palette [ ▁src [ i ]* 4 +0 ▁]; ▁dst [1] = ▁palette [ ▁src [ i ]* 4 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁code block ( D ira c Context ▁* s , ▁Sub Band ▁* b , ▁Get Bit Context ▁* gb , ▁D ira c Ar ith ▁* c , ▁int ▁left , ▁int ▁right , ▁int ▁top , ▁int ▁bottom , ▁int ▁block cnt _ one , ▁int ▁is _ ar ith ) ▁{ ▁int ▁x , ▁y , ▁zero _ block ; ▁int ▁q offset , ▁q factor ; ▁ID W TE LE M ▁* buf ; ▁/* ▁check ▁for ▁any ▁coded ▁coefficients ▁in ▁this ▁code block ▁*/ ▁if ▁(! block cnt _ one ) ▁{ ▁if ▁( is _ ar ith ) ▁zero _ block ▁= ▁di rac _ get _ ar ith _ bit ( c , ▁CT X _ ZERO _ BLOCK ); ▁else ▁z

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ frame ( AV Codec Context ▁* av ctx , ▁unsigned ▁char ▁* buf , ▁int ▁buf _ size , ▁void ▁* data ){ ▁FF V 1 Context ▁* f ▁= ▁av ctx -> priv _ data ; ▁C AB AC Context ▁* ▁const ▁c = ▁& f -> c ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁const ▁int ▁width = ▁f -> width ; ▁const ▁int ▁height = ▁f -> height ; ▁AV Frame ▁* ▁const ▁p = ▁& f -> picture ; ▁int ▁used _ count = ▁0; ▁if ( av ctx -> strict _ std _ compl iance ▁>= ▁0){ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" this ▁codec ▁is ▁under ▁develo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ PO WER _ mask g ▁( void ) ▁{ ▁uint 32_ t ▁ret ; ▁if ▁(( uint 32_ t ) T 0 ▁== ▁( uint 32_ t )( T 1 ▁+ ▁1)) ▁{ ▁ret ▁= ▁-1; ▁} ▁else ▁{ ▁ret ▁= ▁( (( uint 32_ t )( -1 )) ▁>> ▁(( uint 32_ t ) T 0 )) ▁^ ▁( (( uint 32_ t )( -1) ▁>> ▁(( uint 32_ t ) T 1)) ▁>> ▁1); ▁if ▁(( uint 32_ t ) T 0 ▁> ▁( uint 32_ t ) T 1) ▁ret ▁= ▁~ ret ; ▁} ▁T 0 ▁= ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q ed _ a io _ read _ data ( void ▁* op aque , ▁int ▁ret , ▁uint 64_ t ▁offset , ▁size _ t ▁len ) ▁{ ▁Q ED A IO CB ▁* ac b ▁= ▁opaque ; ▁B DR V Q ED State ▁* s ▁= ▁ac b _ to _ s ( ac b ); ▁Block Driver State ▁* bs ▁= ▁ac b -> common . bs ; ▁/* ▁Adjust ▁offset ▁into ▁cluster ▁*/ ▁offset ▁+= ▁q ed _ offset _ into _ cluster ( s , ▁ac b -> cur _ pos ); ▁trace _ q ed _ a io _ read _ data ( s , ▁ac b , ▁ret , ▁offset , ▁len ); ▁if ▁( ret ▁< ▁0) ▁{ ▁goto ▁err ; ▁} ▁qemu _ i ove c _ concat ( & ac b 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qc ow 2_ update _ header ( Block Driver State ▁* bs ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁Q C ow Header ▁* header ; ▁char ▁* buf ; ▁size _ t ▁buf len ▁= ▁s -> cluster _ size ; ▁int ▁ret ; ▁uint 64_ t ▁total _ size ; ▁uint 32_ t ▁ref count _ table _ clusters ; ▁size _ t ▁header _ length ; ▁Q c ow 2 Unknown Header Extension ▁* u ext ; ▁buf ▁= ▁qemu _ block align ( bs , ▁buf len ); ▁/* ▁Header ▁structure ▁*/ ▁header ▁= ▁( Q C ow Header *) ▁buf ; ▁if ▁( buf len ▁< ▁sizeof (* header )) ▁{ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tcp _ start _ incoming _ migration ( const ▁char ▁* host _ port , ▁Error ▁** err p ) ▁{ ▁int ▁s ; ▁s ▁= ▁inet _ listen ( host _ port , ▁NULL , ▁256 , ▁SOCK _ STREAM , ▁0, ▁err p ); ▁if ▁( s ▁< ▁0) ▁{ ▁return ; ▁} ▁qemu _ set _ fd _ handler 2( s , ▁NULL , ▁tcp _ accept _ incoming _ migration , ▁NULL , ▁( void ▁* )( int ptr _ t ) s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sp ap r _ populate _ pc i _ child _ dt ( PC ID evice ▁* dev , ▁void ▁* fd t , ▁int ▁offset , ▁s P AP R PH B State ▁* s ph b ) ▁{ ▁Resource Props ▁rp ; ▁bool ▁is _ bridge ▁= ▁false ; ▁int ▁pci _ status , ▁err ; ▁char ▁* buf ▁= ▁NULL ; ▁uint 32_ t ▁d rc _ index ▁= ▁sp ap r _ ph b _ get _ pc i _ d rc _ index ( s ph b , ▁dev ); ▁uint 32_ t ▁c code ▁= ▁pci _ default _ read _ config ( dev , ▁P CI _ CLASS _ PRO G , ▁3 ); ▁uint 32_ t ▁max _ m si , ▁max _ ms ix ; ▁if ▁( pc i _ default _ read _ config

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ major _ sync ( ML P Decode Context ▁* m , ▁Get Bit Context ▁* gb ) ▁{ ▁M LP Header Info ▁mh ; ▁int ▁substr , ▁ret ; ▁if ▁(( ret ▁= ▁ff _ ml p _ read _ major _ sync ( m -> av ctx , ▁& m h , ▁gb )) ▁!= ▁0) ▁return ▁ret ; ▁if ▁( m h . group 1_ bits ▁== ▁0) ▁{ ▁av _ log ( m -> av ctx , ▁AV _ LOG _ ERROR , ▁" invalid / unknown ▁bits ▁per ▁sample \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( m h . group 2_ bits ▁> ▁mh . group 1_ bits ) ▁{ ▁av _ log ( m -> av ctx , ▁AV _ LOG _ ERROR 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁AV Stream ▁* ▁init _ stream ( AV Format Context ▁* s ) ▁{ ▁Bin Dem ux Context ▁* bin ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st ▁= ▁av format _ new _ stream ( s , ▁NULL ); ▁if ▁(! st ) ▁return ▁NULL ; ▁st -> codec -> codec _ tag ▁= ▁0; ▁st -> codec -> codec _ type ▁= ▁AV MEDIA _ TYPE _ VI DEO ; ▁if ▁(! bin -> width ) ▁{ ▁st -> codec -> width ▁= ▁( 80 << 3); ▁st -> codec -> height ▁= ▁( 25 << 4 ); ▁} ▁av priv _ set _ pts _ info ( st , ▁60, ▁bin -> f ram erate . den , ▁bin -> f ram erate . num ); ▁/* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁coroutine _ fn ▁int ▁sd _ co _ write v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁Sh eep dog A IO CB ▁* ac b ; ▁int ▁ret ; ▁if ▁( bs -> g rowable ▁&& ▁sector _ num ▁+ ▁nb _ sect ors ▁> ▁bs -> total _ sect ors ) ▁{ ▁ret ▁= ▁sd _ truncate ( bs , ▁( sect or _ num ▁+ ▁nb _ sect ors ) ▁* ▁B DR V _ SE CTOR _ SIZE ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁bs -> total _ sect ors ▁= ▁sector _ num ▁+ ▁nb _ sect ors ; ▁} ▁ac b ▁= ▁sd _ a 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd l _ send _ mouse _ event ( int ▁dx , ▁int ▁dy , ▁int ▁x , ▁int ▁y , ▁int ▁state ) ▁{ ▁static ▁uint 32_ t ▁b map [ INPUT _ BUTTON __ MAX ] ▁= ▁{ ▁[ INPUT _ BUTTON _ LEFT ] ▁= ▁SDL _ BUTTON ( S DL _ BUTTON _ LEFT ), ▁[ INPUT _ BUTTON _ M IDDLE ] ▁= ▁SDL _ BUTTON ( S DL _ BUTTON _ M IDDLE ), ▁[ INPUT _ BUTTON _ RIGHT ] ▁= ▁SDL _ BUTTON ( S DL _ BUTTON _ RIGHT ), ▁[ INPUT _ BUTTON _ W HE EL _ UP ] ▁= ▁SDL _ BUTTON ( S DL _ BUTTON _ W HE EL UP ), ▁[ INPUT _ BUTTON _ W HE EL _ DOWN ] ▁= ▁SDL _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁device _ init fn ( Object ▁* obj ) ▁{ ▁Device State ▁* dev ▁= ▁DEVICE ( obj ); ▁Property ▁* prop ; ▁if ▁( q dev _ hot plug ) ▁{ ▁dev -> hot plug ged ▁= ▁1; ▁q dev _ hot _ added ▁= ▁true ; ▁} ▁dev -> instance _ id _ alias ▁= ▁-1; ▁dev -> state ▁= ▁DEV _ STATE _ CREATED ; ▁q dev _ prop _ set _ defaults ( dev , ▁q dev _ get _ props ( dev )); ▁for ▁( prop ▁= ▁q dev _ get _ props ( dev ); ▁prop ▁&& ▁prop -> name ; ▁prop ++) ▁{ ▁q dev _ property _ add _ legacy ( dev , ▁prop , ▁NULL ); ▁q dev _ pr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ write _ data ( SC SI Request ▁* req ) ▁{ ▁S CS ID isk Req ▁* r ▁= ▁DO _ UP CAST ( SC S ID isk Req , ▁req , ▁req ); ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁r -> req . dev ); ▁uint 32_ t ▁n ; ▁/* ▁No ▁data ▁transfer ▁may ▁already ▁be ▁in ▁progress ▁*/ ▁assert ( r -> req . ai oc b ▁== ▁NULL ); ▁/* ▁The ▁request ▁is ▁used ▁as ▁the ▁A IO ▁opaque ▁value , ▁so ▁add ▁a ▁ref . ▁*/ ▁sc si _ req _ ref ( & r -> req ); ▁if ▁( r -> req . cmd . mode ▁!= ▁SC SI _ X 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁id iv 64 ( uint 64_ t ▁* pl ow , ▁uint 64_ t ▁* ph igh , ▁int 64_ t ▁b ) ▁{ ▁int ▁sa , ▁sb ; ▁sa ▁= ▁(( int 64_ t )* ph igh ▁< ▁0); ▁if ▁( sa ) ▁neg 128 ( pl ow , ▁ph igh ); ▁sb ▁= ▁( b ▁< ▁0); ▁if ▁( sb ) ▁b ▁= ▁- b ; ▁div 64 ( pl ow , ▁ph igh , ▁b ); ▁if ▁( sa ▁^ ▁sb ) ▁* pl ow ▁= ▁- ▁* pl ow ; ▁if ▁( sa ) ▁* ph igh ▁= ▁- ▁* ph igh ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b ios _ link er _ loader _ alloc ( G Array ▁* link er , ▁const ▁char ▁* file , ▁uint 32_ t ▁alloc _ align , ▁bool ▁alloc _ f seg ) ▁{ ▁B ios Linker Loader Entry ▁entry ; ▁assert (! ( alloc _ align ▁& ▁( alloc _ align ▁- ▁1 ))); ▁mem set ( & entry , ▁0, ▁sizeof ▁entry ); ▁str nc py ( entry . alloc . file , ▁file , ▁sizeof ▁entry . alloc . file ▁- ▁1); ▁entry . command ▁= ▁cpu _ to _ le 32 ( B IOS _ LINK ER _ LO ADER _ COMMAND _ AL LOC ATE ); ▁entry . alloc . align ▁= ▁cpu _ to _ le 32 ( alloc _ alig

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁iscsi _ refresh _ limits ( Block Driver State ▁* bs , ▁Error ▁** err p ) ▁{ ▁/* ▁We ▁don ' t ▁actually ▁refresh ▁here , ▁but ▁just ▁return ▁data ▁quer ied ▁in ▁* ▁iscsi _ open (): ▁iscsi ▁targets ▁don ' t ▁change ▁their ▁limits . ▁*/ ▁I sc si L un ▁* is cs il un ▁= ▁bs -> op aque ; ▁uint 64_ t ▁max _ x fer _ len ▁= ▁is cs il un -> use _1 6_ for _ rw ▁? ▁0 xffffffff ▁: ▁0 xffff ; ▁bs -> bl . request _ alignment ▁= ▁is cs il un -> block _ size ; ▁if ▁( is cs il un -> bl . max _ x fer _ len ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tap _ receive ( void ▁* op aque , ▁const ▁uint 8_ t ▁* buf , ▁size _ t ▁size ) ▁{ ▁T AP State ▁* s ▁= ▁opaque ; ▁int ▁ret ; ▁for ( ; ;) ▁{ ▁ret ▁= ▁write ( s -> fd , ▁buf , ▁size ); ▁if ▁( ret ▁< ▁0 ▁&& ▁( err no ▁== ▁E INT R ▁|| ▁errno ▁== ▁E AG AIN )) ▁{ ▁} ▁else ▁{ ▁break ; ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ disk _ real ize ( SC S ID evice ▁* dev , ▁Error ▁** err p ) ▁{ ▁Drive Info ▁* d info ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁if ▁(! dev -> conf . bs ) ▁{ ▁sc si _ real ize ( dev , ▁& local _ err ); ▁assert ( local _ err ); ▁error _ propag ate ( err p , ▁local _ err ); ▁return ; ▁} ▁d info ▁= ▁drive _ get _ by _ block dev ( dev -> conf . bs ); ▁if ▁( d info -> media _ cd ) ▁{ ▁sc si _ cd _ real ize ( dev , ▁err p ); ▁} ▁else ▁{ ▁sc si _ hd _ real ize ( dev , ▁err p ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sd _ snapshot _ create ( Block Driver State ▁* bs , ▁Q EM US napshot Info ▁* sn _ info ) ▁{ ▁B DR V Sh eep dog State ▁* s ▁= ▁bs -> op aque ; ▁int ▁ret , ▁fd ; ▁uint 32_ t ▁new _ vid ; ▁Sh eep dog In ode ▁* in ode ; ▁unsigned ▁int ▁dat al en ; ▁d printf (" sn _ info : ▁name ▁% s ▁id _ str ▁% s ▁s : ▁name ▁% s ▁vm _ state _ size ▁% " ▁PR Id 64 ▁" ▁" ▁" is _ snapshot ▁% d \ n ", ▁sn _ info -> name , ▁sn _ info -> id _ str , ▁s -> name , ▁sn _ info -> vm _ state _ size , ▁s -> is _ snapshot ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v nc _ display _ listen ( V nc Display ▁* vd , ▁SocketAddress ▁** s addr , ▁size _ t ▁ns addr , ▁SocketAddress ▁** ws addr , ▁size _ t ▁n ws addr , ▁Error ▁** err p ) ▁{ ▁size _ t ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ns addr ; ▁i ++) ▁{ ▁if ▁( vn c _ display _ listen _ addr ( vd , ▁s addr [ i ], ▁" vn c - listen ", ▁& vd -> ls ock , ▁& vd -> ls ock _ tag , ▁& vd -> n ls ock , ▁err p ) ▁< ▁0) ▁{ ▁return ▁-1; ▁} ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁n ws addr ; ▁i ++) ▁{ ▁if ▁( vn c _ display _ listen _ addr ( v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* enum erate _ cpus ( un signed ▁long ▁* cpus , ▁int ▁max _ cpus ) ▁{ ▁int ▁cpu ; ▁bool ▁first ▁= ▁true ; ▁G String ▁* s ▁= ▁g _ string _ new ( NULL ); ▁for ▁( cpu ▁= ▁find _ first _ bit ( cpus , ▁max _ cpus ); ▁cpu ▁< ▁max _ cpus ; ▁cpu ▁= ▁find _ next _ bit ( cpus , ▁max _ cpus , ▁cpu ▁+ ▁1)) ▁{ ▁g _ string _ append _ printf ( s , ▁"% s % d ", ▁first ▁? ▁"" ▁: ▁" ▁", ▁cpu ); ▁first ▁= ▁false ; ▁} ▁return ▁g _ string _ free ( s , ▁FALSE ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Migration State ▁* exec _ start _ out going _ migration ( const ▁char ▁* command , ▁int 64_ t ▁bandwidth _ limit , ▁int ▁async ) ▁{ ▁F d Migration State ▁* s ; ▁FILE ▁* f ; ▁s ▁= ▁qemu _ m alloc z ( size of (* s )); ▁if ▁( s ▁== ▁NULL ) ▁{ ▁d printf (" Unable ▁to ▁allocate ▁F d Migration State \ n "); ▁goto ▁err ; ▁} ▁f ▁= ▁popen ( command , ▁" w "); ▁if ▁( f ▁== ▁NULL ) ▁{ ▁d printf (" Unable ▁to ▁popen ▁exec ▁target \ n "); ▁goto ▁err _ after _ alloc ; ▁} ▁s -> fd ▁= ▁fileno ( f ); ▁if ▁( s -> fd ▁== ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁register _ core _ rt as ( void ) ▁{ ▁sp ap r _ rt as _ register (" display - character ", ▁rt as _ display _ character ); ▁sp ap r _ rt as _ register (" get - time - of - day ", ▁rt as _ get _ time _ of _ day ); ▁sp ap r _ rt as _ register (" power - off ", ▁rt as _ power _ off ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁target _ ulong ▁h _ put _ t ce ( CP UP PC State ▁* env , ▁s P AP R Environment ▁* sp ap r , ▁target _ ulong ▁opcode , ▁target _ ulong ▁* args ) ▁{ ▁target _ ulong ▁li ob n ▁= ▁args [0]; ▁target _ ulong ▁i ob a ▁= ▁args [1]; ▁target _ ulong ▁t ce ▁= ▁args [2 ]; ▁V IO s P AP R Device ▁* dev ▁= ▁sp ap r _ v io _ find _ by _ reg ( sp ap r -> v io _ bus , ▁li ob n ); ▁V IO s P AP R _ RT CE ▁* rt ce ; ▁if ▁(! dev ) ▁{ ▁h call _ d printf (" LI OB N ▁0 x " ▁TARGET _ F MT _ l x ▁" ▁does ▁not ▁exist \ n ",

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nv me _ get _ boot index ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁N v me Ctrl ▁* s ▁= ▁NV ME ( obj ); ▁visit _ type _ int 32 ( v , ▁& s -> conf . boot index , ▁name , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ff _ rm _ parse _ packet ▁( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Stream ▁* st , ▁RM Stream ▁* ast , ▁int ▁len , ▁AV Packet ▁* pk t , ▁int ▁* seq , ▁int ▁flags , ▁int 64_ t ▁timestamp ) ▁{ ▁R MD em ux Context ▁* rm ▁= ▁s -> priv _ data ; ▁int ▁ret ; ▁if ▁( st -> codec -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ) ▁{ ▁rm -> current _ stream = ▁st -> id ; ▁ret ▁= ▁rm _ as semble _ video _ frame ( s , ▁pb , ▁rm , ▁ast , ▁pkt , ▁len , ▁seq , ▁& timestamp ); ▁if ( ret ) ▁return ▁ret ▁< ▁0 ▁? ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Object ▁* object _ resolve _ path _ component ( Object ▁* parent , ▁const ▁g char ▁* part ) ▁{ ▁Object Property ▁* prop ▁= ▁object _ property _ find ( parent , ▁part , ▁NULL ); ▁if ▁( prop ▁== ▁NULL ) ▁{ ▁return ▁NULL ; ▁} ▁if ▁( object _ property _ is _ link ( prop )) ▁{ ▁return ▁* ( Object ▁** ) prop -> op aque ; ▁} ▁else ▁if ▁( object _ property _ is _ child ( prop )) ▁{ ▁return ▁prop -> op aque ; ▁} ▁else ▁{ ▁return ▁NULL ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v sc si _ process _ login ( V SC SI State ▁* s , ▁v sc si _ req ▁* req ) ▁{ ▁union ▁v ios rp _ i u ▁* i u ▁= ▁& req -> i u ; ▁struct ▁sr p _ login _ r sp ▁* r sp ▁= ▁& i u -> sr p . login _ r sp ; ▁uint 64_ t ▁tag ▁= ▁i u -> sr p . r sp . tag ; ▁trace _ sp ap r _ v sc si __ process _ login (); ▁/* ▁TODO ▁handle ▁case ▁that ▁requested ▁size ▁is ▁wrong ▁and ▁* ▁buffer ▁format ▁is ▁wrong ▁*/ ▁mem set ( i u , ▁0, ▁sizeof ( struct ▁sr p _ login _ r sp )); ▁rsp -> op code ▁= ▁SR P _ LOGIN _ R SP 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ tick _ set _ count ( CP UT imer ▁* timer , ▁uint 64_ t ▁count ) ▁{ ▁uint 64_ t ▁real _ count ▁= ▁count ▁& ▁~ timer -> disabled _ mask ; ▁uint 64_ t ▁disabled _ bit ▁= ▁count ▁& ▁timer -> disabled _ mask ; ▁int 64_ t ▁vm _ clock _ offset ▁= ▁qemu _ clock _ get _ ns ( Q EM U _ C LOCK _ VI RTUAL ) ▁- ▁cpu _ to _ timer _ ticks ( real _ count , ▁timer -> frequency ); ▁T IMER _ DP RI NT F ("% s ▁set _ count ▁count =0 x % 016 l x ▁( % s ) ▁p =% p \ n ", ▁timer -> name , ▁real _ count , ▁timer -> dis

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁commit _ start ( const ▁char ▁* job _ id , ▁Block Driver State ▁* bs , ▁Block Driver State ▁* base , ▁Block Driver State ▁* top , ▁int 64_ t ▁speed , ▁Block dev OnError ▁on _ error , ▁const ▁char ▁* back ing _ file _ str , ▁const ▁char ▁* filter _ node _ name , ▁Error ▁** err p ) ▁{ ▁Commit Block Job ▁* s ; ▁Block Re open Queue ▁* re open _ queue ▁= ▁NULL ; ▁int ▁orig _ overlay _ flags ; ▁int ▁orig _ base _ flags ; ▁Block Driver State ▁* iter ; ▁Block Driver State ▁* overlay _ bs ; ▁Block Driver St

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ is _ rem ov able ( Block Driver State ▁* bs ) ▁{ ▁return ▁bs -> rem ov able ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁null _ filter _ samples ( AV Filter Link ▁* link , ▁AV Filter Buffer Ref ▁* samples ref ) ▁{ ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ block dev _ add ( Block dev Options ▁* options , ▁Error ▁** err p ) ▁{ ▁Q mp Output Visitor ▁* ov ▁= ▁q mp _ output _ visitor _ new (); ▁Q Object ▁* obj ; ▁Q Dict ▁* q dict ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁/* ▁Require ▁an ▁ID ▁in ▁the ▁top ▁level ▁*/ ▁if ▁(! options -> has _ id ) ▁{ ▁error _ set g ( err p , ▁" Block ▁device ▁needs ▁an ▁ID "); ▁goto ▁fail ; ▁} ▁/* ▁TODO ▁Sort ▁it ▁out ▁in ▁raw - posix ▁and ▁drive _ init : ▁Reject ▁aio = native ▁with ▁* ▁cache . direct = false ▁instead ▁of 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ div w u o ▁( void ) ▁{ ▁if ▁( likely (( uint 32_ t ) T 1 ▁!= ▁0 )) ▁{ ▁x er _ ov ▁= ▁0; ▁T 0 ▁= ▁( uint 32_ t ) T 0 ▁/ ▁( uint 32_ t ) T 1; ▁} ▁else ▁{ ▁x er _ so ▁= ▁1; ▁x er _ ov ▁= ▁1; ▁T 0 ▁= ▁0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm clock _ pre _ save ( void ▁* op aque ) ▁{ ▁K VM Clock State ▁* s ▁= ▁opaque ; ▁struct ▁k vm _ clock _ data ▁data ; ▁int ▁ret ; ▁if ▁( s -> clock _ valid ) ▁{ ▁return ; ▁} ▁ret ▁= ▁k vm _ vm _ io ctl ( k vm _ state , ▁K VM _ GET _ C LOCK , ▁& data ); ▁if ▁( ret ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" K VM _ GET _ C LOCK ▁failed : ▁% s \ n ", ▁strerror ( ret )); ▁data . clock ▁= ▁0; ▁} ▁s -> clock ▁= ▁data . clock ; ▁/* ▁* ▁If ▁the ▁VM ▁is ▁stopped , ▁declare ▁the ▁clock ▁state ▁valid ▁to ▁avo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ sat n ( ES P State ▁* s ) ▁{ ▁uint 8_ t ▁buf [ 32 ]; ▁int ▁len ; ▁if ▁( s -> d ma ▁&& ▁! s -> d ma _ enabled ) ▁{ ▁s -> d ma _ cb ▁= ▁handle _ sat n ; ▁return ; ▁} ▁len ▁= ▁get _ cmd ( s , ▁buf ); ▁if ▁( len ) ▁do _ cmd ( s , ▁buf ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ checksum ( Byte IO Context ▁* bc ){ ▁unsigned ▁long ▁checksum = ▁get _ checksum ( bc ); ▁// ▁return ▁checksum ▁!= ▁get _ be 32 ( bc ); ▁av _ log ( NULL , ▁AV _ LOG _ ERROR , ▁"% 08 X ▁% 08 X \ n ", ▁checksum , ▁( int ) get _ be 32 ( bc )); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ide _ init _ drive ( IDE State ▁* s , ▁Block Backend ▁* blk , ▁IDE Drive Kind ▁kind , ▁const ▁char ▁* version , ▁const ▁char ▁* serial , ▁const ▁char ▁* model , ▁uint 64_ t ▁ww n , ▁uint 32_ t ▁cy l ind ers , ▁uint 32_ t ▁heads , ▁uint 32_ t ▁secs , ▁int ▁ch s _ trans ) ▁{ ▁uint 64_ t ▁nb _ sect ors ; ▁s -> blk ▁= ▁blk ; ▁s -> drive _ kind ▁= ▁kind ; ▁blk _ get _ geometry ( blk , ▁& nb _ sect ors ); ▁s -> cy l ind ers ▁= ▁cy l ind ers ; ▁s -> head s ▁= ▁heads ; ▁s -> sect ors ▁= ▁secs ; ▁s -> ch s _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v host _ backend _ in validate _ device _ iot lb ( struct ▁v host _ dev ▁* dev , ▁uint 64_ t ▁i ova , ▁uint 64_ t ▁len ) ▁{ ▁struct ▁v host _ iot lb _ msg ▁im sg ; ▁im sg . io va ▁= ▁i ova ; ▁im sg . size ▁= ▁len ; ▁im sg . type ▁= ▁V HOST _ I OT LB _ IN V ALIDATE ; ▁return ▁dev -> v host _ ops -> v host _ send _ device _ iot lb _ msg ( dev , ▁& im sg ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁g ic _ dist _ read w ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset ) ▁{ ▁uint 32_ t ▁val ; ▁val ▁= ▁g ic _ dist _ read b ( op aque , ▁offset ); ▁val ▁|= ▁g ic _ dist _ read b ( op aque , ▁offset ▁+ ▁1) ▁<< ▁8 ; ▁return ▁val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str t ou ll _ overflow ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" 99999999 99999999 99999999 99999999 99999999 9999 "; ▁char ▁f ▁= ▁' X '; ▁const ▁char ▁* end ptr ▁= ▁& f ; ▁uint 64_ t ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str t ou ll ( str , ▁& end ptr , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁- ER ANGE ); ▁g _ assert _ cmp int ( res , ▁== , ▁U LL ONG _ MAX ); ▁g _ assert ( end ptr ▁== ▁str ▁+ ▁str len ( str )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P XA 2 xx State ▁* px a 25 5_ init ( un signed ▁int ▁sd ram _ size ) ▁{ ▁P XA 2 xx State ▁* s ; ▁int ▁i om em type , ▁i ; ▁Drive Info ▁* d info ; ▁s ▁= ▁( P XA 2 xx State ▁* ) ▁qemu _ m alloc z ( size of ( P XA 2 xx State )); ▁s -> env ▁= ▁cpu _ init (" px a 255 "); ▁if ▁(! s -> env ) ▁{ ▁f printf ( stderr , ▁" Unable ▁to ▁find ▁CPU ▁definition \ n "); ▁exit (1); ▁} ▁s -> reset ▁= ▁qemu _ allocate _ ir qs ( px a 2 xx _ reset , ▁s , ▁1) [0]; ▁/* ▁SD RAM ▁& ▁Internal ▁Memory ▁Storage ▁*/ ▁cpu _ register _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁usb _ device _ delete _ addr ( int ▁bus nr , ▁int ▁addr ) ▁{ ▁USB Bus ▁* bus ; ▁USB Port ▁* port ; ▁USB Device ▁* dev ; ▁bus ▁= ▁usb _ bus _ find ( bus nr ); ▁if ▁(! bus ) ▁return ▁-1; ▁TA IL Q _ FORE A CH ( port , ▁& bus -> used , ▁next ) ▁{ ▁if ▁( port -> dev -> addr ▁== ▁addr ) ▁break ; ▁} ▁if ▁(! port ) ▁return ▁-1; ▁dev ▁= ▁port -> dev ; ▁TA IL Q _ REMOVE ( & bus -> used , ▁port , ▁next ); ▁bus -> n used --; ▁usb _ attach ( port , ▁NULL ); ▁dev -> info -> handle _ destroy ( dev ); ▁TA IL Q _ IN

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q mp _ output _ type _ number ( Visitor ▁* v , ▁const ▁char ▁* name , ▁double ▁* obj , ▁Error ▁** err p ) ▁{ ▁Q mp Output Visitor ▁* q ov ▁= ▁to _ q ov ( v ); ▁q mp _ output _ add ( q ov , ▁name , ▁q float _ from _ double (* obj )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁aio _ write _ f ( Block Backend ▁* blk , ▁int ▁arg c , ▁char ▁** argv ) ▁{ ▁int ▁nr _ io v , ▁c ; ▁int ▁pattern ▁= ▁0 x cd ; ▁struct ▁aio _ ctx ▁* ctx ▁= ▁g _ new 0( struct ▁aio _ ctx , ▁1); ▁ctx -> blk ▁= ▁blk ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" C q P : z ")) ▁!= ▁-1) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' C ': ▁ctx -> C flag ▁= ▁1; ▁break ; ▁case ▁' q ': ▁ctx -> q flag ▁= ▁1; ▁break ; ▁case ▁' P ': ▁pattern ▁= ▁parse _ pattern ( opt arg ); ▁if ▁( pattern ▁< ▁0) ▁{ ▁return ▁0; ▁} ▁break ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁alloc _ refcount _ block ( Block Driver State ▁* bs , ▁int 64_ t ▁cluster _ index , ▁uint 16_ t ▁** refcount _ block ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁unsigned ▁int ▁ref count _ table _ index ; ▁int ▁ret ; ▁BL K DB G _ EVENT ( bs -> file , ▁BL K DB G _ REF BLOCK _ AL LOC ); ▁/* ▁Find ▁the ▁ref count ▁block ▁for ▁the ▁given ▁cluster ▁*/ ▁ref count _ table _ index ▁= ▁cluster _ index ▁>> ▁s -> refcount _ block _ bits ; ▁if ▁( refcount _ table _ index ▁< ▁s -> refcount _ table

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a la c _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* out buffer , ▁int ▁* output size , ▁const ▁uint 8_ t ▁* in buffer , ▁int ▁input _ buffer _ size ) ▁{ ▁A LA C Context ▁* al ac ▁= ▁av ctx -> priv _ data ; ▁int ▁channels ; ▁unsigned ▁int ▁outputs amples ; ▁int ▁hass ize ; ▁int ▁read samples ize ; ▁int ▁wast ed _ bytes ; ▁int ▁is not compressed ; ▁uint 8_ t ▁inter lacing _ shift ; ▁uint 8_ t ▁inter lacing _ left weight ; ▁/* ▁short - c ircuit ▁null ▁buffers ▁*/ ▁if ▁(! in buffer ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁getopt ( int ▁arg c , ▁char ▁* argv [], ▁char ▁* opts ) ▁{ ▁static ▁int ▁sp ▁= ▁1; ▁int ▁c ; ▁char ▁* cp ; ▁if ▁( sp ▁== ▁1) ▁if ▁( opt ind ▁>= ▁arg c ▁|| ▁argv [ opt ind ][0] ▁!= ▁'-' ▁|| ▁argv [ opt ind ][1] ▁== ▁'\ 0 ') ▁return ▁EOF ; ▁else ▁if ▁(! str cmp ( argv [ opt ind ], ▁"-- ")) ▁{ ▁opt ind ++; ▁return ▁EOF ; ▁} ▁opt opt ▁= ▁c ▁= ▁argv [ opt ind ][ sp ]; ▁if ▁( c ▁== ▁' :' ▁|| ▁( cp ▁= ▁str chr ( opts , ▁c )) ▁== ▁NULL ) ▁{ ▁f printf ( stderr , ▁": ▁illegal ▁option ▁-- ▁% c \ n ", ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sla v io _ timer _ mem _ writ el ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁S LA V IO _ T IMER State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁s addr ; ▁int ▁reload ▁= ▁0; ▁D PRI NT F (" write ▁" ▁TARGET _ F MT _ pl x ▁" ▁% 08 x \ n ", ▁addr , ▁val ); ▁s addr ▁= ▁( addr ▁& ▁T IMER _ MAX ADDR ) ▁>> ▁2; ▁switch ▁( s addr ) ▁{ ▁case ▁T IMER _ LIMIT : ▁if ▁( s la v io _ timer _ is _ user ( s )) ▁{ ▁// ▁set ▁user ▁counter ▁MS W , ▁reset ▁counter ▁qemu _ irq _ lower ( s ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ cpu _ k ick ( void ▁* env ) ▁{ ▁return ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁temp _ allocate _ frame ( TC G Context ▁* s , ▁int ▁temp ) ▁{ ▁TC G Temp ▁* ts ; ▁ts ▁= ▁& s -> tem ps [ temp ]; ▁s -> current _ frame _ offset ▁= ▁( s -> current _ frame _ offset ▁+ ▁sizeof ( tc g _ target _ long ) ▁- ▁1) ▁& ▁~ ( size of ( tc g _ target _ long ) ▁- ▁1); ▁if ▁( s -> current _ frame _ offset ▁+ ▁sizeof ( tc g _ target _ long ) ▁> ▁s -> frame _ end ) ▁tc g _ abort (); ▁ts -> mem _ offset ▁= ▁s -> current _ frame _ offset ; ▁ts -> mem _ reg ▁= ▁s -> frame _ reg ; ▁ts -> mem _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ block _ stream ( const ▁char ▁* device , ▁bool ▁has _ base , ▁const ▁char ▁* base , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁Block Driver State ▁* base _ bs ▁= ▁NULL ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁bs ▁= ▁b dr v _ find ( device ); ▁if ▁(! bs ) ▁{ ▁error _ set ( err p , ▁Q ERR _ DEVICE _ NOT _ FOUND , ▁device ); ▁return ; ▁} ▁if ▁( base ) ▁{ ▁base _ bs ▁= ▁b dr v _ find _ back ing _ image ( bs , ▁base ); ▁if ▁( base _ bs ▁== ▁NULL ) ▁{ ▁error _ set ( err p , ▁Q ERR _ BASE _ NOT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m pts as _ sc si _ init ( PC ID evice ▁* dev , ▁Error ▁** err p ) ▁{ ▁Device State ▁* d ▁= ▁DEVICE ( dev ); ▁M PT S AS State ▁* s ▁= ▁M PT _ S AS ( dev ); ▁dev -> config [ PC I _ LATE NCY _ T IMER ] ▁= ▁0; ▁dev -> config [ PC I _ INTER R UP T _ P IN ] ▁= ▁0 x 01 ; ▁memory _ region _ init _ io ( & s -> mm io _ io , ▁OBJECT ( s ), ▁& m pts as _ mm io _ ops , ▁s , ▁" m pts as - mm io ", ▁0 x 4 000); ▁memory _ region _ init _ io ( & s -> port _ io , ▁OBJECT ( s ), ▁& m pts as _ port _ ops , ▁s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁num _ effect ive _ bu ss es ( X il inx S PI PS ▁* s ) ▁{ ▁return ▁( s -> re gs [ R _ L Q S PI _ ST S ] ▁& ▁L Q S PI _ CF G _ SEP _ B US ▁&& ▁s -> re gs [ R _ L Q S PI _ ST S ] ▁& ▁L Q S PI _ CF G _ T WO _ ME M ) ▁? ▁s -> num _ bu ss es ▁: ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁FFT Context ▁* av _ fft _ init ( int ▁nb its , ▁int ▁inverse ) ▁{ ▁FFT Context ▁* s ▁= ▁av _ m alloc ( size of (* s )); ▁if ▁( s ▁&& ▁ff _ fft _ init ( s , ▁nb its , ▁inverse )) ▁av _ fre ep ( & s ); ▁return ▁s ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ set _ CF _ bit 31 ( TC G v ▁var ) ▁{ ▁TC G v ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ sh ri _ i 32 ( tmp , ▁var , ▁31 ); ▁gen _ set _ CF ( tmp ); ▁dead _ tmp ( tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ s iz ( J peg 2000 Decoder Context ▁* s ) ▁{ ▁int ▁i ; ▁int ▁n components ; ▁uint 32_ t ▁log 2_ chrom a _ wh ▁= ▁0; ▁const ▁enum ▁AV Pixel Format ▁* possible _ fmt s ▁= ▁NULL ; ▁int ▁possible _ fmt s _ nb ▁= ▁0; ▁if ▁( by test ream 2_ get _ bytes _ left ( & s -> g ) ▁< ▁36 ) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" Ins ufficient ▁space ▁for ▁SI Z \ n "); ▁s -> av ctx -> profile ▁= ▁by test ream 2_ get _ be 16 u ( & s -> g ); ▁// ▁R s iz ▁s -> width ▁= ▁by test ream 2_ get _ b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁commit _ set _ speed ( Block Job ▁* job , ▁int 64_ t ▁speed , ▁Error ▁** err p ) ▁{ ▁Commit Block Job ▁* s ▁= ▁container _ of ( job , ▁Commit Block Job , ▁common ); ▁if ▁( speed ▁< ▁0) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER , ▁" speed "); ▁return ; ▁} ▁rat el imit _ set _ speed ( & s -> limit , ▁speed ▁/ ▁B DR V _ SE CTOR _ SIZE , ▁S LI CE _ TIME ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd _1 d 97 _ int ( int ▁* p , ▁int ▁i 0, ▁int ▁i 1) ▁{ ▁int ▁i ; ▁if ▁( i 1 ▁<= ▁i 0 ▁+ ▁1) ▁{ ▁if ▁( i 0 ▁== ▁1) ▁p [1] ▁= ▁( p [1] ▁* ▁I _ L FT G _ X ▁+ ▁(1 << 15 )) ▁>> ▁16 ; ▁else ▁p [0] ▁= ▁( p [0] ▁* ▁I _ L FT G _ K ▁+ ▁(1 << 15 )) ▁>> ▁16 ; ▁return ; ▁} ▁extend 97 _ int ( p , ▁i 0, ▁i 1); ▁i 0 ++; ▁i 1 ++; ▁for ▁( i ▁= ▁i 0 /2 ▁- ▁2; ▁i ▁< ▁i 1/ 2 ▁+ ▁1; ▁i ++) ▁p [2 ▁* ▁i ▁+ ▁1] ▁-= ▁( I _ L FT G _ ALPHA ▁* ▁( p [2 ▁* ▁i ] ▁+ ▁p [2 ▁* ▁i ▁+ ▁2 ]) ▁+ ▁(1 ▁<< ▁15 )) ▁>> ▁16 ; ▁for ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( rgb 32 To Y )( uint 8_ t ▁* dst , ▁uint 8_ t ▁* src , ▁int ▁width ) ▁{ ▁int ▁i ; ▁for ( i =0; ▁i < width ; ▁i ++) ▁{ ▁int ▁r = ▁(( uint 32_ t *) src )[ i ] & 0 xFF ; ▁int ▁g = ▁( (( uint 32_ t *) src )[ i ] >> 8) & 0 xFF ; ▁int ▁b = ▁( (( uint 32_ t *) src )[ i ] >> 16) & 0 xFF ; ▁dst [ i ]= ▁(( RY * r ▁+ ▁G Y * g ▁+ ▁BY * b ▁+ ▁( 33 << ( RGB 2 Y UV _ SHIFT -1 )) ▁) >> RGB 2 Y UV _ SHIFT ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁s 39 0_ pc i _ generate _ f id ( Error ▁** err p ) ▁{ ▁uint 32_ t ▁fid ▁= ▁0; ▁while ▁( f id ▁<= ▁Z PC I _ MAX _ F ID ) ▁{ ▁if ▁(! s 39 0_ pc i _ find _ dev _ by _ f id ( f id )) ▁{ ▁return ▁fid ; ▁} ▁if ▁( f id ▁== ▁Z PC I _ MAX _ F ID ) ▁{ ▁break ; ▁} ▁fid ++; ▁} ▁error _ set g ( err p , ▁" no ▁free ▁fid ▁could ▁be ▁found "); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _9 p _ device _ un real ize ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( dev ); ▁V 9 fs V irt io State ▁* v ▁= ▁VI RT IO _9 P ( dev ); ▁V 9 fs State ▁* s ▁= ▁& v -> state ; ▁virt io _ cleanup ( v dev ); ▁v 9 fs _ device _ un real ize _ common ( s , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ip movie _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁IP M VE Context ▁* ip movie ▁= ▁( IP M VE Context ▁* ) s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁& s -> pb ; ▁int ▁ret ; ▁ret ▁= ▁process _ ip movie _ chunk ( ip movie , ▁pb , ▁pkt ); ▁if ▁( ret ▁== ▁CHUNK _ BAD ) ▁ret ▁= ▁A VER ROR _ IN V ALI DD ATA ; ▁else ▁if ▁( ret ▁== ▁CHUNK _ EOF ) ▁ret ▁= ▁A VER ROR _ IO ; ▁else ▁if ▁( ret ▁== ▁CHUNK _ NO ME M ) ▁ret ▁= ▁A VER ROR _ NO ME M ; ▁else ▁ret ▁= ▁0; ▁return ▁re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁op us _ decode _ frame ( Op us Stream Context ▁* s , ▁const ▁uint 8_ t ▁* data , ▁int ▁size ) ▁{ ▁int ▁samples ▁= ▁s -> packet . frame _ duration ; ▁int ▁redund ancy ▁= ▁0; ▁int ▁redund ancy _ size , ▁redund ancy _ pos ; ▁int ▁ret , ▁i , ▁consumed ; ▁int ▁delayed _ samples ▁= ▁s -> delayed _ samples ; ▁ret ▁= ▁op us _ rc _ init ( & s -> rc , ▁data , ▁size ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁/* ▁decode ▁the ▁sil k ▁frame ▁*/ ▁if ▁( s -> packet . mode ▁== ▁OP US _ MODE _ SI L K ▁|| ▁s -> pack

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁qemu _ co _ enter _ next ( Co Queue ▁* queue ) ▁{ ▁Cor outine ▁* next ; ▁next ▁= ▁Q SI MPLE Q _ FIRST ( & queue -> entries ); ▁if ▁(! next ) ▁{ ▁return ▁false ; ▁} ▁Q SI MPLE Q _ REMOVE _ HEAD ( & queue -> entries , ▁co _ queue _ next ); ▁qemu _ cor outine _ enter ( next , ▁NULL ); ▁return ▁true ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode Channel Sound Unit ▁( AT RA C 3 Context ▁* q , ▁Get Bit Context ▁* gb , ▁channel _ unit ▁* p S nd , ▁float ▁* p Out , ▁int ▁channel Num , ▁int ▁coding Mode ) ▁{ ▁int ▁band , ▁result =0, ▁num Sub b ands , ▁last T onal , ▁num B ands ; ▁if ▁( coding Mode ▁== ▁J O INT _ ST ERE O ▁&& ▁channel Num ▁== ▁1) ▁{ ▁if ▁( get _ bits ( gb , 2) ▁!= ▁3) ▁{ ▁av _ log ( NULL , AV _ LOG _ ERROR ," JS ▁mon o ▁Sound ▁Unit ▁id ▁!= ▁3. \ n "); ▁return ▁-1; ▁} ▁} ▁else ▁{ ▁if ▁( get _ bits ( gb , 6) ▁!= ▁0 x

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁target _ long ▁monitor _ get _ reg ( const ▁struct ▁Monitor Def ▁* md , ▁int ▁val ) ▁{ ▁CPU State ▁* env ▁= ▁mon _ get _ cpu (); ▁if ▁(! env ) ▁return ▁0; ▁return ▁env -> reg w ptr [ val ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vp 8_ id ct _ dc _ add 4 uv _ c ( uint 8_ t ▁* dst , ▁int 16_ t ▁block [4 ][ 16 ], ▁ptr diff _ t ▁stride ) ▁{ ▁vp 8_ id ct _ dc _ add _ c ( dst + stride * 0 + 0, ▁block [0], ▁stride ); ▁vp 8_ id ct _ dc _ add _ c ( dst + stride * 0 + 4, ▁block [1], ▁stride ); ▁vp 8_ id ct _ dc _ add _ c ( dst + stride * 4 + 0, ▁block [2], ▁stride ); ▁vp 8_ id ct _ dc _ add _ c ( dst + stride * 4 + 4, ▁block [3 ], ▁stride ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁integ rator cp _ init ( Q EM UM achine Init Args ▁* args ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁args -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁args -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁args -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁args -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁args -> init rd _ filename ; ▁ARM CPU ▁* cpu ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ram ▁= ▁g _ new ( Memo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁set _ vlan ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Device State ▁* dev ▁= ▁DEVICE ( obj ); ▁Property ▁* prop ▁= ▁opaque ; ▁N IC P eers ▁* pe ers _ ptr ▁= ▁q dev _ get _ prop _ ptr ( dev , ▁prop ); ▁Net Client State ▁** ptr ▁= ▁& pe ers _ ptr -> n cs [0]; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int 32_ t ▁id ; ▁Net Client State ▁* hub port ; ▁if ▁( dev -> real ized ) ▁{ ▁q dev _ prop _ set _ after _ real ize ( dev , ▁name , ▁err p ); ▁visi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁png _ dec _ end ( AV Codec Context ▁* av ctx ) ▁{ ▁PNG Dec Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁ff _ thread _ release _ buffer ( av ctx , ▁& s -> previous _ picture ); ▁av _ frame _ free ( & s -> previous _ picture . f ); ▁ff _ thread _ release _ buffer ( av ctx , ▁& s -> last _ picture ); ▁av _ frame _ free ( & s -> last _ picture . f ); ▁ff _ thread _ release _ buffer ( av ctx , ▁& s -> picture ); ▁av _ frame _ free ( & s -> picture . f ); ▁av _ fre ep ( & s -> buffer ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fd _ chr _ update _ read _ handler ( Char Driver State ▁* chr ) ▁{ ▁F D Char Driver ▁* s ▁= ▁chr -> op aque ; ▁if ▁( s -> fd _ in _ tag ) ▁{ ▁g _ source _ remove ( s -> fd _ in _ tag ); ▁s -> fd _ in _ tag ▁= ▁0; ▁} ▁if ▁( s -> fd _ in ) ▁{ ▁s -> fd _ in _ tag ▁= ▁io _ add _ watch _ poll ( s -> fd _ in , ▁fd _ chr _ read _ poll , ▁fd _ chr _ read , ▁chr ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁probe _ file ( Writer Context ▁* w ctx , ▁const ▁char ▁* filename ) ▁{ ▁AV Format Context ▁* fmt _ ctx ; ▁int ▁ret , ▁i ; ▁int ▁section _ id ; ▁do _ read _ frames ▁= ▁do _ show _ frames ▁|| ▁do _ count _ frames ; ▁do _ read _ pack ets ▁= ▁do _ show _ pack ets ▁|| ▁do _ count _ pack ets ; ▁ret ▁= ▁open _ input _ file ( & fmt _ ctx , ▁filename ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁# define ▁CHECK _ END ▁if ▁( ret ▁< ▁0) ▁goto ▁end ▁nb _ streams _ frames ▁= ▁av _ cal loc ( fmt _ ctx -> nb _ stre

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ ph ysical _ sync _ dirty _ bitmap ( target _ ph ys _ addr _ t ▁start _ addr , ▁target _ ph ys _ addr _ t ▁end _ addr ) ▁{ ▁K VM State ▁* s ▁= ▁k vm _ state ; ▁unsigned ▁long ▁size , ▁allocated _ size ▁= ▁0; ▁K VM Dirty Log ▁d ; ▁KV MS lot ▁* mem ; ▁int ▁ret ▁= ▁0; ▁d . dirty _ bitmap ▁= ▁NULL ; ▁while ▁( start _ addr ▁< ▁end _ addr ) ▁{ ▁mem ▁= ▁k vm _ lookup _ over lapping _ slot ( s , ▁start _ addr , ▁end _ addr ); ▁if ▁( mem ▁== ▁NULL ) ▁{ ▁break ; ▁} ▁size ▁= ▁ALIGN (( ( mem -> me

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁filter ( US PP Context ▁* p , ▁uint 8_ t ▁* dst [3 ], ▁uint 8_ t ▁* src [3 ], ▁int ▁dst _ stride [3 ], ▁int ▁src _ stride [3 ], ▁int ▁width , ▁int ▁height , ▁uint 8_ t ▁* qp _ store , ▁int ▁qp _ stride ) ▁{ ▁int ▁x , ▁y , ▁i , ▁j ; ▁const ▁int ▁count ▁= ▁1 << p -> log 2_ count ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁3; ▁i ++) ▁{ ▁int ▁is _ chrom a ▁= ▁!! i ; ▁int ▁w ▁= ▁width ▁>> ▁( is _ chrom a ▁? ▁p -> h sub ▁: ▁0); ▁int ▁h ▁= ▁height ▁>> ▁( is _ chrom a ▁? ▁p -> v sub ▁: ▁0); ▁int ▁stride ▁= ▁p -> tem

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁main ( void ) ▁{ ▁int ▁nf ; ▁Suite ▁* s ; ▁S Runner ▁* sr ; ▁s ▁= ▁q float _ suite (); ▁sr ▁= ▁s runner _ create ( s ); ▁s runner _ run _ all ( sr , ▁CK _ NORMAL ); ▁nf ▁= ▁s runner _ nt ests _ failed ( sr ); ▁s runner _ free ( sr ); ▁return ▁( nf ▁== ▁0) ▁? ▁EXIT _ SUCCESS ▁: ▁EXIT _ FAILURE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁target _ ulong ▁put _ t ce _ emu ( s P AP RT CE Table ▁* tc et , ▁target _ ulong ▁i ob a , ▁target _ ulong ▁t ce ) ▁{ ▁IO MM UT LB Entry ▁entry ; ▁hw addr ▁page _ mask ▁= ▁IO MM U _ PAGE _ MASK ( tc et -> page _ shift ); ▁unsigned ▁long ▁index ▁= ▁( iob a ▁- ▁tc et -> bus _ offset ) ▁>> ▁tc et -> page _ shift ; ▁if ▁( index ▁>= ▁tc et -> nb _ table ) ▁{ ▁h call _ d printf (" sp ap r _ v io _ put _ t ce ▁on ▁out - of - bounds ▁IO BA ▁0 x " ▁TARGET _ F MT _ l x ▁"\ n ", ▁i ob a ); ▁return ▁H _ PARA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁target _ ulong ▁h _ enter ( CPU State ▁* env , ▁s P AP R Environment ▁* sp ap r , ▁target _ ulong ▁opcode , ▁target _ ulong ▁* args ) ▁{ ▁target _ ulong ▁flags ▁= ▁args [0]; ▁target _ ulong ▁p te _ index ▁= ▁args [1]; ▁target _ ulong ▁p te h ▁= ▁args [2 ]; ▁target _ ulong ▁pt el ▁= ▁args [3 ]; ▁target _ ulong ▁i ; ▁uint 8_ t ▁* h pt e ; ▁/* ▁only ▁handle ▁4 k ▁and ▁16 M ▁pages ▁for ▁now ▁*/ ▁if ▁( pt eh ▁& ▁H P TE _ V _ L ARGE ) ▁{ ▁# if ▁0 ▁/* ▁We ▁don ' t ▁support ▁64 k ▁pages ▁yet ▁*/ ▁if ▁(( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ ar ith _ add ( Dis as Context ▁* ctx , ▁TC G v ▁ret , ▁TC G v ▁arg 1, ▁TC G v ▁arg 2, ▁int ▁add _ ca , ▁int ▁compute _ ca , ▁int ▁compute _ ov ) ▁{ ▁TC G v ▁t 0, ▁t 1; ▁if ▁(( ! compute _ ca ▁&& ▁! compute _ ov ) ▁|| ▁(! TC GV _ EQUAL ( ret , arg 1) ▁&& ▁! TC GV _ EQUAL ( ret , ▁arg 2 ))) ▁{ ▁t 0 ▁= ▁ret ; ▁} ▁else ▁{ ▁t 0 ▁= ▁tc g _ temp _ local _ new (); ▁} ▁if ▁( add _ ca ) ▁{ ▁t 1 ▁= ▁tc g _ temp _ local _ new (); ▁tc g _ gen _ mov _ tl ( t 1, ▁cpu _ ca ); ▁} ▁else ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( rgb 15 to b gr 24 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁int ▁src _ size ) ▁{ ▁const ▁uint 16_ t ▁* end ; ▁const ▁uint 16_ t ▁* mm _ end ; ▁uint 8_ t ▁* d ▁= ▁dst ; ▁const ▁uint 16_ t ▁* s ▁= ▁( const ▁uint 16_ t *) src ; ▁end ▁= ▁s ▁+ ▁src _ size /2 ; ▁__ asm __ ▁volatile ( PRE FETCH " ▁% 0 ": :" m " (* s ): " memory "); ▁mm _ end ▁= ▁end ▁- ▁7 ; ▁while ▁( s ▁< ▁mm _ end ) ▁{ ▁__ asm __ ▁volatile ( ▁PREF ETCH " ▁32 % 1 ▁\ n \ t " ▁" mov q ▁% 1, ▁%% mm 0 ▁\ n \ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁inet _ d gram _ opts ( Q emu Opts ▁* opts ) ▁{ ▁struct ▁addr info ▁ai , ▁* peer ▁= ▁NULL , ▁* local ▁= ▁NULL ; ▁const ▁char ▁* addr ; ▁const ▁char ▁* port ; ▁char ▁u addr [ INET 6_ ADDR STR LEN +1 ]; ▁char ▁u port [ 33 ]; ▁int ▁sock ▁= ▁-1, ▁rc ; ▁/* ▁lookup ▁peer ▁addr ▁*/ ▁mem set ( & ai , 0, ▁sizeof ( ai )); ▁ai . ai _ flags ▁= ▁AI _ CAN ON NAME ▁| ▁AI _ ADDR CONFIG ; ▁ai . ai _ family ▁= ▁P F _ UN SPEC ; ▁ai . ai _ sock type ▁= ▁SOCK _ D GRAM ; ▁addr ▁= ▁qemu _ opt _ get ( opts , ▁" host "); ▁po

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ file _ size ( FTP Context ▁* s ) ▁{ ▁char ▁command [ CONTROL _ BUFFER _ SIZE ]; ▁char ▁* res ▁= ▁NULL ; ▁const ▁int ▁size _ codes [] ▁= ▁{ 21 3, ▁0 }; ▁sn printf ( command , ▁sizeof ( command ), ▁" SIZE ▁% s \ r \ n ", ▁s -> path ); ▁if ▁( ftp _ send _ command ( s , ▁command , ▁size _ codes , ▁& res )) ▁{ ▁s -> files ize ▁= ▁str tol l ( & res [4 ], ▁NULL , ▁10); ▁} ▁else ▁{ ▁s -> files ize ▁= ▁-1; ▁av _ free ( res ); ▁return ▁A VER ROR ( E IO ); ▁} ▁av _ free ( res ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ q emu _ ld ( TC G Context ▁* s , ▁const ▁TC G Arg ▁* args , ▁bool ▁is _64 ) ▁{ ▁TC G Reg ▁dat al o , ▁data hi , ▁addr lo , ▁r base ; ▁TC G Reg ▁addr hi ▁__ attribute __ (( unused )); ▁TC G Mem Op Idx ▁o i ; ▁TC G Mem Op ▁op c , ▁s _ bits ; ▁# if def ▁CONFIG _ SO FT MM U ▁int ▁mem _ index ; ▁tc g _ ins n _ unit ▁* label _ ptr ; ▁# end if ▁dat al o ▁= ▁* args ++; ▁data hi ▁= ▁( TC G _ TARGET _ REG _ BITS ▁== ▁32 ▁&& ▁is _64 ▁? ▁* args ++ ▁: ▁0); ▁addr lo ▁= ▁* args ++; ▁addr hi ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ decode _ ref _ pic _ mark ing ( const ▁H 264 Context ▁* h , ▁H 264 Slice Context ▁* sl , ▁Get Bit Context ▁* gb ) ▁{ ▁int ▁i ; ▁MM CO ▁* mm co ▁= ▁sl -> mm co ; ▁int ▁nb _ mm co ▁= ▁0; ▁if ▁( h -> nal _ unit _ type ▁== ▁N AL _ ID R _ S LI CE ) ▁{ ▁// ▁FIX ME ▁fields ▁skip _ bits 1( gb ); ▁// ▁broken _ link ▁if ▁( get _ bits 1( gb )) ▁{ ▁mm co [0]. op code ▁= ▁MM CO _ LONG ; ▁mm co [0]. long _ arg ▁= ▁0; ▁nb _ mm co ▁= ▁1; ▁} ▁sl -> explicit _ ref _ mark ing ▁= ▁1; ▁} ▁else ▁{ ▁sl -> exp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ sh 4_ in validate _ tl b ( CP USH 4 State ▁* s ) ▁{ ▁int ▁i ; ▁/* ▁UT LB ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁UT LB _ SIZE ; ▁i ++) ▁{ ▁tl b _ t ▁* ▁entry ▁= ▁& s -> ut lb [ i ]; ▁entry -> v ▁= ▁0; ▁} ▁/* ▁I TL B ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁UT LB _ SIZE ; ▁i ++) ▁{ ▁tl b _ t ▁* ▁entry ▁= ▁& s -> ut lb [ i ]; ▁entry -> v ▁= ▁0; ▁} ▁tl b _ flush ( s , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 16_ t ▁net _ checksum _ finish ( uint 32_ t ▁sum ) ▁{ ▁while ▁( sum >> 16) ▁sum ▁= ▁( sum ▁& ▁0 xFFFF )+ ( sum ▁>> ▁16 ); ▁return ▁~ sum ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ init _ mask _ bridge ( PC ID evice ▁* d ) ▁{ ▁/* ▁P CI _ PRI MARY _ B US , ▁P CI _ SECOND ARY _ B US , ▁P CI _ SUB ORD IN ATE _ B US ▁and ▁P CI _ SEC _ LETE NCY _ T IMER ▁*/ ▁mem set ( d -> w mask ▁+ ▁P CI _ PRI MARY _ B US , ▁0 xff , ▁4 ); ▁/* ▁base ▁and ▁limit ▁*/ ▁d -> w mask [ PC I _ IO _ BASE ] ▁= ▁P CI _ IO _ RANGE _ MASK ▁& ▁0 xff ; ▁d -> w mask [ PC I _ IO _ LIMIT ] ▁= ▁P CI _ IO _ RANGE _ MASK ▁& ▁0 xff ; ▁pci _ set _ word ( d -> w mask ▁+ ▁P CI _ MEMORY _ BASE , ▁P CI _ MEMO

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Translation Block ▁* tb _ alloc ( target _ ulong ▁pc ) ▁{ ▁Translation Block ▁* tb ; ▁TB Context ▁* ctx ; ▁assert _ tb _ locked (); ▁tb ▁= ▁tc g _ tb _ alloc ( & tc g _ ctx ); ▁if ▁( un likely ( tb ▁== ▁NULL )) ▁{ ▁return ▁NULL ; ▁} ▁ctx ▁= ▁& tc g _ ctx . tb _ ctx ; ▁if ▁( un likely ( ctx -> nb _ t bs ▁== ▁ctx -> t bs _ size )) ▁{ ▁ctx -> t bs _ size ▁*= ▁2; ▁ctx -> t bs ▁= ▁g _ re new ( Translation Block ▁* , ▁ctx -> t bs , ▁ctx -> t bs _ size ); ▁} ▁ctx -> t bs [ ctx -> nb _ t bs ++ ] ▁= ▁tb ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁g poll fds _ from _ select ( void ) ▁{ ▁int ▁fd ; ▁for ▁( fd ▁= ▁0; ▁fd ▁<= ▁nf ds ; ▁fd ++) ▁{ ▁int ▁events ▁= ▁0; ▁if ▁( FD _ ISSET ( fd , ▁& rf ds )) ▁{ ▁events ▁|= ▁G _ IO _ IN ▁| ▁G _ IO _ H UP ▁| ▁G _ IO _ ERR ; ▁} ▁if ▁( FD _ ISSET ( fd , ▁& w fds )) ▁{ ▁events ▁|= ▁G _ IO _ OUT ▁| ▁G _ IO _ ERR ; ▁} ▁if ▁( FD _ ISSET ( fd , ▁& xf ds )) ▁{ ▁events ▁|= ▁G _ IO _ PRI ; ▁} ▁if ▁( events ) ▁{ ▁G Poll FD ▁p fd ▁= ▁{ ▁. fd ▁= ▁fd , ▁. events ▁= ▁events , ▁}; ▁g _ array _ append _ val ( g p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁T iff Context ▁* const ▁s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* const ▁p ▁= ▁data ; ▁Thread Frame ▁frame ▁= ▁{ ▁. f ▁= ▁data ▁}; ▁unsigned ▁off ; ▁int ▁le , ▁ret , ▁plane , ▁plan es ; ▁int ▁i , ▁j , ▁entries , ▁stride ; ▁unsigned ▁so ff , ▁s size ; ▁uint 8_ t ▁* dst ; ▁Get Byte Context ▁strip sizes ; ▁Get Byte Context ▁strip data ; ▁by test ream 2_ init ( & s -> gb , ▁av pk t ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁attribute _ align _ arg ▁av codec _ decode _ video 2( AV Codec Context ▁* av ctx , ▁AV Frame ▁* picture , ▁int ▁* got _ picture _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁int ▁ret ; ▁* got _ picture _ ptr ▁= ▁0; ▁if ▁(( av ctx -> coded _ width ▁|| ▁av ctx -> coded _ height ) ▁&& ▁av _ image _ check _ size ( av ctx -> coded _ width , ▁av ctx -> coded _ height , ▁0, ▁av ctx )) ▁return ▁-1; ▁av ctx -> pk t ▁= ▁av pk t ; ▁apply _ param _ change ( av ctx , ▁av pk t ); ▁av codec _ get _ frame _ defaults ( pictur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁meg as as _ pd _ get _ info _ submit ( SC S ID evice ▁* s dev , ▁int ▁lun , ▁M eg as as Cmd ▁* cmd ) ▁{ ▁struct ▁mf i _ pd _ info ▁* info ▁= ▁cmd -> io v _ buf ; ▁size _ t ▁d cmd _ size ▁= ▁sizeof ( struct ▁mf i _ pd _ info ); ▁uint 64_ t ▁pd _ size ; ▁uint 16_ t ▁pd _ id ▁= ▁(( s dev -> id ▁& ▁0 xFF ) ▁<< ▁8) ▁| ▁( lun ▁& ▁0 xFF ); ▁uint 8_ t ▁cmd buf [6 ]; ▁SC SI Request ▁* req ; ▁size _ t ▁len , ▁resid ; ▁if ▁(! cmd -> io v _ buf ) ▁{ ▁cmd -> io v _ buf ▁= ▁g _ m alloc 0( d cmd _ size ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ is el ( Dis as Context ▁* ctx ) ▁{ ▁int ▁l 1, ▁l 2; ▁uint 32_ t ▁bi ▁= ▁r C ( ctx -> op code ); ▁uint 32_ t ▁mask ; ▁TC G v _ i 32 ▁t 0; ▁l 1 ▁= ▁gen _ new _ label (); ▁l 2 ▁= ▁gen _ new _ label (); ▁mask ▁= ▁0 x 08 ▁>> ▁( bi ▁& ▁0 x 03 ); ▁t 0 ▁= ▁tc g _ temp _ new _ i 32 (); ▁tc g _ gen _ and i _ i 32 ( t 0, ▁cpu _ cr f [ bi ▁>> ▁2], ▁mask ); ▁tc g _ gen _ br con di _ i 32 ( TC G _ COND _ EQ , ▁t 0, ▁0, ▁l 1); ▁if ▁( r A ( ctx -> op code ) ▁== ▁0) ▁tc g _ gen _ mov i _ tl ( cpu _ g 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁stream _ process _ mem 2 s ( struct ▁Stream ▁* s , ▁Stream Slave ▁* tx _ dev ) ▁{ ▁uint 32_ t ▁prev _ d ; ▁unsigned ▁char ▁tx buf [ 16 ▁* ▁1024 ]; ▁unsigned ▁int ▁tx len ; ▁uint 32_ t ▁app [6 ]; ▁if ▁(! stream _ running ( s ) ▁|| ▁stream _ idle ( s )) ▁{ ▁return ; ▁} ▁while ▁(1) ▁{ ▁stream _ desc _ load ( s , ▁s -> re gs [ R _ CUR DESC ]); ▁if ▁( s -> desc . status ▁& ▁S DESC _ STATUS _ COMPLETE ) ▁{ ▁s -> re gs [ R _ DM AS R ] ▁|= ▁DM AS R _ H AL TED ; ▁break ; ▁} ▁if ▁( stream _ desc _ so

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ad pc m _ decode _ init ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁AD PC M Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁if ( av ctx -> channels ▁> ▁2 U ){ ▁return ▁-1; ▁} ▁c -> channel ▁= ▁0; ▁c -> status [0]. predict or ▁= ▁c -> status [1]. predict or ▁= ▁0; ▁c -> status [0]. step _ index ▁= ▁c -> status [1]. step _ index ▁= ▁0; ▁c -> status [0]. step ▁= ▁c -> status [1]. step ▁= ▁0; ▁switch ( av ctx -> codec -> id ) ▁{ ▁case ▁CODE C _ ID _ AD PC M _ CT : ▁c -> status [0]. step ▁= ▁c -> status [1]. s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁bt _ h ci _ event _ complete _ read _ local _ name ( struct ▁bt _ h ci _ s ▁* h ci ) ▁{ ▁read _ local _ name _ rp ▁params ; ▁params . status ▁= ▁H CI _ SUCCESS ; ▁mem set ( params . name , ▁0, ▁sizeof ( params . name )); ▁if ▁( h ci -> device . l mp _ name ) ▁str nc py ( params . name , ▁h ci -> device . l mp _ name , ▁sizeof ( params . name )); ▁bt _ h ci _ event _ complete ( h ci , ▁& params , ▁READ _ LOCAL _ NAME _ RP _ SIZE ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁v nc _ should _ update ( V nc State ▁* vs ) ▁{ ▁switch ▁( vs -> update ) ▁{ ▁case ▁V NC _ STATE _ UPDATE _ NONE : ▁break ; ▁case ▁V NC _ STATE _ UPDATE _ IN CREMENT AL : ▁/* ▁Only ▁allow ▁incremental ▁updates ▁if ▁the ▁output ▁buffer ▁* ▁is ▁empty , ▁or ▁if ▁audio ▁capture ▁is ▁enabled . ▁*/ ▁if ▁(! vs -> output . offset ▁|| ▁vs -> audio _ cap ) ▁{ ▁return ▁true ; ▁} ▁break ; ▁case ▁V NC _ STATE _ UPDATE _ FOR CE : ▁return ▁true ; ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str tol l _ whitespace ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" ▁\ t ▁"; ▁char ▁f ▁= ▁' X '; ▁const ▁char ▁* end ptr ▁= ▁& f ; ▁int 64_ t ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str tol l ( str , ▁& end ptr , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert _ cmp int ( res , ▁== , ▁0); ▁g _ assert ( end ptr ▁== ▁str ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ migrate ( void ) ▁{ ▁char ▁* uri ▁= ▁g _ str dup _ printf (" unix :% s / mig socket ", ▁tmp fs ); ▁Q Test State ▁* global ▁= ▁global _ q test , ▁* from , ▁* to ; ▁unsigned ▁char ▁dest _ byte _ a , ▁dest _ byte _ b , ▁dest _ byte _ c , ▁dest _ byte _ d ; ▁g char ▁* cmd ; ▁Q Dict ▁* r sp ; ▁char ▁* boot path ▁= ▁g _ str dup _ printf ("% s / boot sect ", ▁tmp fs ); ▁FILE ▁* boot file ▁= ▁f open ( boot path , ▁" wb "); ▁got _ stop ▁= ▁false ; ▁g _ assert _ cmp int ( f write ( boot sect ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 8_ t ▁net _ tx _ pk t _ get _ gs o _ type ( struct ▁Net Tx P kt ▁* pk t , ▁bool ▁t so _ enable ) ▁{ ▁uint 8_ t ▁rc ▁= ▁VI RT IO _ NET _ H DR _ G SO _ NONE ; ▁uint 16_ t ▁l 3_ proto ; ▁l 3_ proto ▁= ▁eth _ get _ l 3_ proto ( pk t -> vec [ NET _ TX _ PK T _ L 2 H DR _ FR AG ]. io v _ base , ▁pkt -> vec [ NET _ TX _ PK T _ L 2 H DR _ FR AG ]. io v _ len ); ▁if ▁(! t so _ enable ) ▁{ ▁goto ▁func _ exit ; ▁} ▁rc ▁= ▁eth _ get _ gs o _ type ( l 3_ proto , ▁pkt -> vec [ NET _ TX _ PK T _ L 3 H DR _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ req _ length ( SC SI Request ▁* req , ▁uint 8_ t ▁* cmd ) ▁{ ▁switch ▁( cmd [0] ▁>> ▁5) ▁{ ▁case ▁0: ▁req -> cmd . x fer ▁= ▁cmd [4 ]; ▁req -> cmd . len ▁= ▁6 ; ▁/* ▁length ▁0 ▁means ▁256 ▁blocks ▁*/ ▁if ▁( req -> cmd . x fer ▁== ▁0) ▁req -> cmd . x fer ▁= ▁256 ; ▁break ; ▁case ▁1: ▁case ▁2: ▁req -> cmd . x fer ▁= ▁cmd [ 8] ▁| ▁( cmd [ 7] ▁<< ▁8 ); ▁req -> cmd . len ▁= ▁10; ▁break ; ▁case ▁4: ▁req -> cmd . x fer ▁= ▁cmd [1 3] ▁| ▁( cmd [ 12 ] ▁<< ▁8) ▁| ▁( cmd [ 11 ] ▁<< ▁16 ) ▁| ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ sch ro _ queue _ push _ back ( FF Sch ro Queue ▁* queue , ▁void ▁* p _ data ) ▁{ ▁F FS ch ro Queue Element ▁* p _ new ▁= ▁av _ m alloc z ( size of ( FF Sch ro Queue Element )); ▁if ▁(! p _ new ) ▁return ▁-1; ▁p _ new -> data ▁= ▁p _ data ; ▁if ▁(! queue -> p _ head ) ▁queue -> p _ head ▁= ▁p _ new ; ▁else ▁queue -> p _ tail -> next ▁= ▁p _ new ; ▁queue -> p _ tail ▁= ▁p _ new ; ▁++ queue -> size ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm pp c _ reset _ ht ab ( int ▁shift _ hint ) ▁{ ▁uint 32_ t ▁shift ▁= ▁shift _ hint ; ▁if ▁(! k vm _ enabled ()) ▁{ ▁/* ▁Full ▁em ulation , ▁tell ▁caller ▁to ▁allocate ▁ht ab ▁itself ▁*/ ▁return ▁0; ▁} ▁if ▁( k vm _ check _ extension ( k vm _ state , ▁K VM _ CAP _ P PC _ AL LOC _ HT AB )) ▁{ ▁int ▁ret ; ▁ret ▁= ▁k vm _ vm _ io ctl ( k vm _ state , ▁K VM _ P PC _ AL LOC ATE _ HT AB , ▁& shift ); ▁if ▁( ret ▁== ▁- EN OT TY ) ▁{ ▁/* ▁At ▁least ▁some ▁versions ▁of ▁PR ▁K VM ▁advert ise ▁the ▁* ▁capab

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁p tx _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁P TX Context ▁* ▁const ▁s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁AV Frame ▁* ▁const ▁p ▁= ▁& s -> picture ; ▁unsigned ▁int ▁offset , ▁w , ▁h , ▁y , ▁stride , ▁bytes _ per _ pixel ; ▁uint 8_ t ▁* ptr ; ▁offset ▁= ▁AV _ RL 16 ( buf ); ▁w ▁= ▁AV _ RL 16 ( buf + 8 ); ▁h ▁= ▁AV _ RL 16 ( buf + 10 ); ▁bytes _ per

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vpc _ close ( Block Driver State ▁* bs ) ▁{ ▁B DR V V PC State ▁* s ▁= ▁bs -> op aque ; ▁g _ free ( s -> pag etable ); ▁# if def ▁CACHE ▁g _ free ( s -> page entry _ u 8 ); ▁# end if ▁migrate _ del _ block er ( s -> migration _ block er ); ▁error _ free ( s -> migration _ block er ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁PO WER PC _ FAMILY ( PO WER 9) ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( oc ); ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ CLASS ( oc ); ▁CPU Class ▁* cc ▁= ▁CPU _ CLASS ( oc ); ▁dc -> fw _ name ▁= ▁" Power PC , PO WER 9 "; ▁dc -> desc ▁= ▁" PO WER 9 "; ▁dc -> props ▁= ▁power pc _ server cpu _ properties ; ▁p cc -> pv r _ match ▁= ▁p pc _ pv r _ match _ power 9 ; ▁p cc -> pc r _ mask ▁= ▁P CR _ COMP AT _2 _0 5 ▁| ▁P CR _ COMP AT _2 _0 6 ▁| ▁P CR _ COMP AT _2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁M XF Context ▁* mx f ▁= ▁s -> priv _ data ; ▁K LV Packet ▁k lv ; ▁int 64_ t ▁ess ence _ offset ▁= ▁0; ▁mx f -> last _ forward _ t ell ▁= ▁INT 64_ MAX ; ▁if ▁(! mx f _ read _ sync ( s -> pb , ▁mx f _ header _ partition _ pack _ key , ▁14 )) ▁{ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" could ▁not ▁find ▁header ▁partition ▁pack ▁key \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁av io _ seek ( s -> pb , ▁- 14, ▁S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁op j _ image _ t ▁* m j 2_ create _ image ( AV Codec Context ▁* av ctx , ▁op j _ c parameters _ t ▁* parameters ) ▁{ ▁const ▁AV Pix F mt Descriptor ▁* desc ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> pix _ fmt ); ▁op j _ image _ cm pt par m _ t ▁cm pt par m [4] ▁= ▁{{ 0 }} ; ▁op j _ image _ t ▁* img ; ▁int ▁i ; ▁int ▁sub _ dx [4 ]; ▁int ▁sub _ dy [4 ]; ▁int ▁num com ps ; ▁OP J _ COLOR _ SPACE ▁color _ space ▁= ▁CL R SP C _ UNKNOWN ; ▁sub _ dx [0] ▁= ▁sub _ dx [3] ▁= ▁1; ▁sub _ dy [0] ▁= ▁sub _ dy

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁xen _ platform _ init fn ( PC ID evice ▁* dev ) ▁{ ▁P CI X en Platform State ▁* d ▁= ▁DO _ UP CAST ( PC IX en Platform State , ▁pci _ dev , ▁dev ); ▁uint 8_ t ▁* pc i _ conf ; ▁pci _ conf ▁= ▁d -> pc i _ dev . config ; ▁pci _ set _ word ( pc i _ conf ▁+ ▁P CI _ COMMAND , ▁P CI _ COMMAND _ IO ▁| ▁P CI _ COMMAND _ MEMORY ); ▁pci _ config _ set _ prog _ interface ( pc i _ conf , ▁0); ▁pci _ conf [ PC I _ INTER R UP T _ P IN ] ▁= ▁1; ▁pci _ register _ bar ( & d -> pc i _ dev , ▁0, ▁0 x 100, ▁P C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁proxy _ symlink ( Fs Context ▁* fs _ ctx , ▁const ▁char ▁* old path , ▁V 9 fs Path ▁* dir _ path , ▁const ▁char ▁* name , ▁Fs Cred ▁* cre dp ) ▁{ ▁int ▁retval ; ▁V 9 fs String ▁fullname , ▁target ; ▁v 9 fs _ string _ init ( & fullname ); ▁v 9 fs _ string _ init ( & target ); ▁v 9 fs _ string _ sp rint f ( & fullname , ▁"% s /% s ", ▁dir _ path -> data , ▁name ); ▁v 9 fs _ string _ sp rint f ( & target , ▁"% s ", ▁old path ); ▁retval ▁= ▁v 9 fs _ request ( fs _ ctx -> private , ▁T _ SY M LINK

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vf io _ enable _ int x ( V FI O Device ▁* v dev ) ▁{ ▁V FI O IR Q Set FD ▁irq _ set _ fd ▁= ▁{ ▁. irq _ set ▁= ▁{ ▁. args z ▁= ▁sizeof ( irq _ set _ fd ), ▁. flags ▁= ▁V FI O _ IR Q _ SET _ DATA _ EVENT FD ▁| ▁V FI O _ IR Q _ SET _ ACTION _ TRI GGER , ▁. index ▁= ▁V FI O _ PC I _ INT X _ IR Q _ INDEX , ▁. start ▁= ▁0, ▁. count ▁= ▁1, ▁}, ▁}; ▁uint 8_ t ▁pin ▁= ▁vf io _ pc i _ read _ config ( & v dev -> pd ev , ▁P CI _ INTER R UP T _ P IN , ▁1); ▁int ▁ret ; ▁if ▁( v dev -> int x . disabled ▁|

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( mvc )( CP US 390 X State ▁* env , ▁uint 32_ t ▁l , ▁uint 64_ t ▁dest , ▁uint 64_ t ▁src ) ▁{ ▁int ▁i ▁= ▁0; ▁int ▁x ▁= ▁0; ▁uint 32_ t ▁l _64 ▁= ▁( l ▁+ ▁1) ▁/ ▁8 ; ▁HEL PER _ LOG ("% s ▁l ▁% d ▁dest ▁% " ▁PRI x 64 ▁" ▁src ▁% " ▁PRI x 64 ▁"\ n ", ▁__ func __, ▁l , ▁dest , ▁src ); ▁# if nd ef ▁CONFIG _ USER _ ONLY ▁if ▁(( l ▁> ▁3 2) ▁&& ▁( src ▁& ▁TARGET _ PAGE _ MASK ) ▁== ▁(( src ▁+ ▁l ) ▁& ▁TARGET _ PAGE _ MASK ) ▁&& ▁( dest ▁& ▁TARGET _ PAGE _ MASK ) ▁== ▁(( dest ▁+ ▁l ) ▁& ▁TARGET _ P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ store _ f pc r ▁( uint 64_ t ▁val ) ▁{ ▁# if def ▁CONFIG _ SO FT FLOAT ▁set _ float _ exception _ flags (( val ▁>> ▁5 2) ▁& ▁0 x 3 F , ▁& FP _ STATUS ); ▁# end if ▁switch ▁(( val ▁>> ▁5 8) ▁& ▁3) ▁{ ▁case ▁0: ▁set _ float _ rounding _ mode ( float _ round _ to _ zero , ▁& FP _ STATUS ); ▁break ; ▁case ▁1: ▁set _ float _ rounding _ mode ( float _ round _ down , ▁& FP _ STATUS ); ▁break ; ▁case ▁2: ▁set _ float _ rounding _ mode ( float _ round _ nearest _ even , ▁& FP _ STATUS ); ▁break ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sp ap r _ t ce _ set _ b yp ass ( s P AP RT CE Table ▁* tc et , ▁bool ▁bypass ) ▁{ ▁tc et -> b yp ass ▁= ▁bypass ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ system _ w ake up _ request ( Wake up Reason ▁reason ) ▁{ ▁if ▁(! is _ s uspended ) ▁{ ▁return ; ▁} ▁if ▁(! ( w ake up _ reason _ mask ▁& ▁(1 ▁<< ▁reason ))) ▁{ ▁return ; ▁} ▁run state _ set ( RUN _ STATE _ RUN NING ); ▁monitor _ protocol _ event ( Q EVENT _ WA KE UP , ▁NULL ); ▁notifier _ list _ notify ( & w ake up _ not ifiers , ▁& reason ); ▁reset _ requested ▁= ▁1; ▁qemu _ notify _ event (); ▁is _ s uspended ▁= ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rt sp _ listen ( AV Format Context ▁* s ) ▁{ ▁RT SP State ▁* rt ▁= ▁s -> priv _ data ; ▁char ▁proto [ 128 ], ▁host [ 128 ], ▁path [ 512 ], ▁auth [ 128 ]; ▁char ▁uri [ 500 ]; ▁int ▁port ; ▁int ▁default _ port ▁= ▁RT SP _ DEFAULT _ PORT ; ▁char ▁tcp name [ 500 ]; ▁const ▁char ▁* lower _ proto ▁= ▁" tcp "; ▁unsigned ▁char ▁r buf [ 40 96 ]; ▁unsigned ▁char ▁method [10 ]; ▁int ▁r buf len ▁= ▁0; ▁int ▁ret ; ▁enum ▁RT SP Method ▁method code ; ▁if ▁(! rt -> protocols ) ▁{ ▁rt -> protocols ▁= ▁ff url

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ w ma _ run _ level _ decode ( AV Codec Context ▁* av ctx , ▁Get Bit Context ▁* gb , ▁V LC ▁* vlc , ▁const ▁float ▁* level _ table , ▁const ▁uint 16_ t ▁* run _ table , ▁int ▁version , ▁W MAC o ef ▁* ptr , ▁int ▁offset , ▁int ▁num _ co efs , ▁int ▁block _ len , ▁int ▁frame _ len _ bits , ▁int ▁coef _ nb _ bits ) ▁{ ▁int ▁code , ▁level , ▁sign ; ▁const ▁uint 32_ t ▁* il vl ▁= ▁( const ▁uint 32_ t ▁* ) ▁level _ table ; ▁uint 32_ t ▁* ip tr ▁= ▁( uint 32_ t ▁* ) ▁ptr ; ▁const ▁unsigned ▁int ▁coef _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av filter _ graph _ parse ( AV Filter Graph ▁* graph , ▁const ▁char ▁* filters , ▁AV Filter In Out ▁* open _ inputs , ▁AV Filter In Out ▁* open _ outputs , ▁AV Class ▁* log _ ctx ) ▁{ ▁int ▁index ▁= ▁0, ▁ret ; ▁char ▁chr ▁= ▁0; ▁AV Filter In Out ▁* curr _ inputs ▁= ▁NULL ; ▁do ▁{ ▁AV Filter Context ▁* filter ; ▁filters ▁+= ▁str sp n ( filters , ▁WH ITESPACE S ); ▁if ▁(( ret ▁= ▁parse _ inputs ( & filters , ▁& curr _ inputs , ▁& open _ outputs , ▁log _ ctx )) ▁< ▁0) ▁goto ▁fail ; ▁if ▁(( ret ▁= ▁pars

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ net _ device _ exit ( Device State ▁* q dev ) ▁{ ▁V irt ION et ▁* n ▁= ▁VI RT IO _ NET ( q dev ); ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( q dev ); ▁int ▁i ; ▁/* ▁This ▁will ▁stop ▁v host ▁backend ▁if ▁appropriate . ▁*/ ▁virt io _ net _ set _ status ( v dev , ▁0); ▁unregister _ save vm ( q dev , ▁" virt io - net ", ▁n ); ▁if ▁( n -> net client _ name ) ▁{ ▁g _ free ( n -> net client _ name ); ▁n -> net client _ name ▁= ▁NULL ; ▁} ▁if ▁( n -> net client _ type ) ▁{ ▁g _ fre

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ ne on _ w iden ( TC G v ▁dest , ▁TC G v ▁src , ▁int ▁size , ▁int ▁u ) ▁{ ▁if ▁( u ) ▁{ ▁switch ▁( size ) ▁{ ▁case ▁0: ▁gen _ helper _ ne on _ w iden _ u 8 ( dest , ▁src ); ▁break ; ▁case ▁1: ▁gen _ helper _ ne on _ w iden _ u 16 ( dest , ▁src ); ▁break ; ▁case ▁2: ▁tc g _ gen _ ext u _ i 32_ i 64 ( dest , ▁src ); ▁break ; ▁default : ▁abort (); ▁} ▁} ▁else ▁{ ▁switch ▁( size ) ▁{ ▁case ▁0: ▁gen _ helper _ ne on _ w iden _ s 8 ( dest , ▁src ); ▁break ; ▁case ▁1: ▁gen _ helper _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sd _ create _ branch ( B DR V Sh eep dog State ▁* s ) ▁{ ▁int ▁ret , ▁fd ; ▁uint 32_ t ▁vid ; ▁char ▁* buf ; ▁d printf ("% " ▁PRI x 32 ▁" ▁is ▁snapshot .\ n ", ▁s -> in ode . v di _ id ); ▁buf ▁= ▁g _ m alloc ( SD _ IN ODE _ SIZE ); ▁ret ▁= ▁do _ sd _ create ( s -> name , ▁s -> in ode . v di _ size , ▁s -> in ode . v di _ id , ▁& vid , ▁1, ▁s -> addr , ▁s -> port ); ▁if ▁( ret ) ▁{ ▁goto ▁out ; ▁} ▁d printf ("% " ▁PRI x 32 ▁" ▁is ▁created .\ n ", ▁vid ); ▁fd ▁= ▁connect _ to _ sd og ( s -> a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ uint 8 ( Device State ▁* dev , ▁Property ▁* prop , ▁const ▁char ▁* str ) ▁{ ▁uint 8_ t ▁* ptr ▁= ▁q dev _ get _ prop _ ptr ( dev , ▁prop ); ▁const ▁char ▁* fmt ; ▁/* ▁accept ▁both ▁hex ▁and ▁decimal ▁*/ ▁fmt ▁= ▁str n case cmp ( str , ▁"0 x ", 2) ▁== ▁0 ▁? ▁"% " ▁PRI x 8 ▁: ▁"% " ▁PRI u 8 ; ▁if ▁( ss can f ( str , ▁fmt , ▁ptr ) ▁!= ▁1) ▁return ▁- E IN VAL ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁sw ri _ rem atrix _ init ( S wr Context ▁* s ){ ▁int ▁i , ▁j ; ▁int ▁nb _ in ▁= ▁av _ get _ channel _ layout _ nb _ channels ( s -> in _ ch _ layout ); ▁int ▁nb _ out ▁= ▁av _ get _ channel _ layout _ nb _ channels ( s -> out _ ch _ layout ); ▁s -> mix _ any _ f ▁= ▁NULL ; ▁if ▁(! s -> rem atrix _ custom ) ▁{ ▁int ▁r ▁= ▁auto _ matrix ( s ); ▁if ▁( r ) ▁return ▁r ; ▁} ▁if ▁( s -> mid buf . fmt ▁== ▁AV _ SA MPLE _ F MT _ S 16 P ){ ▁s -> native _ matrix ▁= ▁av _ cal loc ( nb _ in ▁* ▁nb _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁s 39 0_ machine _ reset ( void ) ▁{ ▁S 390 CPU ▁* i pl _ cpu ▁= ▁S 39 0_ CPU ( q emu _ get _ cpu (0 )); ▁qemu _ devices _ reset (); ▁s 39 0_ cm ma _ reset (); ▁s 39 0_ crypto _ reset (); ▁/* ▁all ▁cpus ▁are ▁stopped ▁- ▁configure ▁and ▁start ▁the ▁i pl ▁cpu ▁only ▁*/ ▁s 39 0_ i pl _ prepare _ cpu ( i pl _ cpu ); ▁s 39 0_ cpu _ set _ state ( CPU _ STATE _ O PER ATING , ▁i pl _ cpu ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁f ic _ decode _ block ( FI C Context ▁* ctx , ▁Get Bit Context ▁* gb , ▁uint 8_ t ▁* dst , ▁int ▁stride , ▁int 16_ t ▁* block ) ▁{ ▁int ▁i , ▁num _ coeff ; ▁/* ▁Is ▁it ▁a ▁skip ▁block ? ▁*/ ▁if ▁( get _ bits 1( gb )) ▁{ ▁/* ▁This ▁is ▁a ▁P - frame . ▁*/ ▁ctx -> frame -> key _ frame ▁= ▁0; ▁ctx -> frame -> p ict _ type ▁= ▁AV _ PI CT URE _ TYPE _ P ; ▁return ▁0; ▁} ▁mem set ( block , ▁0, ▁sizeof (* block ) ▁* ▁64 ); ▁num _ coeff ▁= ▁get _ bits ( gb , ▁7 ); ▁if ▁( num _ coeff ▁> ▁64 ) ▁return 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ rt sp _ undo _ setup ( AV Format Context ▁* s , ▁int ▁send _ pack ets ) ▁{ ▁RT SP State ▁* rt ▁= ▁s -> priv _ data ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁rt -> nb _ rt sp _ streams ; ▁i ++) ▁{ ▁RT SP Stream ▁* rt sp _ st ▁= ▁rt -> rt sp _ streams [ i ]; ▁if ▁(! rt sp _ st ) ▁continue ; ▁if ▁( rt sp _ st -> transport _ priv ) ▁{ ▁if ▁( s -> o format ) ▁{ ▁AV Format Context ▁* r tp ctx ▁= ▁rt sp _ st -> transport _ priv ; ▁av _ write _ trail er ( r tp ctx ); ▁if ▁( rt -> lower _ transport ▁== ▁RT S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ token _ in ( US B Device ▁* s , ▁USB Packet ▁* p ) ▁{ ▁int ▁request , ▁value , ▁index ; ▁assert ( p -> ep -> nr ▁== ▁0); ▁request ▁= ▁( s -> setup _ buf [0] ▁<< ▁8) ▁| ▁s -> setup _ buf [1]; ▁value ▁= ▁( s -> setup _ buf [3] ▁<< ▁8) ▁| ▁s -> setup _ buf [2 ]; ▁index ▁= ▁( s -> setup _ buf [5] ▁<< ▁8) ▁| ▁s -> setup _ buf [4 ]; ▁switch ( s -> setup _ state ) ▁{ ▁case ▁SET UP _ STATE _ ACK : ▁if ▁(! ( s -> setup _ buf [0] ▁& ▁USB _ DIR _ IN )) ▁{ ▁usb _ device _ handle _ control ( s , ▁p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ video _ buffer ( AV Frame ▁* frame , ▁int ▁align ) ▁{ ▁const ▁AV Pix F mt Descriptor ▁* desc ▁= ▁av _ pix _ fmt _ desc _ get ( frame -> format ); ▁int ▁ret , ▁i ; ▁if ▁(! desc ) ▁return ▁A VER ROR ( E IN VAL ); ▁if ▁(( ret ▁= ▁av _ image _ check _ size ( frame -> width , ▁frame -> height , ▁0, ▁NULL )) ▁< ▁0) ▁return ▁ret ; ▁if ▁(! frame -> lines ize [0]) ▁{ ▁ret ▁= ▁av _ image _ fill _ lines izes ( frame -> lines ize , ▁frame -> format , ▁frame -> width ); ▁if ▁( ret ▁< ▁0) ▁return ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ get _ ms rs ( X 86 CPU ▁* cpu ) ▁{ ▁CPU X 86 State ▁* env ▁= ▁& cpu -> env ; ▁struct ▁k vm _ ms r _ entry ▁* ms rs ▁= ▁cpu -> k vm _ ms r _ buf -> entries ; ▁int ▁ret , ▁i ; ▁uint 64_ t ▁m tr r _ top _ bits ; ▁k vm _ ms r _ buf _ reset ( cpu ); ▁k vm _ ms r _ entry _ add ( cpu , ▁MS R _ IA 32_ SY SENT ER _ CS , ▁0); ▁k vm _ ms r _ entry _ add ( cpu , ▁MS R _ IA 32_ SY SENT ER _ ES P , ▁0); ▁k vm _ ms r _ entry _ add ( cpu , ▁MS R _ IA 32_ SY SENT ER _ E IP , ▁0); ▁k vm _ ms r _ entry 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁host _ memory _ backend _ can _ be _ deleted ( User Cre atable ▁* uc , ▁Error ▁** err p ) ▁{ ▁Memory Region ▁* mr ; ▁mr ▁= ▁host _ memory _ backend _ get _ memory ( MEMORY _ BACK END ( uc ), ▁err p ); ▁if ▁( memory _ region _ is _ mapped ( mr )) ▁{ ▁return ▁false ; ▁} ▁else ▁{ ▁return ▁true ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff v 1_ init _ slice _ contexts ( FF V 1 Context ▁* f ) ▁{ ▁int ▁i ; ▁f -> slice _ count ▁= ▁f -> num _ h _ slices ▁* ▁f -> num _ v _ slices ; ▁if ▁( f -> slice _ count ▁<= ▁0) ▁{ ▁av _ log ( f -> av ctx , ▁AV _ LOG _ ERROR , ▁" Invalid ▁number ▁of ▁slices \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁f -> slice _ count ; ▁i ++) ▁{ ▁FF V 1 Context ▁* fs ▁= ▁av _ m alloc z ( size of (* fs )); ▁int ▁sx ▁= ▁i ▁% ▁f -> num _ h _ slices ; ▁int ▁sy ▁= ▁i ▁/ ▁f -> num _ h 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁o map _ p wt _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁value , ▁unsigned ▁size ) ▁{ ▁struct ▁o map _ p wt _ s ▁* s ▁= ▁( struct ▁o map _ p wt _ s ▁* ) ▁opaque ; ▁int ▁offset ▁= ▁addr ▁& ▁O MAP _ MP UI _ REG _ MASK ; ▁if ▁( size ▁!= ▁1) ▁{ ▁return ▁o map _ bad width _ write 8 ( op aque , ▁addr , ▁value ); ▁} ▁switch ▁( offset ) ▁{ ▁case ▁0 x 00 : ▁/* ▁F RC ▁*/ ▁s -> f rc ▁= ▁value ▁& ▁0 x 3 f ; ▁break ; ▁case ▁0 x 04 : ▁/* ▁V RC ▁*/ ▁if ▁(( value ▁^ ▁s -> v 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁predict or _ decode _ mon o ( A PE Context ▁* ctx , ▁int ▁count ) ▁{ ▁A PE Pred ictor ▁* p ▁= ▁& ctx -> predict or ; ▁int 32_ t ▁* decoded 0 ▁= ▁ctx -> decoded [0]; ▁int 32_ t ▁prediction A , ▁current A , ▁A , ▁sign ; ▁current A ▁= ▁p -> last A [0]; ▁while ▁( count --) ▁{ ▁A ▁= ▁* decoded 0; ▁p -> buf [ Y DELAY A ] ▁= ▁current A ; ▁p -> buf [ Y DELAY A ▁- ▁1] ▁= ▁p -> buf [ Y DELAY A ] ▁- ▁p -> buf [ Y DELAY A ▁- ▁1 ]; ▁prediction A ▁= ▁p -> buf [ Y DELAY A ▁] ▁* ▁p -> coeff s A [0][0] ▁+ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁print _ report ( AV Format Context ▁** output _ files , ▁AV OutputStream ▁** ost _ table , ▁int ▁nb _ ost ream s , ▁int ▁is _ last _ report ) ▁{ ▁char ▁buf [10 24 ]; ▁AV OutputStream ▁* ost ; ▁AV Format Context ▁* oc ; ▁int 64_ t ▁total _ size ; ▁AV Codec Context ▁* enc ; ▁int ▁frame _ number , ▁vid , ▁i ; ▁double ▁bitrate , ▁ti 1, ▁pts ; ▁static ▁int 64_ t ▁last _ time ▁= ▁-1; ▁static ▁int ▁qp _ histogram [ 52 ]; ▁if ▁(! is _ last _ report ) ▁{ ▁int 64_ t ▁cur _ time ; ▁/* ▁display ▁the ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁rv 40 _ strong _ loop _ filter ( uint 8_ t ▁* src , ▁const ▁int ▁step , ▁const ▁int ▁stride , ▁const ▁int ▁alpha , ▁const ▁int ▁l ims , ▁const ▁int ▁d mode , ▁const ▁int ▁chrom a ) ▁{ ▁int ▁i ; ▁for ( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++, ▁src ▁+= ▁stride ){ ▁int ▁s flag , ▁p 0, ▁q 0, ▁p 1, ▁q 1; ▁int ▁t ▁= ▁src [0 * step ] ▁- ▁src [-1 * step ]; ▁if ▁(! t ) ▁continue ; ▁s flag ▁= ▁( alpha ▁* ▁FF AB S ( t )) ▁>> ▁7 ; ▁if ▁( s flag ▁> ▁1) ▁continue ; ▁p 0 ▁= ▁( 25 * src [ -3 * step 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Device State ▁* q dev _ device _ add ( Q emu Opts ▁* opts , ▁Error ▁** err p ) ▁{ ▁Device Class ▁* dc ; ▁const ▁char ▁* driver , ▁* path ; ▁Device State ▁* dev ; ▁Bus State ▁* bus ▁= ▁NULL ; ▁Error ▁* err ▁= ▁NULL ; ▁driver ▁= ▁qemu _ opt _ get ( opts , ▁" driver "); ▁if ▁(! driver ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ MISS ING _ PARAMETER , ▁" driver "); ▁return ▁NULL ; ▁} ▁/* ▁find ▁driver ▁*/ ▁dc ▁= ▁q dev _ get _ device _ class ( & driver , ▁err p ); ▁if ▁(! dc ) ▁{ ▁return ▁NULL ; ▁} ▁/* ▁find ▁bus

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rv 10_ decode _ packet ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁int ▁buf _ size 2) ▁{ ▁R V Dec Context ▁* rv ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& rv -> m ; ▁int ▁mb _ count , ▁mb _ pos , ▁left , ▁start _ mb _ x , ▁active _ bits _ size , ▁ret ; ▁active _ bits _ size ▁= ▁buf _ size ▁* ▁8 ; ▁init _ get _ bits ( & s -> gb , ▁buf , ▁FF MAX ( buf _ size , ▁buf _ size 2) ▁* ▁8 ); ▁if ▁( s -> codec _ id ▁== ▁AV _ CODE C _ ID _ RV 10) ▁mb _ co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁cpu _ g db _ index ( CPU State ▁* cpu ) ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁return ▁cpu -> host _ tid ; ▁# else ▁return ▁cpu -> cpu _ index ▁+ ▁1; ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁* DEC _ U QU AD ( int ▁* dst , ▁unsigned ▁idx , ▁unsigned ▁sign ) ▁{ ▁unsigned ▁nz ▁= ▁idx ▁>> ▁12 ; ▁dst [0] ▁= ▁( idx ▁& ▁3) ▁* ▁(1 ▁+ ▁( (( int ) sign ▁>> ▁3 1) ▁<< ▁1 )); ▁sign ▁<<= ▁nz ▁& ▁1; ▁nz ▁>>= ▁1; ▁dst [1] ▁= ▁( idx ▁>> ▁2 ▁& ▁3) ▁* ▁(1 ▁+ ▁( (( int ) sign ▁>> ▁3 1) ▁<< ▁1 )); ▁sign ▁<<= ▁nz ▁& ▁1; ▁nz ▁>>= ▁1; ▁dst [2] ▁= ▁( idx ▁>> ▁4 ▁& ▁3) ▁* ▁(1 ▁+ ▁( (( int ) sign ▁>> ▁3 1) ▁<< ▁1 )); ▁sign ▁<<= ▁nz ▁& ▁1; ▁nz ▁>>= ▁1; ▁dst [3] ▁= ▁( idx ▁>> ▁6 ▁& ▁3) ▁* ▁(1 ▁+ ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h mp _ info _ block _ jobs ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁Block Job InfoList ▁* list ; ▁Error ▁* err ▁= ▁NULL ; ▁list ▁= ▁q mp _ query _ block _ jobs ( & err ); ▁assert (! err ); ▁if ▁(! list ) ▁{ ▁monitor _ printf ( mon , ▁" No ▁active ▁jobs \ n "); ▁return ; ▁} ▁while ▁( list ) ▁{ ▁if ▁( str cmp ( list -> value -> type , ▁" stream ") ▁== ▁0) ▁{ ▁monitor _ printf ( mon , ▁" Streaming ▁device ▁% s : ▁Completed ▁% " ▁PR Id 64 ▁" ▁of ▁% " ▁PR Id 64 ▁" ▁bytes , ▁speed ▁limit ▁% " ▁P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a trim _ filter _ frame ( AV Filter Link ▁* in link , ▁AV Frame ▁* frame ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁in link -> dst ; ▁Tr im Context ▁* s ▁= ▁ctx -> priv ; ▁int 64_ t ▁start _ sample , ▁end _ sample ▁= ▁frame -> nb _ samples ; ▁int 64_ t ▁pts ; ▁int ▁drop ; ▁/* ▁drop ▁everything ▁if ▁EOF ▁has ▁already ▁been ▁returned ▁*/ ▁if ▁( s -> eof ) ▁{ ▁av _ frame _ free ( & frame ); ▁return ▁0; ▁} ▁if ▁( frame -> pts ▁!= ▁AV _ NO PT S _ VALUE ) ▁pts ▁= ▁av _ res cale _ q ( frame -> pts , ▁in li

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ reg _ alloc _ call ( TC G Context ▁* s , ▁int ▁nb _ o args , ▁int ▁nb _ i args , ▁const ▁TC G Arg ▁* ▁const ▁args , ▁uint 16_ t ▁dead _ args , ▁uint 8_ t ▁sync _ args ) ▁{ ▁int ▁flags , ▁nb _ re gs , ▁i ; ▁TC G Reg ▁reg ; ▁TC G Arg ▁arg ; ▁TC G Temp ▁* ts ; ▁int ptr _ t ▁stack _ offset ; ▁size _ t ▁call _ stack _ size ; ▁tc g _ ins n _ unit ▁* func _ addr ; ▁int ▁allocate _ args ; ▁TC G Reg Set ▁allocated _ re gs ; ▁func _ addr ▁= ▁( tc g _ ins n _ unit ▁* )( int ptr _ t ) args [ nb 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁curl _ multi _ do ( void ▁* arg ) ▁{ ▁B DR VC URL State ▁* s ▁= ▁( B DR VC URL State ▁* ) arg ; ▁int ▁running ; ▁int ▁r ; ▁if ▁(! s -> multi ) ▁{ ▁return ; ▁} ▁do ▁{ ▁r ▁= ▁curl _ multi _ socket _ all ( s -> multi , ▁& running ); ▁} ▁while ( r ▁== ▁C URL M _ CALL _ MULTI _ PER FORM ); ▁curl _ multi _ read ( s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ff server _ save _ av option ( const ▁char ▁* opt , ▁const ▁char ▁* arg , ▁int ▁type , ▁FF Server Config ▁* config ) ▁{ ▁static ▁int ▁hint ed ▁= ▁0; ▁int ▁ret ▁= ▁0; ▁AV Dictionary Entry ▁* e ; ▁const ▁AV Option ▁* o ▁= ▁NULL ; ▁const ▁char ▁* option ▁= ▁NULL ; ▁const ▁char ▁* codec _ name ▁= ▁NULL ; ▁char ▁buff [10 24 ]; ▁AV Codec Context ▁* ctx ; ▁AV Dictionary ▁** dict ; ▁enum ▁AV Codec ID ▁guessed _ codec _ id ; ▁switch ▁( type ) ▁{ ▁case ▁AV _ OPT _ FLAG _ VI DEO _ PARAM : ▁ctx ▁= ▁conf

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ op c ( M ox ie CPU ▁* cpu , ▁Dis as Context ▁* ctx ) ▁{ ▁CP UM ox ie State ▁* env ▁= ▁& cpu -> env ; ▁/* ▁Local ▁cache ▁for ▁the ▁instruction ▁opcode . ▁*/ ▁int ▁opcode ; ▁/* ▁Set ▁the ▁default ▁instruction ▁length . ▁*/ ▁int ▁length ▁= ▁2; ▁if ▁( un likely ( q emu _ log level _ mask ( CPU _ LOG _ TB _ OP ▁| ▁CPU _ LOG _ TB _ OP _ OPT ))) ▁{ ▁tc g _ gen _ debug _ ins n _ start ( ctx -> pc ); ▁} ▁/* ▁Exam ine ▁the ▁16 - bit ▁opcode . ▁*/ ▁opcode ▁= ▁ctx -> op code ; ▁/* ▁Decode ▁inst

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ op c ( TC G Context ▁* s , ▁int ▁op c , ▁int ▁r , ▁int ▁rm , ▁int ▁x ) ▁{ ▁int ▁rex ; ▁if ▁( op c ▁& ▁P _ GS ) ▁{ ▁tc g _ out 8 ( s , ▁0 x 65 ); ▁} ▁if ▁( op c ▁& ▁P _ DATA 16) ▁{ ▁/* ▁We ▁should ▁never ▁be ▁asking ▁for ▁both ▁16 ▁and ▁64- bit ▁operation . ▁*/ ▁assert (( op c ▁& ▁P _ RE X W ) ▁== ▁0); ▁tc g _ out 8 ( s , ▁0 x 66 ); ▁} ▁if ▁( op c ▁& ▁P _ ADDR 32) ▁{ ▁tc g _ out 8 ( s , ▁0 x 67 ); ▁} ▁rex ▁= ▁0; ▁rex ▁|= ▁( op c ▁& ▁P _ RE X W ) ▁? ▁0 x 8 ▁: ▁0 x 0; ▁/* ▁RE X . 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁qc ow 2_ co _ p write v _ compressed ( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁uint 64_ t ▁bytes , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁Q EM UI O Vector ▁hd _ q io v ; ▁struct ▁i ove c ▁i ov ; ▁z _ stream ▁str m ; ▁int ▁ret , ▁out _ len ; ▁uint 8_ t ▁* buf , ▁* out _ buf ; ▁uint 64_ t ▁cluster _ offset ; ▁if ▁( bytes ▁== ▁0) ▁{ ▁/* ▁align ▁end ▁of ▁file ▁to ▁a ▁sector ▁boundary ▁to ▁ease ▁reading ▁with ▁sector ▁based ▁I / Os ▁*/ ▁cluster _ offset ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ m from ( Dis as Context ▁* ctx ) ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ OP C ); ▁# else ▁if ▁( un likely ( ctx -> pr )) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ OP C ); ▁return ; ▁} ▁gen _ helper _ 60 2_ m from ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ g pr [ r A ( ctx -> op code ) ]); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 4 22 pt ou y vy )( const ▁uint 8_ t ▁* ys rc , ▁const ▁uint 8_ t ▁* us rc , ▁const ▁uint 8_ t ▁* v src , ▁uint 8_ t ▁* dst , ▁long ▁width , ▁long ▁height , ▁long ▁l um Stride , ▁long ▁chrom Stride , ▁long ▁dst Stride ) ▁{ ▁RE NAME ( y uv Plan art ou y vy )( ys rc , ▁us rc , ▁v src , ▁dst , ▁width , ▁height , ▁l um Stride , ▁chrom Stride , ▁dst Stride , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁ga _ channel _ open ( GA Channel ▁* c , ▁const ▁g char ▁* path , ▁GA Channel Method ▁method , ▁int ▁fd ) ▁{ ▁int ▁ret ; ▁c -> method ▁= ▁method ; ▁switch ▁( c -> method ) ▁{ ▁case ▁GA _ CHANNEL _ VI RT IO _ SER IAL : ▁{ ▁assert ( fd ▁< ▁0); ▁fd ▁= ▁qemu _ open ( path , ▁O _ RD WR ▁| ▁O _ NON BLOCK ▁# if nd ef ▁CONFIG _ SOL AR IS ▁| ▁O _ AS Y NC ▁# end if ▁); ▁if ▁( fd ▁== ▁-1) ▁{ ▁g _ cr itical (" error ▁opening ▁channel : ▁% s ", ▁strerror ( err no )); ▁return ▁false ; ▁} ▁# if def ▁C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ram _ save _ block ( Q EM U File ▁* f ) ▁{ ▁RAM Block ▁* block ▁= ▁last _ block ; ▁ram _ addr _ t ▁offset ▁= ▁last _ offset ; ▁int ▁bytes _ sent ▁= ▁-1; ▁Memory Region ▁* mr ; ▁if ▁(! block ) ▁block ▁= ▁Q LIST _ FIRST ( & ram _ list . blocks ); ▁do ▁{ ▁mr ▁= ▁block -> mr ; ▁if ▁( memory _ region _ get _ dirty ( mr , ▁offset , ▁TARGET _ PAGE _ SIZE , ▁DIR TY _ MEMORY _ M IG R ATION )) ▁{ ▁uint 8_ t ▁* p ; ▁int ▁cont ▁= ▁( block ▁== ▁last _ block ) ▁? ▁RAM _ SA VE _ FLAG _ CONT INUE ▁: ▁0; ▁me

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁net _ tx _ pk t _ add _ raw _ fragment ( struct ▁Net Tx P kt ▁* pk t , ▁hw addr ▁pa , ▁size _ t ▁len ) ▁{ ▁hw addr ▁mapped _ len ▁= ▁0; ▁struct ▁i ove c ▁* vent ry ; ▁assert ( pk t ); ▁assert ( pk t -> max _ raw _ f rag s ▁> ▁pkt -> raw _ f rag s ); ▁if ▁(! len ) ▁{ ▁return ▁true ; ▁} ▁v entry ▁= ▁& pk t -> raw [ pk t -> raw _ f rag s ]; ▁mapped _ len ▁= ▁len ; ▁v entry -> io v _ base ▁= ▁cpu _ ph ysical _ memory _ map ( pa , ▁& mapped _ len , ▁false ); ▁v entry -> io v _ len ▁= ▁mapped _ len ; ▁pk

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 24 22 _2_ c _ template ( Sw s Context ▁* c , ▁const ▁uint 16_ t ▁* buf 0, ▁const ▁uint 16_ t ▁* buf 1, ▁const ▁uint 16_ t ▁* ub uf 0, ▁const ▁uint 16_ t ▁* ub uf 1, ▁const ▁uint 16_ t ▁* v buf 0, ▁const ▁uint 16_ t ▁* v buf 1, ▁const ▁uint 16_ t ▁* ab uf 0, ▁const ▁uint 16_ t ▁* ab uf 1, ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁y alpha , ▁int ▁u val pha , ▁int ▁y , ▁enum ▁Pixel Format ▁target ) ▁{ ▁int ▁y alpha 1 ▁= ▁40 95 ▁- ▁y alpha ; ▁int ▁u val pha 1 ▁= ▁40 95 ▁- ▁u val pha ; ▁int ▁i ; ▁for ▁( i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁em ulated _ edge _ mc ( uint 8_ t ▁* buf , ▁const ▁uint 8_ t ▁* src , ▁int ▁lines ize , ▁int ▁block _ w , ▁int ▁block _ h , ▁int ▁src _ x , ▁int ▁src _ y , ▁int ▁w , ▁int ▁h , ▁em u _ edge _ core _ func ▁* core _ fn ) ▁{ ▁int ▁start _ y , ▁start _ x , ▁end _ y , ▁end _ x , ▁src _ y _ add ▁= ▁0; ▁if ▁( src _ y ▁>= ▁h ) ▁{ ▁src _ y _ add ▁= ▁h ▁- ▁1 ▁- ▁src _ y ; ▁src _ y ▁= ▁h ▁- ▁1; ▁} ▁else ▁if ▁( src _ y ▁<= ▁- block _ h ) ▁{ ▁src _ y _ add ▁= ▁1 ▁- ▁block _ h ▁- ▁sr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁init _ b undles ( B ink Context ▁* c ) ▁{ ▁int ▁bw , ▁bh , ▁blocks ; ▁int ▁i ; ▁bw ▁= ▁( c -> av ctx -> width ▁+ ▁7) ▁>> ▁3; ▁bh ▁= ▁( c -> av ctx -> height ▁+ ▁7) ▁>> ▁3; ▁blocks ▁= ▁bw ▁* ▁bh ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁BIN KB _ NB _ SRC ; ▁i ++) ▁{ ▁c -> bundle [ i ]. data ▁= ▁av _ m alloc ( blocks ▁* ▁64 ); ▁if ▁(! c -> bundle [ i ]. data ) ▁return ▁A VER ROR ( EN O ME M ); ▁c -> bundle [ i ]. data _ end ▁= ▁c -> bundle [ i ]. data ▁+ ▁blocks ▁* ▁64 ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qu orum _ vote ( Qu orum A IO CB ▁* ac b ) ▁{ ▁bool ▁qu orum ▁= ▁true ; ▁int ▁i , ▁j , ▁ret ; ▁Qu orum Vote Value ▁hash ; ▁B DR V Qu orum State ▁* s ▁= ▁ac b -> common . bs -> op aque ; ▁Qu orum Vote Version ▁* w inner ; ▁if ▁( qu orum _ has _ too _ m uch _ io _ failed ( ac b )) ▁{ ▁return ; ▁} ▁/* ▁get ▁the ▁index ▁of ▁the ▁first ▁successful ▁read ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> num _ children ; ▁i ++) ▁{ ▁if ▁(! ac b -> q cr s [ i ]. ret ) ▁{ ▁break ; ▁} ▁} ▁assert ( i ▁< ▁s -> num _ chi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁st ell aris _ init ( const ▁char ▁* kernel _ filename , ▁const ▁char ▁* cpu _ model , ▁st ell aris _ board _ info ▁* board ) ▁{ ▁static ▁const ▁int ▁u art _ irq [] ▁= ▁{ 5, ▁6, ▁33, ▁34 }; ▁static ▁const ▁int ▁timer _ irq [] ▁= ▁{ 19, ▁21, ▁23, ▁35 }; ▁static ▁const ▁uint 32_ t ▁gp io _ addr [ 7] ▁= ▁{ ▁0 x 4 000 4 000, ▁0 x 4 000 5 000, ▁0 x 4 000 6 000, ▁0 x 4 000 7 000, ▁0 x 400 24 000, ▁0 x 400 25 000, ▁0 x 400 26 000 }; ▁static ▁const ▁int ▁gp io _ irq [ 7] ▁= ▁{ 0, ▁1, ▁2, ▁3, ▁4, ▁30

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ exec _ init ( CPU State ▁* env ) ▁{ ▁CPU State ▁** pen v ; ▁int ▁cpu _ index ; ▁if ▁(! code _ gen _ ptr ) ▁{ ▁code _ gen _ ptr ▁= ▁code _ gen _ buffer ; ▁page _ init (); ▁io _ mem _ init (); ▁} ▁env -> next _ cpu ▁= ▁NULL ; ▁p env ▁= ▁& first _ cpu ; ▁cpu _ index ▁= ▁0; ▁while ▁(* pen v ▁!= ▁NULL ) ▁{ ▁p env ▁= ▁( CPU State ▁** ) & (* pen v ) -> next _ cpu ; ▁cpu _ index ++; ▁} ▁env -> cpu _ index ▁= ▁cpu _ index ; ▁* pen v ▁= ▁env ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 4 22 pto y uy 2) ( const ▁uint 8_ t ▁* ys rc , ▁const ▁uint 8_ t ▁* us rc , ▁const ▁uint 8_ t ▁* v src , ▁uint 8_ t ▁* dst , ▁long ▁width , ▁long ▁height , ▁long ▁l um Stride , ▁long ▁chrom Stride , ▁long ▁dst Stride ) ▁{ ▁RE NAME ( y uv Plan art oy uy 2) ( ys rc , ▁us rc , ▁v src , ▁dst , ▁width , ▁height , ▁l um Stride , ▁chrom Stride , ▁dst Stride , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁bool ▁handler _ is _ async ( const ▁mon _ cmd _ t ▁* cmd ) ▁{ ▁return ▁cmd -> flags ▁& ▁MON IT OR _ CMD _ AS Y NC ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v qa _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁V qa Context ▁* s ▁= ▁( V qa Context ▁* ) av ctx -> priv _ data ; ▁unsigned ▁char ▁* v qa _ header ; ▁int ▁i , ▁j , ▁code book _ index ; ; ▁s -> av ctx ▁= ▁av ctx ; ▁av ctx -> pix _ fmt ▁= ▁PI X _ F MT _ P AL 8 ; ▁av ctx -> has _ b _ frames ▁= ▁0; ▁ds put il _ init ( & s -> d sp , ▁av ctx ); ▁/* ▁make ▁sure ▁the ▁extr ad ata ▁made ▁it ▁*/ ▁if ▁( s -> av ctx -> ex tr ad ata _ size ▁!= ▁V Q A _ HEADER _ SIZE ) ▁{ ▁av _ log ( s -> av ctx ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁open _ output _ file ( Options Context ▁* o , ▁const ▁char ▁* filename ) ▁{ ▁AV Format Context ▁* oc ; ▁int ▁i , ▁j , ▁err ; ▁AV OutputFormat ▁* file _ o format ; ▁Output File ▁* of ; ▁OutputStream ▁* ost ; ▁InputStream ▁* ist ; ▁AV Dictionary ▁* unused _ opts ▁= ▁NULL ; ▁AV Dictionary Entry ▁* e ▁= ▁NULL ; ▁if ▁( configure _ complex _ filters () ▁< ▁0) ▁{ ▁av _ log ( NULL , ▁AV _ LOG _ F ATAL , ▁" Error ▁configuring ▁filters .\ n "); ▁exit _ program (1); ▁} ▁if ▁( o -> stop _ time ▁!= ▁INT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁logic _ im m _ decode _ w mask ( uint 64_ t ▁* result , ▁unsigned ▁int ▁im mn , ▁unsigned ▁int ▁im ms , ▁unsigned ▁int ▁im mr ) ▁{ ▁uint 64_ t ▁mask ; ▁unsigned ▁e , ▁levels , ▁s , ▁r ; ▁int ▁len ; ▁assert ( im mn ▁< ▁2 ▁&& ▁im ms ▁< ▁64 ▁&& ▁im mr ▁< ▁64 ); ▁/* ▁The ▁bit ▁patterns ▁we ▁create ▁here ▁are ▁64 ▁bit ▁patterns ▁which ▁* ▁are ▁vectors ▁of ▁identical ▁elements ▁of ▁size ▁e ▁= ▁2, ▁4, ▁8, ▁16, ▁32 ▁or ▁* ▁64 ▁bits ▁each . ▁Each ▁element ▁contains ▁the ▁same ▁value : ▁a ▁run ▁* ▁of

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁add _ candidate _ ref ( HE VC Context ▁* s , ▁Ref Pic List ▁* list , ▁int ▁p oc , ▁int ▁ref _ flag ) ▁{ ▁HE VC Frame ▁* ref ▁= ▁find _ ref _ idx ( s , ▁p oc ); ▁if ▁( ref ▁== ▁s -> ref ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁(! ref ) ▁{ ▁ref ▁= ▁generate _ missing _ ref ( s , ▁p oc ); ▁if ▁(! ref ) ▁return ▁A VER ROR ( EN O ME M ); ▁} ▁list -> list [ list -> nb _ refs ] ▁= ▁ref -> p oc ; ▁list -> ref [ list -> nb _ refs ] ▁= ▁ref ; ▁list -> nb _ refs ++; ▁mark _ ref ( ref , ▁ref _ flag

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁t _ gen _ mov _ p reg _ T N ( Dis as Context ▁* dc , ▁int ▁r , ▁TC G v ▁tn ) ▁{ ▁if ▁( r ▁< ▁0 ▁|| ▁r ▁> ▁15 ) ▁{ ▁f printf ( stderr , ▁" wrong ▁register ▁write ▁$ p % d \ n ", ▁r ); ▁} ▁if ▁( r ▁== ▁PR _ B Z ▁|| ▁r ▁== ▁PR _ W Z ▁|| ▁r ▁== ▁PR _ D Z ) ▁{ ▁return ; ▁} ▁else ▁if ▁( r ▁== ▁PR _ S RS ) ▁{ ▁tc g _ gen _ and i _ tl ( cpu _ PR [ r ], ▁tn , ▁3 ); ▁} ▁else ▁{ ▁if ▁( r ▁== ▁PR _ PID ) ▁{ ▁gen _ helper _ tl b _ flush _ pid ( cpu _ env , ▁tn ); ▁} ▁if ▁( dc -> tb _ flags ▁& ▁S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v orb is _ parse _ id _ hdr ( vor b is _ context ▁* vc ){ ▁Get Bit Context ▁* gb =& vc -> gb ; ▁uint _ fast 8_ t ▁bl 0, ▁bl 1; ▁if ▁(( get _ bits ( gb , ▁8) ! =' v ') ▁|| ▁( get _ bits ( gb , ▁8) ! =' o ') ▁|| ▁( get _ bits ( gb , ▁8) ! =' r ') ▁|| ▁( get _ bits ( gb , ▁8) ! =' b ') ▁|| ▁( get _ bits ( gb , ▁8) ! =' i ') ▁|| ▁( get _ bits ( gb , ▁8) ! =' s ')) ▁{ ▁av _ log ( vc -> av c context , ▁AV _ LOG _ ERROR , ▁" ▁V orb is ▁id ▁header ▁packet ▁corrupt ▁( no ▁v orb is ▁signature ). ▁\ n 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ avg _ h 2 64_ qp el 4_ mc 3 1_ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ h v _ q rt _ and _ aver _ dst _4 x 4_ ms a ( src ▁- ▁2, ▁src ▁- ▁( stride ▁* ▁2) ▁+ ▁sizeof ( uint 8_ t ), ▁stride , ▁dst , ▁stride ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ v host _ user _ init ( Net Client State ▁* peer , ▁const ▁char ▁* device , ▁const ▁char ▁* name , ▁Char Driver State ▁* chr , ▁int ▁queues ) ▁{ ▁Net Client State ▁* nc ; ▁V host User State ▁* s ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁queues ; ▁i ++) ▁{ ▁nc ▁= ▁qemu _ new _ net _ client ( & net _ v host _ user _ info , ▁peer , ▁device , ▁name ); ▁sn printf ( nc -> info _ str , ▁sizeof ( nc -> info _ str ), ▁" v host - user % d ▁to ▁% s ", ▁i , ▁chr -> label ); ▁nc -> queue _ index ▁= ▁i ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fl v _ pro be ( AV Probe Data ▁* p ) ▁{ ▁const ▁uint 8_ t ▁* d ; ▁if ▁( p -> buf _ size ▁< ▁6) ▁return ▁0; ▁d ▁= ▁p -> buf ; ▁if ▁( d [0] ▁== ▁' F ' ▁&& ▁d [1] ▁== ▁' L ' ▁&& ▁d [2] ▁== ▁' V ' ▁&& ▁d [3] ▁< ▁5 ▁&& ▁d [5] == 0) ▁{ ▁return ▁AV PRO BE _ S CORE _ MAX ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ read _ data ( SC S ID evice ▁* d , ▁uint 32_ t ▁tag ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁d ); ▁S CS ID isk Req ▁* r ; ▁r ▁= ▁sc si _ find _ request ( s , ▁tag ); ▁if ▁(! r ) ▁{ ▁BAD F (" Bad ▁read ▁tag ▁0 x % x \ n ", ▁tag ); ▁/* ▁??? ▁This ▁is ▁the ▁wrong ▁error . ▁*/ ▁sc si _ command _ complete ( r , ▁CHECK _ CONDITION , ▁H ARD WARE _ ERROR ); ▁return ; ▁} ▁/* ▁No ▁data ▁transfer ▁may ▁already ▁be ▁in ▁progress ▁*/ ▁assert ( r -> req . ai o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁opt _ output _ file ( void ▁* opt ctx , ▁const ▁char ▁* filename ) ▁{ ▁Options Context ▁* o ▁= ▁opt ctx ; ▁AV Format Context ▁* oc ; ▁int ▁i , ▁err ; ▁AV OutputFormat ▁* file _ o format ; ▁OutputStream ▁* ost ; ▁InputStream ▁* ist ; ▁if ▁(! str cmp ( filename , ▁"- ")) ▁filename ▁= ▁" pipe : "; ▁oc ▁= ▁av format _ alloc _ context (); ▁if ▁(! oc ) ▁{ ▁print _ error ( filename , ▁A VER ROR ( EN O ME M )); ▁exit _ program (1); ▁} ▁if ▁( last _ ask ed _ format ) ▁{ ▁file _ o format ▁= ▁av _ gue

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁spawn _ thread ( void ) ▁{ ▁p thread _ attr _ t ▁attr ; ▁int ▁ret ; ▁cur _ threads ++; ▁idle _ threads ++; ▁p thread _ attr _ init ( & attr ); ▁p thread _ attr _ set detach state ( & attr , ▁P THREAD _ CREATE _ DE TA CHED ); ▁ret ▁= ▁p thread _ create ( & thread _ id , ▁& attr , ▁aio _ thread , ▁NULL ); ▁p thread _ attr _ destroy ( & attr ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ g ab 2_ sub ( AV Stream ▁* st , ▁AV Packet ▁* pk t ) ▁{ ▁if ▁( pk t -> size ▁>= ▁7 ▁&& ▁! str cmp ( pk t -> data , ▁" G AB 2") ▁&& ▁AV _ RL 16 ( pk t -> data ▁+ ▁5) ▁== ▁2) ▁{ ▁uint 8_ t ▁desc [ 256 ]; ▁int ▁score ▁= ▁AV PRO BE _ S CORE _ EXTENSION , ▁ret ; ▁A VI Stream ▁* ast ▁= ▁st -> priv _ data ; ▁AV InputFormat ▁* sub _ dem ux er ; ▁AV R ational ▁time _ base ; ▁AV IO Context ▁* pb ▁= ▁av io _ alloc _ context ( pk t -> data ▁+ ▁7, ▁pkt -> size ▁- ▁7, ▁0, ▁NULL , ▁NULL , ▁NULL , ▁N

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁machine _ iom mu ( Machine State ▁* machine ) ▁{ ▁return ▁machine -> iom mu ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dis as _ cp 15 _ ins n ( CPU State ▁* env , ▁Dis as Context ▁* s , ▁uint 32_ t ▁insn ) ▁{ ▁uint 32_ t ▁rd ; ▁TC G v ▁tmp , ▁tmp 2; ▁/* ▁M ▁profile ▁cores ▁use ▁memory ▁mapped ▁registers ▁instead ▁of ▁cp 15. ▁*/ ▁if ▁( arm _ feature ( env , ▁ARM _ FEATURE _ M )) ▁return ▁1; ▁if ▁(( ins n ▁& ▁(1 ▁<< ▁25 )) ▁== ▁0) ▁{ ▁if ▁( ins n ▁& ▁(1 ▁<< ▁20 )) ▁{ ▁/* ▁mr rc ▁*/ ▁return ▁1; ▁} ▁/* ▁m cr r . ▁Used ▁for ▁block ▁cache ▁operations , ▁so ▁implement ▁as ▁no - op . ▁*/ ▁return ▁0; ▁} ▁if ▁(( ins n

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* vc _ init ( const ▁char ▁* id , ▁Ch ard ev Backend ▁* backend , ▁Ch ard ev Return ▁* ret , ▁Error ▁** err p ) ▁{ ▁return ▁vc _ handler ( backend -> u . vc , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁USB Device ▁* usb _ host _ device _ open ( const ▁char ▁* dev name ) ▁{ ▁int ▁fd ▁= ▁-1, ▁ret ; ▁USB Host Device ▁* dev ▁= ▁NULL ; ▁struct ▁usb dev fs _ connect info ▁ci ; ▁char ▁buf [10 24 ]; ▁int ▁bus _ num , ▁addr ; ▁char ▁product _ name [ PRO DUCT _ NAME _ S Z ]; ▁dev ▁= ▁qemu _ m alloc z ( size of ( US B Host Device )); ▁if ▁(! dev ) ▁goto ▁fail ; ▁# if def ▁DEBUG _ ISO CH ▁printf (" usb _ host _ device _ open ▁% s \ n ", ▁dev name ); ▁# end if ▁if ▁( usb _ host _ find _ device ( & bus _ num , ▁& ad

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ fr sp ( CP UP PC State ▁* env , ▁uint 64_ t ▁arg ) ▁{ ▁CPU _ Double U ▁f arg ; ▁float 32 ▁f 32 ; ▁f arg . ll ▁= ▁arg ; ▁if ▁( un likely ( float 64_ is _ signal ing _ nan ( f arg . d ))) ▁{ ▁/* ▁s NaN ▁square ▁root ▁*/ ▁f load _ invalid _ op _ ex cp ( env , ▁PO WER PC _ EX CP _ FP _ V X SN AN ); ▁} ▁f 32 ▁= ▁float 64_ to _ float 32 ( f arg . d , ▁& env -> fp _ status ); ▁f arg . d ▁= ▁float 32_ to _ float 64 ( f 32, ▁& env -> fp _ status ); ▁return ▁f arg . ll ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁gen _ new _ label ( void ) ▁{ ▁TC G Context ▁* s ▁= ▁& tc g _ ctx ; ▁int ▁idx ; ▁TC G Label ▁* l ; ▁if ▁( s -> nb _ labels ▁>= ▁TC G _ MAX _ LABEL S ) ▁tc g _ abort (); ▁idx ▁= ▁s -> nb _ labels ++; ▁l ▁= ▁& s -> labels [ idx ]; ▁l -> has _ value ▁= ▁0; ▁l -> u . first _ re loc ▁= ▁NULL ; ▁return ▁idx ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ round _ to _ clusters ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int 64_ t ▁* cluster _ sect or _ num , ▁int ▁* cluster _ nb _ sect ors ) ▁{ ▁Block Driver Info ▁b di ; ▁if ▁( b dr v _ get _ info ( bs , ▁& bd i ) ▁< ▁0 ▁|| ▁b di . cluster _ size ▁== ▁0) ▁{ ▁* cluster _ sect or _ num ▁= ▁sector _ num ; ▁* cluster _ nb _ sect ors ▁= ▁nb _ sect ors ; ▁} ▁else ▁{ ▁int 64_ t ▁c ▁= ▁b di . cluster _ size ▁/ ▁B DR V _ SE CTOR _ SIZE ; ▁* cluster _ sect or _ num 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ reset _ dirty ( CPU State ▁* cpu , ▁ram _ addr _ t ▁start 1, ▁ram _ addr _ t ▁length ) ▁{ ▁CPU Arch State ▁* env ; ▁int ▁mm u _ idx ; ▁assert _ cpu _ is _ self ( cpu ); ▁env ▁= ▁cpu -> env _ ptr ; ▁for ▁( mm u _ idx ▁= ▁0; ▁mm u _ idx ▁< ▁NB _ MM U _ MODE S ; ▁mm u _ idx ++) ▁{ ▁unsigned ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁CPU _ TL B _ SIZE ; ▁i ++) ▁{ ▁tl b _ reset _ dirty _ range ( & env -> tl b _ table [ mm u _ idx ][ i ], ▁start 1, ▁length ); ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁CPU _ VT LB _ SIZE ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁blk debug _ co _ p read v ( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁uint 64_ t ▁bytes , ▁Q EM UI O Vector ▁* q io v , ▁int ▁flags ) ▁{ ▁B DR V Bl k debug State ▁* s ▁= ▁bs -> op aque ; ▁Bl k debug Rule ▁* rule ▁= ▁NULL ; ▁Q SI MPLE Q _ FORE A CH ( rule , ▁& s -> active _ rules , ▁active _ next ) ▁{ ▁uint 64_ t ▁inject _ offset ▁= ▁rule -> options . inject . offset ; ▁if ▁( inject _ offset ▁== ▁-1 ▁|| ▁( inject _ offset ▁>= ▁offset ▁&& ▁inject _ offset ▁< ▁offset ▁+ ▁bytes )) ▁{ ▁break ; ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁id reg _ init 1( Sys Bus Device ▁* dev ) ▁{ ▁ID Reg State ▁* s ▁= ▁MAC IO _ ID _ REGI STER ( dev ); ▁memory _ region _ init _ ram ( & s -> mem , ▁OBJECT ( s ), ▁" sun 4 m . id reg ", ▁sizeof ( id reg _ data ), ▁& error _ abort ); ▁vm state _ register _ ram _ global ( & s -> mem ); ▁memory _ region _ set _ readonly ( & s -> mem , ▁true ); ▁sys bus _ init _ mm io ( dev , ▁& s -> mem ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁tc g _ out _ ld _ ptr ( TC G Context ▁* s , ▁int ▁ret , ▁tc g _ target _ long ▁arg ) ▁{ ▁# if ▁defined (__ s par c _ v 9 __) ▁&& ▁! defined (__ s par c _ v 8 plus __) ▁if ▁( arg ▁!= ▁( arg ▁& ▁0 xffffffff )) ▁f printf ( stderr , ▁" un implemented ▁% s ▁with ▁offset ▁% ld \ n ", ▁__ func __, ▁arg ); ▁if ▁( arg ▁!= ▁( arg ▁& ▁0 xff f )) ▁tc g _ out 32 ( s , ▁SET HI ▁| ▁IN SN _ RD ( ret ) ▁| ▁( (( uint 32_ t ) arg ▁& ▁0 xffff fc 00) ▁>> ▁10 )); ▁tc g _ out 32 ( s , ▁LD X ▁| ▁IN SN _ RD

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁xen _ config _ dev _ blk ( Drive Info ▁* disk ) ▁{ ▁char ▁fe [ 256 ], ▁be [ 256 ]; ▁int ▁v dev ▁= ▁202 ▁* ▁256 ▁+ ▁16 ▁* ▁disk -> unit ; ▁int ▁cd rom ▁= ▁disk -> b dr v -> type ▁== ▁B DR V _ TYPE _ CD ROM ; ▁const ▁char ▁* dev type ▁= ▁cd rom ▁? ▁" cd rom " ▁: ▁" disk "; ▁const ▁char ▁* mode ▁= ▁cd rom ▁? ▁" r " ▁: ▁" w "; ▁sn printf ( disk -> b dr v -> device _ name , ▁sizeof ( disk -> b dr v -> device _ name ), ▁" x vd % c ", ▁' a ' ▁+ ▁disk -> unit ); ▁xen _ be _ printf ( NULL , ▁1, ▁" config ▁di

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ inter mediate _ code _ internal ( Open RI SC CPU ▁* cpu , ▁Translation Block ▁* tb , ▁int ▁search _ pc ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁struct ▁Dis as Context ▁ctx , ▁* dc ▁= ▁& ctx ; ▁uint 16_ t ▁* gen _ op c _ end ; ▁uint 32_ t ▁pc _ start ; ▁int ▁j , ▁k ; ▁uint 32_ t ▁next _ page _ start ; ▁int ▁num _ ins ns ; ▁int ▁max _ ins ns ; ▁pc _ start ▁= ▁tb -> pc ; ▁dc -> tb ▁= ▁tb ; ▁gen _ op c _ end ▁= ▁tc g _ ctx . gen _ op c _ buf ▁+ ▁O PC _ MAX _ SIZE ; ▁dc -> is _ j mp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ iv sh mem _ real ize ( PC ID evice ▁* dev , ▁Error ▁** err p ) ▁{ ▁IV Sh mem State ▁* s ▁= ▁IV SH ME M ( dev ); ▁Error ▁* err ▁= ▁NULL ; ▁uint 8_ t ▁* pc i _ conf ; ▁uint 8_ t ▁attr ▁= ▁P CI _ BASE _ ADDRESS _ SPACE _ MEMORY ▁| ▁P CI _ BASE _ ADDRESS _ ME M _ PRE FETCH ; ▁if ▁( !! s -> server _ chr ▁+ ▁!! s -> sh m obj ▁+ ▁!! s -> host mem ▁!= ▁1) ▁{ ▁error _ set g ( err p , ▁" You ▁must ▁specify ▁either ▁' sh m ', ▁' ch ard ev ' ▁or ▁' x - mem dev ' "); ▁return ; ▁} ▁if ▁( s -> host 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁print _ ins n _ lm 32 ( b fd _ v ma ▁mem addr , ▁struct ▁dis as semble _ info ▁* info ) ▁{ ▁f printf _ function ▁f printf _ fn ▁= ▁info -> f printf _ func ; ▁void ▁* stream ▁= ▁info -> stream ; ▁int ▁rc ; ▁uint 8_ t ▁insn [4 ]; ▁const ▁L m 32 Op code Info ▁* op c _ info ; ▁uint 32_ t ▁op ; ▁const ▁char ▁* args _ fmt ; ▁rc ▁= ▁info -> read _ memory _ func ( mem addr , ▁insn , ▁4, ▁info ); ▁if ▁( rc ▁!= ▁0) ▁{ ▁info -> memory _ error _ func ( rc , ▁mem addr , ▁info ); ▁return ▁-1; ▁} ▁f printf _ fn ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ c oc ( J peg 2000 Decoder Context ▁* s , ▁J peg 2000 Coding Style ▁* c , ▁uint 8_ t ▁* properties ) ▁{ ▁int ▁comp no ; ▁if ▁( s -> buf _ end ▁- ▁s -> buf ▁< ▁2) ▁return ▁A VER ROR ( E IN VAL ); ▁comp no ▁= ▁by test ream _ get _ byte ( & s -> buf ); ▁c ▁+= ▁comp no ; ▁c -> c st y ▁= ▁by test ream _ get _ byte ( & s -> buf ); ▁get _ c ox ( s , ▁c ); ▁properties [ comp no ] ▁|= ▁H AD _ CO C ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁curses _ setup ( void ) ▁{ ▁int ▁i , ▁colour _ default [ 8] ▁= ▁{ ▁COLOR _ BLACK , ▁COLOR _ BL UE , ▁COLOR _ G REEN , ▁COLOR _ CY AN , ▁COLOR _ RED , ▁COLOR _ M AGENT A , ▁COLOR _ Y ELLOW , ▁COLOR _ WHITE , ▁}; ▁/* ▁input ▁as ▁raw ▁as ▁possible , ▁let ▁everything ▁be ▁interpreted ▁* ▁by ▁the ▁guest ▁system ▁*/ ▁init scr (); ▁no echo (); ▁intr flush ( std scr , ▁FALSE ); ▁nod el ay ( std scr , ▁TRUE ); ▁non l (); ▁key pad ( std scr , ▁TRUE ); ▁start _ color (); ▁raw (); ▁sc rol lo k ( std sc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( h ys cale )( uint 16_ t ▁* dst , ▁int ▁dst Width , ▁uint 8_ t ▁* src , ▁int ▁src W , ▁int ▁x Inc ) ▁{ ▁# if def ▁HAVE _ MM X ▁// ▁use ▁the ▁new ▁M MX ▁scaler ▁if ▁th ▁mm x 2 ▁cant ▁be ▁used ▁( its ▁faster ▁than ▁the ▁x 86 asm ▁one ) ▁if ( sw s _ flags ▁!= ▁S WS _ FA ST _ BI LINE AR ▁|| ▁(! can MM X 2 Be Used )) ▁# else ▁if ( sw s _ flags ▁!= ▁S WS _ FA ST _ BI LINE AR ) ▁# end if ▁{ ▁RE NAME ( h Scale )( dst , ▁dst Width , ▁src , ▁src W , ▁x Inc , ▁h L um Filter , ▁h L um 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ uint 16_ equal ( Q EM U File ▁* f , ▁void ▁* pv , ▁size _ t ▁size ) ▁{ ▁uint 16_ t ▁* v ▁= ▁pv ; ▁uint 16_ t ▁v 2; ▁qemu _ get _ be 16 s ( f , ▁& v 2); ▁if ▁(* v ▁== ▁v 2) ▁{ ▁return ▁0; ▁} ▁return ▁- E IN VAL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h 2 64_ handle _ packet ( AV Format Context ▁* ctx , ▁Payload Context ▁* data , ▁AV Stream ▁* st , ▁AV Packet ▁* pk t , ▁uint 32_ t ▁* timestamp , ▁const ▁uint 8_ t ▁* buf , ▁int ▁len , ▁uint 16_ t ▁seq , ▁int ▁flags ) ▁{ ▁uint 8_ t ▁n al ; ▁uint 8_ t ▁type ; ▁int ▁result ▁= ▁0; ▁if ▁(! len ) ▁{ ▁av _ log ( ctx , ▁AV _ LOG _ ERROR , ▁" Empty ▁H 264 ▁R TP ▁packet \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁n al ▁= ▁buf [0]; ▁type ▁= ▁n al ▁& ▁0 x 1 f ; ▁assert ( data ); ▁assert ( buf )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ refresh _ filename ( Block Driver State ▁* bs ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁Q Dict ▁* opts ; ▁if ▁(! dr v ) ▁{ ▁return ; ▁} ▁/* ▁This ▁B DS ' s ▁file ▁name ▁will ▁most ▁probably ▁depend ▁on ▁its ▁file ' s ▁name , ▁so ▁* ▁refresh ▁that ▁first ▁*/ ▁if ▁( bs -> file ) ▁{ ▁b dr v _ refresh _ filename ( bs -> file -> bs ); ▁} ▁if ▁( dr v -> b dr v _ refresh _ filename ) ▁{ ▁/* ▁O bs ol ete ▁information ▁is ▁of ▁no ▁use ▁here , ▁so ▁drop ▁the ▁old ▁file ▁name ▁* ▁information ▁befo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁bool ▁cpu _ handle _ exception ( CPU State ▁* cpu , ▁int ▁* ret ) ▁{ ▁if ▁( cpu -> exception _ index ▁>= ▁0) ▁{ ▁if ▁( cpu -> exception _ index ▁>= ▁EX CP _ INTER R UP T ) ▁{ ▁/* ▁exit ▁request ▁from ▁the ▁cpu ▁execution ▁loop ▁*/ ▁* ret ▁= ▁cpu -> exception _ index ; ▁if ▁(* ret ▁== ▁EX CP _ DEBUG ) ▁{ ▁cpu _ handle _ debug _ exception ( cpu ); ▁} ▁cpu -> exception _ index ▁= ▁-1; ▁return ▁true ; ▁} ▁else ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁/* ▁if ▁user ▁mode ▁only , ▁we ▁simulat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ dn x hd enc _ init _ x 86 ( DN X H DE nc Context ▁* ctx ) ▁{ ▁# if ▁HAVE _ IN LINE _ AS M ▁if ▁( av _ get _ cpu _ flags () ▁& ▁AV _ CPU _ FLAG _ SS E 2) ▁{ ▁if ▁( ctx -> cid _ table -> bit _ depth ▁== ▁8) ▁ctx -> get _ pixels _8 x 4_ sym ▁= ▁get _ pixels _8 x 4_ sym _ s se 2; ▁} ▁# end if ▁/* ▁HAVE _ IN LINE _ AS M ▁*/ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ f div ( CP UP PC State ▁* env , ▁uint 64_ t ▁arg 1, ▁uint 64_ t ▁arg 2) ▁{ ▁CPU _ Double U ▁f arg 1, ▁f arg 2; ▁f arg 1. ll ▁= ▁arg 1; ▁f arg 2. ll ▁= ▁arg 2; ▁if ▁( un likely ( float 64_ is _ infinity ( f arg 1. d ) ▁&& ▁float 64_ is _ infinity ( f arg 2. d ))) ▁{ ▁/* ▁Div ision ▁of ▁infinity ▁by ▁infinity ▁*/ ▁f arg 1. ll ▁= ▁f load _ invalid _ op _ ex cp ( env , ▁PO WER PC _ EX CP _ FP _ V X ID I ); ▁} ▁else ▁if ▁( un likely ( float 64_ is _ zero ( f arg 1. d ) ▁&& ▁float 64_ is _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ io _ channel _ ipv 4 ( bool ▁async ) ▁{ ▁SocketAddress ▁* listen _ addr ▁= ▁g _ new 0( SocketAddress , ▁1); ▁SocketAddress ▁* connect _ addr ▁= ▁g _ new 0( SocketAddress , ▁1); ▁listen _ addr -> type ▁= ▁SO CKET _ ADDRESS _ K IND _ INET ; ▁listen _ addr -> u . inet ▁= ▁g _ new 0( Inet SocketAddress , ▁1); ▁listen _ addr -> u . inet -> host ▁= ▁g _ str dup (" 0 .0.0.0 "); ▁listen _ addr -> u . inet -> port ▁= ▁NULL ; ▁/* ▁Auto - select ▁*/ ▁connect _ addr -> type ▁= ▁SO CKET _ ADDRESS

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ lo ongs on _ mult im edia ( Dis as Context ▁* ctx , ▁int ▁rd , ▁int ▁rs , ▁int ▁rt ) ▁{ ▁const ▁char ▁* op n ▁= ▁" lo ongs on _ cp 2" ; ▁uint 32_ t ▁op c , ▁shift _ max ; ▁TC G v _ i 64 ▁t 0, ▁t 1; ▁op c ▁= ▁MASK _ L MI ( ctx -> op code ); ▁switch ▁( op c ) ▁{ ▁case ▁O PC _ ADD _ CP 2: ▁case ▁O PC _ SUB _ CP 2: ▁case ▁O PC _ D ADD _ CP 2: ▁case ▁O PC _ DS UB _ CP 2: ▁t 0 ▁= ▁tc g _ temp _ local _ new _ i 64 (); ▁t 1 ▁= ▁tc g _ temp _ local _ new _ i 64 (); ▁break ; ▁default : ▁t 0 ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v 9 fs _ stat ( void ▁* op aque ) ▁{ ▁int 32_ t ▁fid ; ▁V 9 fs Stat ▁v 9 stat ; ▁s size _ t ▁err ▁= ▁0; ▁size _ t ▁offset ▁= ▁7 ; ▁struct ▁stat ▁st buf ; ▁V 9 fs F id State ▁* f id p ; ▁V 9 fs P DU ▁* pd u ▁= ▁opaque ; ▁V 9 fs State ▁* s ▁= ▁pdu -> s ; ▁pdu _ un marshal ( pd u , ▁offset , ▁" d ", ▁& f id ); ▁trace _ v 9 fs _ stat ( pd u -> tag , ▁pdu -> id , ▁fid ); ▁fid p ▁= ▁get _ f id ( pd u , ▁fid ); ▁if ▁( f id p ▁== ▁NULL ) ▁{ ▁err ▁= ▁- EN O ENT ; ▁goto ▁out _ n of id ; ▁} ▁err ▁= ▁v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ add lv ▁( uint 64_ t ▁op 1, ▁uint 64_ t ▁op 2) ▁{ ▁uint 64_ t ▁tmp ▁= ▁op 1; ▁op 1 ▁= ▁( uint 32_ t )( op 1 ▁+ ▁op 2); ▁if ▁( un likely (( tmp ▁^ ▁op 2 ▁^ ▁( -1 UL )) ▁& ▁( tmp ▁^ ▁op 1) ▁& ▁(1 UL ▁<< ▁31 ))) ▁{ ▁ar ith _ ex cp ( env , ▁GET PC (), ▁EX C _ M _ IO V , ▁0); ▁} ▁return ▁op 1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁of _ d pa _ cmd _ add _ l 2_ f lood ( Of D pa ▁* of _ d pa , ▁Of D pa Group ▁* group , ▁R ocker Tlv ▁** group _ tl vs ) ▁{ ▁Of D pa Group ▁* l 2_ group ; ▁R ocker Tlv ▁** tl vs ; ▁int ▁err ; ▁int ▁i ; ▁if ▁(! group _ tl vs [ RO CKER _ TL V _ OF _ D PA _ GROUP _ COUNT ] ▁|| ▁! group _ tl vs [ RO CKER _ TL V _ OF _ D PA _ GROUP _ IDS ]) ▁{ ▁return ▁- RO CKER _ E IN VAL ; ▁} ▁group -> l 2_ f lood . group _ count ▁= ▁ro cker _ tl v _ get _ le 16 ( group _ tl vs [ RO CKER _ TL V _ OF _ D PA _ GRO

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁LL VM F uzz er Test One Input ( const ▁uint 8_ t ▁* data , ▁size _ t ▁size ) ▁{ ▁const ▁uint 64_ t ▁fuzz _ tag ▁= ▁F U ZZ _ TAG ; ▁F uzz Data Buffer ▁buffer ; ▁const ▁uint 8_ t ▁* last ▁= ▁data ; ▁const ▁uint 8_ t ▁* end ▁= ▁data ▁+ ▁size ; ▁uint 32_ t ▁it ▁= ▁0; ▁if ▁(! c ) ▁c ▁= ▁AV Codec Initialize ( FF M PEG _ CODE C ); ▁// ▁Done ▁once . ▁AV Codec Context * ▁ctx ▁= ▁av codec _ alloc _ context 3( NULL ); ▁if ▁(! ctx ) ▁error (" Failed ▁memory ▁allocation "); ▁ctx -> max _ pixels ▁= ▁4096 ▁* ▁4096

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁op _ cp 1_ 64 bit mode ( void ) ▁{ ▁if ▁(! ( env -> CP 0_ Status ▁& ▁(1 ▁<< ▁CP 0 St _ FR ))) ▁{ ▁CALL _ FROM _ TB 1( do _ raise _ exception , ▁EX CP _ RI ); ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁dis as _ a 64_ ins n ( CPU ARM State ▁* env , ▁Dis as Context ▁* s ) ▁{ ▁uint 32_ t ▁insn ; ▁insn ▁= ▁arm _ ld l _ code ( env , ▁s -> pc , ▁s -> b swap _ code ); ▁s -> ins n ▁= ▁insn ; ▁s -> pc ▁+= ▁4; ▁switch ▁(( ins n ▁>> ▁24 ) ▁& ▁0 x 1 f ) ▁{ ▁default : ▁un allocated _ encoding ( s ); ▁break ; ▁} ▁if ▁( un likely ( s -> sing l est ep _ enabled ) ▁&& ▁( s -> is _ j mp ▁== ▁DIS AS _ TB _ J UMP )) ▁{ ▁/* ▁go ▁through ▁the ▁main ▁loop ▁for ▁single ▁step ▁*/ ▁s -> is _ j mp ▁= ▁DIS AS _ J UMP ; ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ mov _ v _ reg ( int ▁ot , ▁TC G v ▁t 0, ▁int ▁reg ) ▁{ ▁switch ( ot ) ▁{ ▁case ▁O T _ BYTE : ▁if ▁( reg ▁< ▁4 ▁X 86_64 _ DEF ( ▁|| ▁reg ▁>= ▁8 ▁|| ▁x 86_64 _ h re gs )) ▁{ ▁goto ▁std _ case ; ▁} ▁else ▁{ ▁tc g _ gen _ sh ri _ tl ( t 0, ▁cpu _ re gs [ reg ▁- ▁4], ▁8 ); ▁tc g _ gen _ ext 8 u _ tl ( t 0, ▁t 0); ▁} ▁break ; ▁default : ▁std _ case : ▁tc g _ gen _ mov _ tl ( t 0, ▁cpu _ re gs [ reg ]); ▁break ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h dev _ open ( Block Driver State ▁* bs , ▁const ▁char ▁* filename , ▁int ▁flags ) ▁{ ▁B DR V Raw State ▁* s ▁= ▁bs -> op aque ; ▁int ▁access _ flags , ▁create _ flags ; ▁DWORD ▁over la pped ; ▁char ▁device _ name [ 64 ]; ▁if ▁( str start ( filename , ▁"/ dev / cd rom ", ▁NULL )) ▁{ ▁if ▁( find _ cd rom ( device _ name , ▁sizeof ( device _ name )) ▁< ▁0) ▁return ▁- EN O ENT ; ▁filename ▁= ▁device _ name ; ▁} ▁else ▁{ ▁/* ▁transform ▁drive ▁letters ▁into ▁device ▁name ▁*/ ▁if ▁( (( filename [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sig p _ store _ ad tl _ status ( CPU State ▁* cs , ▁run _ on _ cpu _ data ▁arg ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁S 39 0_ CPU ( cs ); ▁Sig p Info ▁* si ▁= ▁arg . host _ ptr ; ▁if ▁(! s 39 0_ has _ feat ( S 39 0_ FE AT _ VE CTOR )) ▁{ ▁set _ sig p _ status ( si , ▁SIG P _ STAT _ INVALID _ ORDER ); ▁return ; ▁} ▁/* ▁cpu ▁has ▁to ▁be ▁stopped ▁*/ ▁if ▁( s 39 0_ cpu _ get _ state ( cpu ) ▁!= ▁CPU _ STATE _ STOP PED ) ▁{ ▁set _ sig p _ status ( si , ▁SIG P _ STAT _ INC OR RECT _ STATE ); ▁return ; ▁} ▁/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cpu _ g db _ write _ register ( CPU State ▁* env , ▁uint 8_ t ▁* mem _ buf , ▁int ▁n ) ▁{ ▁target _ ulong ▁tmp ; ▁tmp ▁= ▁l dt ul _ p ( mem _ buf ); ▁if ▁( n ▁< ▁3 2) ▁{ ▁env -> active _ tc . g pr [ n ] ▁= ▁tmp ; ▁return ▁sizeof ( target _ ulong ); ▁} ▁if ▁( env -> CP 0_ Config 1 ▁& ▁(1 ▁<< ▁CP 0 C 1_ FP ) ▁&& ▁n ▁>= ▁38 ▁&& ▁n ▁< ▁7 3) ▁{ ▁if ▁( n ▁< ▁7 0) ▁{ ▁if ▁( env -> CP 0_ Status ▁& ▁(1 ▁<< ▁CP 0 St _ FR )) ▁env -> active _ f pu . f pr [ n ▁- ▁38 ]. d ▁= ▁tmp ; ▁else ▁env -> active _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q EM UB H ▁* a io _ b h _ new ( A io Context ▁* ctx , ▁Q EM UB H Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁Q EM UB H ▁* b h ; ▁bh ▁= ▁g _ m alloc 0( size of ( Q EM UB H )); ▁bh -> ctx ▁= ▁ctx ; ▁bh -> cb ▁= ▁cb ; ▁bh -> op aque ▁= ▁opaque ; ▁qemu _ mut ex _ lock ( & ctx -> b h _ lock ); ▁bh -> next ▁= ▁ctx -> first _ b h ; ▁/* ▁Make ▁sure ▁that ▁the ▁members ▁are ▁ready ▁before ▁putting ▁bh ▁into ▁list ▁*/ ▁s mp _ w mb (); ▁ctx -> first _ b h ▁= ▁bh ; ▁qemu _ mut ex _ un lock ( & ctx -> b h _ lock ); ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁audi og en ( void ▁* data , ▁enum ▁AV Sample Format ▁sample _ fmt , ▁int ▁channels , ▁int ▁sample _ rate , ▁int ▁nb _ samples ) ▁{ ▁int ▁i , ▁ch , ▁k ; ▁double ▁v , ▁f , ▁a , ▁am pa ; ▁double ▁tab f 1[ S WR _ CH _ MAX ]; ▁double ▁tab f 2[ S WR _ CH _ MAX ]; ▁double ▁tab a [ S WR _ CH _ MAX ]; ▁unsigned ▁static ▁rnd ; ▁# define ▁PUT _ SA MPLE ▁set ( data , ▁ch , ▁k , ▁channels , ▁sample _ fmt , ▁v ); ▁# define ▁uint _ rand ( x ) ▁( x ▁= ▁x ▁* ▁16 645 25 ▁+ ▁101 39 04 22 3) ▁# define ▁dbl _ r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁paint _ mouse _ pointer ( AV Format Context ▁* s 1, ▁struct ▁g dig rab ▁* g dig rab ) ▁{ ▁CUR SOR INFO ▁ci ▁= ▁{0 }; ▁# define ▁CUR SOR _ ERROR ( str ) ▁\ ▁if ▁(! g dig rab -> cursor _ error _ print ed ) ▁{ ▁\ ▁WIN 32_ API _ ERROR ( str ); ▁\ ▁g dig rab -> cursor _ error _ print ed ▁= ▁1; ▁\ ▁} ▁ci . cb Size ▁= ▁sizeof ( ci ); ▁if ▁( Get Cursor Info ( & ci )) ▁{ ▁H CUR SOR ▁icon ▁= ▁Copy Cursor ( ci . h Cursor ); ▁ICON INFO ▁info ; ▁POINT ▁pos ; ▁RECT ▁clip _ rect ▁= ▁g dig rab -> clip _ re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁machine _ init fn ( Object ▁* obj ) ▁{ ▁Machine State ▁* ms ▁= ▁MA CHINE ( obj ); ▁ms -> kernel _ irq ch ip _ allowed ▁= ▁true ; ▁ms -> k vm _ shadow _ mem ▁= ▁-1; ▁ms -> dump _ guest _ core ▁= ▁true ; ▁object _ property _ add _ str ( obj , ▁" accel ", ▁machine _ get _ accel , ▁machine _ set _ accel , ▁NULL ); ▁object _ property _ set _ description ( obj , ▁" accel ", ▁" Accel erator ▁list ", ▁NULL ); ▁object _ property _ add _ bool ( obj , ▁" kernel - irq ch ip ", ▁NULL , ▁machine _ set _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ delete ( Block Driver State ▁* bs ) ▁{ ▁assert (! bs -> peer ); ▁/* ▁remove ▁from ▁list , ▁if ▁necessary ▁*/ ▁if ▁( bs -> device _ name [0] ▁!= ▁'\ 0 ') ▁{ ▁Q TAIL Q _ REMOVE ( & b dr v _ states , ▁bs , ▁list ); ▁} ▁b dr v _ close ( bs ); ▁if ▁( bs -> file ▁!= ▁NULL ) ▁{ ▁b dr v _ delete ( bs -> file ); ▁} ▁assert ( bs ▁!= ▁bs _ snapshots ); ▁qemu _ free ( bs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h mp _ migrate _ status _ cb ( void ▁* op aque ) ▁{ ▁Migration Status ▁* status ▁= ▁opaque ; ▁Migration Info ▁* info ; ▁info ▁= ▁q mp _ query _ migrate ( NULL ); ▁if ▁(! info -> has _ status ▁|| ▁str cmp ( info -> status , ▁" active ") ▁== ▁0) ▁{ ▁if ▁( info -> has _ disk ) ▁{ ▁int ▁progress ; ▁if ▁( info -> disk -> remaining ) ▁{ ▁progress ▁= ▁info -> disk -> transfer red ▁* ▁100 ▁/ ▁info -> disk -> total ; ▁} ▁else ▁{ ▁progress ▁= ▁100; ▁} ▁monitor _ printf ( status -> mon , ▁" Completed 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ on _ sig bus ( int ▁code , ▁void ▁* addr ) ▁{ ▁# if def ▁K VM _ CAP _ MCE ▁if ▁(( first _ cpu -> mc g _ cap ▁& ▁M CG _ SER _ P ) ▁&& ▁addr ▁&& ▁code ▁== ▁B US _ MCE ERR _ A O ) ▁{ ▁void ▁* v addr ; ▁ram _ addr _ t ▁ram _ addr ; ▁target _ ph ys _ addr _ t ▁p addr ; ▁/* ▁Hope ▁we ▁are ▁luck y ▁for ▁A O ▁M CE ▁*/ ▁v addr ▁= ▁addr ; ▁if ▁( q emu _ ram _ addr _ from _ host ( v addr , ▁& ram _ addr ) ▁|| ▁! k vm _ ph ysical _ memory _ addr _ from _ ram ( first _ cpu -> k vm _ state , ▁ram _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁coroutine _ fn ▁iscsi _ co _ pd is card ( Block Driver State ▁* bs , ▁int 64_ t ▁offset , ▁int ▁bytes ) ▁{ ▁I sc si L un ▁* is cs il un ▁= ▁bs -> op aque ; ▁struct ▁I sc si Task ▁i Task ; ▁struct ▁un map _ list ▁list ; ▁int ▁r ▁= ▁0; ▁if ▁(! is _ byte _ request _ lun _ aligned ( offset , ▁bytes , ▁is cs il un )) ▁{ ▁return ▁- EN OT SUP ; ▁} ▁if ▁(! is cs il un -> lb p . lb pu ) ▁{ ▁/* ▁UN MAP ▁is ▁not ▁supported ▁by ▁the ▁target ▁*/ ▁return ▁0; ▁} ▁list . l ba ▁= ▁offset ▁/ ▁is cs il un -> block _ size ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁m ips _ cpu _ handle _ mm u _ fault ( CPU State ▁* cs , ▁v addr ▁address , ▁int ▁rw , ▁int ▁mm u _ idx ) ▁{ ▁M IP SC PU ▁* cpu ▁= ▁M IP S _ CPU ( cs ); ▁CP UM IP S State ▁* env ▁= ▁& cpu -> env ; ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁hw addr ▁physical ; ▁int ▁prot ; ▁int ▁access _ type ; ▁# end if ▁int ▁ret ▁= ▁0; ▁# if ▁0 ▁log _ cpu _ state ( cs , ▁0); ▁# end if ▁qemu _ log _ mask ( CPU _ LOG _ MM U , ▁"% s ▁pc ▁" ▁TARGET _ F MT _ l x ▁" ▁ad ▁% " ▁V ADDR _ PRI x ▁" ▁rw ▁% d ▁mm u _ idx ▁% d \ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁ModuleType List ▁* find _ type ( module _ init _ type ▁type ) ▁{ ▁ModuleType List ▁* l ; ▁init _ types (); ▁l ▁= ▁& init _ type _ list [ type ]; ▁return ▁l ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ s uspend _ requested ( void ) ▁{ ▁int ▁r ▁= ▁suspend _ requested ; ▁suspend _ requested ▁= ▁0; ▁return ▁r ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁opt _ cp uf lags ( const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁# define ▁CPU FLAG _ MM X 2 ▁( AV _ CPU _ FLAG _ MM X ▁| ▁AV _ CPU _ FLAG _ MM X 2) ▁# define ▁CPU FLAG _3 D NOW ▁( AV _ CPU _ FLAG _3 D NOW ▁| ▁AV _ CPU _ FLAG _ MM X ) ▁# define ▁CPU FLAG _3 D NOW EXT ▁( AV _ CPU _ FLAG _3 D NOW EXT ▁| ▁CPU FLAG _3 D NOW ) ▁# define ▁CPU FLAG _ SS E ▁( AV _ CPU _ FLAG _ SS E ▁| ▁CPU FLAG _ MM X 2) ▁# define ▁CPU FLAG _ SS E 2 ▁( AV _ CPU _ FLAG _ SS E 2 ▁| ▁CPU FLAG _ SS E ) ▁# define ▁CPU FLAG _ SS

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ put _ h 2 64_ qp el 8_ mc 2 1_ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ mid v _ q rt _8 w _ ms a ( src ▁- ▁(2 ▁* ▁stride ) ▁- ▁2, ▁stride , ▁dst , ▁stride , ▁8, ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁serial _ tx _ done ( void ▁* op aque ) ▁{ ▁Serial State ▁* s ▁= ▁opaque ; ▁if ▁( s -> tx _ b urst ▁< ▁0) ▁{ ▁uint 16_ t ▁divider ; ▁if ▁( s -> div ider ) ▁divider ▁= ▁s -> div ider ; ▁else ▁divider ▁= ▁1; ▁/* ▁We ▁assume ▁10 ▁bits / char , ▁OK ▁for ▁this ▁purpose . ▁*/ ▁s -> tx _ b urst ▁= ▁TH RO TTLE _ TX _ INTERVAL ▁* ▁1000 ▁/ ▁(1 000000 ▁* ▁10 ▁/ ▁( s -> ba ud base ▁/ ▁divider )); ▁} ▁s -> th r _ ip ending ▁= ▁1; ▁s -> ls r ▁|= ▁U ART _ LS R _ TH RE ; ▁s -> ls r ▁|= ▁U ART _ LS R _ TE MT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ sp ice _ create _ host _ primary ( Simple Sp ice Display ▁* ss d ) ▁{ ▁Q X LD ev Surface Create ▁surface ; ▁mem set ( & surface , ▁0, ▁sizeof ( surface )); ▁d print (1, ▁"% s /% d : ▁% dx % d \ n ", ▁__ func __, ▁s sd -> q xl . id , ▁surface _ width ( ss d -> ds ), ▁surface _ height ( ss d -> ds )); ▁surface . format ▁= ▁S PI CE _ S UR FACE _ F MT _ 32_ x RGB ; ▁surface . width ▁= ▁surface _ width ( ss d -> ds ); ▁surface . height ▁= ▁surface _ height ( ss d -> ds ); ▁surface . stride ▁= ▁- 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ proc _7 50 fx ▁( CP UP PC State ▁* env ) ▁{ ▁gen _ spr _ ne _6 01 ( env ); ▁gen _ spr _7 xx ( env ); ▁/* ▁XXX ▁: ▁not ▁implemented ▁*/ ▁spr _ register ( env , ▁SP R _ L 2 CR , ▁" L 2 CR ", ▁SP R _ NO ACCESS , ▁SP R _ NO ACCESS , ▁& spr _ read _ generic , ▁NULL , ▁0 x 00000000 ); ▁/* ▁Time ▁base ▁*/ ▁gen _ tbl ( env ); ▁/* ▁Th erm al ▁management ▁*/ ▁gen _ spr _ th rm ( env ); ▁/* ▁XXX ▁: ▁not ▁implemented ▁*/ ▁spr _ register ( env , ▁SP R _7 50 _ TH RM 4, ▁" TH RM 4", ▁SP R _ NO ACCE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st _ print _ trace _ file _ status ( FILE ▁* stream , ▁int ▁(* stream _ printf )( FILE ▁* stream , ▁const ▁char ▁* fmt , ▁... )) ▁{ ▁stream _ printf ( stream , ▁" Trace ▁file ▁\" % s \" ▁% s .\ n ", ▁trace _ file _ name , ▁trace _ file _ enabled ▁? ▁" on " ▁: ▁" off "); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mk v _ write _ header ( AV Format Context ▁* s ) ▁{ ▁Mat ro sk a M ux Context ▁* mk v ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁eb ml _ master ▁eb ml _ header ; ▁AV Dictionary Entry ▁* tag ; ▁int ▁ret , ▁i , ▁version ▁= ▁2; ▁int 64_ t ▁creation _ time ; ▁if ▁(! str cmp ( s -> o format -> name , ▁" web m ")) ▁mk v -> mode ▁= ▁MODE _ WEB M ; ▁else ▁mk v -> mode ▁= ▁MODE _ M AT RO SK Av 2; ▁if ▁( mk v -> mode ▁!= ▁MODE _ WEB M ▁|| ▁av _ dict _ get ( s -> metadata , ▁" st ere o 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁e 1000 _ can _ receive ( void ▁* op aque ) ▁{ ▁E 1000 State ▁* s ▁= ▁opaque ; ▁return ▁(! ( s -> mac _ reg [ R CT L ] ▁& ▁E 1000 _ R CT L _ EN ) ▁|| ▁s -> mac _ reg [ RD H ] ▁!= ▁s -> mac _ reg [ R DT ]); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ sw s _ init _ sw Scale _ mm x ( Sw s Context ▁* c ) ▁{ ▁int ▁cpu _ flags ▁= ▁av _ get _ cpu _ flags (); ▁# if ▁HAVE _ IN LINE _ AS M ▁if ▁( cpu _ flags ▁& ▁AV _ CPU _ FLAG _ MM X ) ▁sw s _ init _ sw Scale _ MM X ( c ); ▁# if ▁HAVE _ MM X EXT _ IN LINE ▁if ▁( cpu _ flags ▁& ▁AV _ CPU _ FLAG _ MM X EXT ) ▁sw s _ init _ sw Scale _ MM X 2( c ); ▁# end if ▁# end if ▁/* ▁HAVE _ IN LINE _ AS M ▁*/ ▁# if ▁HAVE _ Y AS M ▁# define ▁ASS IGN _ SCALE _ F UNC 2( hs cal ef n , ▁filter size , ▁opt

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁t get ( const ▁uint 8_ t ▁** p , ▁int ▁type , ▁int ▁le ) ▁{ ▁switch ▁( type ) ▁{ ▁case ▁TI FF _ BYTE : ▁return ▁* (* p ) ++; ▁case ▁TI FF _ SHORT : ▁return ▁t get _ short ( p , ▁le ); ▁case ▁TI FF _ LONG : ▁return ▁t get _ long ( p , ▁le ); ▁default : ▁return ▁U INT _ MAX ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ hq _ slice ( AV Codec Context ▁* av ctx , ▁void ▁* arg ) ▁{ ▁int ▁i , ▁quant , ▁level , ▁orientation , ▁quant _ idx ; ▁uint 8_ t ▁qu ants [ MAX _ D WT _ LE VE LS ][ 4 ]; ▁D ira c Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁D ira c Slice ▁* slice ▁= ▁arg ; ▁Get Bit Context ▁* gb ▁= ▁& slice -> gb ; ▁skip _ bits _ long ( gb , ▁8 * s -> high quality . prefix _ bytes ); ▁quant _ idx ▁= ▁get _ bits ( gb , ▁8 ); ▁/* ▁Slice ▁quant ization ▁( slice _ quant izers () ▁in ▁the ▁specs ) ▁*/ ▁for 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁am r _ wb _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁AM R W B Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> sample _ rate ▁!= ▁16 000) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁16 000 Hz ▁sample ▁rate ▁supported \ n "); ▁return ▁A VER ROR ( EN OS Y S ); ▁} ▁if ▁( av ctx -> channels ▁!= ▁1) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁mon o ▁supported \ n "); ▁return ▁A VER ROR ( EN OS Y S ); ▁} ▁s -> mode ▁= ▁get _ wb _ bit rate _ mode ( av 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁div 32 ( uint 32_ t ▁* q _ ptr , ▁uint 64_ t ▁num , ▁uint 32_ t ▁den ) ▁{ ▁* q _ ptr ▁= ▁num ▁/ ▁den ; ▁return ▁num ▁% ▁den ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ fetch _ timestamp ( AV Codec Parser Context ▁* s , ▁int ▁off , ▁int ▁remove ) ▁{ ▁int ▁i ; ▁s -> d ts ▁= ▁s -> pts ▁= ▁AV _ NO PT S _ VALUE ; ▁s -> pos ▁= ▁-1; ▁s -> offset ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁AV _ PAR SER _ PT S _ NB ; ▁i ++) ▁{ ▁if ▁( s -> cur _ offset ▁+ ▁off ▁>= ▁s -> cur _ frame _ offset [ i ] ▁&& ▁( s -> frame _ offset ▁< ▁s -> cur _ frame _ offset [ i ] ▁|| ▁(! s -> frame _ offset ▁&& ▁! s -> next _ frame _ offset )) ▁&& ▁// ▁first ▁field / frame ▁// ▁check ▁disabled ▁since ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁simple _ whitespace ( void ) ▁{ ▁int ▁i ; ▁struct ▁{ ▁const ▁char ▁* encoded ; ▁Literal Q Object ▁decoded ; ▁} ▁test _ cases [] ▁= ▁{ ▁{ ▁. encoded ▁= ▁" ▁[ ▁43 ▁, ▁42 ▁] ", ▁. decoded ▁= ▁Q LIT _ Q LIST (( ( Literal Q Object [] ){ ▁Q LIT _ Q INT ( 43 ), ▁Q LIT _ Q INT ( 42 ), ▁{ ▁} ▁}) ), ▁}, ▁{ ▁. encoded ▁= ▁" ▁[ ▁43 ▁, ▁{ ▁' h ' ▁: ▁' b ' ▁}, ▁[ ▁], ▁42 ▁] ", ▁. decoded ▁= ▁Q LIT _ Q LIST (( ( Literal Q Object [] ){ ▁Q LIT _ Q INT ( 43 ), ▁Q LIT _ Q DICT (( ( Literal Q Dict Entry [] ){ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ check _ sr ( Dis as Context ▁* dc , ▁uint 32_ t ▁sr , ▁unsigned ▁access ) ▁{ ▁if ▁(! xt ens a _ option _ bits _ enabled ( dc -> config , ▁s reg names [ sr ]. opt _ bits )) ▁{ ▁if ▁( s reg names [ sr ]. name ) ▁{ ▁qemu _ log (" SR ▁% s ▁is ▁not ▁configured \ n ", ▁s reg names [ sr ]. name ); ▁} ▁else ▁{ ▁qemu _ log (" SR ▁% d ▁is ▁not ▁implemented \ n ", ▁sr ); ▁} ▁gen _ exception _ cause ( dc , ▁I L LEG AL _ IN STR U CTION _ CA USE ); ▁} ▁else ▁if ▁(! ( s reg names [ sr ]. access ▁& ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ l sw i ( Dis as Context ▁* ctx ) ▁{ ▁TC G v ▁t 0; ▁TC G v _ i 32 ▁t 1, ▁t 2; ▁int ▁nb ▁= ▁NB ( ctx -> op code ); ▁int ▁start ▁= ▁r D ( ctx -> op code ); ▁int ▁ra ▁= ▁r A ( ctx -> op code ); ▁int ▁nr ; ▁if ▁( nb ▁== ▁0) ▁nb ▁= ▁32 ; ▁nr ▁= ▁( nb ▁+ ▁3) ▁/ ▁4; ▁if ▁( un likely ( l sw _ reg _ in _ range ( start , ▁nr , ▁ra ))) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ IN VAL _ LS W X ); ▁return ; ▁} ▁gen _ set _ access _ type ( ctx , ▁ACCESS _ INT ); ▁/* ▁N IP ▁cannot ▁be

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* data buf , ▁float ▁** out _ samples ) ▁{ ▁AT RA C 3 Context ▁* q ▁= ▁av ctx -> priv _ data ; ▁int ▁ret , ▁i ; ▁uint 8_ t ▁* ptr 1; ▁if ▁( q -> coding _ mode ▁== ▁J O INT _ ST ERE O ) ▁{ ▁/* ▁channel ▁cou pling ▁mode ▁*/ ▁/* ▁decode ▁Sound ▁Unit ▁1 ▁*/ ▁init _ get _ bits ( & q -> gb , ▁data buf , ▁av ctx -> block _ align ▁* ▁8 ); ▁ret ▁= ▁decode _ channel _ sound _ unit ( q , ▁& q -> gb , ▁q -> units , ▁out _ samples [0], ▁0, 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁HEL PER ( sh r _ cc )( CP UM 68 K State ▁* env , ▁uint 32_ t ▁val , ▁uint 32_ t ▁shift ) ▁{ ▁uint 64_ t ▁temp ; ▁uint 32_ t ▁result ; ▁shift ▁&= ▁6 3; ▁temp ▁= ▁( uint 64_ t ) val ▁<< ▁32 ▁>> ▁shift ; ▁result ▁= ▁temp ▁>> ▁32 ; ▁env -> cc _ c ▁= ▁( temp ▁>> ▁3 1) ▁& ▁1; ▁env -> cc _ n ▁= ▁result ; ▁env -> cc _ z ▁= ▁result ; ▁env -> cc _ v ▁= ▁0; ▁env -> cc _ x ▁= ▁shift ▁? ▁env -> cc _ c ▁: ▁env -> cc _ x ; ▁return ▁result ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁term _ down _ char ( void ) ▁{ ▁if ▁( term _ hist _ entry ▁== ▁TER M _ MAX _ CM DS ▁- ▁1 ▁|| ▁term _ hist _ entry ▁== ▁-1) ▁return ; ▁if ▁( term _ history [ ++ term _ hist _ entry ] ▁!= ▁NULL ) ▁{ ▁str c py ( term _ cmd _ buf , ▁term _ history [ term _ hist _ entry ]); ▁} ▁else ▁{ ▁term _ hist _ entry ▁= ▁-1; ▁} ▁term _ printf ("\ n "); ▁term _ print _ cmdline ( term _ cmd _ buf ); ▁term _ cmd _ buf _ index ▁= ▁term _ cmd _ buf _ size ▁= ▁str len ( term _ cmd _ buf ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ c ab ac _ mb _ cb p _ l um a ( ▁H 264 Context ▁* h ) ▁{ ▁int ▁cb p _ b , ▁cb p _ a , ▁ctx , ▁cb p ▁= ▁0; ▁cb p _ a ▁= ▁h -> slice _ table [ h -> left _ mb _ xy [0]] ▁== ▁h -> slice _ num ▁? ▁h -> left _ cb p ▁: ▁-1; ▁cb p _ b ▁= ▁h -> slice _ table [ h -> top _ mb _ xy ] ▁== ▁h -> slice _ num ▁? ▁h -> top _ cb p ▁: ▁-1; ▁ctx ▁= ▁! ( cb p _ a ▁& ▁0 x 0 2) ▁+ ▁2 ▁* ▁! ( cb p _ b ▁& ▁0 x 04 ); ▁cb p ▁|= ▁get _ c ab ac _ n oin line ( & h -> c ab ac , ▁& h -> c ab ac _ state [ 73 ▁+ ▁ctx

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ q sv _ decode _ reset ( AV Codec Context ▁* av ctx , ▁Q SV Context ▁* q ) ▁{ ▁Q SV Frame ▁* cur ; ▁AV Packet ▁pkt ; ▁int ▁ret ▁= ▁0; ▁m fx Video Param ▁param ▁= ▁{ ▁{ ▁0 ▁} ▁}; ▁if ▁( q -> re init _ pending ) ▁{ ▁close _ decoder ( q ); ▁} ▁else ▁if ▁( q -> engine _ ready ) ▁{ ▁ret ▁= ▁M FX Video DE CODE _ Get Video Param ( q -> session , ▁& param ); ▁if ▁( ret ▁< ▁0) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" M FX ▁decode ▁get ▁param ▁error ▁% d \ n ", ▁ret ); ▁} ▁ret ▁= ▁M FX Video DE COD

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁helper _ s div ( target _ ulong ▁a , ▁target _ ulong ▁b ) ▁{ ▁int 64_ t ▁x 0; ▁int 32_ t ▁x 1; ▁x 0 ▁= ▁( a ▁& ▁0 xffffffff ) ▁| ▁(( int 64_ t ) ▁( env -> y ) ▁<< ▁32 ); ▁x 1 ▁= ▁( b ▁& ▁0 xffffffff ); ▁if ▁( x 1 ▁== ▁0) ▁{ ▁raise _ exception ( TT _ DIV _ ZERO ); ▁} ▁x 0 ▁= ▁x 0 ▁/ ▁x 1; ▁if ▁(( int 32_ t ) ▁x 0 ▁!= ▁x 0) ▁{ ▁env -> cc _ src 2 ▁= ▁1; ▁return ▁x 0 ▁< ▁0 ? ▁0 x 8 0000000 : ▁0 x 7 ffff fff ; ▁} ▁else ▁{ ▁env -> cc _ src 2 ▁= ▁0; ▁return ▁x 0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x h ci _ reset ( Device State ▁* dev ) ▁{ ▁X H CI State ▁* x h ci ▁= ▁X H CI ( dev ); ▁int ▁i ; ▁trace _ usb _ x h ci _ reset (); ▁if ▁(! ( x h ci -> usb st s ▁& ▁USB ST S _ H CH )) ▁{ ▁D PRI NT F (" x h ci : ▁reset ▁while ▁running ! \ n "); ▁} ▁x h ci -> usb cmd ▁= ▁0; ▁x h ci -> usb st s ▁= ▁USB ST S _ H CH ; ▁x h ci -> dn ctrl ▁= ▁0; ▁x h ci -> crc r _ low ▁= ▁0; ▁x h ci -> crc r _ high ▁= ▁0; ▁x h ci -> d cb a ap _ low ▁= ▁0; ▁x h ci -> d cb a ap _ high ▁= ▁0; ▁x h ci -> config ▁= ▁0; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁p pc _ find _ by _ pv r ▁( uint 32_ t ▁p vr , ▁p pc _ def _ t ▁** def ) ▁{ ▁int ▁i , ▁ret ; ▁ret ▁= ▁-1; ▁* def ▁= ▁NULL ; ▁for ▁( i ▁= ▁0; ▁p pc _ defs [ i ]. name ▁!= ▁NULL ; ▁i ++) ▁{ ▁if ▁(( pv r ▁& ▁p pc _ defs [ i ]. pv r _ mask ) ▁== ▁( pp c _ defs [ i ]. pv r ▁& ▁p pc _ defs [ i ]. pv r _ mask )) ▁{ ▁* def ▁= ▁& pp c _ defs [ i ]; ▁ret ▁= ▁0; ▁break ; ▁} ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ tl b _ update ( uint 32_ t ▁T 0) ▁{ ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁uint 32_ t ▁v addr ; ▁uint 32_ t ▁srs ▁= ▁env -> pre gs [ PR _ S RS ]; ▁if ▁( s rs ▁!= ▁1 ▁&& ▁srs ▁!= ▁2) ▁return ; ▁v addr ▁= ▁cr is _ mm u _ tl b _ latest _ update ( env , ▁T 0); ▁D ( printf (" flush ▁old _ v addr =% x ▁v addr =% x ▁T 0 =% x \ n ", ▁v addr , ▁env -> s re gs [ S FR _ R _ MM _ CA USE ] ▁& ▁TARGET _ PAGE _ MASK , ▁T 0 )); ▁tl b _ flush _ page ( env , ▁v addr ); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁patch _ pc ih p ( int ▁slot , ▁uint 8_ t ▁* ss dt _ ptr , ▁uint 32_ t ▁e ject ) ▁{ ▁s sd t _ ptr [ AC PI _ PC I HP _ OFFSET _ H EX ] ▁= ▁ac pi _ get _ hex ( slot ▁>> ▁4 ); ▁s sd t _ ptr [ AC PI _ PC I HP _ OFFSET _ H EX ▁+ ▁1] ▁= ▁ac pi _ get _ hex ( slot ); ▁s sd t _ ptr [ AC PI _ PC I HP _ OFFSET _ ID ] ▁= ▁slot ; ▁s sd t _ ptr [ AC PI _ PC I HP _ OFFSET _ AD R ▁+ ▁2] ▁= ▁slot ; ▁/* ▁Runtime ▁patch ing ▁of ▁AC PI _ E J 0: ▁to ▁disable ▁hot plug ▁for ▁a ▁slot , ▁* ▁replace ▁the ▁method ▁na

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁float ▁ss im _ plane ( uint 8_ t ▁* main , ▁int ▁main _ stride , ▁uint 8_ t ▁* ref , ▁int ▁ref _ stride , ▁int ▁width , ▁int ▁height , ▁void ▁* temp ) ▁{ ▁int ▁z ▁= ▁0; ▁int ▁x , ▁y ; ▁float ▁ss im ▁= ▁0.0 ; ▁int ▁(* sum 0) [4] ▁= ▁temp ; ▁int ▁(* sum 1) [4] ▁= ▁sum 0 ▁+ ▁( width ▁>> ▁2) ▁+ ▁3; ▁width ▁>>= ▁2; ▁height ▁>>= ▁2; ▁for ▁( y ▁= ▁1; ▁y ▁< ▁height ; ▁y ++) ▁{ ▁for ▁( ; ▁z ▁<= ▁y ; ▁z ++) ▁{ ▁F FS W AP ( void *, ▁sum 0, ▁sum 1); ▁for ▁( x ▁= ▁0; ▁x ▁< ▁width ; ▁x += 2) ▁ss im _4 x 4 x 2_

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nv me _ instance _ init ( Object ▁* obj ) ▁{ ▁object _ property _ add ( obj , ▁" boot index ", ▁" int 32 ", ▁nv me _ get _ boot index , ▁nv me _ set _ boot index , ▁NULL , ▁NULL , ▁NULL ); ▁object _ property _ set _ int ( obj , ▁-1, ▁" boot index ", ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁blk verify _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁B DR V Bl k verify State ▁* s ▁= ▁bs -> op aque ; ▁Q emu Opts ▁* opts ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁opts ▁= ▁qemu _ opts _ create ( & runtime _ opts , ▁NULL , ▁0, ▁& error _ abort ); ▁qemu _ opts _ abs orb _ q dict ( opts , ▁options , ▁& local _ err ); ▁if ▁( local _ err ) ▁{ ▁error _ propag ate ( err p , ▁local _ err ); ▁ret ▁= ▁- E IN VAL ; ▁goto ▁fail ; ▁/* ▁Open ▁the

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ tl b _ read ( TC G Context ▁* s , ▁TC G Reg ▁addr lo , ▁TC G Reg ▁addr hi , ▁int ▁s _ bits , ▁int ▁tl b _ offset ) ▁{ ▁TC G Reg ▁base ▁= ▁TC G _ A REG 0; ▁/* ▁Should ▁generate ▁something ▁like ▁the ▁following : ▁* ▁pre - v 7: ▁* ▁sh r ▁tmp , ▁addr _ reg , ▁# TARGET _ PAGE _ BITS ▁(1) ▁* ▁add ▁r 2, ▁env , ▁# off ▁& ▁0 xff 00 ▁* ▁and ▁r 0, ▁tmp , ▁# ( CPU _ TL B _ SIZE ▁- ▁1) ▁(2) ▁* ▁add ▁r 2, ▁r 2, ▁r 0, ▁l sl ▁# CPU _ TL B _ ENTRY _ BITS ▁(3) ▁* ▁l dr ▁r 0, ▁[ r 2, ▁# off ▁& ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q dm 2_ decode _ super _ block ( Q DM 2 Context ▁* q ) ▁{ ▁Get Bit Context ▁gb ; ▁Q DM 2 Sub Packet ▁header , ▁* packet ; ▁int ▁i , ▁packet _ bytes , ▁sub _ packet _ size , ▁sub _ pack ets _ D ; ▁unsigned ▁int ▁next _ index ▁= ▁0; ▁mem set ( q -> tone _ level _ idx _ hi 1, ▁0, ▁sizeof ( q -> tone _ level _ idx _ hi 1) ); ▁mem set ( q -> tone _ level _ idx _ mid , ▁0, ▁sizeof ( q -> tone _ level _ idx _ mid )); ▁mem set ( q -> tone _ level _ idx _ hi 2, ▁0, ▁sizeof ( q -> tone _ level _ idx 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h Scale 8 To 15 _ c ( Sw s Context ▁* c , ▁int 16_ t ▁* dst , ▁int ▁dst W , ▁const ▁uint 8_ t ▁* src , ▁const ▁int 16_ t ▁* filter , ▁const ▁int 16_ t ▁* filter Pos , ▁int ▁filter Size ) ▁{ ▁int ▁i ; ▁for ▁( i =0; ▁i < dst W ; ▁i ++) ▁{ ▁int ▁j ; ▁int ▁src Pos = ▁filter Pos [ i ]; ▁int ▁val =0; ▁for ▁( j =0; ▁j < filter Size ; ▁j ++) ▁{ ▁val ▁+= ▁(( int ) src [ src Pos ▁+ ▁j ]) * filter [ filter Size * i ▁+ ▁j ]; ▁} ▁// filter ▁+= ▁h Filter Size ; ▁dst [ i ] ▁= ▁FF MIN ( val >> 7, ▁(1 << 15

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Migration State ▁* migrate _ get _ current ( void ) ▁{ ▁static ▁Migration State ▁current _ migration ▁= ▁{ ▁. state ▁= ▁M IG _ STATE _ NONE , ▁. band width _ limit ▁= ▁MAX _ TH RO TTLE , ▁. xb z r le _ cache _ size ▁= ▁DEFAULT _ M IG RATE _ CACHE _ SIZE , ▁. mb ps ▁= ▁-1, ▁}; ▁return ▁& current _ migration ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁qemu _ co _ send v _ recv v ( int ▁sock fd , ▁struct ▁i ove c ▁* io v , ▁unsigned ▁i ov _ cnt , ▁size _ t ▁offset , ▁size _ t ▁bytes , ▁bool ▁do _ send ) ▁{ ▁size _ t ▁done ▁= ▁0; ▁s size _ t ▁ret ; ▁while ▁( done ▁< ▁bytes ) ▁{ ▁ret ▁= ▁i ov _ send _ recv ( sock fd , ▁i ov , ▁offset ▁+ ▁done , ▁bytes ▁- ▁done , ▁do _ send ); ▁if ▁( ret ▁> ▁0) ▁{ ▁done ▁+= ▁ret ; ▁} ▁else ▁if ▁( ret ▁< ▁0) ▁{ ▁if ▁( err no ▁== ▁E AG AIN ) ▁{ ▁qemu _ cor outine _ yield (); ▁} ▁else ▁if ▁( done ▁== ▁0) ▁{ ▁return ▁-1; ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ change _ back ing _ file ( Block Driver State ▁* bs , ▁const ▁char ▁* back ing _ file , ▁const ▁char ▁* back ing _ fmt ) ▁{ ▁return ▁qc ow 2_ update _ ext _ header ( bs , ▁backing _ file , ▁backing _ fmt ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av _ always _ inline ▁filter _ mb _ edge ch ( ▁uint 8_ t ▁* pix , ▁int ▁stride , ▁const ▁int 16_ t ▁b S [4 ], ▁unsigned ▁int ▁qp , ▁H 264 Context ▁* h ▁) ▁{ ▁const ▁int ▁qp _ bd _ offset ▁= ▁6 ▁* ▁( h -> sp s . bit _ depth _ l um a ▁- ▁8 ); ▁const ▁unsigned ▁int ▁index _ a ▁= ▁qp ▁- ▁qp _ bd _ offset ▁+ ▁h -> slice _ alpha _ c 0_ offset ; ▁const ▁int ▁alpha ▁= ▁alpha _ table [ index _ a ]; ▁const ▁int ▁beta ▁= ▁beta _ table [ qp ▁- ▁qp _ bd _ offset ▁+ ▁h -> slice _ beta _ offset ]; ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sun 4 d _ hw _ init ( const ▁struct ▁sun 4 d _ hw def ▁* hw def , ▁ram _ addr _ t ▁RAM _ size , ▁const ▁char ▁* boot _ device , ▁Display State ▁* ds , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁CPU State ▁* env , ▁* envs [ MAX _ CP US ]; ▁unsigned ▁int ▁i ; ▁void ▁* i oun its [ MAX _ IO UN ITS ], ▁* es pd ma , ▁* led ma , ▁* main _ es p , ▁* nv ram , ▁* sb i ; ▁qemu _ irq ▁* cpu _ ir qs [ MAX 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ rd ma _ block _ for _ w rid ( RD MA Context ▁* rd ma , ▁int ▁wr id _ requested ) ▁{ ▁int ▁num _ c q _ events ▁= ▁0, ▁ret ▁= ▁0; ▁struct ▁ib v _ c q ▁* c q ; ▁void ▁* c q _ ctx ; ▁uint 64_ t ▁wr _ id ▁= ▁R D MA _ WR ID _ NONE , ▁wr _ id _ in ; ▁if ▁( ib v _ req _ notify _ c q ( rd ma -> c q , ▁0 )) ▁{ ▁return ▁-1; ▁} ▁/* ▁poll ▁cq ▁first ▁*/ ▁while ▁( wr _ id ▁!= ▁wr id _ requested ) ▁{ ▁ret ▁= ▁qemu _ rd ma _ poll ( rd ma , ▁& wr _ id _ in ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁wr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( rgb 15 to 32 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁int ▁src _ size ) ▁{ ▁const ▁uint 16_ t ▁* end ; ▁const ▁uint 16_ t ▁* mm _ end ; ▁uint 8_ t ▁* d ▁= ▁dst ; ▁const ▁uint 16_ t ▁* s ▁= ▁( const ▁uint 16_ t ▁* ) src ; ▁end ▁= ▁s ▁+ ▁src _ size /2 ; ▁__ asm __ ▁volatile ( PRE FETCH " ▁% 0 ": :" m " (* s ): " memory "); ▁__ asm __ ▁volatile (" px or ▁%% mm 7, % % mm 7 ▁\ n \ t ": :: " memory "); ▁__ asm __ ▁volatile (" pc m pe q d ▁%% mm 6, % % mm 6 ▁\ n \ t ": :

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mux _ chr _ can _ read ( void ▁* op aque ) ▁{ ▁Char Driver State ▁* chr ▁= ▁opaque ; ▁M ux Driver ▁* d ▁= ▁chr -> op aque ; ▁if ▁(( d -> prod ▁- ▁d -> cons ) ▁< ▁M U X _ BUFFER _ SIZE ) ▁return ▁1; ▁if ▁( d -> chr _ can _ read [ chr -> focus ]) ▁return ▁d -> chr _ can _ read [ chr -> focus ]( d -> ext _ op aque [ chr -> focus ]); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁bool ▁v td _ queued _ inv _ enable _ check ( Int el I OM MU State ▁* s ) ▁{ ▁return ▁s -> iq _ tail ▁== ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁h cs cale ( Sw s Context ▁* c , ▁int 16_ t ▁* dst 1, ▁int 16_ t ▁* dst 2, ▁int ▁dst Width , ▁const ▁uint 8_ t ▁* src _ in [4 ], ▁int ▁src W , ▁int ▁x Inc , ▁const ▁int 16_ t ▁* h Ch r Filter , ▁const ▁int 16_ t ▁* h Ch r Filter Pos , ▁int ▁h Ch r Filter Size , ▁uint 8_ t ▁* format Conv Buffer , ▁uint 32_ t ▁* pal ) ▁{ ▁const ▁uint 8_ t ▁* src 1 ▁= ▁src _ in [1], ▁* src 2 ▁= ▁src _ in [2 ]; ▁if ▁( c -> chr To Y V 12) ▁{ ▁uint 8_ t ▁* buf 2 ▁= ▁format Conv Buffer ▁+ ▁F F

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁b dr v _ co _ do _ copy _ on _ read v ( B dr v Child ▁* child , ▁int 64_ t ▁offset , ▁unsigned ▁int ▁bytes , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁Block Driver State ▁* bs ▁= ▁child -> bs ; ▁/* ▁Perform ▁I / O ▁through ▁a ▁temporary ▁buffer ▁so ▁that ▁users ▁who ▁s cri b ble ▁over ▁* ▁their ▁read ▁buffer ▁while ▁the ▁operation ▁is ▁in ▁progress ▁do ▁not ▁end ▁up ▁* ▁modifying ▁the ▁image ▁file . ▁This ▁is ▁critical ▁for ▁zero - copy ▁guest ▁I / O ▁* ▁where ▁anything ▁might ▁happe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ sc si _ device _ un real ize ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁virt io _ sc si _ common _ un real ize ( dev , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁protocol _ client _ init ( V nc State ▁* vs , ▁uint 8_ t ▁* data , ▁size _ t ▁len ) ▁{ ▁char ▁buf [10 24 ]; ▁V nc Share Mode ▁mode ; ▁int ▁size ; ▁mode ▁= ▁data [0] ▁? ▁V NC _ SHA RE _ MODE _ SHA RED ▁: ▁V NC _ SHA RE _ MODE _ EX CLUSIVE ; ▁switch ▁( vs -> vd -> share _ policy ) ▁{ ▁case ▁V NC _ SHA RE _ POLICY _ IGNO RE : ▁/* ▁* ▁Ignore ▁the ▁shared ▁flag . ▁Nothing ▁to ▁do ▁here . ▁* ▁* ▁Doesn ' t ▁conform ▁to ▁the ▁r fb ▁spec ▁but ▁is ▁traditional ▁qemu ▁* ▁behavior , ▁thus ▁left ▁here ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ l um a _ h v _ q rt _ and _ aver _ dst _4 x 4_ ms a ( const ▁uint 8_ t ▁* src _ x , ▁const ▁uint 8_ t ▁* src _ y , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride ) ▁{ ▁v 16 i 8 ▁src _ hz 0, ▁src _ hz 1, ▁src _ hz 2, ▁src _ hz 3; ▁v 16 u 8 ▁dst 0, ▁dst 1, ▁dst 2, ▁dst 3; ▁v 16 i 8 ▁src _ vt 0, ▁src _ vt 1, ▁src _ vt 2, ▁src _ vt 3, ▁src _ vt 4; ▁v 16 i 8 ▁src _ vt 5, ▁src _ vt 6, ▁src _ vt 7, ▁src _ vt 8 ; ▁v 16 i 8 ▁mask 0, ▁mask 1, ▁mask 2; ▁v 8 i 16 ▁h z _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block Driver A IO CB ▁* raw _ a io _ read v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁B DR V Raw State ▁* s ▁= ▁bs -> op aque ; ▁return ▁pa io _ submit ( bs , ▁s -> h file , ▁sector _ num , ▁q io v , ▁nb _ sect ors , ▁cb , ▁opaque , ▁Q EM U _ A IO _ READ ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc x _ blit _ writ el ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁TC X State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁ad sr , ▁len ; ▁int ▁i ; ▁if ▁(! ( addr ▁& ▁4 )) ▁{ ▁s -> tmp blit ▁= ▁val ; ▁} ▁else ▁{ ▁addr ▁= ▁( addr ▁>> ▁3) ▁& ▁0 xff fff ; ▁ad sr ▁= ▁val ▁& ▁0 xff ffff ; ▁len ▁= ▁(( val ▁>> ▁24 ) ▁& ▁0 x 1 f ) ▁+ ▁1; ▁if ▁( ad sr ▁== ▁0 xff ffff ) ▁{ ▁mem set ( & s -> v ram [ addr ], ▁s -> tmp blit , ▁len ); ▁if ▁( s -> depth ▁== ▁24 ) ▁{ ▁val ▁= ▁s -> tmp bl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ loop filter _ cb _ or _ cr _ in tra _ edge _ ver _ ms a ( uint 8_ t ▁* data _ cb _ or _ cr , ▁uint 8_ t ▁alpha _ in , ▁uint 8_ t ▁beta _ in , ▁uint 32_ t ▁img _ width ) ▁{ ▁uint 16_ t ▁out 0, ▁out 1, ▁out 2, ▁out 3; ▁v 8 i 16 ▁tmp 1; ▁v 16 u 8 ▁alpha , ▁beta , ▁is _ less _ than ; ▁v 8 i 16 ▁p 0_ or _ q 0, ▁q 0_ or _ p 0; ▁v 16 u 8 ▁p 1_ or _ q 1_ org , ▁p 0_ or _ q 0_ org , ▁q 0_ or _ p 0_ org , ▁q 1_ or _ p 1_ org ; ▁v 16 i 8 ▁zero ▁= ▁{ ▁0 ▁}; ▁v 16 u 8 ▁p 0_ as ub _ q 0, ▁p 1_ as 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 26 1_ handle _ packet ( AV Format Context ▁* ctx , ▁Payload Context ▁* data , ▁AV Stream ▁* st , ▁AV Packet ▁* pk t , ▁uint 32_ t ▁* timestamp , ▁const ▁uint 8_ t ▁* buf , ▁int ▁len , ▁uint 16_ t ▁seq , ▁int ▁flags ) ▁{ ▁int ▁sb it , ▁e bit , ▁g ob n , ▁mb ap , ▁quant ; ▁int ▁res ; ▁// av _ log ( ctx , ▁AV _ LOG _ DEBUG , ▁" got ▁h 26 1 ▁R TP ▁packet ▁with ▁time : ▁% u \ n ", ▁timestamp ); ▁/* ▁drop ▁data ▁of ▁previous ▁packets ▁in ▁case ▁of ▁non - contin uous ▁( loss ) ▁packet ▁stream ▁*/ ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v d pa u _ mpeg _ start _ frame ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buffer , ▁uint 32_ t ▁size ) ▁{ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁av ctx -> priv _ data ; ▁Picture ▁* pic ▁= ▁s -> current _ picture _ ptr ; ▁struct ▁v d pa u _ picture _ context ▁* pic _ ctx ▁= ▁pic -> hw accel _ picture _ private ; ▁V dp Picture Info M PEG 1 Or 2 ▁* info ▁= ▁& pic _ ctx -> info . mpeg ; ▁V dp Video Surface ▁ref ; ▁int ▁i ; ▁/* ▁fill ▁V dp Picture Info M PEG 1 Or 2 ▁struct ▁*/ ▁info -> for

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h 26 3_ decode _ init _ vlc ( M peg Enc Context ▁* s ) ▁{ ▁static ▁int ▁done ▁= ▁0; ▁if ▁(! done ) ▁{ ▁done ▁= ▁1; ▁init _ vlc ( & in tra _ M CB PC _ vlc , ▁INT RA _ M CB PC _ V LC _ BITS , ▁9, ▁in tra _ M CB PC _ bits , ▁1, ▁1, ▁in tra _ M CB PC _ code , ▁1, ▁1); ▁init _ vlc ( & inter _ M CB PC _ vlc , ▁INTER _ M CB PC _ V LC _ BITS , ▁28, ▁inter _ M CB PC _ bits , ▁1, ▁1, ▁inter _ M CB PC _ code , ▁1, ▁1); ▁init _ vlc ( & cb py _ vlc , ▁CB PY _ V LC _ BITS , ▁16, ▁& cb py _ tab [0] [1], ▁2, ▁1, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁i cp _ p it _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁unsigned ▁size ) ▁{ ▁i cp _ p it _ state ▁* s ▁= ▁( ic p _ p it _ state ▁* ) op aque ; ▁int ▁n ; ▁/* ▁??? ▁Don ' t ▁know ▁the ▁Prime Cell ▁ID ▁for ▁this ▁device . ▁*/ ▁n ▁= ▁offset ▁>> ▁8 ; ▁if ▁( n ▁> ▁3) ▁{ ▁hw _ error (" sp 80 4_ read : ▁Bad ▁timer ▁% d \ n ", ▁n ); ▁} ▁return ▁arm _ timer _ read ( s -> timer [ n ], ▁offset ▁& ▁0 xff ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg 1_ decode _ sequence ( AV Codec Context ▁* av ctx , ▁U INT 8 ▁* buf , ▁int ▁buf _ size ) ▁{ ▁M peg 1 Context ▁* s 1 ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& s 1 -> mpeg _ enc _ ctx ; ▁int ▁width , ▁height , ▁i , ▁v , ▁j ; ▁init _ get _ bits ( & s -> gb , ▁buf , ▁buf _ size ); ▁width ▁= ▁get _ bits ( & s -> gb , ▁12 ); ▁height ▁= ▁get _ bits ( & s -> gb , ▁12 ); ▁skip _ bits ( & s -> gb , ▁4 ); ▁s -> frame _ rate _ index ▁= ▁get _ bits ( & s -> gb , ▁4 ); ▁if ▁( s -> fr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ rf ps _ calculate ( AV Format Context ▁* ic ) ▁{ ▁int ▁i , ▁j ; ▁for ▁( i ▁= ▁0; ▁i < ic -> nb _ streams ; ▁i ++) ▁{ ▁AV Stream ▁* st ▁= ▁ic -> streams [ i ]; ▁if ▁( st -> codec -> codec _ type ▁!= ▁AV MEDIA _ TYPE _ VI DEO ) ▁// ▁the ▁check ▁for ▁tb _ un re liable () ▁is ▁not ▁completely ▁correct , ▁since ▁this ▁is ▁not ▁about ▁handling ▁// ▁a ▁unre liable / in exact ▁time ▁base , ▁but ▁a ▁time ▁base ▁that ▁is ▁fin er ▁than ▁necessary , ▁as ▁e . g . ▁// ▁ip movie . c ▁produces . ▁if ▁( tb _ u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ compute _ ef lags _ o ( Dis as Context ▁* s , ▁TC G v ▁reg ) ▁{ ▁gen _ compute _ ef lags ( s ); ▁tc g _ gen _ sh ri _ tl ( reg , ▁cpu _ cc _ src , ▁11 ); ▁tc g _ gen _ and i _ tl ( reg , ▁reg , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pred _ spatial _ direct _ m otion ( const ▁H 264 Context ▁* const ▁h , ▁H 264 Slice Context ▁* sl , ▁int ▁* mb _ type ) ▁{ ▁int ▁b 8_ stride ▁= ▁2; ▁int ▁b 4_ stride ▁= ▁h -> b _ stride ; ▁int ▁mb _ xy ▁= ▁sl -> mb _ xy , ▁mb _ y ▁= ▁sl -> mb _ y ; ▁int ▁mb _ type _ col [2 ]; ▁const ▁int 16_ t ▁(* l 1 mv 0) [2], ▁(* l 1 mv 1) [2 ]; ▁const ▁int 8_ t ▁* l 1 ref 0, ▁* l 1 ref 1; ▁const ▁int ▁is _ b 8 x 8 ▁= ▁IS _8 X 8 (* mb _ type ); ▁unsigned ▁int ▁sub _ mb _ type ▁= ▁MB _ TYPE _ L 0 L 1; ▁in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gem _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁Gem State ▁* s ▁= ▁( G em State ▁* ) op aque ; ▁uint 32_ t ▁readonly ; ▁DB _ PRI NT (" offset : ▁0 x % 04 x ▁write : ▁0 x % 08 x ▁", ▁offset , ▁( un signed ) val ); ▁offset ▁>>= ▁2; ▁/* ▁S qu ash ▁bits ▁which ▁are ▁read ▁only ▁in ▁write ▁value ▁*/ ▁val ▁&= ▁~ ( s -> re gs _ ro [ offset ]); ▁/* ▁Pre serve ▁( only ) ▁bits ▁which ▁are ▁read ▁only ▁in ▁register ▁*/ ▁readonly ▁= ▁s -> re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ loop ( CP UM IP S State ▁* env ) ▁{ ▁target _ sig info _ t ▁info ; ▁int ▁tra pn r , ▁ret ; ▁unsigned ▁int ▁sy scall _ num ; ▁for ( ; ;) ▁{ ▁tra pn r ▁= ▁cpu _ m ips _ exec ( env ); ▁switch ( tr ap nr ) ▁{ ▁case ▁EX CP _ SY SC ALL : ▁sy scall _ num ▁= ▁env -> active _ tc . g pr [2] ▁- ▁4 000; ▁env -> active _ tc . PC ▁+= ▁4; ▁if ▁( sy scall _ num ▁>= ▁sizeof ( m ips _ sy scall _ args )) ▁{ ▁ret ▁= ▁- EN OS Y S ; ▁} ▁else ▁{ ▁int ▁nb _ args ; ▁abi _ ulong ▁sp _ reg ; ▁abi _ ulong ▁arg 5 ▁= ▁0, 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁tm v _ read _ seek ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁timestamp , ▁int ▁flags ) ▁{ ▁T M V Context ▁* tm v ▁= ▁s -> priv _ data ; ▁int 64_ t ▁pos ; ▁if ▁( stream _ index ) ▁return ▁-1; ▁pos ▁= ▁timestamp ▁* ▁( tm v -> audio _ chunk _ size ▁+ ▁tm v -> video _ chunk _ size ▁+ ▁tm v -> padding ); ▁av io _ seek ( s -> pb , ▁pos ▁+ ▁T M V _ HEADER _ SIZE , ▁SE EK _ SET ); ▁tm v -> stream _ index ▁= ▁0; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b on ito _ ld ma _ writ el ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁P CI B on ito State ▁* s ▁= ▁opaque ; ▁(( uint 32_ t ▁* )( & s -> bon ld ma )) [ addr / size of ( uint 32_ t )] ▁= ▁val ▁& ▁0 xffffffff ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁jpeg 2000 _ decode _ packet ( J peg 2000 Decoder Context ▁* s , ▁J peg 2000 Tile ▁* tile , ▁int ▁* tp _ index , ▁J peg 2000 Coding Style ▁* cod st y , ▁J peg 2000 Res Level ▁* r level , ▁int ▁prec no , ▁int ▁lay no , ▁uint 8_ t ▁* exp n , ▁int ▁num gb its ) ▁{ ▁int ▁band no , ▁c blk no , ▁ret , ▁nb _ code _ blocks ; ▁int ▁c ws no ; ▁if ▁( lay no ▁< ▁r level -> band [0]. prec [ prec no ]. decoded _ layers ) ▁return ▁0; ▁r level -> band [0]. prec [ prec no ]. decoded _ layers ▁= ▁lay no ▁+ ▁1;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁curses _ refresh ( Display ChangeListener ▁* d cl ) ▁{ ▁int ▁chr , ▁next chr , ▁keys ym , ▁keycode , ▁keycode _ alt ; ▁curses _ win ch _ check (); ▁if ▁( in validate ) ▁{ ▁clear (); ▁refresh (); ▁curses _ calc _ pad (); ▁graphic _ hw _ in validate ( NULL ); ▁invalidate ▁= ▁0; ▁} ▁graphic _ hw _ text _ update ( NULL , ▁screen ); ▁next chr ▁= ▁ERR ; ▁while ▁(1) ▁{ ▁/* ▁while ▁there ▁are ▁any ▁pending ▁key ▁st rokes ▁to ▁process ▁*/ ▁if ▁( next chr ▁== ▁ERR ) ▁chr ▁= ▁get ch (); ▁else ▁{ ▁chr 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁read _ ts ( char ▁** line , ▁int ▁* duration ) ▁{ ▁int 64_ t ▁start , ▁end ; ▁if ▁( ss can f (* line , ▁"% " SC N d 64 ", %" SC N d 64, ▁& start , ▁& end ) ▁== ▁2) ▁{ ▁* line ▁+= ▁str c sp n (* line , ▁"\" ") ▁+ ▁1; ▁* duration ▁= ▁end ▁- ▁start ; ▁return ▁start ; ▁} ▁return ▁AV _ NO PT S _ VALUE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ra ven _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁PC ID evice Class ▁* k ▁= ▁P CI _ DEVICE _ CLASS ( k lass ); ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁k -> init ▁= ▁ra ven _ init ; ▁k -> vendor _ id ▁= ▁P CI _ VE ND OR _ ID _ M OT OR OL A ; ▁k -> device _ id ▁= ▁P CI _ DEVICE _ ID _ M OT OR OL A _ RA VEN ; ▁k -> revision ▁= ▁0 x 00 ; ▁k -> class _ id ▁= ▁P CI _ CLASS _ BR ID GE _ HOST ; ▁dc -> desc ▁= ▁" P Re P ▁Host ▁Bridge ▁- ▁M otor ola ▁R aven "; ▁dc -> v 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ add _ option _ rom ( PC ID evice ▁* pd ev , ▁bool ▁is _ default _ rom , ▁Error ▁** err p ) ▁{ ▁int ▁size ; ▁char ▁* path ; ▁void ▁* ptr ; ▁char ▁name [ 32 ]; ▁const ▁VM State Description ▁* v ms d ; ▁if ▁(! pd ev -> rom file ) ▁return ; ▁if ▁( str len ( pd ev -> rom file ) ▁== ▁0) ▁return ; ▁if ▁(! pd ev -> rom _ bar ) ▁{ ▁/* ▁* ▁Load ▁rom ▁via ▁fw _ cfg ▁instead ▁of ▁creating ▁a ▁rom ▁bar , ▁* ▁for ▁0.1 1 ▁compatibility . ▁*/ ▁int ▁class ▁= ▁pci _ get _ word ( pd ev -> config ▁+ ▁P C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mov _ write _ uuid prof _ tag ( AV IO Context ▁* pb , ▁AV Format Context ▁* s ) ▁{ ▁AV Stream ▁* video _ st ▁= ▁s -> streams [0]; ▁AV Codec Parameters ▁* video _ par ▁= ▁s -> streams [0] -> codec par ; ▁AV Codec Parameters ▁* audio _ par ▁= ▁s -> streams [1] -> codec par ; ▁int ▁audio _ rate ▁= ▁audio _ par -> sample _ rate ; ▁// ▁TODO : ▁should ▁be ▁avg _ frame _ rate ▁int ▁frame _ rate ▁= ▁(( video _ st -> time _ base . den ) ▁* ▁(0 x 10000 )) ▁/ ▁( video _ st -> time _ base . num ); ▁int

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* sp ap r _ ph b _ vf io _ get _ loc _ code ( s P AP R PH B State ▁* s ph b , ▁PC ID evice ▁* pd ev ) ▁{ ▁char ▁* path ▁= ▁NULL , ▁* buf ▁= ▁NULL , ▁* host ▁= ▁NULL ; ▁/* ▁Get ▁the ▁P CI ▁V FI O ▁host ▁id ▁*/ ▁host ▁= ▁object _ property _ get _ str ( OBJECT ( pd ev ), ▁" host ", ▁NULL ); ▁if ▁(! host ) ▁{ ▁goto ▁err _ out ; ▁} ▁/* ▁Construct ▁the ▁path ▁of ▁the ▁file ▁that ▁will ▁give ▁us ▁the ▁DT ▁location ▁*/ ▁path ▁= ▁g _ str dup _ printf ("/ sys / bus / pc i / devices /% s / dev spec ",

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁y uv 2 nv 12 X in C ( int 16_ t ▁* l um Filter , ▁int 16_ t ▁** l um Src , ▁int ▁l um Filter Size , ▁int 16_ t ▁* chr Filter , ▁int 16_ t ▁** chr Src , ▁int ▁chr Filter Size , ▁uint 8_ t ▁* dest , ▁uint 8_ t ▁* u Dest , ▁int ▁dst W , ▁int ▁chr Dst W , ▁int ▁dst Format ) ▁{ ▁// FIX ME ▁Opt imize ▁( just ▁quickly ▁writ en ▁not ▁opt i ..) ▁int ▁i ; ▁for ▁( i =0; ▁i < dst W ; ▁i ++) ▁{ ▁int ▁val =1 << 18 ; ▁int ▁j ; ▁for ▁( j =0; ▁j < l um Filter Size ; ▁j ++) ▁val ▁+= ▁l um Src [ j ][ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nv me _ process _ db ( N v me Ctrl ▁* n , ▁hw addr ▁addr , ▁int ▁val ) ▁{ ▁uint 32_ t ▁q id ; ▁if ▁( addr ▁& ▁( (1 ▁<< ▁2) ▁- ▁1)) ▁{ ▁return ; ▁} ▁if ▁( (( addr ▁- ▁0 x 1000 ) ▁>> ▁2) ▁& ▁1) ▁{ ▁uint 16_ t ▁new _ head ▁= ▁val ▁& ▁0 xffff ; ▁int ▁start _ sq s ; ▁N v me C Queue ▁* c q ; ▁q id ▁= ▁( addr ▁- ▁(0 x 1000 ▁+ ▁(1 ▁<< ▁2 ))) ▁>> ▁3; ▁if ▁( nv me _ check _ c q id ( n , ▁q id )) ▁{ ▁return ; ▁} ▁cq ▁= ▁n -> c q [ q id ]; ▁if ▁( new _ head ▁>= ▁cq -> size ) ▁{ ▁return ; ▁} ▁start _ sq

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁build _ mod pred ( Ind eo 3 Decode Context ▁* s ) ▁{ ▁int ▁i , ▁j ; ▁s -> Mod Pred ▁= ▁av _ m alloc (8 ▁* ▁128 ); ▁for ▁( i =0; ▁i ▁< ▁128 ; ▁++ i ) ▁{ ▁s -> Mod Pred [ i +0 * 128 ] ▁= ▁i ▁> ▁126 ▁? ▁25 4 ▁: ▁2 *( i ▁+ ▁1 ▁- ▁(( i ▁+ ▁1) ▁% ▁2 )); ▁s -> Mod Pred [ i +1 * 128 ] ▁= ▁i ▁== ▁7 ▁? ▁20 ▁: ▁i ▁== ▁119 ▁|| ▁i ▁== ▁120 ▁? ▁2 36 ▁: ▁2 *( i ▁+ ▁2 ▁- ▁(( i ▁+ ▁1) ▁% ▁3 )); ▁s -> Mod Pred [ i +2 * 128 ] ▁= ▁i ▁> ▁125 ▁? ▁2 48 ▁: ▁2 *( i ▁+ ▁2 ▁- ▁(( i ▁+ ▁2) ▁% ▁4 )); ▁s -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ store q _ reg ( Dis as Context ▁* s , ▁int ▁r low , ▁int ▁r high , ▁TC G v _ i 64 ▁val ) ▁{ ▁TC G v ▁tmp ; ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ trunc _ i 64_ i 32 ( tmp , ▁val ); ▁store _ reg ( s , ▁r low , ▁tmp ); ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ sh ri _ i 64 ( val , ▁val , ▁32 ); ▁tc g _ gen _ trunc _ i 64_ i 32 ( tmp , ▁val ); ▁store _ reg ( s , ▁r high , ▁tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cc id _ bulk _ in _ copy _ to _ guest ( US B CC ID State ▁* s , ▁uint 8_ t ▁* data , ▁int ▁len ) ▁{ ▁int ▁ret ▁= ▁0; ▁assert ( len ▁> ▁0); ▁cc id _ bulk _ in _ get ( s ); ▁if ▁( s -> current _ bulk _ in ▁!= ▁NULL ) ▁{ ▁ret ▁= ▁MIN ( s -> current _ bulk _ in -> len ▁- ▁s -> current _ bulk _ in -> pos , ▁len ); ▁mem c py ( data , ▁s -> current _ bulk _ in -> data ▁+ ▁s -> current _ bulk _ in -> pos , ▁ret ); ▁s -> current _ bulk _ in -> pos ▁+= ▁ret ; ▁if ▁( s -> current _ bulk _ in -> pos ▁==

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l ms _ update ( W mall Decode Ctx ▁* s , ▁int ▁i ch , ▁int ▁il ms , ▁int 16_ t ▁input , ▁int 16_ t ▁pred ) ▁{ ▁int 16_ t ▁i coef ; ▁int ▁recent ▁= ▁s -> cd l ms [ ich ][ il ms ]. recent ; ▁int 16_ t ▁range ▁= ▁1 ▁<< ▁( s -> bits _ per _ sample ▁- ▁1); ▁int ▁b ps ▁= ▁s -> bits _ per _ sample ▁> ▁16 ▁? ▁4 ▁: ▁2; ▁// ▁bytes ▁per ▁sample ▁if ▁( input ▁> ▁pred ) ▁{ ▁for ▁( ico ef ▁= ▁0; ▁i coef ▁< ▁s -> cd l ms [ ich ][ il ms ]. order ; ▁i coef ++) ▁s -> cd l ms [ ich ][ il ms ]. co efs [ ico ef

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁create _ filter ( AV Filter Context ▁** fil t _ ctx , ▁AV Filter Graph ▁* ctx , ▁int ▁index , ▁const ▁char ▁* fil t _ name , ▁const ▁char ▁* args , ▁AV Class ▁* log _ ctx ) ▁{ ▁AV Filter ▁* fil t ; ▁char ▁inst _ name [ 30 ]; ▁char ▁tmp _ args [ 256 ]; ▁int ▁ret ; ▁sn printf ( inst _ name , ▁sizeof ( inst _ name ), ▁" Parsed ▁filter ▁% d ▁% s ", ▁index , ▁filt _ name ); ▁filt ▁= ▁av filter _ get _ by _ name ( fil t _ name ); ▁if ▁(! fil t ) ▁{ ▁av _ log ( log _ ctx , ▁AV _ LOG _ ERROR , ▁" No

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ m cl ms ( W mall Decode Ctx ▁* s ) ▁{ ▁s -> m cl ms _ order ▁= ▁( get _ bits ( & s -> gb , ▁4) ▁+ ▁1) ▁* ▁2; ▁s -> m cl ms _ scaling ▁= ▁get _ bits ( & s -> gb , ▁4 ); ▁if ( get _ bits 1( & s -> gb )) ▁{ ▁// ▁m cl ms _ send _ coef ▁int ▁i ; ▁int ▁send _ coef _ bits ; ▁int ▁cb its ▁= ▁av _ log 2( s -> m cl ms _ scaling ▁+ ▁1); ▁assert ( cb its ▁== ▁my _ log 2( s -> m cl ms _ scaling ▁+ ▁1 )); ▁if (1 ▁<< ▁cb its ▁< ▁s -> m cl ms _ scaling ▁+ ▁1) ▁cb its ++; ▁send _ coef _ bits ▁= ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ sp ap r _ init ( ram _ addr _ t ▁ram _ size , ▁const ▁char ▁* boot _ device , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁Power PC CPU ▁* cpu ; ▁CP UP PC State ▁* env ; ▁int ▁i ; ▁Memory Region ▁* sys mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ram ▁= ▁g _ new ( Memory Region , ▁1); ▁target _ ph ys _ addr _ t ▁r ma _ alloc _ size , ▁r ma _ size ; ▁uint 32_ t ▁init rd _ base ▁= ▁0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁s onic _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁S onic Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁Put Bit Context ▁pb ; ▁int ▁i , ▁version ▁= ▁0; ▁if ▁( av ctx -> channels ▁> ▁MAX _ CH AN NE LS ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁mon o ▁and ▁st ere o ▁streams ▁are ▁supported ▁by ▁now \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁/* ▁only ▁st ere o ▁or ▁mon o ▁for ▁now ▁*/ ▁} ▁if ▁( av ctx -> channels ▁== ▁2) ▁s -> dec orrelation ▁= ▁MID _ SIDE ; ▁else ▁s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ check _ in tra _ pred _ mode ( H 264 Context ▁* h , ▁int ▁mode , ▁int ▁is _ chrom a ) ▁{ ▁static ▁const ▁int 8_ t ▁top [ 7] ▁= ▁{ ▁LEFT _ DC _ PRE D 8 x 8, ▁1, ▁-1, ▁-1 ▁}; ▁static ▁const ▁int 8_ t ▁left [ 7] ▁= ▁{ ▁TOP _ DC _ PRE D 8 x 8, ▁-1, ▁2, ▁-1, ▁DC _ 128 _ PRE D 8 x 8 ▁}; ▁if ▁( mode ▁> ▁6 U ) ▁{ ▁av _ log ( h -> av ctx , ▁AV _ LOG _ ERROR , ▁" out ▁of ▁range ▁in tra ▁chrom a ▁pred ▁mode ▁at ▁% d ▁% d \ n ", ▁h -> mb _ x , ▁h -> mb _ y ); ▁return ▁-1; ▁} ▁if ▁(! ( h -> top _ sa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁audio _ pc m _ init _ info ▁( struct ▁audio _ pc m _ info ▁* info , ▁aud settings _ t ▁* as ) ▁{ ▁int ▁bits ▁= ▁8, ▁sign ▁= ▁0, ▁shift ▁= ▁0; ▁switch ▁( as -> fmt ) ▁{ ▁case ▁A UD _ F MT _ S 8: ▁sign ▁= ▁1; ▁case ▁A UD _ F MT _ U 8: ▁break ; ▁case ▁A UD _ F MT _ S 16 : ▁sign ▁= ▁1; ▁case ▁A UD _ F MT _ U 16 : ▁bits ▁= ▁16 ; ▁shift ▁= ▁1; ▁break ; ▁case ▁A UD _ F MT _ S 32 : ▁sign ▁= ▁1; ▁case ▁A UD _ F MT _ U 32 : ▁bits ▁= ▁32 ; ▁shift ▁= ▁2; ▁break ; ▁} ▁info -> freq ▁= ▁as -> freq ; ▁info -> bits

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁block _ job _ completed _ txn _ abort ( Block Job ▁* job ) ▁{ ▁A io Context ▁* ctx ; ▁Block Job Txn ▁* txn ▁= ▁job -> txn ; ▁Block Job ▁* other _ job , ▁* next ; ▁if ▁( txn -> abort ing ) ▁{ ▁/* ▁* ▁We ▁are ▁cancelled ▁by ▁another ▁job , ▁which ▁will ▁handle ▁everything . ▁*/ ▁return ; ▁} ▁txn -> abort ing ▁= ▁true ; ▁/* ▁We ▁are ▁the ▁first ▁failed ▁job . ▁Cancel ▁other ▁jobs . ▁*/ ▁Q LIST _ FORE A CH ( other _ job , ▁& txn -> jobs , ▁txn _ list ) ▁{ ▁ctx ▁= ▁blk _ get _ a io _ context ( o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁isa _ mm io _ setup ( Memory Region ▁* mr , ▁target _ ph ys _ addr _ t ▁size ) ▁{ ▁memory _ region _ init _ io ( mr , ▁& isa _ mm io _ ops , ▁NULL , ▁" isa - mm io ", ▁size ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁q io _ channel _ socket _ d gram _ sync ( Q IO Channel Socket ▁* i oc , ▁SocketAddress Legacy ▁* local Addr , ▁SocketAddress Legacy ▁* remote Addr , ▁Error ▁** err p ) ▁{ ▁int ▁fd ; ▁trace _ q io _ channel _ socket _ d gram _ sync ( i oc , ▁local Addr , ▁remote Addr ); ▁fd ▁= ▁socket _ d gram ( remote Addr , ▁local Addr , ▁err p ); ▁if ▁( fd ▁< ▁0) ▁{ ▁trace _ q io _ channel _ socket _ d gram _ fail ( i oc ); ▁return ▁-1; ▁} ▁trace _ q io _ channel _ socket _ d gram _ complete ( i oc , ▁fd ); ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dec _ bit ( Dis as Context ▁* dc ) ▁{ ▁TC G v ▁t 0, ▁t 1; ▁unsigned ▁int ▁op ; ▁int ▁mem _ index ▁= ▁cpu _ mm u _ index ( dc -> env ); ▁op ▁= ▁dc -> ir ▁& ▁( (1 ▁<< ▁9 ) ▁- ▁1); ▁switch ▁( op ) ▁{ ▁case ▁0 x 2 1: ▁/* ▁src . ▁*/ ▁t 0 ▁= ▁tc g _ temp _ new (); ▁LOG _ DIS (" src ▁r % d ▁r % d \ n ", ▁dc -> rd , ▁dc -> ra ); ▁tc g _ gen _ and i _ tl ( t 0, ▁cpu _ R [ dc -> ra ], ▁1); ▁if ▁( dc -> rd ) ▁{ ▁t 1 ▁= ▁tc g _ temp _ new (); ▁read _ car ry ( dc , ▁t 1); ▁tc g _ gen _ sh li _ tl ( t 1,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁memory _ region _ get _ fd ( Memory Region ▁* mr ) ▁{ ▁if ▁( mr -> alias ) ▁{ ▁return ▁memory _ region _ get _ fd ( mr -> alias ); ▁} ▁assert ( mr -> termin ates ); ▁return ▁qemu _ get _ ram _ fd ( mr -> ram _ addr ▁& ▁TARGET _ PAGE _ MASK ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ ins n _ 33 14 ( TC G Context ▁* s , ▁A Arch 64 Insn ▁insn , ▁TC G Reg ▁r 1, ▁TC G Reg ▁r 2, ▁TC G Reg ▁rn , ▁tc g _ target _ long ▁ofs , ▁bool ▁pre , ▁bool ▁w ) ▁{ ▁insn ▁|= ▁1 u ▁<< ▁31 ; ▁/* ▁ext ▁*/ ▁insn ▁|= ▁pre ▁<< ▁24 ; ▁insn ▁|= ▁w ▁<< ▁23 ; ▁assert ( of s ▁>= ▁- 0 x 200 ▁&& ▁ofs ▁< ▁0 x 200 ▁&& ▁( of s ▁& ▁7) ▁== ▁0); ▁insn ▁|= ▁( of s ▁& ▁(0 x 7 f ▁<< ▁3 )) ▁<< ▁( 15 ▁- ▁3 ); ▁tc g _ out 32 ( s , ▁insn ▁| ▁r 2 ▁<< ▁10 ▁| ▁rn ▁<< ▁5 ▁| ▁r 1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x 86_ cp uid _ set _ t sc _ freq ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁X 86 CPU ▁* cpu ▁= ▁X 86_ CPU ( obj ); ▁const ▁int 64_ t ▁min ▁= ▁0; ▁const ▁int 64_ t ▁max ▁= ▁INT _ MAX ; ▁int 64_ t ▁value ; ▁visit _ type _ int ( v , ▁& value , ▁name , ▁err p ); ▁if ▁( error _ is _ set ( err p )) ▁{ ▁return ; ▁} ▁if ▁( value ▁< ▁min ▁|| ▁value ▁> ▁max ) ▁{ ▁error _ set ( err p , ▁Q ERR _ PROPERTY _ VALUE _ OUT _ OF _ RANGE , ▁"", ▁name ▁? 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cow _ create ( const ▁char ▁* filename , ▁Q emu Opts ▁* opts , ▁Error ▁** err p ) ▁{ ▁struct ▁cow _ header _ v 2 ▁cow _ header ; ▁struct ▁stat ▁st ; ▁int 64_ t ▁image _ sect ors ▁= ▁0; ▁char ▁* image _ filename ▁= ▁NULL ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁Block Driver State ▁* c ow _ bs ; ▁/* ▁Read ▁out ▁options ▁*/ ▁image _ sect ors ▁= ▁qemu _ opt _ get _ size _ del ( opts , ▁BLOCK _ OPT _ SIZE , ▁0) ▁/ ▁512 ; ▁image _ filename ▁= ▁qemu _ opt _ get _ del ( opts , ▁BLOCK _ OPT _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁check _ format ( AV Codec Context ▁* av ctx ) ▁{ ▁AV Codec Parser Context ▁* parser ; ▁uint 8_ t ▁* p out ; ▁int ▁p size ; ▁int ▁index ; ▁H 264 Context ▁* h ; ▁int ▁ret ▁= ▁-1; ▁/* ▁init ▁parser ▁& ▁parse ▁file ▁*/ ▁parser ▁= ▁av _ parser _ init ( av ctx -> codec -> id ); ▁if ▁(! parser ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Failed ▁to ▁open ▁H .2 64 ▁parser .\ n "); ▁goto ▁final ; ▁} ▁parser -> flags ▁= ▁PARSER _ FLAG _ COMPLETE _ FRAME S ; ▁index ▁= ▁av _ parser _ par

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁dec _ move _ mr ( Dis as Context ▁* dc ) ▁{ ▁int ▁mem size ▁= ▁mem size _ zz ( dc ); ▁int ▁insn _ len ; ▁DIS ( f printf ▁( log file , ▁" move . % c ▁[ $ r % u % s , ▁$ r % u \ n ", ▁mem size _ char ( mem size ), ▁dc -> op 1, ▁dc -> post inc ▁? ▁"+ ]" ▁: ▁" ]", ▁dc -> op 2 )); ▁if ▁( mem size ▁== ▁4) ▁{ ▁insn _ len ▁= ▁dec _ prep _ move _ m ( dc , ▁0, ▁4, ▁cpu _ R [ dc -> op 2] ); ▁cr is _ cc _ mask ( dc , ▁CC _ MASK _ N Z ); ▁cr is _ update _ cc _ op ( dc , ▁CC _ OP _ MOVE , ▁4 ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rt c _ init fn ( IS AD evice ▁* dev ) ▁{ ▁R TC State ▁* s ▁= ▁DO _ UP CAST ( RTC State , ▁dev , ▁dev ); ▁int ▁base ▁= ▁0 x 70 ; ▁int ▁is air q ▁= ▁8 ; ▁isa _ init _ irq ( dev , ▁& s -> irq , ▁is air q ); ▁s -> cm os _ data [ RTC _ REG _ A ] ▁= ▁0 x 26 ; ▁s -> cm os _ data [ RTC _ REG _ B ] ▁= ▁0 x 02 ; ▁s -> cm os _ data [ RTC _ REG _ C ] ▁= ▁0 x 00 ; ▁s -> cm os _ data [ RTC _ REG _ D ] ▁= ▁0 x 80 ; ▁rt c _ set _ date _ from _ host ( s ); ▁s -> period ic _ timer ▁= ▁qemu _ new _ timer ( rt 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ net _ load ( Q EM U File ▁* f , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁V irt ION et ▁* n ▁= ▁opaque ; ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( n ); ▁if ▁( version _ id ▁< ▁2 ▁|| ▁version _ id ▁> ▁VI RT IO _ NET _ VM _ VERSION ) ▁return ▁- E IN VAL ; ▁return ▁virt io _ load ( v dev , ▁f , ▁version _ id ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ packet ( AV Format Context ▁* s 1, ▁AV Packet ▁* pk t ) ▁{ ▁Video Dem ux Data ▁* s ▁= ▁s 1 -> priv _ data ; ▁char ▁filename _ bytes [10 24 ]; ▁char ▁* filename ▁= ▁filename _ bytes ; ▁int ▁i ; ▁int ▁size [3] ={ 0 }, ▁ret [3] ={ 0 }; ▁AV IO Context ▁* f [3] ▁= ▁{ NULL }; ▁AV Codec Context ▁* codec = ▁s 1 -> streams [0] -> codec ; ▁if ▁(! s -> is _ pipe ) ▁{ ▁/* ▁loop ▁over ▁input ▁*/ ▁if ▁( s -> loop ▁&& ▁s -> img _ number ▁> ▁s -> img _ last ) ▁{ ▁s -> img _ number ▁= ▁s -> img _ firs

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sm ack er _ read _ header ( AV Format Context ▁* s ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁Sm ack er Context ▁* sm k ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st , ▁* ast [ 7 ]; ▁int ▁i , ▁ret ; ▁int ▁t base ; ▁/* ▁read ▁and ▁check ▁header ▁*/ ▁sm k -> magic ▁= ▁av io _ rl 32 ( pb ); ▁if ▁( sm k -> magic ▁!= ▁M K TAG (' S ', ▁' M ', ▁' K ', ▁'2 ') ▁&& ▁sm k -> magic ▁!= ▁M K TAG (' S ', ▁' M ', ▁' K ', ▁'4 ')) ▁sm k -> width ▁= ▁av io _ rl 32 ( pb ); ▁sm k -> height ▁= ▁av io _ rl 32 ( pb ); ▁sm

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁raw _ co _ dis card ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors ) ▁{ ▁return ▁b dr v _ co _ dis card ( bs -> file -> bs , ▁sector _ num , ▁nb _ sect ors ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block A IO CB ▁* b dr v _ a io _ write _ zero es ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁B dr v Request Flags ▁flags , ▁Block Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁trace _ b dr v _ a io _ write _ zero es ( bs , ▁sector _ num , ▁nb _ sect ors , ▁flags , ▁opaque ); ▁return ▁b dr v _ co _ a io _ rw _ vector ( bs , ▁sector _ num , ▁NULL , ▁nb _ sect ors , ▁B DR V _ REQ _ ZERO _ WRITE ▁| ▁flags , ▁cb , ▁opaque , ▁true ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ pc i _ reset ( Device State ▁* d ) ▁{ ▁V irt IO PC I Proxy ▁* proxy ▁= ▁container _ of ( d , ▁V irt IO PC I Proxy , ▁pci _ dev . q dev ); ▁virt io _ reset ( proxy -> v dev ); ▁ms ix _ reset ( & proxy -> pc i _ dev ); ▁proxy -> flags ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ dat _ r IK ( TC G Context ▁* s , ▁int ▁cond , ▁int ▁op c , ▁int ▁op inv , ▁TC G Reg ▁dst , ▁TC G Reg ▁lhs , ▁TC G Arg ▁rhs , ▁bool ▁rhs _ is _ const ) ▁{ ▁/* ▁E mit ▁either ▁the ▁reg , im m ▁or ▁reg , reg ▁form ▁of ▁a ▁data - processing ▁insn . ▁* ▁rhs ▁must ▁satisfy ▁the ▁" r IK " ▁constraint . ▁*/ ▁if ▁( rhs _ is _ const ) ▁{ ▁int ▁rot ▁= ▁encode _ im m ( rhs ); ▁if ▁( rot ▁< ▁0) ▁{ ▁rhs ▁= ▁~ rhs ; ▁rot ▁= ▁encode _ im m ( rhs ); ▁assert ( rot ▁>= ▁0); ▁op c ▁= ▁op inv ; ▁} 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁tw l 9 22 30 _ init ( i 2 c _ slave ▁* i 2 c ) ▁{ ▁M en el a us State ▁* s ▁= ▁FROM _ I 2 C _ S LA VE ( M en el a us State , ▁i 2 c ); ▁s -> rt c . hz _ tm ▁= ▁qemu _ new _ timer ( rt _ clock , ▁men el a us _ rt c _ hz , ▁s ); ▁/* ▁Three ▁output ▁pins ▁plus ▁one ▁interrupt ▁pin . ▁*/ ▁q dev _ init _ gp io _ out ( & i 2 c -> q dev , ▁s -> out , ▁4 ); ▁q dev _ init _ gp io _ in ( & i 2 c -> q dev , ▁men el a us _ gp io _ set , ▁3 ); ▁s -> p wr btn ▁= ▁qemu _ allocate _ ir qs ( men el a us _ p 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ write _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁MO V Context ▁* mov ▁= ▁s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁s -> pb ; ▁MO V Track ▁* tr k ▁= ▁& mov -> tracks [ pk t -> stream _ index ]; ▁AV Codec Context ▁* enc ▁= ▁tr k -> enc ; ▁unsigned ▁int ▁samples In Chunk ▁= ▁0; ▁int ▁size = ▁pkt -> size ; ▁if ▁( url _ is _ stream ed ( s -> pb )) ▁return ▁0; ▁/* ▁Can ' t ▁handle ▁that ▁*/ ▁if ▁(! size ) ▁return ▁0; ▁/* ▁Dis card ▁0 ▁sized ▁packets ▁*/ ▁if ▁( enc -> co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ st _ cond ▁( Dis as Context ▁* ctx , ▁uint 32_ t ▁op c , ▁int ▁rt , ▁int ▁base , ▁int 16_ t ▁offset ) ▁{ ▁const ▁char ▁* op n ▁= ▁" st _ cond "; ▁TC G v ▁t 0, ▁t 1; ▁t 0 ▁= ▁tc g _ temp _ local _ new (); ▁gen _ base _ offset _ addr ( ctx , ▁t 0, ▁base , ▁offset ); ▁/* ▁Don ' t ▁do ▁NO P ▁if ▁destination ▁is ▁zero : ▁we ▁must ▁perform ▁the ▁actual ▁memory ▁access . ▁*/ ▁t 1 ▁= ▁tc g _ temp _ local _ new (); ▁gen _ load _ g pr ( t 1, ▁rt ); ▁switch ▁( op c ) ▁{ ▁# if ▁defined ( TARGET _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 32_ t ▁b md ma _ prepare _ buf ( I DED MA ▁* d ma , ▁int ▁is _ write ) ▁{ ▁B MD MA State ▁* bm ▁= ▁DO _ UP CAST ( B MD MA State , ▁d ma , ▁d ma ); ▁IDE State ▁* s ▁= ▁b md ma _ active _ if ( bm ); ▁PC ID evice ▁* pc i _ dev ▁= ▁P CI _ DEVICE ( bm -> pc i _ dev ); ▁struct ▁{ ▁uint 32_ t ▁addr ; ▁uint 32_ t ▁size ; ▁} ▁pr d ; ▁int ▁l , ▁len ; ▁pci _ d ma _ sg list _ init ( & s -> sg , ▁pci _ dev , ▁s -> n sect or ▁/ ▁( B MD MA _ PAGE _ SIZE ▁/ ▁512 ) ▁+ ▁1); ▁s -> io _ buffer _ size ▁= ▁0; ▁for

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁apply _ window _ and _ md ct ( vor b is _ enc _ context ▁* v enc , ▁float ▁* audio , ▁int ▁samples ) ▁{ ▁int ▁channel ; ▁const ▁float ▁* ▁win ▁= ▁v enc -> win [0]; ▁int ▁window _ len ▁= ▁1 ▁<< ▁( v enc -> log 2_ block size [0] ▁- ▁1); ▁float ▁n ▁= ▁( float ) (1 ▁<< ▁v enc -> log 2_ block size [0]) ▁/ ▁4.0 ; ▁AV Float DS P Context ▁* fd sp ▁= ▁v enc -> fd sp ; ▁if ▁(! v enc -> have _ saved ▁&& ▁! samples ) ▁return ▁0; ▁if ▁( v enc -> have _ saved ) ▁{ ▁for ▁( channel ▁= ▁0; ▁channel ▁< ▁v enc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁pop count l ( un signed ▁long ▁l ) ▁{ ▁return ▁B ITS _ PER _ LONG ▁== ▁32 ▁? ▁c tp op 32 ( l ) ▁: ▁c tp op 64 ( l ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 32_ t ▁parse _ gain ( const ▁char ▁* gain ) ▁{ ▁char ▁* fraction ; ▁int ▁scale ▁= ▁10000 ; ▁int 32_ t ▁mb ▁= ▁0; ▁int ▁sign ▁= ▁1; ▁int ▁db ; ▁if ▁(! gain ) ▁return ▁INT 32_ MIN ; ▁gain ▁+= ▁str sp n ( gain , ▁" ▁\ t "); ▁if ▁(* gain ▁== ▁'- ') ▁sign ▁= ▁-1; ▁db ▁= ▁str tol ( gain , ▁& fraction , ▁0); ▁if ▁(* fraction ++ ▁== ▁'. ') ▁{ ▁while ▁( av _ is digit (* fraction ) ▁&& ▁scale ) ▁{ ▁mb ▁+= ▁scale ▁* ▁(* fraction ▁- ▁'0 '); ▁scale ▁/= ▁10; ▁fraction ++; ▁} ▁} ▁if ▁( abs ( db ) ▁> ▁( INT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁ide _ d ma _ submit _ check ( IDE State ▁* s , ▁Block Driver Completion Func ▁* d ma _ cb ) ▁{ ▁if ▁( s -> bus -> d ma -> ai oc b ) ▁return ; ▁d ma _ cb ( s , ▁-1 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block Stats ▁* b dr v _ query _ b ds _ stats ( const ▁Block Driver State ▁* bs , ▁bool ▁query _ back ing ) ▁{ ▁Block Stats ▁* s ▁= ▁NULL ; ▁s ▁= ▁g _ m alloc 0( size of (* s )); ▁s -> stats ▁= ▁g _ m alloc 0( size of (* s -> stats )); ▁if ▁(! bs ) ▁{ ▁return ▁s ; ▁} ▁if ▁( b dr v _ get _ node _ name ( bs ) [0]) ▁{ ▁s -> has _ node _ name ▁= ▁true ; ▁s -> node _ name ▁= ▁g _ str dup ( b dr v _ get _ node _ name ( bs )); ▁} ▁s -> stats -> wr _ high est _ offset ▁= ▁stat 64_ get ( & bs -> wr _ high 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lag _ decode _ zero _ run _ line ( L ag ar ith Context ▁* l , ▁uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁const ▁uint 8_ t ▁* src _ end , ▁int ▁width , ▁int ▁esc _ count ) ▁{ ▁int ▁i ▁= ▁0; ▁int ▁count ; ▁uint 8_ t ▁zero _ run ▁= ▁0; ▁const ▁uint 8_ t ▁* src _ start ▁= ▁src ; ▁uint 8_ t ▁mask 1 ▁= ▁- ( esc _ count ▁< ▁2); ▁uint 8_ t ▁mask 2 ▁= ▁- ( esc _ count ▁< ▁3 ); ▁uint 8_ t ▁* end ▁= ▁dst ▁+ ▁( width ▁- ▁2); ▁av priv _ request _ sample ( l -> av ctx , ▁" zero _ run _ line "); ▁retu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ram _ init _ all ( RAM State ▁** r sp ) ▁{ ▁Error ▁* local _ err ▁= ▁NULL ; ▁if ▁( ram _ state _ init ( r sp )) ▁{ ▁return ▁-1; ▁} ▁if ▁( migrate _ use _ xb z r le ()) ▁{ ▁X B Z R LE _ cache _ lock (); ▁X B Z R LE . zero _ target _ page ▁= ▁g _ m alloc 0( TARGET _ PAGE _ SIZE ); ▁X B Z R LE . cache ▁= ▁cache _ init ( migrate _ xb z r le _ cache _ size (), ▁TARGET _ PAGE _ SIZE , ▁& local _ err ); ▁if ▁(! X B Z R LE . cache ) ▁{ ▁X B Z R LE _ cache _ un lock (); ▁error _ report _ err ( local 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av _ always _ inline ▁filter _ mb _ ed g ec v ( ▁uint 8_ t ▁* pix , ▁int ▁stride , ▁int 16_ t ▁b S [4 ], ▁unsigned ▁int ▁qp , ▁H 264 Context ▁* h ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁qp ▁+ ▁h -> slice _ alpha _ c 0_ offset ; ▁const ▁int ▁alpha ▁= ▁alpha _ table [ index _ a ]; ▁const ▁int ▁beta ▁= ▁beta _ table [ qp ▁+ ▁h -> slice _ beta _ offset ]; ▁if ▁( alpha ▁== 0 ▁|| ▁beta ▁== ▁0) ▁return ; ▁if ( ▁b S [0] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc [4 ]; ▁tc [0] ▁= ▁tc 0_ table [ index _ a ][ b S [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ entropy _ coded _ image ( Web P Context ▁* s , ▁enum ▁Image Role ▁role , ▁int ▁w , ▁int ▁h ) ▁{ ▁Image Context ▁* img ; ▁H uff Reader ▁* hg ; ▁int ▁i , ▁j , ▁ret , ▁x , ▁y , ▁width ; ▁img ▁= ▁& s -> image [ role ]; ▁img -> role ▁= ▁role ; ▁if ▁(! img -> frame ) ▁{ ▁img -> frame ▁= ▁av _ frame _ alloc (); ▁if ▁(! img -> frame ) ▁return ▁A VER ROR ( EN O ME M ); ▁} ▁img -> frame -> format ▁= ▁AV _ PI X _ F MT _ AR GB ; ▁img -> frame -> width ▁= ▁w ; ▁img -> frame -> height ▁= ▁h ; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ m sp el _ m otion ( M peg Enc Context ▁* s , ▁uint 8_ t ▁* dest _ y , ▁uint 8_ t ▁* dest _ cb , ▁uint 8_ t ▁* dest _ cr , ▁uint 8_ t ▁** ref _ picture , ▁op _ pixels _ func ▁(* pix _ op ) [4 ], ▁int ▁motion _ x , ▁int ▁motion _ y , ▁int ▁h ) ▁{ ▁W mv 2 Context ▁* ▁const ▁w = ▁( W mv 2 Context *) s ; ▁uint 8_ t ▁* ptr ; ▁int ▁d xy , ▁offset , ▁mx , ▁my , ▁src _ x , ▁src _ y , ▁v _ edge _ pos , ▁lines ize , ▁uv lines ize ; ▁int ▁em u =0; ▁d xy ▁= ▁(( m otion _ y ▁& ▁1) ▁<< ▁1) ▁| ▁( m otion _ x 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sv q 1_ encode _ plane ( SV Q 1 Context ▁* s , ▁int ▁plane , ▁unsigned ▁char ▁* src _ plane , ▁unsigned ▁char ▁* ref _ plane , ▁unsigned ▁char ▁* decoded _ plane , ▁int ▁width , ▁int ▁height , ▁int ▁src _ stride , ▁int ▁stride ) ▁{ ▁const ▁AV Frame ▁* f ▁= ▁s -> av ctx -> coded _ frame ; ▁int ▁x , ▁y ; ▁int ▁i ; ▁int ▁block _ width , ▁block _ height ; ▁int ▁level ; ▁int ▁threshold [6 ]; ▁uint 8_ t ▁* src ▁= ▁s -> scr atch buf ▁+ ▁stride ▁* ▁16 ; ▁const ▁int ▁lambda ▁= ▁( f -> quality ▁* ▁f -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ff mm al _ add _ packet ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* av pk t , ▁int ▁is _ ex tr ad ata ) ▁{ ▁MM AL Decode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁AV Buffer Ref ▁* buf ▁= ▁NULL ; ▁int ▁size ▁= ▁0; ▁uint 8_ t ▁* data ▁= ▁( uint 8_ t ▁* )" "; ▁uint 8_ t ▁* start ; ▁int ▁ret ▁= ▁0; ▁if ▁( av pk t -> size ) ▁{ ▁if ▁( av pk t -> buf ) ▁{ ▁buf ▁= ▁av _ buffer _ ref ( av pk t -> buf ); ▁size ▁= ▁av pk t -> size ; ▁data ▁= ▁av pk t -> data ; ▁} ▁else ▁{ ▁buf ▁= ▁av _ buffer _ allo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁write _ frame ( AV Format Context ▁* s , ▁AV Packet ▁* pk t , ▁OutputStream ▁* ost ) ▁{ ▁AV Bit Stream Filter Context ▁* bs fc ▁= ▁o st -> bit stream _ filters ; ▁AV Codec Context ▁* av ctx ▁= ▁o st -> st -> codec ; ▁int ▁ret ; ▁if ▁(( av ctx -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ▁&& ▁video _ sync _ method ▁== ▁V SYNC _ DROP ) ▁|| ▁( av ctx -> codec _ type ▁== ▁AV MEDIA _ TYPE _ AU DIO ▁&& ▁audio _ sync _ method ▁< ▁0 )) ▁pkt -> pts ▁= ▁pkt -> d ts ▁= ▁AV _ NO PT S _ VALUE ; ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q ed _ commit _ l 2_ cache _ entry ( L 2 Table Cache ▁* l 2_ cache , ▁Cached L 2 Table ▁* l 2_ table ) ▁{ ▁Cached L 2 Table ▁* entry ; ▁entry ▁= ▁q ed _ find _ l 2_ cache _ entry ( l 2_ cache , ▁l 2_ table -> offset ); ▁if ▁( entry ) ▁{ ▁q ed _ un ref _ l 2_ cache _ entry ( entry ); ▁q ed _ un ref _ l 2_ cache _ entry ( l 2_ table ); ▁return ; ▁} ▁if ▁( l 2_ cache -> n _ entries ▁>= ▁MAX _ L 2_ CACHE _ SIZE ) ▁{ ▁entry ▁= ▁Q TAIL Q _ FIRST ( & l 2_ cache -> entries ); ▁Q TAIL Q _ REMOVE ( & l 2_ ca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ pix block d sp _ init _ x 86 ( Pix block DS P Context ▁* c , ▁AV Codec Context ▁* av ctx , ▁unsigned ▁high _ bit _ depth ) ▁{ ▁int ▁cpu _ flags ▁= ▁av _ get _ cpu _ flags (); ▁if ▁( EXTERNAL _ MM X ( cpu _ flags )) ▁{ ▁if ▁(! high _ bit _ depth ) ▁c -> get _ pixels ▁= ▁ff _ get _ pixels _ mm x ; ▁c -> diff _ pixels ▁= ▁ff _ diff _ pixels _ mm x ; ▁} ▁if ▁( EXTERNAL _ SS E 2( cpu _ flags )) ▁{ ▁if ▁(! high _ bit _ depth ) ▁c -> get _ pixels ▁= ▁ff _ get _ pixels _ s se 2; ▁c -> diff

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁USB Device ▁* usb _ net _ init ( const ▁char ▁* cmdline ) ▁{ ▁USB Device ▁* dev ; ▁Q emu Opts ▁* opts ; ▁int ▁idx ; ▁opts ▁= ▁qemu _ opts _ parse ( & q emu _ net _ opts , ▁cmdline , ▁NULL ); ▁if ▁(! opts ) ▁{ ▁qemu _ opt _ set ( opts , ▁" type ", ▁" nic "); ▁qemu _ opt _ set ( opts , ▁" model ", ▁" usb "); ▁idx ▁= ▁net _ client _ init ( NULL , ▁opts , ▁0); ▁if ▁( idx ▁== ▁-1) ▁{ ▁dev ▁= ▁usb _ create ( NULL ▁/* ▁FIX ME ▁*/ , ▁" usb - net "); ▁q dev _ set _ nic _ properties ( & dev -> q dev , ▁& n

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pkt _ dump _ internal ( void ▁* av cl , ▁FILE ▁* f , ▁int ▁level , ▁const ▁AV Packet ▁* pk t , ▁int ▁dump _ payload , ▁AV R ational ▁time _ base ) ▁{ ▁HEX DU MP _ PRI NT (" stream ▁# % d :\ n ", ▁pkt -> stream _ index ); ▁HEX DU MP _ PRI NT (" ▁key frame =% d \ n ", ▁( pk t -> flags ▁& ▁AV _ PK T _ FLAG _ KEY ) ▁!= ▁0); ▁HEX DU MP _ PRI NT (" ▁duration =% 0. 3 f \ n ", ▁pkt -> duration ▁* ▁av _ q 2 d ( time _ base )); ▁/* ▁D TS ▁is ▁_ always _ ▁valid ▁after ▁av _ read _ frame () ▁*/ ▁HEX DU

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ mouse wheel ( S DL _ Event ▁* ev ) ▁{ ▁struct ▁sd l 2_ console ▁* s con ▁= ▁get _ s con _ from _ window ( ev -> key . window ID ); ▁SDL _ Mouse Wheel Event ▁* w ev ▁= ▁& ev -> wheel ; ▁Input Button ▁btn ; ▁if ▁( w ev -> y ▁> ▁0) ▁{ ▁btn ▁= ▁INPUT _ BUTTON _ W HE EL _ UP ; ▁} ▁else ▁if ▁( w ev -> y ▁< ▁0) ▁{ ▁btn ▁= ▁INPUT _ BUTTON _ W HE EL _ DOWN ; ▁} ▁else ▁{ ▁return ; ▁} ▁qemu _ input _ queue _ btn ( s con -> d cl . con , ▁btn , ▁true ); ▁qemu _ input _ event _ sync (); ▁qemu _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ virt io _ dev ( Test Server ▁* s ) ▁{ ▁Q PC I Bus ▁* bus ; ▁Q V irt io PC ID evice ▁* dev ; ▁uint 32_ t ▁features ; ▁bus ▁= ▁q pc i _ init _ pc ( NULL ); ▁g _ assert _ non null ( bus ); ▁dev ▁= ▁q virt io _ pc i _ device _ find ( bus , ▁VI RT IO _ ID _ NET ); ▁g _ assert _ non null ( dev ); ▁q virt io _ pc i _ device _ enable ( dev ); ▁q virt io _ reset ( & dev -> v dev ); ▁q virt io _ set _ ack nowledge ( & dev -> v dev ); ▁q virt io _ set _ driver ( & dev -> v dev ); ▁features ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ packet _ split _ side _ data ( AV Packet ▁* pk t ){ ▁if ▁(! pk t -> side _ data _ elems ▁&& ▁pkt -> size ▁> 12 ▁&& ▁AV _ RB 64 ( pk t -> data ▁+ ▁pkt -> size ▁- ▁8) ▁== ▁FF _ MER GE _ MARKER ){ ▁int ▁i ; ▁unsigned ▁int ▁size ; ▁uint 8_ t ▁* p ; ▁p ▁= ▁pkt -> data ▁+ ▁pkt -> size ▁- ▁8 ▁- ▁5; ▁for ▁( i =1; ▁; ▁i ++){ ▁size ▁= ▁AV _ RB 32 ( p ); ▁if ▁( size > INT _ MAX ▁|| ▁p ▁- ▁pkt -> data ▁< ▁size ) ▁return ▁0; ▁if ▁( p [4] & 12 8) ▁break ; ▁p - = ▁size + 5; ▁} ▁pkt -> side _ data ▁= ▁av _ m a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb _ ms d _ cancel _ io ( US B Device ▁* dev , ▁USB Packet ▁* p ) ▁{ ▁MS D State ▁* s ▁= ▁DO _ UP CAST ( MS D State , ▁dev , ▁dev ); ▁sc si _ req _ cancel ( s -> req ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ram _ addr _ t ▁p pc 40 5_ set _ boot info ▁( CPU State ▁* env , ▁p pc 4 xx _ bd _ info _ t ▁* bd , ▁uint 32_ t ▁flags ) ▁{ ▁ram _ addr _ t ▁bd loc ; ▁int ▁i , ▁n ; ▁/* ▁We ▁put ▁the ▁bd ▁structure ▁at ▁the ▁top ▁of ▁memory ▁*/ ▁if ▁( bd -> bi _ mem size ▁>= ▁0 x 01 000000 UL ) ▁bd loc ▁= ▁0 x 01 000000 UL ▁- ▁sizeof ( struct ▁p pc 4 xx _ bd _ info _ t ); ▁else ▁bd loc ▁= ▁bd -> bi _ mem size ▁- ▁sizeof ( struct ▁p pc 4 xx _ bd _ info _ t ); ▁st l _ ph ys ( bd loc ▁+ ▁0 x 00, ▁bd -> bi _ mem start ); ▁st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁virt io _ i pl _ disk _ is _ valid ( void ) ▁{ ▁return ▁blk _ cfg . blk _ size ▁&& ▁( virt io _ disk _ is _ sc si () ▁|| ▁virt io _ disk _ is _ eck d ()); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ password _ cb ( Monitor ▁* mon , ▁const ▁char ▁* password , ▁void ▁* op aque ) ▁{ ▁Block Driver State ▁* bs ▁= ▁opaque ; ▁int ▁ret ▁= ▁0; ▁if ▁( b dr v _ set _ key ( bs , ▁password ) ▁!= ▁0) ▁{ ▁monitor _ printf ( mon , ▁" invalid ▁password \ n "); ▁ret ▁= ▁- E PER M ; ▁} ▁if ▁( mon -> password _ completion _ cb ) ▁mon -> password _ completion _ cb ( mon -> password _ op aque , ▁ret ); ▁monitor _ read _ command ( mon , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁d show _ cycle _ devices ( AV Format Context ▁* av ctx , ▁I Create Dev Enum ▁* dev enum , ▁enum ▁d show Device Type ▁dev type , ▁I Base Filter ▁** p filter ) ▁{ ▁struct ▁d show _ ctx ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁I Base Filter ▁* device _ filter ▁= ▁NULL ; ▁I Enum Mon ik er ▁* class enum ▁= ▁NULL ; ▁I Mon ik er ▁* m ▁= ▁NULL ; ▁const ▁char ▁* device _ name ▁= ▁ctx -> device _ name [ dev type ]; ▁int ▁skip ▁= ▁( dev type ▁== ▁Video Device ) ▁? ▁ctx -> video _ device _ number ▁: ▁ctx -> audio _ devic

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁do _ decode ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁got _ frame ; ▁int ▁ret ; ▁av _ assert 0 (! av ctx -> internal -> buffer _ frame -> buf [0]); ▁if ▁(! pk t ) ▁pkt ▁= ▁av ctx -> internal -> buffer _ pk t ; ▁// ▁This ▁is ▁the ▁less er ▁evil . ▁The ▁field ▁is ▁for ▁compatibility ▁with ▁legacy ▁users ▁// ▁of ▁the ▁legacy ▁API , ▁and ▁users ▁using ▁the ▁new ▁API ▁should ▁not ▁be ▁forced ▁to ▁// ▁even ▁know ▁about ▁this ▁field . ▁av ctx -> refcount ed _ frames ▁= ▁1; ▁// ▁S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁net _ host _ device _ remove ( Monitor ▁* mon , ▁int ▁vlan _ id , ▁const ▁char ▁* device ) ▁{ ▁V LAN State ▁* vlan ; ▁V LAN Client State ▁* vc ; ▁vlan ▁= ▁qemu _ find _ vlan ( vlan _ id ); ▁for ( vc ▁= ▁vlan -> first _ client ; ▁vc ▁!= ▁NULL ; ▁vc ▁= ▁vc -> next ) ▁if ▁(! str cmp ( vc -> name , ▁device )) ▁break ; ▁if ▁(! vc ) ▁{ ▁monitor _ printf ( mon , ▁" can ' t ▁find ▁device ▁% s \ n ", ▁device ); ▁return ; ▁} ▁qemu _ del _ vlan _ client ( vc ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ bar _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁data , ▁unsigned ▁size ) ▁{ ▁V FI OB AR ▁* bar ▁= ▁opaque ; ▁union ▁{ ▁uint 8_ t ▁byte ; ▁uint 16_ t ▁word ; ▁uint 32_ t ▁d word ; ▁uint 64_ t ▁q word ; ▁} ▁buf ; ▁switch ▁( size ) ▁{ ▁case ▁1: ▁buf . byte ▁= ▁data ; ▁break ; ▁case ▁2: ▁buf . word ▁= ▁cpu _ to _ le 16 ( data ); ▁break ; ▁case ▁4: ▁buf . d word ▁= ▁cpu _ to _ le 32 ( data ); ▁break ; ▁default : ▁hw _ error (" vf io : ▁unsupported ▁write ▁size , ▁% d ▁bytes

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m cf 5 208 ev b _ init ( Q EM UM achine Init Args ▁* args ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁args -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁args -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁args -> kernel _ filename ; ▁CP UM 68 K State ▁* env ; ▁int ▁kernel _ size ; ▁uint 64_ t ▁el f _ entry ; ▁target _ ph ys _ addr _ t ▁entry ; ▁qemu _ irq ▁* pic ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ram ▁= ▁g _ new ( Memory Region , ▁1)

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Q Object ▁* parse _ escape ( JSON Parser Context ▁* ctxt , ▁va _ list ▁* ap ) ▁{ ▁Q Object ▁* token ; ▁const ▁char ▁* val ; ▁if ▁( ap ▁== ▁NULL ) ▁{ ▁return ▁NULL ; ▁} ▁token ▁= ▁parser _ context _ pop _ token ( ctxt ); ▁assert ( token ▁&& ▁token _ get _ type ( token ) ▁== ▁JSON _ E SCAPE ); ▁val ▁= ▁token _ get _ value ( token ); ▁if ▁(! str cmp ( val , ▁"% p ")) ▁{ ▁return ▁va _ arg (* ap , ▁Q Object ▁* ); ▁} ▁else ▁if ▁(! str cmp ( val , ▁"% i ")) ▁{ ▁return ▁Q OBJECT ( q bool _ from _ bool ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁uint 64_ t ▁ld q _ ph ys _ internal ( hw addr ▁addr , ▁enum ▁device _ endian ▁endian ) ▁{ ▁uint 8_ t ▁* ptr ; ▁uint 64_ t ▁val ; ▁Memory Region Section ▁* section ; ▁section ▁= ▁phys _ page _ find ( address _ space _ memory . dispatch , ▁addr ▁>> ▁TARGET _ PAGE _ BITS ); ▁if ▁(! ( memory _ region _ is _ ram ( section -> mr ) ▁|| ▁memory _ region _ is _ rom d ( section -> mr ))) ▁{ ▁/* ▁I / O ▁case ▁*/ ▁addr ▁= ▁memory _ region _ section _ addr ( section , ▁addr ); ▁/* ▁XXX ▁This ▁is ▁brok

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁main _ loop _ wait ( int ▁non blocking ) ▁{ ▁fd _ set ▁rf ds , ▁wf ds , ▁x fds ; ▁int ▁ret , ▁nf ds ; ▁struct ▁time val ▁tv ; ▁int ▁timeout ; ▁if ▁( non blocking ) ▁timeout ▁= ▁0; ▁else ▁{ ▁timeout ▁= ▁qemu _ calculate _ timeout (); ▁qemu _ b h _ update _ timeout ( & timeout ); ▁} ▁os _ host _ main _ loop _ wait ( & timeout ); ▁tv . tv _ sec ▁= ▁timeout ▁/ ▁1000 ; ▁tv . tv _ use c ▁= ▁( timeout ▁% ▁1000 ) ▁* ▁1000 ; ▁/* ▁poll ▁any ▁events ▁*/ ▁/* ▁XXX : ▁separate ▁device ▁handlers ▁from ▁system ▁on

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ in validate _ cache _ all ( Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁B dr v Next Iterator ▁* it ▁= ▁NULL ; ▁while ▁(( it ▁= ▁b dr v _ next ( it , ▁& bs )) ▁!= ▁NULL ) ▁{ ▁A io Context ▁* a io _ context ▁= ▁b dr v _ get _ a io _ context ( bs ); ▁aio _ context _ acquire ( a io _ context ); ▁b dr v _ in validate _ cache ( bs , ▁& local _ err ); ▁aio _ context _ release ( a io _ context ); ▁if ▁( local _ err ) ▁{ ▁error _ propag ate ( err p , ▁local _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ adapt ation _ sets ( AV Format Context ▁* s ) ▁{ ▁Web MD ash M ux Context ▁* w ▁= ▁s -> priv _ data ; ▁char ▁* p ▁= ▁w -> adapt ation _ sets ; ▁char ▁* q ; ▁enum ▁{ ▁new _ set , ▁parsed _ id , ▁parsing _ streams ▁} ▁state ; ▁if ▁(! w -> adapt ation _ sets ) ▁{ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" The ▁' adapt ation _ sets ' ▁option ▁must ▁be ▁set .\ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁// ▁syntax ▁id =0, streams =0, 1, 2 ▁id =1, streams =3, 4 ▁and ▁so ▁on ▁state ▁= ▁new _ set

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Q Object ▁* parse _ keyword ( JSON Parser Context ▁* ctxt ) ▁{ ▁Q Object ▁* token , ▁* ret ; ▁JSON Parser Context ▁saved _ ctxt ▁= ▁parser _ context _ save ( ctxt ); ▁token ▁= ▁parser _ context _ pop _ token ( ctxt ); ▁if ▁( token ▁== ▁NULL ) ▁{ ▁goto ▁out ; ▁} ▁if ▁( token _ get _ type ( token ) ▁!= ▁JSON _ KEYWORD ) ▁{ ▁goto ▁out ; ▁} ▁if ▁( token _ is _ keyword ( token , ▁" true ")) ▁{ ▁ret ▁= ▁Q OBJECT ( q bool _ from _ int ( true )); ▁} ▁else ▁if ▁( token _ is _ keyword ( token , ▁" false ")

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a ac _ encode _ frame ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* frame , ▁int ▁buf _ size , ▁void ▁* data ) ▁{ ▁A AC Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int 16_ t ▁* samples ▁= ▁s -> samples , ▁* samples 2, ▁* la ; ▁Channel Element ▁* c pe ; ▁int ▁i , ▁j , ▁ch ans , ▁tag , ▁start _ ch ; ▁const ▁uint 8_ t ▁* chan _ map ▁= ▁a ac _ chan _ configs [ av ctx -> channels -1 ]; ▁int ▁chan _ el _ counter [4 ]; ▁FF P sy Window Info ▁windows [ A AC _ MAX _ CH AN NE LS ]; ▁if ▁( s -> last _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dx t ory _ decode _ v 2_ 4 20 ( AV Codec Context ▁* av ctx , ▁AV Frame ▁* pic , ▁const ▁uint 8_ t ▁* src , ▁int ▁src _ size ) ▁{ ▁Get Byte Context ▁gb ; ▁Get Bit Context ▁gb 2; ▁int ▁ns lices , ▁slice , ▁slice _ height , ▁ref _ slice _ height ; ▁int ▁cur _ y , ▁next _ y ; ▁uint 32_ t ▁off , ▁slice _ size ; ▁uint 8_ t ▁* Y , ▁* U , ▁* V ; ▁int ▁ret ; ▁by test ream 2_ init ( & gb , ▁src , ▁src _ size ); ▁ns lices ▁= ▁by test ream 2_ get _ le 16 ( & gb ); ▁off ▁= ▁F FA LI GN ( ns lices ▁* ▁4 ▁+

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ s br _ grid ( A AC Context ▁* ac , ▁Spect ral Band Replication ▁* s br , ▁Get Bit Context ▁* gb , ▁S BR Data ▁* ch _ data ) ▁{ ▁int ▁i ; ▁unsigned ▁bs _ pointer ▁= ▁0; ▁// ▁frame Length Flag ▁? ▁15 ▁: ▁16 ; ▁9 60 ▁sample ▁length ▁frames ▁unsupported ; ▁this ▁value ▁is ▁num Time Slots ▁int ▁abs _ b ord _ trail ▁= ▁16 ; ▁int ▁num _ rel _ lead , ▁num _ rel _ trail ; ▁unsigned ▁bs _ num _ env _ old ▁= ▁ch _ data -> bs _ num _ env ; ▁ch _ data -> bs _ freq _ res [0] ▁= ▁ch _ data -> bs _ f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁u h ci _ complete _ td ( U H CI State ▁* s , ▁U H CI _ TD ▁* td , ▁U H CI Async ▁* async , ▁uint 32_ t ▁* int _ mask ) ▁{ ▁int ▁len ▁= ▁0, ▁max _ len , ▁err , ▁ret ; ▁uint 8_ t ▁pid ; ▁max _ len ▁= ▁(( td -> token ▁>> ▁2 1) ▁+ ▁1) ▁& ▁0 x 7 ff ; ▁pid ▁= ▁td -> token ▁& ▁0 xff ; ▁ret ▁= ▁async -> packet . result ; ▁if ▁( td -> ctrl ▁& ▁TD _ CT RL _ IOS ) ▁td -> ctrl ▁&= ▁~ TD _ CT RL _ ACTIVE ; ▁if ▁( ret ▁< ▁0) ▁goto ▁out ; ▁len ▁= ▁async -> packet . result ; ▁td -> ctrl ▁= ▁( td -> ctrl ▁& 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ x 86_ dump _ state ( FILE ▁* f ) ▁{ ▁int ▁ef lags ; ▁char ▁cc _ op _ name [ 32 ]; ▁ef lags ▁= ▁cc _ table [ CC _ OP ]. compute _ all (); ▁ef lags ▁|= ▁( DF ▁& ▁DF _ MASK ); ▁if ▁(( un signed ) env -> cc _ op ▁< ▁CC _ OP _ NB ) ▁str c py ( cc _ op _ name , ▁cc _ op _ str [ env -> cc _ op ]); ▁else ▁sn printf ( cc _ op _ name , ▁sizeof ( cc _ op _ name ), ▁"[ % d ]", ▁env -> cc _ op ); ▁f printf ( f , ▁" E AX =% 08 x ▁E B X =% 08 X ▁EC X =% 08 x ▁ED X =% 08 x \ n " ▁" E SI =% 08 x ▁E DI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gif _ read _ image ( G if State ▁* s ) ▁{ ▁int ▁left , ▁top , ▁width , ▁height , ▁bits _ per _ pixel , ▁code _ size , ▁flags ; ▁int ▁is _ inter le aved , ▁has _ local _ palette , ▁y , ▁pass , ▁y 1, ▁lines ize , ▁n , ▁i ; ▁uint 8_ t ▁* ptr , ▁* sp al , ▁* palette , ▁* ptr 1; ▁left ▁= ▁by test ream _ get _ le 16 ( & s -> by test ream ); ▁top ▁= ▁by test ream _ get _ le 16 ( & s -> by test ream ); ▁width ▁= ▁by test ream _ get _ le 16 ( & s -> by test ream ); ▁height ▁= ▁by test ream _ get _ le

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a la c _ encode _ frame ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* frame , ▁int ▁buf _ size , ▁void ▁* data ) ▁{ ▁A la c Encode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁Put Bit Context ▁* pb ▁= ▁& s -> pb ctx ; ▁int ▁i , ▁out _ bytes , ▁verb at im _ flag ▁= ▁0; ▁if ▁( av ctx -> frame _ size ▁> ▁DEFAULT _ FRAME _ SIZE ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" input ▁frame ▁size ▁exceeded \ n "); ▁return ▁-1; ▁} ▁if ▁( buf _ size ▁< ▁2 ▁* ▁s -> max _ coded _ frame _ size ) ▁{ ▁av _ l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁i 4 40 fx _ update _ memory _ mappings ( PC II 4 40 FX State ▁* d ) ▁{ ▁int ▁i , ▁r ; ▁uint 32_ t ▁sm ram ; ▁bool ▁sm ram _ enabled ; ▁memory _ region _ transaction _ begin (); ▁update _ p am ( d , ▁0 xf 0000, ▁0 x 100 000, ▁( d -> dev . config [ I 4 40 FX _ PA M ] ▁>> ▁4) ▁& ▁3, ▁& d -> p am _ regions [0]); ▁for ( i ▁= ▁0; ▁i ▁< ▁12 ; ▁i ++) ▁{ ▁r ▁= ▁( d -> dev . config [( i ▁>> ▁1) ▁+ ▁( I 4 40 FX _ PA M ▁+ ▁1) ] ▁>> ▁(( i ▁& ▁1) ▁* ▁4 )) ▁& ▁3; ▁update _ p am ( d , ▁0 xc 0000 ▁+ ▁0 x 4 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ open _ v mdk 4 ( Block Driver State ▁* bs , ▁Block Driver State ▁* file , ▁int ▁flags ) ▁{ ▁int ▁ret ; ▁uint 32_ t ▁magic ; ▁uint 32_ t ▁l 1_ size , ▁l 1_ entry _ sect ors ; ▁VM DK 4 Header ▁header ; ▁V mdk Extent ▁* extent ; ▁int 64_ t ▁l 1_ backup _ offset ▁= ▁0; ▁ret ▁= ▁b dr v _ p read ( file , ▁sizeof ( magic ), ▁& header , ▁sizeof ( header )); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁if ▁( header . capacity ▁== ▁0) ▁{ ▁int 64_ t ▁desc _ offset ▁= ▁le 64_ to _ cpu ( header . desc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁control _ to _ network ( RD MA Control Header ▁* control ) ▁{ ▁control -> type ▁= ▁ht on l ( control -> type ); ▁control -> len ▁= ▁ht on l ( control -> len ); ▁control -> repeat ▁= ▁ht on l ( control -> repeat ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁use _ multi port ( V irt IO Serial ▁* v ser ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( v ser ); ▁return ▁virt io _ has _ feature ( v dev , ▁VI RT IO _ CON SO LE _ F _ MULTIP ORT ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁poll _ filter ( OutputStream ▁* ost ) ▁{ ▁Output File ▁* of ▁= ▁output _ files [ ost -> file _ index ]; ▁AV Frame ▁* filtered _ frame ▁= ▁NULL ; ▁int ▁frame _ size , ▁ret ; ▁if ▁(! ost -> filtered _ frame ▁&& ▁! ( ost -> filtered _ frame ▁= ▁av codec _ alloc _ frame ())) ▁{ ▁return ▁A VER ROR ( EN O ME M ); ▁} ▁else ▁av codec _ get _ frame _ defaults ( ost -> filtered _ frame ); ▁filtered _ frame ▁= ▁o st -> filtered _ frame ; ▁if ▁( ost -> enc -> type ▁== ▁AV MEDIA _ TYPE _ AU DIO ▁&& ▁! ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* memory _ region _ get _ ram _ ptr ( Memory Region ▁* mr ) ▁{ ▁if ▁( mr -> alias ) ▁{ ▁return ▁memory _ region _ get _ ram _ ptr ( mr -> alias ) ▁+ ▁mr -> alias _ offset ; ▁} ▁assert ( mr -> termin ates ); ▁return ▁qemu _ get _ ram _ ptr ( mr -> ram _ addr ▁& ▁TARGET _ PAGE _ MASK ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ af _ queue _ init ( AV Codec Context ▁* av ctx , ▁Audio Frame Queue ▁* af q ) ▁{ ▁af q -> av ctx ▁= ▁av ctx ; ▁af q -> next _ pts ▁= ▁AV _ NO PT S _ VALUE ; ▁af q -> remaining _ delay ▁= ▁av ctx -> delay ; ▁af q -> remaining _ samples ▁= ▁av ctx -> delay ; ▁af q -> frame _ queue ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁k vm _ s 39 0_ service _ interrupt ( S 390 CPU ▁* cpu , ▁uint 32_ t ▁parm ) ▁{ ▁k vm _ s 39 0_ interrupt _ internal ( cpu , ▁K VM _ S 39 0_ INT _ SERVICE , ▁parm , ▁0 ▁, ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( rgb 24 to b gr 15 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁int ▁src _ size ) ▁{ ▁const ▁uint 8_ t ▁* s ▁= ▁src ; ▁const ▁uint 8_ t ▁* end ; ▁const ▁uint 8_ t ▁* mm _ end ; ▁uint 16_ t ▁* d ▁= ▁( uint 16_ t ▁* ) dst ; ▁end ▁= ▁s ▁+ ▁src _ size ; ▁__ asm __ ▁volatile ( PRE FETCH " ▁% 0 ": :" m " (* src ): " memory "); ▁__ asm __ ▁volatile ( ▁" mov q ▁% 0, ▁%% mm 7 ▁\ n \ t " ▁" mov q ▁% 1, ▁%% mm 6 ▁\ n \ t " ▁:: " m " ( red _15 mask ), " m " ( green _15 mask )); ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁gd _ m otion _ event ( G tk Widget ▁* widget , ▁G dk Event Motion ▁* m otion , ▁void ▁* op aque ) ▁{ ▁Gtk Display State ▁* s ▁= ▁opaque ; ▁int ▁x , ▁y ; ▁int ▁mx , ▁my ; ▁int ▁fb h , ▁fb w ; ▁int ▁ww , ▁wh ; ▁fb w ▁= ▁surface _ width ( s -> ds ) ▁* ▁s -> scale _ x ; ▁fb h ▁= ▁surface _ height ( s -> ds ) ▁* ▁s -> scale _ y ; ▁gdk _ drawable _ get _ size ( g tk _ widget _ get _ window ( s -> draw ing _ area ), ▁& ww , ▁& wh ); ▁mx ▁= ▁my ▁= ▁0; ▁if ▁( ww ▁> ▁fb w ) ▁{ ▁mx ▁= ▁( ww ▁- ▁f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ vd pa u _ common _ init ( AV Codec Context ▁* av ctx , ▁V dp Decoder Profile ▁profile , ▁int ▁level ) ▁{ ▁V D PA U H W Context ▁* hw ctx ▁= ▁av ctx -> hw accel _ context ; ▁V D PA U Context ▁* vd ctx ▁= ▁av ctx -> internal -> hw accel _ priv _ data ; ▁V dp Video Surface Query Capabilities ▁* surface _ query _ caps ; ▁V dp Decoder Query Capabilities ▁* decoder _ query _ caps ; ▁V dp Decoder Create ▁* create ; ▁void ▁* func ; ▁V dp Status ▁status ; ▁V dp Bool ▁supported ; ▁uint 32_ t ▁max _ level

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁estimate _ qp ( M peg Enc Context ▁* s , ▁int ▁dry _ run ){ ▁if ▁( s -> next _ lambda ){ ▁s -> current _ picture _ ptr -> f . quality ▁= ▁s -> current _ picture . f . quality ▁= ▁s -> next _ lambda ; ▁if (! d ry _ run ) ▁s -> next _ lambda = ▁0; ▁} ▁else ▁if ▁(! s -> fixed _ q scale ) ▁{ ▁s -> current _ picture _ ptr -> f . quality ▁= ▁s -> current _ picture . f . quality ▁= ▁ff _ rate _ est imate _ q scale ( s , ▁dry _ run ); ▁if ▁( s -> current _ picture . f . quality ▁< ▁0) ▁return ▁-1; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spr _ write _ t bu ▁( Dis as Context ▁* ctx , ▁int ▁spr n , ▁int ▁g pr n ) ▁{ ▁if ▁( use _ ic ount ) ▁{ ▁gen _ io _ start (); ▁} ▁gen _ helper _ store _ t bu ( cpu _ env , ▁cpu _ g pr [ g pr n ]); ▁if ▁( use _ ic ount ) ▁{ ▁gen _ io _ end (); ▁gen _ stop _ exception ( ctx ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ int x _ enable _ k vm ( V FI OP C ID evice ▁* v dev ) ▁{ ▁# if def ▁CONFIG _ K VM ▁struct ▁k vm _ irq fd ▁irq fd ▁= ▁{ ▁. fd ▁= ▁event _ notifier _ get _ fd ( & v dev -> int x . interrupt ), ▁. gs i ▁= ▁v dev -> int x . route . irq , ▁. flags ▁= ▁K VM _ IR Q FD _ FLAG _ RE SA MPLE , ▁}; ▁struct ▁vf io _ irq _ set ▁* irq _ set ; ▁int ▁ret , ▁args z ; ▁int 32_ t ▁* p fd ; ▁if ▁(! V FI O _ ALLOW _ K VM _ INT X ▁|| ▁! k vm _ irq fds _ enabled () ▁|| ▁v dev -> int x . route . mode ▁!= ▁P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ ev fs n abs ( Dis as Context ▁* ctx ) ▁{ ▁if ▁( un likely (! ctx -> s pe _ enabled )) ▁{ ▁gen _ exception ( ctx , ▁PO WER PC _ EX CP _ AP U ); ▁return ; ▁} ▁# if ▁defined ( TARGET _ P PC 64) ▁tc g _ gen _ or i _ tl ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ g pr [ r A ( ctx -> op code )], ▁0 x 8 00000008 0000000 LL ); ▁# else ▁tc g _ gen _ or i _ tl ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ g pr [ r A ( ctx -> op code )], ▁0 x 8 0000000 ); ▁tc g _ gen _ or i _ tl ( cp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁im x _ timer g _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁unsigned ▁size ) ▁{ ▁IM X Timer G State ▁* s ▁= ▁( IM X Timer G State ▁* ) op aque ; ▁D PRI NT F (" g - read ( offset =% x )", ▁offset ▁>> ▁2); ▁switch ▁( offset ▁>> ▁2) ▁{ ▁case ▁0: ▁/* ▁Control ▁Register ▁*/ ▁D PRI NT F (" ▁cr ▁= ▁% x \ n ", ▁s -> cr ); ▁return ▁s -> cr ; ▁case ▁1: ▁/* ▁pre scaler ▁*/ ▁D PRI NT F (" ▁pr ▁= ▁% x \ n ", ▁s -> pr ); ▁return ▁s -> pr ; ▁case ▁2: ▁/* ▁Status ▁Register ▁*/ ▁D 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁blk debug _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁B DR V Bl k debug State ▁* s ▁= ▁bs -> op aque ; ▁Q emu Opts ▁* opts ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁opts ▁= ▁qemu _ opts _ create ( & runtime _ opts , ▁NULL , ▁0, ▁& error _ abort ); ▁qemu _ opts _ abs orb _ q dict ( opts , ▁options , ▁& local _ err ); ▁if ▁( local _ err ) ▁{ ▁error _ propag ate ( err p , ▁local _ err ); ▁ret ▁= ▁- E IN VAL ; ▁goto ▁out ; ▁} ▁/* ▁Read ▁rul

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str t ou ll _ full _ negative ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" ▁\ t ▁- 32 1" ; ▁uint 64_ t ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str t ou ll ( str , ▁NULL , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert _ cmp int ( res , ▁== , ▁18 44 67 4 407 37 09 55 12 95 LL U ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁ex yn os 42 10_ f im d _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁unsigned ▁size ) ▁{ ▁Ex yn os 42 10 f im d State ▁* s ▁= ▁( Ex yn os 42 10 f im d State ▁* ) op aque ; ▁int ▁w , ▁i ; ▁uint 32_ t ▁ret ▁= ▁0; ▁D PRI NT _ L 2 (" read ▁offset ▁0 x % 08 x \ n ", ▁offset ); ▁switch ▁( offset ) ▁{ ▁case ▁FI MD _ V ID CON 0 ▁... ▁FI MD _ V ID CON 3: ▁return ▁s -> vid con [( offset ▁- ▁FI MD _ V ID CON 0) ▁>> ▁2 ]; ▁case ▁FI MD _ V ID T CON _ START ▁... ▁FI MD _ V ID T C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁float 64 ▁HEL PER ( uc f 64_ ab sd )( float 64 ▁a ) ▁{ ▁return ▁float 64_ abs ( a ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ null ( const ▁char ▁* id , ▁Ch ard ev Backend ▁* backend , ▁Ch ard ev Return ▁* ret , ▁Error ▁** err p ) ▁{ ▁Char Driver State ▁* chr ; ▁Ch ard ev Common ▁* common ▁= ▁backend -> u . null ; ▁chr ▁= ▁qemu _ chr _ alloc ( common , ▁err p ); ▁if ▁(! chr ) ▁{ ▁return ▁NULL ; ▁} ▁chr -> chr _ write ▁= ▁null _ chr _ write ; ▁chr -> explicit _ be _ open ▁= ▁true ; ▁return ▁chr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁packet _ enqueue ( Compare State ▁* s , ▁int ▁mode ) ▁{ ▁Connection Key ▁key ; ▁Packet ▁* pk t ▁= ▁NULL ; ▁Connection ▁* conn ; ▁if ▁( mode ▁== ▁PRIMARY _ IN ) ▁{ ▁pkt ▁= ▁packet _ new ( s -> p ri _ rs . buf , ▁s -> p ri _ rs . packet _ len , ▁s -> p ri _ rs . v net _ hdr _ len ); ▁} ▁else ▁{ ▁pkt ▁= ▁packet _ new ( s -> sec _ rs . buf , ▁s -> sec _ rs . packet _ len , ▁s -> sec _ rs . v net _ hdr _ len ); ▁} ▁if ▁( parse _ packet _ ear ly ( pk t )) ▁{ ▁packet _ destroy ( pk t , ▁NULL ); ▁pk

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁enum ▁Codec ID ▁av _ codec _ get _ id ( const ▁AV Codec Tag ▁* tags [4 ], ▁unsigned ▁int ▁tag ) ▁{ ▁int ▁i ; ▁for ( i =0; ▁i < 4 ▁&& ▁tags [ i ]; ▁i ++){ ▁enum ▁Codec ID ▁id = ▁codec _ get _ id ( tags [ i ], ▁tag ); ▁if ( id != CODE C _ ID _ NONE ) ▁return ▁id ; ▁} ▁return ▁CODE C _ ID _ NONE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ide _ ata pi _ ident ify ( IDE State ▁* s ) ▁{ ▁uint 16_ t ▁* p ; ▁if ▁( s -> ident ify _ set ) ▁{ ▁mem c py ( s -> io _ buffer , ▁s -> ident ify _ data , ▁sizeof ( s -> ident ify _ data )); ▁return ; ▁} ▁mem set ( s -> io _ buffer , ▁0, ▁512 ); ▁p ▁= ▁( uint 16_ t ▁* ) s -> io _ buffer ; ▁/* ▁Rem ov able ▁CD ROM , ▁50 us ▁response , ▁12 ▁byte ▁packets ▁*/ ▁put _ le 16 ( p ▁+ ▁0, ▁(2 ▁<< ▁14 ) ▁| ▁(5 ▁<< ▁8) ▁| ▁(1 ▁<< ▁7) ▁| ▁(2 ▁<< ▁5) ▁| ▁(0 ▁<< ▁0 )); ▁pad str (( char ▁* )( p ▁+ ▁10 ), 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ put _ x save ( CPU State ▁* env ) ▁{ ▁# if def ▁K VM _ CAP _ X SA VE ▁int ▁i , ▁r ; ▁struct ▁k vm _ x save * ▁x save ; ▁uint 16_ t ▁cwd , ▁sw d , ▁tw d , ▁f op ; ▁if ▁(! k vm _ has _ x save ()) ▁return ▁k vm _ put _ f pu ( env ); ▁x save ▁= ▁qemu _ mem align ( 409 6, ▁sizeof ( struct ▁k vm _ x save )); ▁mem set ( x save , ▁0, ▁sizeof ( struct ▁k vm _ x save )); ▁cwd ▁= ▁sw d ▁= ▁tw d ▁= ▁f op ▁= ▁0; ▁sw d ▁= ▁env -> fp us ▁& ▁~ (7 ▁<< ▁11 ); ▁sw d ▁|= ▁( env -> fp st t ▁& ▁7) ▁<< ▁11 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁block Copy ( uint 8_ t ▁dst [], ▁int ▁dst Stride , ▁uint 8_ t ▁src [], ▁int ▁src Stride , ▁int ▁num Lines , ▁int ▁level Fix ) ▁{ ▁int ▁i ; ▁if ( level Fix ) ▁{ ▁# if def ▁HAVE _ MM X ▁asm ▁volatile ( ▁" mov l ▁% 4, ▁%% e ax ▁\ n \ t " ▁" mov l ▁%% e ax , ▁temp 0\ n \ t " ▁" push l ▁% 0 ▁\ n \ t " ▁" push l ▁% 1 ▁\ n \ t " ▁" le al ▁( % 2, %2 ), ▁%% e ax ▁\ n \ t " ▁" le al ▁( % 3, %3 ), ▁%% eb x ▁\ n \ t " ▁" mov q ▁packed Y Offset , ▁%% mm 2 ▁\ n \ t " ▁" mov q ▁packed Y Scale , ▁%

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ tp m 2( G Array ▁* table _ data , ▁B IOS Linker ▁* link er ) ▁{ ▁Ac pi 20 TP M 2 ▁* tp m 2_ ptr ; ▁t pm 2_ ptr ▁= ▁ac pi _ data _ push ( table _ data , ▁sizeof ▁* tp m 2_ ptr ); ▁t pm 2_ ptr -> platform _ class ▁= ▁cpu _ to _ le 16 ( TP M 2_ AC PI _ CLASS _ CLIENT ); ▁t pm 2_ ptr -> control _ area _ address ▁= ▁cpu _ to _ le 64 (0); ▁t pm 2_ ptr -> start _ method ▁= ▁cpu _ to _ le 32 ( TP M 2_ START _ METHOD _ MM IO ); ▁build _ header ( link er , ▁table _ data , ▁( void ▁* ) tp m 2_ ptr , ▁" TP M

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h ev c _ output _ frame ( HE VC Context ▁* s , ▁AV Frame ▁* out , ▁int ▁flush ) ▁{ ▁do ▁{ ▁int ▁nb _ output ▁= ▁0; ▁int ▁min _ p oc ▁= ▁INT _ MAX ; ▁int ▁i , ▁min _ idx , ▁ret ; ▁if ▁( s -> sh . no _ output _ of _ prior _ p ics _ flag ▁== ▁1) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁FF _ ARRAY _ E LE MS ( s -> DP B ); ▁i ++) ▁{ ▁HE VC Frame ▁* frame ▁= ▁& s -> DP B [ i ]; ▁if ▁(! ( frame -> flags ▁& ▁HE VC _ FRAME _ FLAG _ BU MP ING ) ▁&& ▁frame -> p oc ▁!= ▁s -> p oc ▁&& ▁frame -> sequence ▁== ▁s -> seq _ o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg audio _ parse ( AV Codec Parser Context ▁* s 1, ▁AV Codec Context ▁* av ctx , ▁uint 8_ t ▁** p out buf , ▁int ▁* p out buf _ size , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁M peg Audio Parse Context ▁* s ▁= ▁s 1 -> priv _ data ; ▁int ▁len , ▁ret ; ▁uint 32_ t ▁header ; ▁const ▁uint 8_ t ▁* buf _ ptr ; ▁* p out buf ▁= ▁NULL ; ▁* p out buf _ size ▁= ▁0; ▁buf _ ptr ▁= ▁buf ; ▁while ▁( buf _ size ▁> ▁0) ▁{ ▁len ▁= ▁s -> in buf _ ptr ▁- ▁s -> in buf ; ▁if ▁( s -> frame _ size ▁== ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁JNI Env ▁* ff _ jni _ attach _ env ( int ▁* attached , ▁void ▁* log _ ctx ) ▁{ ▁int ▁ret ▁= ▁0; ▁JNI Env ▁* env ▁= ▁NULL ; ▁* attached ▁= ▁0; ▁p thread _ mut ex _ lock ( & lock ); ▁if ▁( java _ vm ▁== ▁NULL ▁&& ▁( java _ vm ▁= ▁av _ jni _ get _ java _ vm ( log _ ctx )) ▁== ▁NULL ) ▁{ ▁av _ log ( log _ ctx , ▁AV _ LOG _ INFO , ▁" Retri ev ing ▁current ▁Java ▁virtual ▁machine ▁using ▁Android ▁J ni Invocation ▁wrapper \ n "); ▁if ▁( check _ jni _ inv ocation ( log _ ctx ) ▁== ▁0) ▁{ ▁if ▁(( java _ vm ▁= ▁ge

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁perform _ c ow ( Block Driver State ▁* bs , ▁Q C ow L 2 Meta ▁* m ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁Q c ow 2 CO W Region ▁* start ▁= ▁& m -> c ow _ start ; ▁Q c ow 2 CO W Region ▁* end ▁= ▁& m -> c ow _ end ; ▁unsigned ▁buffer _ size ; ▁unsigned ▁data _ bytes ▁= ▁end -> offset ▁- ▁( start -> offset ▁+ ▁start -> nb _ bytes ); ▁bool ▁merge _ reads ; ▁uint 8_ t ▁* start _ buffer , ▁* end _ buffer ; ▁Q EM UI O Vector ▁q io v ; ▁int ▁ret ; ▁assert ( start -> nb _ bytes ▁<= ▁U 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sw s _ rgb 2 rgb _ init ( int ▁flags ) ▁{ ▁# if ▁HAVE _ SS E 2 ▁|| ▁HAVE _ MM X 2 ▁|| ▁HAVE _ AM D 3 D NOW ▁|| ▁HAVE _ MM X ▁if ▁( flags ▁& ▁S WS _ CPU _ CAP S _ SS E 2) ▁rgb 2 rgb _ init _ SS E 2 (); ▁else ▁if ▁( flags ▁& ▁S WS _ CPU _ CAP S _ MM X 2) ▁rgb 2 rgb _ init _ MM X 2 (); ▁else ▁if ▁( flags ▁& ▁S WS _ CPU _ CAP S _3 D NOW ) ▁rgb 2 rgb _ init _3 D NOW (); ▁else ▁if ▁( flags ▁& ▁S WS _ CPU _ CAP S _ MM X ) ▁rgb 2 rgb _ init _ MM X (); ▁else ▁# end if ▁/* ▁HAVE _ MM X 2 ▁|| ▁HAVE _ AM D 3 D

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁double ▁t get _ double ( Get Byte Context ▁* gb , ▁int ▁le ) ▁{ ▁av _ alias 64 ▁i ▁= ▁{ ▁. u 64 ▁= ▁le ▁? ▁by test ream 2_ get _ le 64 ( gb ) ▁: ▁by test ream 2_ get _ be 64 ( gb ) }; ▁return ▁i . f 64 ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ proc _ power 5 plus ( CP UP PC State ▁* env ) ▁{ ▁gen _ spr _ ne _6 01 ( env ); ▁gen _ spr _7 xx ( env ); ▁/* ▁Time ▁base ▁*/ ▁gen _ tbl ( env ); ▁/* ▁H ardware ▁implementation ▁registers ▁*/ ▁/* ▁XXX ▁: ▁not ▁implemented ▁*/ ▁spr _ register ( env , ▁SP R _ H ID 0, ▁" H ID 0 ", ▁SP R _ NO ACCESS , ▁SP R _ NO ACCESS , ▁& spr _ read _ generic , ▁& spr _ write _ clear , ▁0 x 6 0000000 ); ▁/* ▁XXX ▁: ▁not ▁implemented ▁*/ ▁spr _ register ( env , ▁SP R _ H ID 1, ▁" H ID 1", ▁SP R _ NO ACC

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁get _ bit _ rate ( AV Codec Context ▁* ctx ) ▁{ ▁int 64_ t ▁bit _ rate ; ▁int ▁bits _ per _ sample ; ▁switch ▁( ctx -> codec _ type ) ▁{ ▁case ▁AV MEDIA _ TYPE _ VI DEO : ▁case ▁AV MEDIA _ TYPE _ DATA : ▁case ▁AV MEDIA _ TYPE _ SUB TITLE : ▁case ▁AV MEDIA _ TYPE _ AT TACH MENT : ▁bit _ rate ▁= ▁ctx -> bit _ rate ; ▁break ; ▁case ▁AV MEDIA _ TYPE _ AU DIO : ▁bits _ per _ sample ▁= ▁av _ get _ bits _ per _ sample ( ctx -> codec _ id ); ▁bit _ rate ▁= ▁bits _ per _ sample ▁? ▁ctx -> sampl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mk v _ write _ code cp rivate ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Codec Parameters ▁* par , ▁int ▁native _ id , ▁int ▁qt _ id ) ▁{ ▁AV IO Context ▁* dyn _ cp ; ▁uint 8_ t ▁* code cp riv ; ▁int ▁ret , ▁code cp riv _ size ; ▁ret ▁= ▁av io _ open _ dyn _ buf ( & dyn _ cp ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁if ▁( native _ id ) ▁{ ▁ret ▁= ▁mk v _ write _ native _ code cp rivate ( s , ▁par , ▁dyn _ cp ); ▁} ▁else ▁if ▁( par -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ) ▁{ ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ vp 3_ id ct _ dc _ add _ c ( uint 8_ t ▁* dest /* align ▁8 */ , ▁int ▁line _ size , ▁const ▁D CT E LE M ▁* block /* align ▁16 */ ){ ▁int ▁i , ▁dc ▁= ▁( block [0] ▁+ ▁15 ) ▁>> ▁5; ▁const ▁uint 8_ t ▁* cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ▁+ ▁dc ; ▁for ( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++){ ▁dest [0] ▁= ▁cm [ dest [0] ]; ▁dest [1] ▁= ▁cm [ dest [1] ]; ▁dest [2] ▁= ▁cm [ dest [2] ]; ▁dest [3] ▁= ▁cm [ dest [3] ]; ▁dest [4] ▁= ▁cm [ dest [4] ]; ▁dest [5] ▁= ▁cm [ dest [5] ]; ▁dest [ 6] ▁= ▁cm [ dest

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁object _ property _ add _ bool ( Object ▁* obj , ▁const ▁char ▁* name , ▁bool ▁(* get )( Object ▁* , ▁Error ▁** ), ▁void ▁(* set )( Object ▁* , ▁bool , ▁Error ▁** ), ▁Error ▁** err p ) ▁{ ▁Bool Property ▁* prop ▁= ▁g _ m alloc 0( size of (* prop )); ▁prop -> get ▁= ▁get ; ▁prop -> set ▁= ▁set ; ▁object _ property _ add ( obj , ▁name , ▁" bool ", ▁get ▁? ▁property _ get _ bool ▁: ▁NULL , ▁set ▁? ▁property _ set _ bool ▁: ▁NULL , ▁property _ release _ bool , ▁prop , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁mirror ( int ▁v , ▁int ▁m ){ ▁if ▁( v < 0) ▁return ▁- v ; ▁else ▁if ( v > m ) ▁return ▁2* m - v ; ▁else ▁return ▁v ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁virt io _ blk _ data _ plane _ stop ( V irt IO Block Data Plane ▁* s ) ▁{ ▁if ▁(! s -> started ) ▁{ ▁return ; ▁} ▁s -> started ▁= ▁false ; ▁trace _ virt io _ blk _ data _ plane _ stop ( s ); ▁/* ▁Stop ▁thread ▁or ▁cancel ▁pending ▁thread ▁creation ▁B H ▁*/ ▁if ▁( s -> start _ b h ) ▁{ ▁qemu _ b h _ delete ( s -> start _ b h ); ▁s -> start _ b h ▁= ▁NULL ; ▁} ▁else ▁{ ▁event _ poll _ notify ( & s -> event _ poll ); ▁qemu _ thread _ join ( & s -> thread ); ▁} ▁io q _ cleanup ( & s -> io queue ); ▁s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ write _ tk hd _ tag ( AV IO Context ▁* pb , ▁MO VM ux Context ▁* mov , ▁MO V Track ▁* track , ▁AV Stream ▁* st ) ▁{ ▁int 64_ t ▁duration ▁= ▁av _ res cale _ r nd ( track -> track _ duration , ▁MO V _ TIME SCALE , ▁track -> times cale , ▁AV _ ROUND _ UP ); ▁int ▁version ▁= ▁duration ▁< ▁INT 32_ MAX ▁? ▁0 ▁: ▁1; ▁int ▁flags ▁= ▁MO V _ T K HD _ FLAG _ IN _ MO VI E ; ▁int ▁rotation ▁= ▁0; ▁int ▁group ▁= ▁0; ▁uint 32_ t ▁* display _ matrix ▁= ▁NULL ; ▁int ▁display _ matrix _ size , ▁i ; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v ob sub _ read _ seek ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁min _ ts , ▁int 64_ t ▁ts , ▁int 64_ t ▁max _ ts , ▁int ▁flags ) ▁{ ▁M peg Dem ux Context ▁* v ob sub ▁= ▁s -> priv _ data ; ▁/* ▁Res cale ▁requested ▁timestamps ▁based ▁on ▁the ▁first ▁stream ▁( time base ▁is ▁the ▁* ▁same ▁for ▁all ▁subtitles ▁stream ▁within ▁a ▁. idx /. sub ). ▁Res cal ing ▁is ▁done ▁just ▁* ▁like ▁in ▁av format _ seek _ file (). ▁*/ ▁if ▁( stream _ index ▁== ▁-1 ▁&& ▁s -> nb _ streams ▁!

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁a ac _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁A AC Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁ret ▁= ▁A VER ROR ( E IN VAL ); ▁AA CE NC _ Info Struct ▁info ▁= ▁{ ▁0 ▁}; ▁CHANNEL _ MODE ▁mode ; ▁AA CE NC _ ERROR ▁err ; ▁int ▁a ot ▁= ▁FF _ PROFILE _ A AC _ LOW ▁+ ▁1; ▁int ▁s ce ▁= ▁0, ▁c pe ▁= ▁0; ▁if ▁(( err ▁= ▁a ac Enc Open ( & s -> handle , ▁0, ▁av ctx -> channels )) ▁!= ▁AA CE NC _ OK ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Unable ▁to ▁open ▁the ▁encoder

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v orb is _ floor 1_ decode ( vor b is _ context ▁* vc , ▁v orb is _ floor _ data ▁* vf u , ▁float ▁* vec ) ▁{ ▁v orb is _ floor 1 ▁* vf ▁= ▁& vf u -> t 1; ▁Get Bit Context ▁* gb ▁= ▁& vc -> gb ; ▁uint 16_ t ▁range _ v [4] ▁= ▁{ ▁256 , ▁12 8, ▁8 6, ▁64 ▁}; ▁unsigned ▁range ▁= ▁range _ v [ vf -> multiplier ▁- ▁1 ]; ▁uint 16_ t ▁floor 1_ Y [ 258 ]; ▁uint 16_ t ▁floor 1_ Y _ final [ 258 ]; ▁int ▁floor 1_ flag [ 258 ]; ▁unsigned ▁class , ▁c dim , ▁cb its , ▁c sub , ▁cval , ▁offset , ▁i , ▁j ; ▁in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁col o _ process _ checkpoint ( Migration State ▁* s ) ▁{ ▁Q IO Channel Buffer ▁* bi oc ; ▁Q EM U File ▁* fb ▁= ▁NULL ; ▁int 64_ t ▁current _ time , ▁checkpoint _ time ▁= ▁qemu _ clock _ get _ ms ( Q EM U _ C LOCK _ HOST ); ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁failover _ init _ state (); ▁s -> rp _ state . from _ dst _ file ▁= ▁qemu _ file _ get _ return _ path ( s -> to _ dst _ file ); ▁if ▁(! s -> rp _ state . from _ dst _ file ) ▁{ ▁error _ report (" Open ▁Q EM U File ▁from _ dst

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ init 1( Q EM UM achine Init Args ▁* args , ▁int ▁pci _ enabled , ▁int ▁k vm clock _ enabled ) ▁{ ▁Memory Region ▁* system _ memory ▁= ▁get _ system _ memory (); ▁Memory Region ▁* system _ io ▁= ▁get _ system _ io (); ▁int ▁i ; ▁ram _ addr _ t ▁below _4 g _ mem _ size , ▁above _4 g _ mem _ size ; ▁P CI Bus ▁* pc i _ bus ; ▁IS AB us ▁* isa _ bus ; ▁P CI I 4 40 FX State ▁* i 4 40 fx _ state ; ▁int ▁pi ix 3_ dev fn ▁= ▁-1; ▁qemu _ irq ▁* cpu _ irq ; ▁qemu _ irq ▁* gs i ; ▁qemu _ irq ▁* i 8

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁wm 87 50 _ ad c _ dat ( void ▁* op aque ) ▁{ ▁W M 87 50 State ▁* s ▁= ▁( WM 87 50 State ▁* ) ▁opaque ; ▁uint 32_ t ▁* data ; ▁if ▁( s -> idx _ in ▁>= ▁sizeof ( s -> data _ in )) ▁wm 87 50 _ in _ load ( s ); ▁data ▁= ▁( uint 32_ t ▁* ) ▁& s -> data _ in [ s -> idx _ in ]; ▁s -> req _ in ▁-= ▁4; ▁s -> idx _ in ▁+= ▁4; ▁return ▁* data ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Q mp Input Visitor ▁* to _ q iv ( Visitor ▁* v ) ▁{ ▁return ▁container _ of ( v , ▁Q mp Input Visitor , ▁visitor ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 4 l 2_ read _ packet ( AV Format Context ▁* s 1, ▁AV Packet ▁* pk t ) ▁{ ▁# if ▁FF _ API _ CODE D _ FRAME ▁FF _ DIS ABLE _ DE PRE CATION _ WARNING S ▁struct ▁video _ data ▁* s ▁= ▁s 1 -> priv _ data ; ▁AV Frame ▁* frame ▁= ▁s 1 -> streams [0] -> codec -> coded _ frame ; ▁FF _ ENABLE _ DE PRE CATION _ WARNING S ▁# end if ▁int ▁res ; ▁av _ init _ packet ( pk t ); ▁if ▁(( res ▁= ▁mmap _ read _ frame ( s 1, ▁pkt )) ▁< ▁0) ▁{ ▁return ▁res ; ▁} ▁# if ▁FF _ API _ CODE D _ FRAME ▁FF _ DIS ABLE _ D

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b on ito _ pc i host _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁Sys Bus Device Class ▁* k ▁= ▁SY S _ B US _ DEVICE _ CLASS ( k lass ); ▁k -> init ▁= ▁b on ito _ pc i host _ init fn ; ▁dc -> no _ user ▁= ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mp 3_ parse _ v br _ tags ( AV Format Context ▁* s , ▁AV Stream ▁* st , ▁int 64_ t ▁base ) ▁{ ▁uint 32_ t ▁v , ▁sp f ; ▁MP AD ecode Header ▁c ; ▁int ▁v br tag _ size ▁= ▁0; ▁MP 3 Dec Context ▁* mp 3 ▁= ▁s -> priv _ data ; ▁ff io _ init _ checksum ( s -> pb , ▁ff _ crc A 00 1_ update , ▁0); ▁v ▁= ▁av io _ rb 32 ( s -> pb ); ▁if ( ff _ mp a _ check _ header ( v ) ▁< ▁0) ▁return ▁-1; ▁if ▁( av priv _ mpeg audio _ decode _ header ( & c , ▁v ) ▁== ▁0) ▁v br tag _ size ▁= ▁c . frame _ size ; ▁if (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁memory _ region _ iom mu _ re play _ all ( Memory Region ▁* mr ) ▁{ ▁IO MM U Notifier ▁* notifier ; ▁IO MM U _ NOT IFIER _ FORE A CH ( notifier , ▁mr ) ▁{ ▁memory _ region _ iom mu _ re play ( mr , ▁notifier , ▁false ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ u h ci _ pi ix 3_ init fn ( PC ID evice ▁* dev ) ▁{ ▁U H CI State ▁* s ▁= ▁DO _ UP CAST ( U H CI State , ▁dev , ▁dev ); ▁uint 8_ t ▁* pc i _ conf ▁= ▁s -> dev . config ; ▁pci _ config _ set _ vendor _ id ( pc i _ conf , ▁P CI _ VE ND OR _ ID _ INT EL ); ▁pci _ config _ set _ device _ id ( pc i _ conf , ▁P CI _ DEVICE _ ID _ INT EL _8 2 37 1 SB _2 ); ▁return ▁usb _ u h ci _ common _ init fn ( s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m peg ts _ write _ p mt ( AV Format Context ▁* s , ▁M peg TS Service ▁* service ) ▁{ ▁M peg TS Write ▁* ts ▁= ▁s -> priv _ data ; ▁uint 8_ t ▁data [1 01 2], ▁* q , ▁* desc _ length _ ptr , ▁* program _ info _ length _ ptr ; ▁int ▁val , ▁stream _ type , ▁i ; ▁q ▁= ▁data ; ▁put 16 ( & q , ▁0 xe 000 ▁| ▁service -> pc r _ pid ); ▁program _ info _ length _ ptr ▁= ▁q ; ▁q ▁+= ▁2; ▁/* ▁patched ▁after ▁*/ ▁/* ▁put ▁program ▁info ▁here ▁*/ ▁val ▁= ▁0 xf 000 ▁| ▁( q ▁- ▁program _ info _ length _ ptr 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁dec _ add i _ r ( Dis as Context ▁* dc ) ▁{ ▁TC G v ▁t 0; ▁DIS ( f printf ▁( log file , ▁" add i . % c ▁$ r % u , ▁$ r % u \ n ", ▁mem size _ char ( mem size _ zz ( dc )), ▁dc -> op 2, ▁dc -> op 1) ); ▁cr is _ cc _ mask ( dc , ▁0); ▁t 0 ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ TL ); ▁tc g _ gen _ sh l _ tl ( t 0, ▁cpu _ R [ dc -> op 2], ▁tc g _ const _ tl ( dc -> zz size )); ▁tc g _ gen _ add _ tl ( cpu _ R [ dc -> op 1], ▁cpu _ R [ dc -> op 1], ▁t 0); ▁tc g _ temp _ free ( t 0); ▁ret

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ tr ap ▁( Dis as Context ▁* ctx , ▁uint 32_ t ▁op c , ▁int ▁rs , ▁int ▁rt , ▁int 16_ t ▁imm ) ▁{ ▁int ▁cond ; ▁TC G v ▁t 0 ▁= ▁tc g _ temp _ new (); ▁TC G v ▁t 1 ▁= ▁tc g _ temp _ new (); ▁cond ▁= ▁0; ▁/* ▁Load ▁needed ▁operands ▁*/ ▁switch ▁( op c ) ▁{ ▁case ▁O PC _ TE Q : ▁case ▁O PC _ T GE : ▁case ▁O PC _ T GE U : ▁case ▁O PC _ T LT : ▁case ▁O PC _ T LT U : ▁case ▁O PC _ T NE : ▁/* ▁Compare ▁two ▁registers ▁*/ ▁if ▁( rs ▁!= ▁rt ) ▁{ ▁gen _ load _ g pr ( t 0, ▁rs ); ▁gen _ load _ g p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁p xa 2 xx _ gp io _ read ( void ▁* op aque , ▁hw addr ▁offset , ▁unsigned ▁size ) ▁{ ▁P XA 2 xx G PIO Info ▁* s ▁= ▁( P XA 2 xx G PIO Info ▁* ) ▁opaque ; ▁uint 32_ t ▁ret ; ▁int ▁bank ; ▁if ▁( offset ▁>= ▁0 x 200) ▁return ▁0; ▁bank ▁= ▁p xa 2 xx _ gp io _ re gs [ offset ]. bank ; ▁switch ▁( px a 2 xx _ gp io _ re gs [ offset ]. reg ) ▁{ ▁case ▁GP DR : ▁/* ▁GPIO ▁Pin - Direction ▁registers ▁*/ ▁return ▁s -> dir [ bank ]; ▁case ▁GPS R : ▁/* ▁GPIO ▁Pin - Output ▁Set ▁registers ▁*/ ▁qemu 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ip video _ decode _ block _ op code _0 xD ( Ipv ideo Context ▁* s , ▁AV Frame ▁* frame ) ▁{ ▁int ▁y ; ▁unsigned ▁char ▁P [2 ]; ▁/* ▁4- color ▁block ▁encoding : ▁each ▁4 x 4 ▁block ▁is ▁a ▁different ▁color ▁*/ ▁for ▁( y ▁= ▁0; ▁y ▁< ▁8 ; ▁y ++) ▁{ ▁if ▁(! ( y ▁& ▁3 )) ▁{ ▁P [0] ▁= ▁by test ream 2_ get _ byte ( & s -> stream _ ptr ); ▁P [1] ▁= ▁by test ream 2_ get _ byte ( & s -> stream _ ptr ); ▁mem set ( s -> pixel _ ptr , ▁P [0], ▁4 ); ▁mem set ( s -> pixel _ ptr ▁+ ▁4, ▁P [1], ▁4 ); ▁s -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁migration _ set _ rate _ limit ( void ▁* op aque , ▁int 64_ t ▁new _ rate ) ▁{ ▁Migration State ▁* s ▁= ▁opaque ; ▁if ▁( q emu _ file _ get _ error ( s -> file )) ▁{ ▁goto ▁out ; ▁} ▁s -> x fer _ limit ▁= ▁new _ rate ; ▁out : ▁return ▁s -> x fer _ limit ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁reverse _ matrix ing ( float ▁* su 1, ▁float ▁* su 2, ▁int ▁* prev _ code , ▁int ▁* curr _ code ) ▁{ ▁int ▁i , ▁ns ample , ▁band ; ▁float ▁mc 1_ l , ▁mc 1_ r , ▁mc 2_ l , ▁mc 2_ r ; ▁for ▁( i ▁= ▁0, ▁band ▁= ▁0; ▁band ▁< ▁4 ▁* ▁256 ; ▁band ▁+= ▁256 , ▁i ++) ▁{ ▁int ▁s 1 ▁= ▁prev _ code [ i ]; ▁int ▁s 2 ▁= ▁curr _ code [ i ]; ▁ns ample ▁= ▁0; ▁if ▁( s 1 ▁!= ▁s 2) ▁{ ▁/* ▁Selector ▁value ▁changed , ▁interpolation ▁needed . ▁*/ ▁mc 1_ l ▁= ▁matrix _ coeff s [ s 1 ▁* ▁2 ▁]; ▁mc 1_ r ▁= ▁matrix 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ disk _ reset ( Device State ▁* dev ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev . q dev , ▁dev ); ▁uint 64_ t ▁nb _ sect ors ; ▁sc si _ device _ pur ge _ requests ( & s -> q dev , ▁SE NSE _ CODE ( RE SET )); ▁b dr v _ get _ geometry ( s -> q dev . conf . bs , ▁& nb _ sect ors ); ▁nb _ sect ors ▁/= ▁s -> q dev . block size ▁/ ▁512 ; ▁if ▁( nb _ sect ors ) ▁{ ▁nb _ sect ors --; ▁} ▁s -> q dev . max _ l ba ▁= ▁nb _ sect ors ; ▁/* ▁reset ▁t ray ▁statuses ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ part _ of _ packet ( AV Format Context ▁* s , ▁int 64_ t ▁* pts , ▁int ▁* len , ▁int ▁* str id , ▁int ▁read _ packet ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁P VA Context ▁* pv act x ▁= ▁s -> priv _ data ; ▁int ▁sync word , ▁stream id , ▁reserved , ▁flags , ▁length , ▁pts _ flag ; ▁int 64_ t ▁p va _ pts ▁= ▁AV _ NO PT S _ VALUE , ▁start pos ; ▁int ▁ret ; ▁recover : ▁start pos ▁= ▁av io _ t ell ( pb ); ▁sync word ▁= ▁av io _ rb 16 ( pb ); ▁stream id ▁= ▁av io _ r 8 ( pb ); ▁av io _ r 8

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pred 8 x 8_ top _ dc _ rv 40 _ c ( uint 8_ t ▁* src , ▁int ▁stride ){ ▁int ▁i ; ▁int ▁dc 0; ▁dc 0 =0; ▁for ( i =0; i < 8 ; ▁i ++) ▁dc 0 += ▁src [ i - stride ]; ▁dc 0 = ▁0 x 0101 0101 * (( dc 0 ▁+ ▁4) >> 3); ▁for ( i =0; ▁i < 8 ; ▁i ++){ ▁(( uint 32_ t * )( src + i * stride )) [0] = ▁(( uint 32_ t * )( src + i * stride )) [1] = ▁dc 0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ cc w _ set _ v qs ( Sub ch Dev ▁* sch , ▁uint 64_ t ▁addr , ▁uint 32_ t ▁align , ▁uint 16_ t ▁index , ▁uint 16_ t ▁num ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁virt io _ cc w _ get _ v dev ( sch ); ▁if ▁( index ▁>= ▁VI RT IO _ PC I _ QUEUE _ MAX ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁/* ▁Current ▁code ▁in ▁virt io . c ▁relies ▁on ▁4 K ▁alignment . ▁*/ ▁if ▁( addr ▁&& ▁( align ▁!= ▁4096 )) ▁{ ▁return ▁- E IN VAL ; ▁} ▁if ▁(! v dev ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁virt io _ queue _ set _ addr ( v de

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt l 81 39 _ receive ( void ▁* op aque , ▁const ▁uint 8_ t ▁* buf , ▁size _ t ▁size ) ▁{ ▁rt l 81 39 _ do _ receive ( op aque , ▁buf , ▁size , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ ch own ( Fs Context ▁* fs _ ctx , ▁V 9 fs Path ▁* fs _ path , ▁Fs Cred ▁* cre dp ) ▁{ ▁char ▁buffer [ PATH _ MAX ]; ▁char ▁* path ▁= ▁fs _ path -> data ; ▁if ▁(( cre dp -> fc _ uid ▁== ▁-1 ▁&& ▁cred p -> fc _ gid ▁== ▁-1) ▁|| ▁( fs _ ctx -> export _ flags ▁& ▁V 9 FS _ SM _ P AS ST H RO UG H ) ▁|| ▁( fs _ ctx -> export _ flags ▁& ▁V 9 FS _ SM _ NONE )) ▁{ ▁return ▁l ch own ( r path ( fs _ ctx , ▁path , ▁buffer ), ▁cred p -> fc _ uid , ▁cred p -> fc _ gid ); ▁} ▁else ▁if ▁( fs _ ctx ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q dict _ cr um ple _ test _ recursive ( void ) ▁{ ▁Q Dict ▁* src , ▁* dst , ▁* rule , ▁* vn c , ▁* acl , ▁* listen ; ▁Q Object ▁* child , ▁* res ; ▁Q List ▁* rules ; ▁src ▁= ▁q dict _ new (); ▁q dict _ put ( src , ▁" vn c . listen . addr ", ▁q string _ from _ str (" 127.0.0.1 ")); ▁q dict _ put ( src , ▁" vn c . listen . port ", ▁q string _ from _ str (" 59 01 ")); ▁q dict _ put ( src , ▁" vn c . acl . rules .0. match ", ▁q string _ from _ str (" f red ")); ▁q dict _ put ( src , ▁" vn c . a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ validate _ fail _ altern ate ( Test Input Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁User Def Altern ate ▁* tmp ; ▁Visitor ▁* v ; ▁Error ▁* err ▁= ▁NULL ; ▁v ▁= ▁validate _ test _ init ( data , ▁" 3.1 4 "); ▁visit _ type _ User Def Altern ate ( v , ▁NULL , ▁& tmp , ▁& err ); ▁error _ free _ or _ abort ( & err ); ▁q api _ free _ User Def Altern ate ( tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ co _ flush ( Block Driver State ▁* bs ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁ret ; ▁qemu _ co _ mut ex _ lock ( & s -> lock ); ▁ret ▁= ▁qc ow 2_ cache _ flush ( bs , ▁s -> l 2_ table _ cache ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁ret ▁= ▁qc ow 2_ cache _ flush ( bs , ▁s -> refcount _ block _ cache ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁return ▁b dr v _ co _ flush ( bs -> file ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vc 1_ init _ common ( VC 1 Context ▁* v ) ▁{ ▁static ▁int ▁done ▁= ▁0; ▁int ▁i ▁= ▁0; ▁v -> h rd _ rate ▁= ▁v -> h rd _ buffer ▁= ▁NULL ; ▁/* ▁V LC ▁tables ▁*/ ▁if (! done ) ▁{ ▁done ▁= ▁1; ▁init _ vlc ( & ff _ vc 1_ bf raction _ vlc , ▁VC 1_ BF RA CTION _ V LC _ BITS , ▁23, ▁ff _ vc 1_ bf raction _ bits , ▁1, ▁1, ▁ff _ vc 1_ bf raction _ codes , ▁1, ▁1, ▁INIT _ V LC _ USE _ STATIC ); ▁init _ vlc ( & ff _ vc 1_ norm 2_ vlc , ▁VC 1_ N ORM 2_ V LC _ BITS , ▁4, ▁ff _ vc 1_ norm 2_ bits , ▁1, ▁1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret , ▁i ; ▁AV Stream ▁* st ; ▁for ( ; ; ){ ▁AV Packet List ▁* pk tl ▁= ▁s -> raw _ packet _ buffer ; ▁if ▁( pk tl ) ▁{ ▁* pk t ▁= ▁pk tl -> pk t ; ▁if ( s -> streams [ pk t -> stream _ index ] -> codec -> codec _ id ▁!= ▁CODE C _ ID _ PRO BE ▁|| ▁! s -> streams [ pk t -> stream _ index ] -> pro be _ pack ets ▁|| ▁s -> raw _ packet _ buffer _ remaining _ size ▁< ▁pkt -> size ){ ▁AV Probe Data ▁* pd ▁= ▁& s -> streams [ pk t 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ can _ accept ( void ) ▁{ ▁return ▁nb _ fds ▁< ▁shared ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ connect ( struct ▁X en Device ▁* x end ev ) ▁{ ▁struct ▁X en Net Dev ▁* net dev ▁= ▁container _ of ( x end ev , ▁struct ▁X en Net Dev , ▁x end ev ); ▁int ▁rx _ copy ; ▁if ▁( x en store _ read _ fe _ int ( & net dev -> x end ev , ▁" tx - ring - ref ", ▁& net dev -> tx _ ring _ ref ) ▁== ▁-1) ▁{ ▁return ▁-1; ▁} ▁if ▁( x en store _ read _ fe _ int ( & net dev -> x end ev , ▁" rx - ring - ref ", ▁& net dev -> rx _ ring _ ref ) ▁== ▁-1) ▁{ ▁return ▁1; ▁} ▁if ▁( x en store _ read _ fe _ int 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁do _ modify _ soft int ( CP US PAR C State ▁* env , ▁uint 32_ t ▁value ) ▁{ ▁if ▁( env -> soft int ▁!= ▁value ) ▁{ ▁env -> soft int ▁= ▁value ; ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁if ▁( cpu _ interrupt s _ enabled ( env )) ▁{ ▁cpu _ check _ ir qs ( env ); ▁} ▁# end if ▁return ▁true ; ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode T onal Components ▁( Get Bit Context ▁* gb , ▁t onal _ component ▁* p Component , ▁int ▁num B ands ) ▁{ ▁int ▁i , j , k , cnt ; ▁int ▁components , ▁coding _ mode _ selector , ▁coding _ mode , ▁coded _ values _ per _ component ; ▁int ▁sf Ind x , ▁coded _ values , ▁max _ coded _ values , ▁quant _ step _ index , ▁coded _ components ; ▁int ▁band _ flags [4 ], ▁mant issa [ 8 ]; ▁float ▁* p Co ef ; ▁float ▁scal ef actor ; ▁int ▁component _ count ▁= ▁0; ▁components ▁= ▁get _ bits ( gb , 5 );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ send _ key ( const ▁char ▁* string ) ▁{ ▁char ▁key buf [ 16 ], ▁* q ; ▁uint 8_ t ▁key codes [ 16 ]; ▁const ▁char ▁* p ; ▁int ▁nb _ key codes , ▁keycode , ▁i ; ▁nb _ key codes ▁= ▁0; ▁p ▁= ▁string ; ▁while ▁(* p ▁!= ▁'\ 0 ') ▁{ ▁q ▁= ▁key buf ; ▁while ▁(* p ▁!= ▁'\ 0' ▁&& ▁* p ▁!= ▁'- ') ▁{ ▁if ▁(( q ▁- ▁key buf ) ▁< ▁sizeof ( key buf ) ▁- ▁1) ▁{ ▁* q ++ ▁= ▁* p ; ▁} ▁p ++; ▁} ▁* q ▁= ▁'\ 0 '; ▁keycode ▁= ▁get _ key code ( key buf ); ▁if ▁( key code ▁< ▁0) ▁{ ▁term _ printf (" unknown ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ migrate _ set _ speed ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict , ▁Q Object ▁** ret _ data ) ▁{ ▁double ▁d ; ▁char ▁* ptr ; ▁F d Migration State ▁* s ; ▁const ▁char ▁* value ▁= ▁q dict _ get _ str ( q dict , ▁" value "); ▁d ▁= ▁str tod ( value , ▁& ptr ); ▁switch ▁(* ptr ) ▁{ ▁case ▁' G ': ▁case ▁' g ': ▁d ▁*= ▁1024 ; ▁case ▁' M ': ▁case ▁' m ': ▁d ▁*= ▁1024 ; ▁case ▁' K ': ▁case ▁' k ': ▁d ▁*= ▁1024 ; ▁default : ▁break ; ▁} ▁max _ th rottle ▁= ▁( uint 32_ t ) d ; ▁s ▁= ▁migrate _ to _ f ms 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ ef dn eg ( Dis as Context ▁* ctx ) ▁{ ▁if ▁( un likely (! ctx -> s pe _ enabled )) ▁{ ▁gen _ exception ( ctx , ▁PO WER PC _ EX CP _ AP U ); ▁return ; ▁} ▁# if ▁defined ( TARGET _ P PC 64) ▁tc g _ gen _ xor i _ tl ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ g pr [ r A ( ctx -> op code )], ▁0 x 8 00000000 0000000 LL ); ▁# else ▁tc g _ gen _ mov _ tl ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ g pr [ r A ( ctx -> op code ) ]); ▁tc g _ gen _ xor i _ tl ( cpu _ g pr h [ r D (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ s rl q ( Dis as Context ▁* ctx ) ▁{ ▁int ▁l 1 ▁= ▁gen _ new _ label (); ▁int ▁l 2 ▁= ▁gen _ new _ label (); ▁TC G v ▁t 0 ▁= ▁tc g _ temp _ local _ new (); ▁TC G v ▁t 1 ▁= ▁tc g _ temp _ local _ new (); ▁TC G v ▁t 2 ▁= ▁tc g _ temp _ local _ new (); ▁tc g _ gen _ and i _ tl ( t 2, ▁cpu _ g pr [ r B ( ctx -> op code )], ▁0 x 1 F ); ▁tc g _ gen _ mov i _ tl ( t 1, ▁0 xFFFFFFFF ); ▁tc g _ gen _ sh r _ tl ( t 2, ▁t 1, ▁t 2); ▁tc g _ gen _ and i _ tl ( t 0, ▁cpu _ g pr [ r B ( ctx -> op cod

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁size _ t ▁send _ control _ msg ( V irt IO Serial ▁* v ser , ▁void ▁* buf , ▁size _ t ▁len ) ▁{ ▁V irt Queue Element ▁elem ; ▁V irt Queue ▁* v q ; ▁v q ▁= ▁v ser -> c _ iv q ; ▁if ▁(! virt io _ queue _ ready ( v q )) ▁{ ▁return ▁0; ▁} ▁if ▁(! virt queue _ pop ( v q , ▁& elem )) ▁{ ▁return ▁0; ▁} ▁/* ▁TODO : ▁detect ▁a ▁buffer ▁that ' s ▁too ▁short , ▁set ▁NEED S _ RE SET ▁*/ ▁i ov _ from _ buf ( elem . in _ sg , ▁elem . in _ num , ▁0, ▁buf , ▁len ); ▁virt queue _ push ( v q , ▁& elem , ▁len ); ▁vi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁i ch 9_ pm _ init ( PC ID evice ▁* l pc _ pc i , ▁I CH 9 LP CP M Re gs ▁* pm , ▁qemu _ irq ▁sc i _ irq ) ▁{ ▁memory _ region _ init ( & pm -> io , ▁OBJECT ( l pc _ pc i ), ▁" ich 9 - pm ", ▁I CH 9_ PM IO _ SIZE ); ▁memory _ region _ set _ enabled ( & pm -> io , ▁false ); ▁memory _ region _ add _ sub region ( pc i _ address _ space _ io ( l pc _ pc i ), ▁0, ▁& pm -> io ); ▁ac pi _ pm _ tm r _ init ( & pm -> ac pi _ re gs , ▁i ch 9_ pm _ update _ sc i _ fn , ▁& pm -> io ); ▁ac pi _ pm 1_ evt _ init (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁o map _ bad width _ read 8 ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁uint 8_ t ▁ret ; ▁O MAP _8 B _ REG ( addr ); ▁cpu _ ph ysical _ memory _ read ( addr , ▁( void ▁* ) ▁& ret , ▁1); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁IR Q _ set bit ( IR Q _ queue _ t ▁* q , ▁int ▁n _ IR Q ) ▁{ ▁q -> pending ++; ▁set _ bit ( q -> queue , ▁n _ IR Q ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mat ro sk a _ decode _ buffer ( uint 8_ t ** ▁buf , ▁int * ▁buf _ size , ▁Mat ro sk a Track ▁* track ) ▁{ ▁Mat ro sk a Track Encoding ▁* encod ings ▁= ▁track -> encod ings . elem ; ▁uint 8_ t * ▁data ▁= ▁* buf ; ▁int ▁is ize ▁= ▁* buf _ size ; ▁uint 8_ t * ▁pkt _ data ▁= ▁NULL ; ▁int ▁pkt _ size ▁= ▁is ize ; ▁int ▁result ▁= ▁0; ▁int ▁o len ; ▁if ▁( pk t _ size ▁>= ▁10000 000) ▁return ▁-1; ▁switch ▁( encod ings [0]. compression . al go ) ▁{ ▁case ▁MAT RO SK A _ TRA CK _ ENCODING _ COMP _ HEAD

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ac 3_ extract _ exponent s _ c ( uint 8_ t ▁* exp , ▁int 32_ t ▁* coef , ▁int ▁nb _ co efs ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁nb _ co efs ; ▁i ++) ▁{ ▁int ▁e ; ▁int ▁v ▁= ▁abs ( coef [ i ]); ▁if ▁( v ▁== ▁0) ▁e ▁= ▁24 ; ▁else ▁{ ▁e ▁= ▁23 ▁- ▁av _ log 2( v ); ▁if ▁( e ▁>= ▁24 ) ▁{ ▁e ▁= ▁24 ; ▁coef [ i ] ▁= ▁0; ▁} ▁av _ assert 2( e ▁>= ▁0); ▁} ▁exp [ i ] ▁= ▁e ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v host _ log _ stop ( Memory Listener ▁* listener , ▁Memory Region Section ▁* section ) ▁{ ▁/* ▁FIX ME : ▁implement ▁*/ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ hot plug _ req _ event ( s P AP R DR Connector ▁* d rc , ▁uint 8_ t ▁hp _ action ) ▁{ ▁struct ▁hp _ log _ full ▁* new _ hp ; ▁struct ▁rt as _ error _ log ▁* hdr ; ▁struct ▁rt as _ event _ log _ v 6 ▁* v 6 hdr ; ▁struct ▁rt as _ event _ log _ v 6_ main a ▁* main a ; ▁struct ▁rt as _ event _ log _ v 6_ main b ▁* main b ; ▁struct ▁rt as _ event _ log _ v 6_ hp ▁* hp ; ▁s P AP R DR Connector Class ▁* dr ck ▁= ▁SP AP R _ DR _ CONNECT OR _ GET _ CLASS ( d rc ); ▁s P AP R DR Connector Ty

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁TC G Reg ▁tc g _ out _ tl b _ load ( TC G Context ▁* s , ▁TC G Reg ▁addr , ▁int ▁mem _ index , ▁TC G Mem Op ▁s _ bits , ▁int ▁which ) ▁{ ▁const ▁TC G Reg ▁r 0 ▁= ▁TC G _ REG _ O 0; ▁const ▁TC G Reg ▁r 1 ▁= ▁TC G _ REG _ O 1; ▁const ▁TC G Reg ▁r 2 ▁= ▁TC G _ REG _ O 2; ▁int ▁tl b _ of s ; ▁/* ▁Shift ▁the ▁page ▁number ▁down . ▁*/ ▁tc g _ out _ ar ith i ( s , ▁r 1, ▁addr , ▁TARGET _ PAGE _ BITS , ▁SH IFT _ S RL ); ▁/* ▁Mask ▁out ▁the ▁page ▁offset , ▁except ▁for ▁the ▁required ▁alignment . ▁*/ ▁tc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁curl _ sock _ cb ( C URL ▁* curl , ▁curl _ socket _ t ▁fd , ▁int ▁action , ▁void ▁* s , ▁void ▁* sp ) ▁{ ▁D PRI NT F (" C URL ▁( A IO ): ▁S ock ▁action ▁% d ▁on ▁fd ▁% d \ n ", ▁action , ▁fd ); ▁switch ▁( action ) ▁{ ▁case ▁C URL _ P OLL _ IN : ▁qemu _ a io _ set _ fd _ handler ( fd , ▁curl _ multi _ do , ▁NULL , ▁s ); ▁break ; ▁case ▁C URL _ P OLL _ OUT : ▁qemu _ a io _ set _ fd _ handler ( fd , ▁NULL , ▁curl _ multi _ do , ▁s ); ▁break ; ▁case ▁C URL _ P OLL _ IN OUT : ▁qemu _ a io _ set _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Sw s Func ▁y uv 2 rgb _ get _ func _ ptr ▁( Sw s Context ▁* c ) ▁{ ▁# if ▁defined ( HA VE _ MM X 2) ▁|| ▁defined ( HA VE _ MM X ) ▁if ( c -> flags ▁& ▁S WS _ CPU _ CAP S _ MM X 2 ){ ▁switch ( c -> dst Format ){ ▁case ▁PI X _ F MT _ RGB 32 : ▁return ▁y uv 4 20 _ rgb 32_ MM X 2; ▁case ▁PI X _ F MT _ B GR 24 : ▁return ▁y uv 4 20 _ rgb 24 _ MM X 2; ▁case ▁PI X _ F MT _ B GR 56 5: ▁return ▁y uv 4 20 _ rgb 16_ MM X 2; ▁case ▁PI X _ F MT _ B GR 555 : ▁return ▁y uv 4 20 _ rgb 15 _ MM X 2; ▁} ▁} ▁if ( c -> flags 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ set _ share _ mode ( V nc State ▁* vs , ▁V nc Share Mode ▁mode ) ▁{ ▁# if def ▁_ V NC _ DEBUG ▁static ▁const ▁char ▁* mn [] ▁= ▁{ ▁[0] ▁= ▁" undefined ", ▁[ V NC _ SHA RE _ MODE _ CONNECT ING ] ▁= ▁" connect ing ", ▁[ V NC _ SHA RE _ MODE _ SHA RED ] ▁= ▁" shared ", ▁[ V NC _ SHA RE _ MODE _ EX CLUSIVE ] ▁= ▁" exclusive ", ▁[ V NC _ SHA RE _ MODE _ DIS CONNECTED ] ▁= ▁" dis connected ", ▁}; ▁f printf ( stderr , ▁"% s /% d : ▁% s ▁-> ▁% s \ n ", ▁__ func __, ▁vs -> cs ock , ▁mn [ vs -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 8_ t ▁ff _ ml p _ calculate _ par ity ( const ▁uint 8_ t ▁* buf , ▁unsigned ▁int ▁buf _ size ) ▁{ ▁uint 32_ t ▁scratch ▁= ▁0; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf ▁+ ▁buf _ size ; ▁for ▁( ; ▁buf ▁< ▁buf _ end ▁- ▁3; ▁buf ▁+= ▁4) ▁scratch ▁^= ▁* (( const ▁uint 32_ t *) buf ); ▁scratch ▁= ▁xor _ 32_ to _8 ( scr atch ); ▁for ▁( ; ▁buf ▁< ▁buf _ end ; ▁buf ++) ▁return ▁scratch ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ er _ frame _ start ( ER Context ▁* s ) ▁{ ▁if ▁(! s -> av ctx -> err _ rec ognition ) ▁return ; ▁mem set ( s -> error _ status _ table , ▁ER _ MB _ ERROR ▁| ▁V P _ START ▁| ▁ER _ MB _ END , ▁s -> mb _ stride ▁* ▁s -> mb _ height ▁* ▁sizeof ( uint 8_ t )); ▁s -> error _ count ▁= ▁3 ▁* ▁s -> mb _ num ; ▁s -> error _ occ urred ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁MP V _ common _ init ( M peg Enc Context ▁* s ) ▁{ ▁int ▁y _ size , ▁c _ size , ▁y c _ size , ▁i , ▁mb _ array _ size , ▁mv _ table _ size , ▁x , ▁y , ▁threads ; ▁if ( s -> codec _ id ▁== ▁CODE C _ ID _ M PEG 2 VI DEO ▁&& ▁! s -> progress ive _ sequence ) ▁s -> mb _ height ▁= ▁( s -> height ▁+ ▁3 1) ▁/ ▁32 ▁* ▁2; ▁else ▁if ▁( s -> codec _ id ▁!= ▁CODE C _ ID _ H 2 64) ▁s -> mb _ height ▁= ▁( s -> height ▁+ ▁15 ) ▁/ ▁16 ; ▁if ( s -> av ctx -> pix _ fmt ▁== ▁PI X _ F MT _ NONE ){ ▁av _ log

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ pro be _ input _ buffer ( AV IO Context ▁* pb , ▁AV InputFormat ▁** fmt , ▁const ▁char ▁* filename , ▁void ▁* log ctx , ▁unsigned ▁int ▁offset , ▁unsigned ▁int ▁max _ pro be _ size ) ▁{ ▁AV Probe Data ▁pd ▁= ▁{ ▁filename ▁? ▁filename ▁: ▁"", ▁NULL , ▁- offset ▁}; ▁unsigned ▁char ▁* buf ▁= ▁NULL ; ▁int ▁ret ▁= ▁0, ▁probe _ size ; ▁if ▁(! max _ pro be _ size ) ▁{ ▁max _ pro be _ size ▁= ▁PRO BE _ BU F _ MAX ; ▁} ▁else ▁if ▁( max _ pro be _ size ▁> ▁PRO BE _ BU F _ MAX ) ▁{ ▁max _ pro be _ size ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sl ir p _ s mb ( Sl ir p State * ▁s , ▁Monitor ▁* mon , ▁const ▁char ▁* export ed _ dir , ▁struct ▁in _ addr ▁vserver _ addr ) ▁{ ▁static ▁int ▁instance ; ▁char ▁smb _ conf [ 128 ]; ▁char ▁smb _ cmdline [ 128 ]; ▁FILE ▁* f ; ▁sn printf ( s -> s mb _ dir , ▁sizeof ( s -> s mb _ dir ), ▁"/ tmp / q emu - s mb . % ld -% d ", ▁( long ) get pid (), ▁instance ++ ); ▁if ▁( mkdir ( s -> s mb _ dir , ▁07 00) ▁< ▁0) ▁{ ▁config _ error ( mon , ▁" could ▁not ▁create ▁s amb a ▁server ▁dir ▁'% s '\ n ", ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ set _ page ( CPU State ▁* env , ▁target _ ulong ▁v addr , ▁target _ ph ys _ addr _ t ▁p addr , ▁int ▁prot , ▁int ▁mm u _ idx , ▁target _ ulong ▁size ) ▁{ ▁Ph ys Page Desc ▁* p ; ▁unsigned ▁long ▁pd ; ▁unsigned ▁int ▁index ; ▁target _ ulong ▁address ; ▁target _ ulong ▁code _ address ; ▁unsigned ▁long ▁add end ; ▁C PUT LB Entry ▁* te ; ▁CPU Watch point ▁* wp ; ▁target _ ph ys _ addr _ t ▁i ot lb ; ▁assert ( size ▁>= ▁TARGET _ PAGE _ SIZE ); ▁if ▁( size ▁!= ▁TARGET _ PAGE _ SIZE ) ▁{ ▁tl b _ ad

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* s la v io _ int ctl _ init ( target _ ph ys _ addr _ t ▁addr , ▁target _ ph ys _ addr _ t ▁addr g , ▁const ▁uint 32_ t ▁* int bit _ to _ level , ▁qemu _ irq ▁** irq , ▁qemu _ irq ▁** cpu _ irq , ▁unsigned ▁int ▁c put imer ) ▁{ ▁int ▁sla v io _ int ctl _ io _ memory , ▁sla v io _ int ctl m _ io _ memory , ▁i ; ▁S LA V IO _ INT CT L State ▁* s ; ▁s ▁= ▁qemu _ m alloc z ( size of ( S LA V IO _ INT CT L State )); ▁if ▁(! s ) ▁return ▁NULL ; ▁s -> int bit _ to _ level ▁= ▁int bit _ to _ level ; ▁for ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ fr nd int ( void ) ▁{ ▁ST 0 ▁= ▁r int ( ST 0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁start _ children ( FF Stream ▁* feed ) ▁{ ▁if ▁( no _ launch ) ▁return ; ▁for ▁( ; ▁feed ; ▁feed ▁= ▁feed -> next ) ▁{ ▁if ▁( feed -> child _ argv ▁&& ▁! feed -> pid ) ▁{ ▁feed -> pid _ start ▁= ▁time (0); ▁feed -> pid ▁= ▁fork (); ▁if ▁( feed -> pid ▁< ▁0) ▁{ ▁http _ log (" Unable ▁to ▁create ▁children \ n "); ▁exit (1); ▁} ▁if ▁(! feed -> pid ) ▁{ ▁/* ▁In ▁child ▁*/ ▁char ▁pathname [10 24 ]; ▁char ▁* slash ; ▁int ▁i ; ▁av _ str lc py ( pathname , ▁my _ program _ name , ▁sizeof ( pathname 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ seek _ fragment ( AV Format Context ▁* s , ▁AV Stream ▁* st , ▁int 64_ t ▁timestamp ) ▁{ ▁MO V Context ▁* mov ▁= ▁s -> priv _ data ; ▁int ▁i , ▁j ; ▁if ▁(! mov -> fragment _ index _ complete ) ▁return ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁mov -> fragment _ index _ count ; ▁i ++) ▁{ ▁if ▁( mov -> fragment _ index _ data [ i ] -> track _ id ▁== ▁st -> id ) ▁{ ▁MO V Fragment Index ▁* index ▁= ▁index ▁= ▁mov -> fragment _ index _ data [ i ]; ▁for ▁( j ▁= ▁index -> item _ count ▁- ▁1; ▁j ▁>= ▁0; ▁j -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ read _ track ( MX F Track ▁* track , ▁Byte IO Context ▁* pb , ▁int ▁tag ) ▁{ ▁switch ( tag ) ▁{ ▁case ▁0 x 48 01 : ▁track -> track _ id ▁= ▁get _ be 32 ( pb ); ▁break ; ▁case ▁0 x 4 80 4: ▁get _ buffer ( pb , ▁track -> track _ number , ▁4 ); ▁break ; ▁case ▁0 x 4 B 01 : ▁track -> edit _ rate . den ▁= ▁get _ be 32 ( pb ); ▁track -> edit _ rate . num ▁= ▁get _ be 32 ( pb ); ▁break ; ▁case ▁0 x 4 80 3: ▁get _ buffer ( pb , ▁track -> sequence _ ref , ▁16 ); ▁break ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ w ms _ parse _ sd p _ a _ line ( AV Format Context ▁* s , ▁const ▁char ▁* p ) ▁{ ▁int ▁ret ▁= ▁0; ▁if ▁( av _ str start ( p , ▁" pg mp u : data : application / v nd . ms . w ms - hdr . as fv 1; base 64, ", ▁& p )) ▁{ ▁AV IO Context ▁pb ; ▁RT SP State ▁* rt ▁= ▁s -> priv _ data ; ▁AV Dictionary ▁* opts ▁= ▁NULL ; ▁int ▁len ▁= ▁str len ( p ) ▁* ▁6 ▁/ ▁8 ; ▁char ▁* buf ▁= ▁av _ m alloc z ( len ); ▁AV InputFormat ▁* iform at ; ▁if ▁(! buf ) ▁return ▁A VER ROR ( EN O ME M ); ▁av _ base 64_ decode ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ra 14 4_ encode _ frame ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* frame , ▁int ▁buf _ size , ▁void ▁* data ) ▁{ ▁static ▁const ▁uint 8_ t ▁sizes [ L PC _ ORDER ] ▁= ▁{ 64, ▁32, ▁32, ▁16, ▁16, ▁8, ▁8, ▁8, ▁8, ▁4 }; ▁static ▁const ▁uint 8_ t ▁bit _ sizes [ L PC _ ORDER ] ▁= ▁{ 6, ▁5, ▁5, ▁4, ▁4, ▁3, ▁3, ▁3, ▁3, ▁2 }; ▁RA 144 Context ▁* ract x ; ▁Put Bit Context ▁pb ; ▁int 32_ t ▁l pc _ data [ N BLOCK S ▁* ▁BLOCKSIZE ]; ▁int 32_ t ▁l pc _ co efs [ L PC _ ORDER ][ MAX _ L PC _ ORDER ]; ▁int ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode 0( Get Byte Context ▁* gb , ▁Range Coder ▁* rc , ▁unsigned ▁cum Freq , ▁unsigned ▁freq , ▁unsigned ▁total _ freq ) ▁{ ▁int ▁t ▁= ▁rc -> range ▁* ▁( uint 64_ t ) cum Freq ▁/ ▁total _ freq ; ▁rc -> code 1 ▁+= ▁t ▁+ ▁1; ▁rc -> range ▁= ▁rc -> range ▁* ▁( uint 64_ t )( freq ▁+ ▁cum Freq ) ▁/ ▁total _ freq ▁- ▁( t ▁+ ▁1); ▁while ▁( rc -> range ▁< ▁TOP ▁&& ▁by test ream 2_ get _ bytes _ left ( gb ) ▁> ▁0) ▁{ ▁unsigned ▁byte ▁= ▁by test ream 2_ get _ byte ( gb ); ▁rc -> code ▁= ▁( rc -> cod

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dm g _ open ( Block Driver State ▁* bs , ▁const ▁char ▁* filename , ▁int ▁flags ) ▁{ ▁B DR VD M G State ▁* s ▁= ▁bs -> op aque ; ▁off _ t ▁info _ begin , info _ end , last _ in _ offset , last _ out _ offset ; ▁uint 32_ t ▁count ; ▁uint 32_ t ▁max _ compressed _ size =1, max _ sect ors _ per _ chunk =1, i ; ▁int 64_ t ▁offset ; ▁s -> fd ▁= ▁open ( filename , ▁O _ RD ONLY ▁| ▁O _ BINARY ); ▁if ▁( s -> fd ▁< ▁0) ▁return ▁- err no ; ▁bs -> read _ only ▁= ▁1; ▁s -> n _ chunks ▁= ▁0; ▁s -> offset

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁net _ rx _ pk t _ is _ vlan _ stri pped ( struct ▁Net Rx P kt ▁* pk t ) ▁{ ▁assert ( pk t ); ▁return ▁pkt -> vlan _ stri pped ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Visitor ▁* validate _ test _ init _ raw ( Test Input Visitor Data ▁* data , ▁const ▁char ▁* json _ string ) ▁{ ▁Visitor ▁* v ; ▁data -> obj ▁= ▁q object _ from _ json ( json _ string ); ▁g _ assert ( data -> obj ▁!= ▁NULL ); ▁data -> q iv ▁= ▁q mp _ input _ visitor _ new _ strict ( data -> obj ); ▁g _ assert ( data -> q iv ▁!= ▁NULL ); ▁v ▁= ▁q mp _ input _ get _ visitor ( data -> q iv ); ▁g _ assert ( v ▁!= ▁NULL ); ▁return ▁v ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁connect _ named socket ( const ▁char ▁* path ) ▁{ ▁int ▁sock fd , ▁size ; ▁struct ▁sock addr _ un ▁helper ; ▁sock fd ▁= ▁socket ( AF _ UN IX , ▁SOCK _ STREAM , ▁0); ▁if ▁( sock fd ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" socket ▁% s \ n ", ▁strerror ( err no )); ▁return ▁-1; ▁} ▁str c py ( helper . sun _ path , ▁path ); ▁helper . sun _ family ▁= ▁AF _ UN IX ; ▁size ▁= ▁str len ( helper . sun _ path ) ▁+ ▁sizeof ( helper . sun _ family ); ▁if ▁( connect ( sock fd , ▁( struct ▁sock addr ▁* ) & helper

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ mem _ writ el ( void ▁* ptr , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁E H CI State ▁* s ▁= ▁ptr ; ▁uint 32_ t ▁* mm io ▁= ▁( uint 32_ t ▁* )( & s -> mm io [ addr ]); ▁uint 32_ t ▁old ▁= ▁* mm io ; ▁int ▁i ; ▁trace _ usb _ eh ci _ mm io _ writ el ( addr , ▁addr 2 str ( addr ), ▁val ); ▁/* ▁Only ▁aligned ▁reads ▁are ▁allowed ▁on ▁O H CI ▁*/ ▁if ▁( addr ▁& ▁3) ▁{ ▁f printf ( stderr , ▁" usb - eh ci : ▁M is - aligned ▁write ▁to ▁addr ▁0 x " ▁TARGET _ F MT _ pl x ▁"\ n 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁dn x hd _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁DN X H DE nc Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁int ▁i , ▁index , ▁bit _ depth , ▁ret ; ▁switch ▁( av ctx -> pix _ fmt ) ▁{ ▁case ▁AV _ PI X _ F MT _ Y UV 4 22 P : ▁bit _ depth ▁= ▁8 ; ▁break ; ▁case ▁AV _ PI X _ F MT _ Y UV 4 22 P 10 : ▁bit _ depth ▁= ▁10; ▁break ; ▁default : ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" pixel ▁format ▁is ▁incompatible ▁with ▁DN x HD \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁ct

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vc 1_ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size , ▁n _ slices ▁= ▁0, ▁i ; ▁VC 1 Context ▁* v ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& v -> s ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁uint 8_ t ▁* buf 2 ▁= ▁NULL ; ▁const ▁uint 8_ t ▁* buf _ start ▁= ▁buf , ▁* buf _ start _ second _ field ▁= ▁NULL ; ▁int ▁mb _ height , ▁n _ slices 1= -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁blk _ apply _ root _ state ( Block Backend ▁* blk , ▁Block Driver State ▁* bs ) ▁{ ▁bs -> detect _ zero es ▁= ▁blk -> root _ state . detect _ zero es ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁v card _ em ul _ mirror _ card ( V Reader ▁* v reader ) ▁{ ▁/* ▁* ▁lookup ▁certs ▁using ▁the ▁C _ Find Objects . ▁The ▁St an ▁Cert ▁handle ▁won ' t ▁give ▁* ▁us ▁the ▁real ▁certs ▁until ▁we ▁log ▁in . ▁*/ ▁PK 11 Generic Object ▁* first Obj , ▁* this Obj ; ▁int ▁cert _ count ; ▁unsigned ▁char ▁** certs ; ▁int ▁* cert _ len ; ▁V Card Key ▁** keys ; ▁PK 11 Slot Info ▁* slot ; ▁V Card ▁* card ; ▁slot ▁= ▁v card _ em ul _ reader _ get _ slot ( v reader ); ▁if ▁( slot ▁== ▁NULL ) ▁{ ▁return ▁NULL ; ▁} ▁first O

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁meg as as _ fw _ time ( void ) ▁{ ▁struct ▁tm ▁cur time ; ▁uint 64_ t ▁b cd _ time ; ▁qemu _ get _ tim ed ate ( & cur time , ▁0); ▁b cd _ time ▁= ▁(( uint 64_ t ) cur time . tm _ sec ▁& ▁0 xff ) ▁<< ▁48 ▁| ▁(( uint 64_ t ) cur time . tm _ min ▁& ▁0 xff ) ▁<< ▁40 ▁| ▁(( uint 64_ t ) cur time . tm _ hour ▁& ▁0 xff ) ▁<< ▁32 ▁| ▁(( uint 64_ t ) cur time . tm _ md ay ▁& ▁0 xff ) ▁<< ▁24 ▁| ▁(( uint 64_ t ) cur time . tm _ mon ▁& ▁0 xff ) ▁<< ▁16 ▁| ▁(( uint 64_ t )( cur time . tm _ year ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Of D pa Flow ▁* of _ d pa _ flow _ alloc ( uint 64_ t ▁cookie ) ▁{ ▁Of D pa Flow ▁* flow ; ▁int 64_ t ▁now ▁= ▁qemu _ clock _ get _ ms ( Q EM U _ C LOCK _ VI RTUAL ) ▁/ ▁1000 ; ▁flow ▁= ▁g _ new 0( Of D pa Flow , ▁1); ▁if ▁(! flow ) ▁{ ▁return ▁NULL ; ▁} ▁flow -> cookie ▁= ▁cookie ; ▁flow -> mask . tbl _ id ▁= ▁0 xffffffff ; ▁flow -> stats . install _ time ▁= ▁flow -> stats . refresh _ time ▁= ▁now ; ▁return ▁flow ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁r tp _ open ( URL Context ▁* h , ▁const ▁char ▁* uri , ▁int ▁flags ) ▁{ ▁R TP Context ▁* s ; ▁int ▁port , ▁is _ output , ▁ttl , ▁local _ port ; ▁char ▁hostname [ 256 ]; ▁char ▁buf [10 24 ]; ▁char ▁path [10 24 ]; ▁const ▁char ▁* p ; ▁is _ output ▁= ▁( flags ▁& ▁URL _ WR ONLY ); ▁s ▁= ▁av _ m alloc z ( size of ( R TP Context )); ▁if ▁(! s ) ▁return ▁A VER ROR ( EN O ME M ); ▁h -> priv _ data ▁= ▁s ; ▁url _ split ( NULL , ▁0, ▁NULL , ▁0, ▁hostname , ▁sizeof ( hostname ), ▁& port , ▁path , ▁size

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁float ▁get _ band _ cost _ U PA IR 7_ m ips ( struct ▁A AC Enc Context ▁* s , ▁Put Bit Context ▁* pb , ▁const ▁float ▁* in , ▁const ▁float ▁* scaled , ▁int ▁size , ▁int ▁scale _ idx , ▁int ▁cb , ▁const ▁float ▁lambda , ▁const ▁float ▁u pl im , ▁int ▁* bits ) ▁{ ▁const ▁float ▁Q 34 ▁= ▁ff _ a ac _ pow 34 sf _ tab [ PO W _ S F 2_ ZERO ▁- ▁scale _ idx ▁+ ▁S CALE _ ONE _ POS ▁- ▁S CALE _ DIV _5 12 ]; ▁const ▁float ▁I Q ▁= ▁ff _ a ac _ pow 2 sf _ tab ▁[ PO W _ S F 2_ ZERO ▁+ ▁scale _ idx ▁- ▁S CALE _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q Object ▁* json _ parser _ parse _ err ( Q List ▁* tokens , ▁va _ list ▁* ap , ▁Error ▁** err p ) ▁{ ▁JSON Parser Context ▁ctxt ▁= ▁{}; ▁Q List ▁* working ▁= ▁q list _ copy ( tokens ); ▁Q Object ▁* result ; ▁result ▁= ▁parse _ value ( & ctxt , ▁& working , ▁ap ); ▁Q DE CRE F ( working ); ▁error _ propag ate ( err p , ▁ctxt . err ); ▁return ▁result ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁init _ directories ( B DR V V V F AT State * ▁s , ▁const ▁char ▁* dirname , ▁int ▁heads , ▁int ▁secs , ▁Error ▁** err p ) ▁{ ▁boot sect or _ t * ▁boot sect or ; ▁mapping _ t * ▁mapping ; ▁unsigned ▁int ▁i ; ▁unsigned ▁int ▁cluster ; ▁mem set ( & ( s -> first _ sect ors [0] ), 0,0 x 40 * 0 x 200 ); ▁s -> cluster _ size = s -> sect ors _ per _ cluster * 0 x 200 ; ▁s -> cluster _ buffer = g _ m alloc ( s -> cluster _ size ); ▁/* ▁* ▁The ▁formula : ▁sc ▁= ▁sp f +1 + sp f * sp c * (5 12 * 8/ f at

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p xa 25 x _ timer _ init ( target _ ph ys _ addr _ t ▁base , ▁qemu _ irq ▁* ir qs ) ▁{ ▁p xa 2 xx _ timer _ info ▁* s ▁= ▁p xa 2 xx _ timer _ init ( base , ▁irq s ); ▁s -> freq ▁= ▁P XA 25 X _ F REQ ; ▁s -> tm 4 ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ mp u _ state _ s ▁* om ap 24 20 _ mp u _ init ( un signed ▁long ▁sd ram _ size , ▁const ▁char ▁* core ) ▁{ ▁struct ▁o map _ mp u _ state _ s ▁* s ▁= ▁( struct ▁o map _ mp u _ state _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ mp u _ state _ s )); ▁ram _ addr _ t ▁s ram _ base , ▁q 2_ base ; ▁qemu _ irq ▁* cpu _ irq ; ▁qemu _ irq ▁d ma _ ir qs [4 ]; ▁Drive Info ▁* d info ; ▁int ▁i ; ▁Sys Bus Device ▁* bus dev ; ▁struct ▁o map _ target _ agent _ s ▁* ta ; ▁/* ▁Core ▁*/ ▁s -> mp u _ mo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ q emu _ ld _ slow _ path ▁( TC G Context ▁* s , ▁TC G Label Q emu L dst ▁* label ) ▁{ ▁int ▁s _ bits ; ▁int ▁ir ; ▁int ▁op c ▁= ▁label -> op c ; ▁int ▁mem _ index ▁= ▁label -> mem _ index ; ▁int ▁data _ reg ▁= ▁label -> dat al o _ reg ; ▁int ▁data _ reg 2 ▁= ▁label -> data hi _ reg ; ▁int ▁addr _ reg ▁= ▁label -> addr lo _ reg ; ▁uint 8_ t ▁* r addr ▁= ▁label -> r addr ; ▁uint 8_ t ▁** label _ ptr ▁= ▁& label -> label _ ptr [0]; ▁s _ bits ▁= ▁op c ▁& ▁3; ▁/* ▁resolve ▁label ▁ad

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ neg ot iate _ handle _ info ( N BD Client ▁* client , ▁uint 32_ t ▁length , ▁uint 32_ t ▁opt , ▁uint 16_ t ▁my flags , ▁Error ▁** err p ) ▁{ ▁int ▁rc ; ▁char ▁name [ N BD _ MAX _ NAME _ SIZE ▁+ ▁1 ]; ▁NB DE x port ▁* exp ; ▁uint 16_ t ▁requests ; ▁uint 16_ t ▁request ; ▁uint 32_ t ▁n amel en ; ▁bool ▁send name ▁= ▁false ; ▁bool ▁blocksize ▁= ▁false ; ▁uint 32_ t ▁sizes [3 ]; ▁char ▁buf [ size of ( uint 64_ t ) ▁+ ▁sizeof ( uint 16_ t ) ]; ▁const ▁char ▁* msg ; ▁/* ▁Client ▁sends : ▁4 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ req _ stream _ length ( SC SI Command ▁* cmd , ▁S CS ID evice ▁* dev , ▁uint 8_ t ▁* buf ) ▁{ ▁switch ▁( buf [0]) ▁{ ▁/* ▁stream ▁commands ▁*/ ▁case ▁E RA SE _12 : ▁case ▁E RA SE _16 : ▁cmd -> x fer ▁= ▁0; ▁break ; ▁case ▁READ _6 : ▁case ▁READ _ RE VER SE : ▁case ▁RE COVER _ BUFFER ED _ DATA : ▁case ▁WRITE _6 : ▁cmd -> len ▁= ▁6 ; ▁cmd -> x fer ▁= ▁buf [4] ▁| ▁( buf [3] ▁<< ▁8) ▁| ▁( buf [2] ▁<< ▁16 ); ▁if ▁( buf [1] ▁& ▁0 x 01) ▁{ ▁/* ▁fixed ▁*/ ▁cmd -> x fer ▁*= ▁dev -> block size 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ t st _ cc ▁( Dis as Context ▁* dc , ▁TC G v ▁cc , ▁int ▁cond ) ▁{ ▁int ▁ar ith _ opt , ▁move _ opt ; ▁/* ▁TODO : ▁optimize ▁more ▁condition ▁codes . ▁*/ ▁/* ▁* ▁If ▁the ▁flags ▁are ▁live , ▁we ' ve ▁got ta ▁look ▁into ▁the ▁bits ▁of ▁C CS . ▁* ▁Otherwise , ▁if ▁we ▁just ▁did ▁an ▁arithmetic ▁operation ▁we ▁try ▁to ▁* ▁evaluate ▁the ▁condition ▁code ▁faster . ▁* ▁* ▁When ▁this ▁function ▁is ▁done , ▁T 0 ▁should ▁be ▁non - zero ▁if ▁the ▁condition ▁* ▁code ▁is ▁true . ▁*/ ▁ar ith _ opt 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ sm m _ enter ( X 86 CPU ▁* cpu ) ▁{ ▁CPU X 86 State ▁* env ▁= ▁& cpu -> env ; ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁target _ ulong ▁sm _ state ; ▁Segment Cache ▁* dt ; ▁int ▁i , ▁offset ; ▁qemu _ log _ mask ( CPU _ LOG _ INT , ▁" S MM : ▁enter \ n "); ▁log _ cpu _ state _ mask ( CPU _ LOG _ INT , ▁CPU ( cpu ), ▁CPU _ DU MP _ C CO P ); ▁env -> h flags ▁|= ▁H F _ S MM _ MASK ; ▁if ▁( env -> h flags 2 ▁& ▁H F 2_ N MI _ MASK ) ▁{ ▁env -> h flags 2 ▁|= ▁H F 2_ S MM _ IN SIDE _ N MI _ MASK ; ▁} ▁else ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁PC ID evice ▁* pc i _ nic _ init ( N IC Info ▁* nd , ▁const ▁char ▁* default _ model , ▁const ▁char ▁* default _ dev addr ) ▁{ ▁const ▁char ▁* dev addr ▁= ▁nd -> dev addr ▁? ▁nd -> dev addr ▁: ▁default _ dev addr ; ▁PC ID evice ▁* pc i _ dev ; ▁Device State ▁* dev ; ▁int ▁i ; ▁i ▁= ▁qemu _ check _ nic _ model _ list ( nd , ▁pci _ nic _ models , ▁default _ model ); ▁pci _ dev ▁= ▁pci _ create ( pc i _ nic _ names [ i ], ▁dev addr ); ▁dev ▁= ▁& pc i _ dev -> q dev ; ▁if ▁( nd -> id ) ▁dev -> id ▁= ▁qemu _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ ml p _ init _ x 86 ( DS P Context * ▁c , ▁AV Codec Context ▁* av ctx ) ▁{ ▁# if ▁HAVE _7 REG S ▁&& ▁HAVE _ TEN _ O PER AN DS ▁c -> ml p _ filter _ channel ▁= ▁ml p _ filter _ channel _ x 86 ; ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ro q _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁R o q Context ▁* enc ▁= ▁av ctx -> priv _ data ; ▁av _ l fg _ init ( & enc -> rand ctx , ▁1); ▁enc -> frames Since Keyframe ▁= ▁0; ▁if ▁(( av ctx -> width ▁& ▁0 xf ) ▁|| ▁( av ctx -> height ▁& ▁0 xf )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Dimensions ▁must ▁be ▁divisible ▁by ▁16 \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁if ▁( av ctx -> width ▁> ▁65535 ▁|| ▁av ctx -> height ▁> ▁65535 ) ▁{ ▁av _ log ( av ctx , ▁AV _ L

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ flush _ change ( H 264 Context ▁* h ) ▁{ ▁int ▁i , ▁j ; ▁h -> next _ output ed _ p oc ▁= ▁INT _ MIN ; ▁h -> prev _ inter laced _ frame ▁= ▁1; ▁id r ( h ); ▁h -> p oc . prev _ frame _ num ▁= ▁-1; ▁if ▁( h -> cur _ pic _ ptr ) ▁{ ▁h -> cur _ pic _ ptr -> reference ▁= ▁0; ▁for ▁( j = i =0; ▁h -> delayed _ pic [ i ]; ▁i ++) ▁if ▁( h -> delayed _ pic [ i ] ▁!= ▁h -> cur _ pic _ ptr ) ▁h -> delayed _ pic [ j ++ ] ▁= ▁h -> delayed _ pic [ i ]; ▁h -> delayed _ pic [ j ] ▁= ▁NULL ; ▁} ▁ff _ h 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av _ set _ number 2( void ▁* obj , ▁const ▁char ▁* name , ▁double ▁num , ▁int ▁den , ▁int 64_ t ▁int num , ▁const ▁AV Option ▁** o _ out ) ▁{ ▁const ▁AV Option ▁* o ▁= ▁av _ opt _ find ( obj , ▁name , ▁NULL , ▁0, ▁0); ▁void ▁* dst ; ▁if ▁( o _ out ) ▁* o _ out = ▁o ; ▁if ▁(! o ▁|| ▁o -> offset < =0) ▁return ▁A VER ROR _ OPTION _ NOT _ FOUND ; ▁if ▁( o -> max * den ▁< ▁num * int num ▁|| ▁o -> min * den ▁> ▁num * int num ) ▁{ ▁av _ log ( obj , ▁AV _ LOG _ ERROR , ▁" Value ▁% l f ▁for ▁paramete

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q xl _ real ize _ common ( PC I Q X L Device ▁* q xl , ▁Error ▁** err p ) ▁{ ▁uint 8_ t * ▁config ▁= ▁q xl -> pc i . config ; ▁uint 32_ t ▁pci _ device _ rev ; ▁uint 32_ t ▁io _ size ; ▁q xl -> mode ▁= ▁Q X L _ MODE _ UN DEFINED ; ▁q xl -> generation ▁= ▁1; ▁q xl -> num _ mem slots ▁= ▁NUM _ ME MS L OT S ; ▁qemu _ mut ex _ init ( & q xl -> track _ lock ); ▁qemu _ mut ex _ init ( & q xl -> async _ lock ); ▁q xl -> current _ async ▁= ▁Q X L _ UN DEFINED _ IO ; ▁q xl -> guest _ bug ▁= ▁0; ▁swi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vc 1_ inv _ trans _8 x 4_ dc _ c ( uint 8_ t ▁* dest , ▁int ▁lines ize , ▁D CT E LE M ▁* block ) ▁{ ▁int ▁i ; ▁int ▁dc ▁= ▁block [0]; ▁const ▁uint 8_ t ▁* cm ; ▁dc ▁= ▁( ▁3 ▁* ▁dc ▁+ ▁1) ▁>> ▁1; ▁dc ▁= ▁( 17 ▁* ▁dc ▁+ ▁64 ) ▁>> ▁7 ; ▁cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ▁+ ▁dc ; ▁for ( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++){ ▁dest [0] ▁= ▁cm [ dest [0] ]; ▁dest [1] ▁= ▁cm [ dest [1] ]; ▁dest [2] ▁= ▁cm [ dest [2] ]; ▁dest [3] ▁= ▁cm [ dest [3] ]; ▁dest [4] ▁= ▁cm [ dest [4] ]; ▁dest [5] ▁= ▁cm [ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁always _ inline ▁uint 8_ t ▁vc 1_ m sp el _ filter ( const ▁uint 8_ t ▁* src , ▁int ▁stride , ▁int ▁mode , ▁int ▁r ) ▁{ ▁switch ( mode ){ ▁case ▁0: ▁// no ▁shift ▁return ▁src [0]; ▁case ▁1: ▁// ▁1 /4 ▁shift ▁return ▁( -4 * src [ - stride ] ▁+ ▁53 * src [0] ▁+ ▁18 * src [ stride ] ▁- ▁3 * src [ stride * 2] ▁+ ▁32 ▁- ▁r ) ▁>> ▁6 ; ▁case ▁2: ▁// ▁1 /2 ▁shift ▁return ▁(- src [ - stride ] ▁+ ▁9 * src [0] ▁+ ▁9 * src [ stride ] ▁- ▁src [ stride * 2] ▁+ ▁8 ▁- ▁r ) ▁>> ▁4; ▁case ▁3: ▁// ▁3 /4 ▁shift ▁ret

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁open pic _ tm r _ read ( void ▁* op aque , ▁hw addr ▁addr , ▁unsigned ▁len ) ▁{ ▁Open PIC State ▁* o pp ▁= ▁opaque ; ▁uint 32_ t ▁retval ▁= ▁-1; ▁int ▁idx ; ▁D PRI NT F ("% s : ▁addr ▁% 08 x \ n ", ▁__ func __, ▁addr ); ▁if ▁( addr ▁& ▁0 xF ) ▁{ ▁goto ▁out ; ▁} ▁idx ▁= ▁( addr ▁>> ▁6) ▁& ▁0 x 3; ▁if ▁( addr ▁== ▁0 x 0) ▁{ ▁/* ▁T IF R ▁( T FR R ) ▁*/ ▁retval ▁= ▁opp -> t if r ; ▁goto ▁out ; ▁} ▁switch ▁( addr ▁& ▁0 x 30) ▁{ ▁case ▁0 x 00 : ▁/* ▁T IC C ▁( GT CC R ) ▁*/ ▁retval ▁= ▁opp -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ exception _ ins n ( Dis as Context ▁* s , ▁int ▁offset , ▁int ▁exc p ) ▁{ ▁gen _ a 64_ set _ pc _ im ( s -> pc ▁- ▁offset ); ▁gen _ exception ( ex cp ); ▁s -> is _ j mp ▁= ▁DIS AS _ J UMP ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Q Dict ▁* q mp _ dispatch _ check _ obj ( const ▁Q Object ▁* request , ▁Error ▁** err p ) ▁{ ▁const ▁Q Dict Entry ▁* ent ; ▁const ▁char ▁* arg _ name ; ▁const ▁Q Object ▁* arg _ obj ; ▁bool ▁has _ exec _ key ▁= ▁false ; ▁Q Dict ▁* dict ▁= ▁NULL ; ▁if ▁( q object _ type ( request ) ▁!= ▁Q TYPE _ Q DICT ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ Q MP _ BAD _ INPUT _ OBJECT , ▁" request ▁is ▁not ▁a ▁dictionary "); ▁return ▁NULL ; ▁} ▁dict ▁= ▁q object _ to _ q dict ( request ); ▁for ▁( ent ▁= ▁q dict _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sha 1_ transform ( uint 32_ t ▁state [5 ], ▁const ▁uint 8_ t ▁buffer [ 64 ]) ▁{ ▁uint 32_ t ▁block [ 80 ]; ▁unsigned ▁int ▁i , ▁a , ▁b , ▁c , ▁d , ▁e ; ▁a ▁= ▁state [0]; ▁b ▁= ▁state [1]; ▁c ▁= ▁state [2 ]; ▁d ▁= ▁state [3 ]; ▁e ▁= ▁state [4 ]; ▁# if ▁CONFIG _ SM ALL ▁for ▁( i ▁= ▁0; ▁i ▁< ▁80 ; ▁i ++) ▁{ ▁int ▁t ; ▁if ▁( i ▁< ▁16 ) ▁t ▁= ▁AV _ RB 32 ( buffer ▁+ ▁4 ▁* ▁i ); ▁else ▁t ▁= ▁rol ( block [ i -3 ] ▁^ ▁block [ i -8 ] ▁^ ▁block [ i -1 4] ▁^ ▁block [ i -16 ], ▁1); ▁block [ i ] ▁= ▁t 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ int 64 ( Q EM U File ▁* f , ▁void ▁* pv , ▁size _ t ▁size ) ▁{ ▁int 64_ t ▁* v ▁= ▁pv ; ▁qemu _ get _ s be 64 s ( f , ▁v ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ac pi _ build _ update ( void ▁* build _ op aque , ▁uint 32_ t ▁offset ) ▁{ ▁Ac pi Build State ▁* build _ state ▁= ▁build _ op aque ; ▁Ac pi Build Tables ▁tables ; ▁/* ▁No ▁state ▁to ▁update ▁or ▁already ▁patched ? ▁Nothing ▁to ▁do . ▁*/ ▁if ▁(! build _ state ▁|| ▁build _ state -> patch ed ) ▁{ ▁return ; ▁} ▁build _ state -> patch ed ▁= ▁1; ▁ac pi _ build _ tables _ init ( & tables ); ▁ac pi _ build ( build _ state -> guest _ info , ▁& tables ); ▁assert ( ac pi _ data _ len ( tables . table

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁am r _ nb _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁AM R Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> sample _ rate ▁!= ▁8 000) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁8000 Hz ▁sample ▁rate ▁supported \ n "); ▁return ▁A VER ROR ( EN OS Y S ); ▁} ▁if ▁( av ctx -> channels ▁!= ▁1) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁mon o ▁supported \ n "); ▁return ▁A VER ROR ( EN OS Y S ); ▁} ▁av ctx -> frame _ size ▁= ▁16 0; ▁av ctx -> coded _ f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁help ( void ) ▁{ ▁printf (" d ct - test ▁[- i ] ▁[< test - number > ]\ n " ▁" test - number ▁0 ▁-> ▁test ▁with ▁random ▁matrix es \ n " ▁" ▁1 ▁-> ▁test ▁with ▁random ▁sparse ▁matrix es \ n " ▁" ▁2 ▁-> ▁do ▁3. ▁test ▁from ▁m peg 4 ▁std \ n " ▁"- i ▁test ▁ID CT ▁implementations \ n " ▁" -4 ▁test ▁ID CT 248 ▁implementations \ n "); ▁exit (1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( sl w ) ▁{ ▁if ▁( T 1 ▁& ▁0 x 20) ▁{ ▁T 0 ▁= ▁0; ▁} ▁else ▁{ ▁T 0 ▁= ▁T 0 ▁<< ▁T 1; ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ num ( Byte IO Context ▁* pb , ▁int ▁* len ) ▁{ ▁int ▁n , ▁n 1; ▁n ▁= ▁get _ be 16 ( pb ); ▁(* len )- = 2; ▁// ▁n ▁&= ▁0 x 7 FFF ; ▁if ▁( n ▁>= ▁0 x 4 000) ▁{ ▁return ▁n ▁- ▁0 x 4 000; ▁} ▁else ▁{ ▁n 1 ▁= ▁get _ be 16 ( pb ); ▁(* len )- = 2; ▁return ▁( n ▁<< ▁16 ) ▁| ▁n 1; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁CPU State ▁* pp c 4 40 ep _ init ( Memory Region ▁* address _ space _ mem , ▁ram _ addr _ t ▁* ram _ size , ▁P CI Bus ▁** pc ip , ▁const ▁unsigned ▁int ▁pci _ irq _ n rs [4 ], ▁int ▁do _ init , ▁const ▁char ▁* cpu _ model ) ▁{ ▁Memory Region ▁* ram _ mem ories ▁= ▁g _ m alloc ( P PC 4 40 EP _ SD RAM _ N R _ B ANK S ▁* ▁sizeof (* ram _ mem ories )); ▁target _ ph ys _ addr _ t ▁ram _ bases [ P PC 4 40 EP _ SD RAM _ N R _ B ANK S ]; ▁target _ ph ys _ addr _ t ▁ram _ sizes [ P PC 4 40 EP _ SD RAM _ N R _ B A

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pi ix 4_ init fn ( PC ID evice ▁* dev ) ▁{ ▁PI IX 4 State ▁* d ▁= ▁DO _ UP CAST ( PI IX 4 State , ▁dev , ▁dev ); ▁uint 8_ t ▁* pc i _ conf ; ▁isa _ bus _ new ( & d -> dev . q dev ); ▁pci _ conf ▁= ▁d -> dev . config ; ▁pci _ config _ set _ vendor _ id ( pc i _ conf , ▁P CI _ VE ND OR _ ID _ INT EL ); ▁pci _ config _ set _ device _ id ( pc i _ conf , ▁P CI _ DEVICE _ ID _ INT EL _8 2 37 1 AB _0 ); ▁// ▁82 37 1 AB / EB / MB ▁PI IX 4 ▁P CI - to - IS A ▁bridge ▁pci _ config _ set _ class ( pc i 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁F UN CC ( ff _ h 2 64_ add _ pixels 8) ( uint 8_ t ▁* _ dst , ▁int 16_ t ▁* _ src , ▁int ▁stride ) ▁{ ▁int ▁i ; ▁pixel ▁* dst ▁= ▁( pixel ▁* ) ▁_ dst ; ▁dct coef ▁* src ▁= ▁( d ct coef ▁* ) ▁_ src ; ▁stride ▁/= ▁sizeof ( pixel ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁{ ▁dst [0] ▁+= ▁src [0]; ▁dst [1] ▁+= ▁src [1]; ▁dst [2] ▁+= ▁src [2 ]; ▁dst [3] ▁+= ▁src [3 ]; ▁dst [4] ▁+= ▁src [4 ]; ▁dst [5] ▁+= ▁src [5 ]; ▁dst [ 6] ▁+= ▁src [6 ]; ▁dst [ 7] ▁+= ▁src [ 7 ]; ▁dst ▁+= ▁stride ; ▁src ▁+= ▁8 ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁output _ frame ( H 264 Context ▁* h , ▁AV Frame ▁* dst , ▁AV Frame ▁* src ) ▁{ ▁int ▁i ; ▁int ▁ret ▁= ▁av _ frame _ ref ( dst , ▁src ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁if ▁(! h -> sp s . crop ) ▁return ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁3; ▁i ++) ▁{ ▁int ▁h shift ▁= ▁( i ▁> ▁0) ▁? ▁h -> chrom a _ x _ shift ▁: ▁0; ▁int ▁v shift ▁= ▁( i ▁> ▁0) ▁? ▁h -> chrom a _ y _ shift ▁: ▁0; ▁int ▁off ▁= ▁(( h -> sp s . crop _ left ▁>> ▁h shift ) ▁<< ▁h -> pixel _ shift ) ▁+ ▁( h -> sp s . crop _ top ▁>> ▁v shi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁throttle _ account ( Th rottle State ▁* ts , ▁bool ▁is _ write , ▁uint 64_ t ▁size ) ▁{ ▁double ▁units ▁= ▁1.0 ; ▁/* ▁if ▁cfg . op _ size ▁is ▁defined ▁and ▁smaller ▁than ▁size ▁we ▁compute ▁unit ▁count ▁*/ ▁if ▁( ts -> cfg . op _ size ▁&& ▁size ▁> ▁ts -> cfg . op _ size ) ▁{ ▁units ▁= ▁( double ) ▁size ▁/ ▁ts -> cfg . op _ size ; ▁} ▁ts -> cfg . buckets [ TH RO TTLE _ B PS _ T OTAL ]. level ▁+= ▁size ; ▁ts -> cfg . buckets [ TH RO TTLE _ OP S _ T OTAL ]. level ▁+= ▁units ; ▁if ▁( is _ write ) ▁{ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ remove _ a io _ context _ notifier ( Block Driver State ▁* bs , ▁void ▁(* attached _ a io _ context )( A io Context ▁* , ▁void ▁* ), ▁void ▁(* detach _ a io _ context )( void ▁* ), ▁void ▁* op aque ) ▁{ ▁B dr v A io Notifier ▁* ban , ▁* ban _ next ; ▁Q LIST _ FORE A CH _ SAFE ( ban , ▁& bs -> a io _ not ifiers , ▁list , ▁ban _ next ) ▁{ ▁if ▁( ban -> attached _ a io _ context ▁== ▁attached _ a io _ context ▁&& ▁ban -> detach _ a io _ context ▁== ▁detach _ a io _ context ▁&& ▁ban -> op aque

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ add q _ lo ( Dis as Context ▁* s , ▁TC G v _ i 64 ▁val , ▁int ▁r low ) ▁{ ▁TC G v _ i 64 ▁tmp ; ▁TC G v ▁tmp 2; ▁/* ▁Load ▁value ▁and ▁extend ▁to ▁64 ▁bits . ▁*/ ▁tmp ▁= ▁tc g _ temp _ new _ i 64 (); ▁tmp 2 ▁= ▁load _ reg ( s , ▁r low ); ▁tc g _ gen _ ext u _ i 32_ i 64 ( tmp , ▁tmp 2); ▁dead _ tmp ( tmp 2); ▁tc g _ gen _ add _ i 64 ( val , ▁val , ▁tmp ); ▁tc g _ temp _ free _ i 64 ( tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ b md ma _ simple _ rw ( void ) ▁{ ▁Q PC ID evice ▁* dev ; ▁void ▁* b md ma _ base , ▁* ide _ base ; ▁uint 8_ t ▁status ; ▁uint 8_ t ▁* buf ; ▁uint 8_ t ▁* cmp buf ; ▁size _ t ▁len ▁= ▁512 ; ▁uint ptr _ t ▁guest _ buf ▁= ▁guest _ alloc ( guest _ m alloc , ▁len ); ▁Pr dt Entry ▁pr dt [] ▁= ▁{ ▁{ ▁. addr ▁= ▁cpu _ to _ le 32 ( guest _ buf ), ▁. size ▁= ▁cpu _ to _ le 32 ( len ▁| ▁PR DT _ E OT ), ▁}, ▁}; ▁dev ▁= ▁get _ pc i _ device ( & b md ma _ base , ▁& ide _ base ); ▁buf ▁= ▁g _ m al

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁id c in _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret ; ▁unsigned ▁int ▁command ; ▁unsigned ▁int ▁chunk _ size ; ▁Id c in Dem ux Context ▁* id c in ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁i ; ▁int ▁palette _ scale ; ▁unsigned ▁char ▁r , ▁g , ▁b ; ▁unsigned ▁char ▁palette _ buffer [ 768 ]; ▁uint 32_ t ▁palette [ 256 ]; ▁if ▁( s -> pb -> eof _ re ached ) ▁return ▁A VER ROR ( E IO ); ▁if ▁( id c in -> next _ chunk _ is _ video ) ▁{ ▁command

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 2 rgb 555 _2 )( Sw s Context ▁* c , ▁const ▁uint 16_ t ▁* buf 0, ▁const ▁uint 16_ t ▁* buf 1, ▁const ▁uint 16_ t ▁* ub uf 0, ▁const ▁uint 16_ t ▁* ub uf 1, ▁const ▁uint 16_ t ▁* v buf 0, ▁const ▁uint 16_ t ▁* v buf 1, ▁const ▁uint 16_ t ▁* ab uf 0, ▁const ▁uint 16_ t ▁* ab uf 1, ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁y alpha , ▁int ▁u val pha , ▁int ▁y ) ▁{ ▁x 86_ reg ▁uv _ off ▁= ▁c -> uv _ off ▁<< ▁1; ▁// Note ▁82 80 ▁== ▁DST W _ OFFSET ▁but ▁the ▁preprocessor ▁ca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁V irt IO Block Req ▁* virt io _ blk _ get _ request ( V irt IO Block ▁* s ) ▁{ ▁V irt IO Block Req ▁* req ▁= ▁virt io _ blk _ alloc _ request ( s ); ▁if ▁(! virt queue _ pop ( s -> v q , ▁& req -> elem )) ▁{ ▁virt io _ blk _ free _ request ( req ); ▁return ▁NULL ; ▁} ▁return ▁req ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁output _ packet ( InputStream ▁* ist , ▁const ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret ▁= ▁0, ▁i ; ▁int ▁got _ output ; ▁AV Packet ▁av pk t ; ▁if ▁(! ist -> s aw _ first _ ts ) ▁{ ▁ist -> d ts ▁= ▁ist -> st -> avg _ frame _ rate . num ▁? ▁- ▁ist -> st -> codec -> has _ b _ frames ▁* ▁AV _ TIME _ BASE ▁/ ▁av _ q 2 d ( ist -> st -> avg _ frame _ rate ) ▁: ▁0; ▁ist -> pts ▁= ▁0; ▁if ▁( pk t ▁!= ▁NULL ▁&& ▁pkt -> pts ▁!= ▁AV _ NO PT S _ VALUE ▁&& ▁! ist -> dec oding _ needed ) ▁{ ▁ist -> d ts ▁+= ▁av _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ system _ reset ( void ) ▁{ ▁Q EM U Reset Entry ▁* re , ▁* n re ; ▁/* ▁reset ▁all ▁devices ▁*/ ▁Q TAIL Q _ FORE A CH _ SAFE ( re , ▁& reset _ handlers , ▁entry , ▁n re ) ▁{ ▁re -> func ( re -> op aque ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd _ reset ( SD State ▁* sd , ▁Block Driver State ▁* b dr v ) ▁{ ▁uint 64_ t ▁size ; ▁uint 64_ t ▁sect ; ▁if ▁( b dr v ) ▁{ ▁b dr v _ get _ geometry ( b dr v , ▁& sect ); ▁} ▁else ▁{ ▁sect ▁= ▁0; ▁} ▁size ▁= ▁sect ▁<< ▁9 ; ▁sect ▁= ▁( size ▁>> ▁( H W BLOCK _ SHIFT ▁+ ▁SE CTOR _ SHIFT ▁+ ▁W P GROUP _ SHIFT )) ▁+ ▁1; ▁sd -> state ▁= ▁sd _ idle _ state ; ▁sd -> rc a ▁= ▁0 x 0000 ; ▁sd _ set _ oc r ( sd ); ▁sd _ set _ scr ( sd ); ▁sd _ set _ cid ( sd ); ▁sd _ set _ cs d ( sd , ▁size ); ▁sd _ se

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁phys _ page _ set ( Address Space Dispatch ▁* d , ▁target _ ph ys _ addr _ t ▁index , ▁target _ ph ys _ addr _ t ▁nb , ▁uint 16_ t ▁leaf ) ▁{ ▁/* ▁Wild ly ▁over re serve ▁- ▁it ▁doesn ' t ▁matter ▁much . ▁*/ ▁phys _ map _ node _ re serve (3 ▁* ▁P _ L 2_ LE VE LS ); ▁phys _ page _ set _ level ( & d -> ph ys _ map , ▁& index , ▁& nb , ▁leaf , ▁P _ L 2_ LE VE LS ▁- ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁tc g _ out _ op ( TC G Context ▁* s , ▁TC G Op code ▁op c , ▁const ▁TC G Arg ▁* args , ▁const ▁int ▁* const _ args ) ▁{ ▁int ▁c ; ▁switch ▁( op c ) ▁{ ▁case ▁INDEX _ op _ exit _ tb : ▁if ▁( check _ fit _ tl ( args [0], ▁13 )) ▁{ ▁tc g _ out _ ar ith i ( s , ▁TC G _ REG _ G 0, ▁TC G _ REG _ I 7, ▁8, ▁RETURN ); ▁tc g _ out _ mov i _ im m 13 ( s , ▁TC G _ REG _ O 0, ▁args [0]); ▁} ▁else ▁{ ▁tc g _ out _ mov i ( s , ▁TC G _ TYPE _ PT R , ▁TC G _ REG _ I 0, ▁args [0] ▁& ▁~ 0 x 3 ff ); ▁t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁eight sv x _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁E ight S v x Context ▁* esc ▁= ▁av ctx -> priv _ data ; ▁int ▁n , ▁out _ data _ size ; ▁int ▁ch , ▁ret ; ▁uint 8_ t ▁* src ; ▁/* ▁decode ▁and ▁inter leave ▁the ▁first ▁packet ▁*/ ▁if ▁(! esc -> samples ▁&& ▁av pk t ) ▁{ ▁int ▁packet _ size ▁= ▁av pk t -> size ; ▁if ▁( packet _ size ▁% ▁av ctx -> channels ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ WARNING , ▁" Packet ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ serial _ load ( Q EM U File ▁* f , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁V irt IO Serial ▁* s ▁= ▁opaque ; ▁V irt IO Serial Port ▁* port ; ▁uint 32_ t ▁max _ nr _ ports , ▁nr _ active _ ports , ▁ports _ map ; ▁unsigned ▁int ▁i ; ▁int ▁ret ; ▁if ▁( version _ id ▁> ▁3) ▁{ ▁return ▁- E IN VAL ; ▁} ▁/* ▁The ▁virt io ▁device ▁*/ ▁ret ▁= ▁virt io _ load ( & s -> v dev , ▁f ); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁if ▁( version _ id ▁< ▁2) ▁{ ▁return ▁0; ▁} ▁/* ▁The ▁config ▁space ▁*/ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ sp ice _ port ( const ▁char ▁* id , ▁Ch ard ev Backend ▁* backend , ▁Ch ard ev Return ▁* ret , ▁Error ▁** err p ) ▁{ ▁const ▁char ▁* name ▁= ▁backend -> sp ic ep ort -> fq dn ; ▁Char Driver State ▁* chr ; ▁Sp ice Char Driver ▁* s ; ▁if ▁( name ▁== ▁NULL ) ▁{ ▁f printf ( stderr , ▁" sp ice - q emu - char : ▁missing ▁name ▁parameter \ n "); ▁return ▁NULL ; ▁} ▁chr ▁= ▁chr _ open (" port ", ▁sp ice _ port _ set _ fe _ open ); ▁s ▁= ▁chr -> op aque ; ▁s -> si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ break point _ remove _ by _ ref ( CPU State ▁* cpu , ▁CP UB reak point ▁* break point ) ▁{ ▁# if ▁defined ( TARGET _ H AS _ ICE ) ▁Q TAIL Q _ REMOVE ( & cpu -> break points , ▁breakpoint , ▁entry ); ▁breakpoint _ in validate ( cpu , ▁breakpoint -> pc ); ▁g _ free ( break point ); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fl v _ write _ trail er ( AV Format Context ▁* s ) ▁{ ▁int 64_ t ▁file _ size ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁FL V Context ▁* fl v ▁= ▁s -> priv _ data ; ▁int ▁i ; ▁/* ▁Add ▁E OS ▁tag ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> nb _ streams ; ▁i ++) ▁{ ▁AV Codec Context ▁* enc ▁= ▁s -> streams [ i ] -> codec ; ▁FL V Stream Context ▁* sc ▁= ▁s -> streams [ i ] -> priv _ data ; ▁if ▁( enc -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ▁&& ▁enc -> codec _ id ▁== ▁AV _ CODE C _ ID _ H 2 64) ▁put _ av 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁void ▁* b oston _ fd t _ filter ( void ▁* op aque , ▁const ▁void ▁* fd t _ orig , ▁const ▁void ▁* match _ data , ▁hw addr ▁* load _ addr ) ▁{ ▁B oston State ▁* s ▁= ▁B OST ON ( op aque ); ▁Machine State ▁* machine ▁= ▁s -> m ach ; ▁const ▁char ▁* cmdline ; ▁int ▁err ; ▁void ▁* fd t ; ▁size _ t ▁fd t _ sz , ▁ram _ low _ sz , ▁ram _ high _ sz ; ▁fd t _ sz ▁= ▁fd t _ total size ( fd t _ orig ) ▁* ▁2; ▁fd t ▁= ▁g _ m alloc 0( fd t _ sz ); ▁err ▁= ▁fd t _ open _ into ( fd t _ orig , ▁fd t , ▁fd

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ cm ov ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁# if ▁CONFIG _ Z LIB ▁AV IO Context ▁ctx ; ▁uint 8_ t ▁* cm ov _ data ; ▁uint 8_ t ▁* m oo v _ data ; ▁/* ▁uncompressed ▁data ▁*/ ▁long ▁cm ov _ len , ▁m oo v _ len ; ▁int ▁ret ▁= ▁-1; ▁av io _ rb 32 ( pb ); ▁/* ▁d com ▁atom ▁*/ ▁if ▁( av io _ rl 32 ( pb ) ▁!= ▁M K TAG (' d ',' c ',' o ',' m ')) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( av io _ rl 32 ( pb ) ▁!= ▁M K TAG (' z ',' l ',' i ',' b ')) ▁{ ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁s dp _ parse _ r tp map ( AV Format Context ▁* s , ▁AV Codec Context ▁* codec , ▁RT SP Stream ▁* rt sp _ st , ▁int ▁payload _ type , ▁const ▁char ▁* p ) ▁{ ▁char ▁buf [ 256 ]; ▁int ▁i ; ▁AV Codec ▁* c ; ▁const ▁char ▁* c _ name ; ▁/* ▁Loop ▁into ▁AV R tp Dynamic Payload Types [] ▁and ▁AV R tp Payload Types [] ▁and ▁* ▁see ▁if ▁we ▁can ▁handle ▁this ▁kind ▁of ▁payload . ▁* ▁The ▁space ▁should ▁normally ▁not ▁be ▁there ▁but ▁some ▁Real ▁streams ▁or ▁* ▁particular ▁servers ▁(" Real Server ▁Vers

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ mp v _ frame _ end ( M peg Enc Context ▁* s ) ▁{ ▁# if ▁FF _ API _ X VM C ▁FF _ DIS ABLE _ DE PRE CATION _ WARNING S ▁/* ▁redraw ▁edges ▁for ▁the ▁frame ▁if ▁decoding ▁didn ' t ▁complete ▁*/ ▁// ▁just ▁to ▁make ▁sure ▁that ▁all ▁data ▁is ▁rendered . ▁if ▁( CONFIG _ M PEG _ X VM C _ DE CO DER ▁&& ▁s -> av ctx -> x vm c _ accel eration ) ▁{ ▁ff _ x vm c _ field _ end ( s ); ▁} ▁else ▁FF _ ENABLE _ DE PRE CATION _ WARNING S ▁# end if ▁/* ▁FF _ API _ X VM C ▁*/ ▁em ms _ c (); ▁if ▁( s -> current _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ ff server _ streams ( AV Format Context ▁* s , ▁const ▁char ▁* filename ) ▁{ ▁int ▁i , ▁err ; ▁AV Format Context ▁* ic ; ▁int ▁no pts ▁= ▁0; ▁err ▁= ▁av _ open _ input _ file ( & ic , ▁filename , ▁NULL , ▁FF M _ PA CKET _ SIZE , ▁NULL ); ▁if ▁( err ▁< ▁0) ▁return ▁err ; ▁/* ▁copy ▁stream ▁format ▁*/ ▁s -> nb _ streams ▁= ▁ic -> nb _ streams ; ▁for ( i =0; i < ic -> nb _ streams ; i ++) ▁{ ▁AV Stream ▁* st ; ▁AV Codec ▁* codec ; ▁// ▁FIX ME : ▁a ▁more ▁elegant ▁solution ▁is ▁needed ▁st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁un init ( AV Filter Context ▁* ctx ) ▁{ ▁Z Scale Context ▁* s ▁= ▁ctx -> priv ; ▁z img _ filter _ graph _ free ( s -> graph ); ▁av _ fre ep ( & s -> tmp ); ▁s -> tmp _ size ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ bo _ addr mode _ post _ pre _ base ( CP UT ri Core State ▁* env , ▁Dis as Context ▁* ctx ) ▁{ ▁uint 32_ t ▁op 2; ▁uint 32_ t ▁off 10 ; ▁int 32_ t ▁r 1, ▁r 2; ▁TC G v ▁temp ; ▁r 1 ▁= ▁MASK _ OP _ BO _ S 1 D ( ctx -> op code ); ▁r 2 ▁= ▁MASK _ OP _ BO _ S 2( ctx -> op code ); ▁off 10 ▁= ▁MASK _ OP _ BO _ OFF 10_ SE XT ( ctx -> op code ); ▁op 2 ▁= ▁MASK _ OP _ BO _ OP 2( ctx -> op code ); ▁switch ▁( op 2) ▁{ ▁case ▁O PC 2_ 32_ BO _ CACHE A _ WI _ SH OR TO FF : ▁case ▁O PC 2_ 32_ BO _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ m ips _ get _ f pu _ regist ers ( CPU State ▁* cs ) ▁{ ▁M IP SC PU ▁* cpu ▁= ▁M IP S _ CPU ( cs ); ▁CP UM IP S State ▁* env ▁= ▁& cpu -> env ; ▁int ▁err , ▁ret ▁= ▁0; ▁unsigned ▁int ▁i ; ▁/* ▁Only ▁get ▁F PU ▁state ▁if ▁we ' re ▁em ulating ▁a ▁CPU ▁with ▁an ▁F PU ▁*/ ▁if ▁( env -> CP 0_ Config 1 ▁& ▁(1 ▁<< ▁CP 0 C 1_ FP )) ▁{ ▁/* ▁F PU ▁Control ▁Reg ist ers ▁*/ ▁err ▁= ▁k vm _ m ips _ get _ one _ ure g ( cs , ▁K VM _ REG _ M IP S _ FC R _ IR , ▁& env -> active _ f pu . f cr 0); ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ lo ongs on _ integer ( Dis as Context ▁* ctx , ▁uint 32_ t ▁op c , ▁int ▁rd , ▁int ▁rs , ▁int ▁rt ) ▁{ ▁const ▁char ▁* op n ▁= ▁" lo ongs on "; ▁TC G v ▁t 0, ▁t 1; ▁if ▁( rd ▁== ▁0) ▁{ ▁/* ▁T reat ▁as ▁NO P . ▁*/ ▁M IP S _ DEBUG (" NO P "); ▁return ; ▁} ▁switch ▁( op c ) ▁{ ▁case ▁O PC _ MULT _ G _2 E : ▁case ▁O PC _ MULT _ G _2 F : ▁case ▁O PC _ MULT U _ G _2 E : ▁case ▁O PC _ MULT U _ G _2 F : ▁# if ▁defined ( TARGET _ M IP S 64) ▁case ▁O PC _ D MULT _ G _2 E : ▁case ▁O PC _ D MULT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ pc i _ load _ rom ( V FI OP C ID evice ▁* v dev ) ▁{ ▁struct ▁vf io _ region _ info ▁reg _ info ▁= ▁{ ▁. args z ▁= ▁sizeof ( reg _ info ), ▁. index ▁= ▁V FI O _ PC I _ ROM _ REGION _ INDEX ▁}; ▁uint 64_ t ▁size ; ▁off _ t ▁off ▁= ▁0; ▁size _ t ▁bytes ; ▁if ▁( io ctl ( v dev -> v based ev . fd , ▁V FI O _ DEVICE _ GET _ REGION _ INFO , ▁& reg _ info )) ▁{ ▁error _ report (" vf io : ▁Error ▁getting ▁R OM ▁info : ▁% m "); ▁return ; ▁} ▁trace _ vf io _ pc i _ load _ rom ( v dev -> v bas

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁try _ poll _ mode ( A io Context ▁* ctx , ▁bool ▁blocking ) ▁{ ▁if ▁( blocking ▁&& ▁ctx -> poll _ max _ ns ▁&& ▁ctx -> poll _ disable _ cnt ▁== ▁0) ▁{ ▁/* ▁See ▁qemu _ so on est _ timeout () ▁uint 64_ t ▁hack ▁*/ ▁int 64_ t ▁max _ ns ▁= ▁MIN (( uint 64_ t ) a io _ compute _ timeout ( ctx ), ▁( uint 64_ t ) ctx -> poll _ max _ ns ); ▁if ▁( max _ ns ) ▁{ ▁if ▁( run _ poll _ handlers ( ctx , ▁max _ ns )) ▁{ ▁return ▁true ; ▁} ▁} ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ basic ( g const pointer ▁data ) ▁{ ▁Q V irt io PC ID evice ▁* dev ; ▁Q PC I Bus ▁* bus ; ▁Q V irt Queue PC I ▁* tx , ▁* rx ; ▁Q Guest Allocator ▁* alloc ; ▁void ▁(* func ) ▁( const ▁Q V irt io Bus ▁* bus , ▁Q V irt io Device ▁* dev , ▁Q Guest Allocator ▁* alloc , ▁Q V irt Queue ▁* rv q , ▁Q V irt Queue ▁* tv q , ▁int ▁socket ) ▁= ▁data ; ▁int ▁sv [2], ▁ret ; ▁ret ▁= ▁socket pair ( PF _ UN IX , ▁SOCK _ STREAM , ▁0, ▁sv ); ▁g _ assert _ cmp int ( ret , ▁!= , ▁-1 ); ▁bus ▁= ▁pci _ test _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str t oul _ full _ negative ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" ▁\ t ▁- 32 1" ; ▁unsigned ▁long ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str t oul ( str , ▁NULL , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert _ cmp int ( res , ▁== , ▁- 321 ul ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v nc _ validate _ certificate ( struct ▁V nc State ▁* vs ) ▁{ ▁int ▁ret ; ▁unsigned ▁int ▁status ; ▁const ▁gn ut ls _ datum _ t ▁* certs ; ▁unsigned ▁int ▁n Certs , ▁i ; ▁time _ t ▁now ; ▁V NC _ DEBUG (" Valid ating ▁client ▁certificate \ n "); ▁if ▁(( ret ▁= ▁gn ut ls _ certificate _ verify _ pe ers 2 ▁( vs -> tls _ session , ▁& status )) ▁< ▁0) ▁{ ▁V NC _ DEBUG (" Verify ▁failed ▁% s \ n ", ▁gn ut ls _ str error ( ret )); ▁return ▁-1; ▁} ▁if ▁(( now ▁= ▁time ( NULL )) ▁== ▁(( time _ t ) -1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁fw _ cfg _ add _ callback ( void ▁* op aque , ▁uint 16_ t ▁key , ▁F W Cfg Callback ▁callback , ▁void ▁* callback _ op aque , ▁uint 8_ t ▁* data , ▁size _ t ▁len ) ▁{ ▁F W Cfg State ▁* s ▁= ▁opaque ; ▁int ▁arch ▁= ▁!! ( key ▁& ▁F W _ CF G _ ARCH _ LOCAL ); ▁key ▁&= ▁F W _ CF G _ ENTRY _ MASK ; ▁if ▁( key ▁>= ▁F W _ CF G _ MAX _ ENTRY ▁|| ▁! ( key ▁& ▁F W _ CF G _ WRITE _ CHANNEL ) ▁|| ▁len ▁> ▁65535 ) ▁return ▁0; ▁s -> entries [ arch ][ key ]. data ▁= ▁data ; ▁s -> entries [ arch ][ key ]. len ▁= ▁le

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l pc _ analy ze _ re mod ulate ( int 32_ t ▁* decoded , ▁const ▁int ▁coeffs [ 32 ], ▁int ▁order , ▁int ▁q level , ▁int ▁len , ▁int ▁b ps ) ▁{ ▁int ▁i , ▁j ; ▁int ▁eb ps ▁= ▁1 ▁<< ▁( b ps -1 ); ▁unsigned ▁sigma ▁= ▁0; ▁for ▁( i ▁= ▁order ; ▁i ▁< ▁len ; ▁i ++) ▁sigma ▁|= ▁decoded [ i ] ▁+ ▁eb ps ; ▁if ▁( sigma ▁< ▁2* eb ps ) ▁return ; ▁for ▁( i ▁= ▁len ▁- ▁1; ▁i ▁>= ▁order ; ▁i --) ▁{ ▁int 64_ t ▁p ▁= ▁0; ▁for ▁( j ▁= ▁0; ▁j ▁< ▁order ; ▁j ++) ▁p ▁+= ▁coeffs [ j ] ▁* ▁( int 64_ t ) decoded [ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ thread ( void ▁* arg ) ▁{ ▁Video State ▁* is ▁= ▁arg ; ▁AV Format Context ▁* ic ▁= ▁NULL ; ▁int ▁err , ▁i , ▁ret ; ▁int ▁st _ index [ AV MEDIA _ TYPE _ NB ]; ▁AV Packet ▁pkt 1, ▁* pk t ▁= ▁& pk t 1; ▁int ▁eof ▁= ▁0; ▁int ▁pkt _ in _ play _ range ▁= ▁0; ▁AV Dictionary Entry ▁* t ; ▁AV Dictionary ▁** opts ; ▁int ▁orig _ nb _ streams ; ▁SDL _ mut ex ▁* wait _ mut ex ▁= ▁SDL _ Create Mut ex (); ▁mem set ( st _ index , ▁-1, ▁sizeof ( st _ index )); ▁is -> last _ video _ stream ▁= ▁is -> vi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ x vm c _ field _ start ( M peg Enc Context ▁* s , ▁AV Codec Context ▁* av ctx ) ▁{ ▁struct ▁x vm c _ pix _ fmt ▁* last , ▁* next , ▁* render ▁= ▁( struct ▁x vm c _ pix _ fmt *) s -> current _ picture . data [2 ]; ▁const ▁int ▁mb _ block _ count ▁= ▁4 ▁+ ▁(1 ▁<< ▁s -> chrom a _ format ); ▁assert ( av ctx ); ▁if ▁(! render ▁|| ▁render -> x vm c _ id ▁!= ▁AV _ X VM C _ ID ▁|| ▁! render -> data _ blocks ▁|| ▁! render -> mv _ blocks ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Render ▁token ▁doe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁calculate _ bit rate ( AV Format Context ▁* s ) ▁{ ▁A VI Context ▁* avi ▁= ▁s -> priv _ data ; ▁int ▁i , ▁j ; ▁int 64_ t ▁len sum ▁= ▁0; ▁int 64_ t ▁max pos ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i < s -> nb _ streams ; ▁i ++) ▁{ ▁int 64_ t ▁len ▁= ▁0; ▁AV Stream ▁* st ▁= ▁s -> streams [ i ]; ▁if ▁(! st -> nb _ index _ entries ) ▁continue ; ▁for ▁( j ▁= ▁0; ▁j ▁< ▁st -> nb _ index _ entries ; ▁j ++) ▁len ▁+= ▁st -> index _ entries [ j ]. size ; ▁max pos ▁= ▁FF MAX ( max pos , ▁st -> index _ entries [ j -1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ st 16 ( TC G v ▁val , ▁TC G v ▁addr , ▁int ▁index ) ▁{ ▁tc g _ gen _ q emu _ st 16 ( val , ▁addr , ▁index ); ▁dead _ tmp ( val ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q 35 _ host _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁P CI Host Bridge Class ▁* hc ▁= ▁P CI _ HOST _ BR ID GE _ CLASS ( k lass ); ▁hc -> root _ bus _ path ▁= ▁q 35 _ host _ root _ bus _ path ; ▁dc -> real ize ▁= ▁q 35 _ host _ real ize ; ▁dc -> props ▁= ▁m ch _ props ; ▁/* ▁Reason : ▁needs ▁to ▁be ▁w ired ▁up ▁by ▁pc _ q 35 _ init ▁*/ ▁dc -> user _ cre atable ▁= ▁false ; ▁set _ bit ( DEVICE _ CATEGORY _ BR ID GE , ▁dc ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁struct ▁addr info ▁* inet _ parse _ connect _ s addr ( Inet SocketAddress ▁* s addr , ▁Error ▁** err p ) ▁{ ▁struct ▁addr info ▁ai , ▁* res ; ▁int ▁rc ; ▁Error ▁* err ▁= ▁NULL ; ▁mem set ( & ai , ▁0, ▁sizeof ( ai )); ▁ai . ai _ flags ▁= ▁AI _ CAN ON NAME ▁| ▁AI _ V 4 MAP PED ▁| ▁AI _ ADDR CONFIG ; ▁ai . ai _ family ▁= ▁inet _ ai _ family _ from _ address ( s addr , ▁& err ); ▁ai . ai _ sock type ▁= ▁SOCK _ STREAM ; ▁if ▁( err ) ▁{ ▁error _ propag ate ( err p , ▁err ); ▁return ▁NULL ; ▁} ▁if ▁( s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b amb oo _ init ( Machine State ▁* machine ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁machine -> ram _ size ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁machine -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁unsigned ▁int ▁pci _ irq _ n rs [4] ▁= ▁{ ▁28, ▁27, ▁26, ▁25 ▁}; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* isa ▁= ▁g _ new ( Memory Regio

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( stp q )( CP US 390 X State ▁* env , ▁uint 64_ t ▁addr , ▁uint 64_ t ▁low , ▁uint 64_ t ▁high ) ▁{ ▁uint ptr _ t ▁ra ▁= ▁GET PC (); ▁if ▁( parallel _ cpus ) ▁{ ▁# if nd ef ▁CONFIG _ AT OM IC 128 ▁cpu _ loop _ exit _ atomic ( ENV _ GET _ CPU ( env ), ▁ra ); ▁# else ▁int ▁mem _ idx ▁= ▁cpu _ mm u _ index ( env , ▁false ); ▁TC G Mem Op Idx ▁o i ▁= ▁make _ mem op _ idx ( MO _ TE Q ▁| ▁MO _ ALIGN _1 6, ▁mem _ idx ); ▁Int 128 ▁v ▁= ▁int 128 _ make 128 ( low , ▁high ); ▁helper _ atomic _ sto _ be

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uy 2 To UV )( uint 8_ t ▁* dst U , ▁uint 8_ t ▁* dst V , ▁uint 8_ t ▁* src 1, ▁uint 8_ t ▁* src 2, ▁long ▁width ) ▁{ ▁# if def ▁HAVE _ MM X ▁asm ▁volatile ( ▁" mov q ▁" M ANG LE ( bm 0101 0101 )", ▁%% mm 4\ n \ t " ▁" mov ▁% 0, ▁% %" REG _ a " ▁\ n \ t " ▁" 1: ▁\ n \ t " ▁" mov q ▁( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁8 ( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 1 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁%% mm 0 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁%% mm 1 ▁\ n \ t " ▁" pack u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h 26 1_ v _ loop _ filter _ c ( uint 8_ t ▁* dest , uint 8_ t ▁* src , ▁int ▁stride ){ ▁int ▁i , j , xy , yz ; ▁int ▁res ; ▁for ( i =0; ▁i < 8 ; ▁i ++){ ▁for ( j =1; ▁j < 7 ; ▁j ++){ ▁xy ▁= ▁j ▁* ▁stride ▁+ ▁i ; ▁y z ▁= ▁j ▁* ▁8 ▁+ ▁i ; ▁res ▁= ▁( int ) src [ yz -1 * 8] ▁+ ▁(( int )( src [ yz +0 * 8 ]) ▁* ▁2) ▁+ ▁( int ) src [ yz +1 * 8 ]; ▁res ▁+= 2; ▁res ▁>>= 2; ▁dest [ xy ] ▁= ▁( uint 8_ t ) res ; ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( uy vy To Y )( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁int ▁width , ▁uint 32_ t ▁* unused ) ▁{ ▁# if ▁COM PI LE _ TEMPLATE _ MM X ▁__ asm __ ▁volatile ( ▁" mov ▁% 0, ▁% %" REG _ a " ▁\ n \ t " ▁" 1: ▁\ n \ t " ▁" mov q ▁( % 1, ▁% %" REG _ a ", 2), ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁8 ( % 1, ▁% %" REG _ a ", 2), ▁%% mm 1 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁%% mm 0 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁%% mm 1 ▁\ n \ t " ▁" pack us wb ▁%% mm 1, ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁%% mm 0, ▁( % 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁simple _ number ( void ) ▁{ ▁int ▁i ; ▁struct ▁{ ▁const ▁char ▁* encoded ; ▁int 64_ t ▁decoded ; ▁int ▁skip ; ▁} ▁test _ cases [] ▁= ▁{ ▁{ ▁"0 ", ▁0 ▁}, ▁{ ▁"1234 ", ▁1234 ▁}, ▁{ ▁"1", ▁1 ▁}, ▁{ ▁"- 32 ", ▁- 32 ▁}, ▁{ ▁" -0 ", ▁0, ▁. skip ▁= ▁1 ▁}, ▁{ ▁}, ▁}; ▁for ▁( i ▁= ▁0; ▁test _ cases [ i ]. encoded ; ▁i ++) ▁{ ▁Q Int ▁* q int ; ▁q int ▁= ▁q object _ to _ q int ( q object _ from _ json ( test _ cases [ i ]. encoded , ▁NULL )); ▁g _ assert ( q int ); ▁g _ assert ( q int _ get _ int ( q 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁video _ thread ( void ▁* arg ) ▁{ ▁Video State ▁* is ▁= ▁arg ; ▁AV Frame ▁* frame ▁= ▁av codec _ alloc _ frame (); ▁int 64_ t ▁pts _ int ; ▁double ▁pts ; ▁int ▁ret ; ▁# if ▁CONFIG _ AV FILTER ▁AV Filter Graph ▁* graph ▁= ▁av filter _ graph _ alloc (); ▁AV Filter Context ▁* fil t _ out ▁= ▁NULL ; ▁int 64_ t ▁pos ; ▁int ▁last _ w ▁= ▁is -> video _ st -> codec -> width ; ▁int ▁last _ h ▁= ▁is -> video _ st -> codec -> height ; ▁if ▁(( ret ▁= ▁configure _ video _ filters ( graph , ▁is , ▁v filte

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cc id _ init fn ( US B Device ▁* dev ) ▁{ ▁USB CC ID State ▁* s ▁= ▁DO _ UP CAST ( US B CC ID State , ▁dev , ▁dev ); ▁s -> bus ▁= ▁cc id _ bus _ new ( & dev -> q dev ); ▁s -> card ▁= ▁NULL ; ▁s -> card info ▁= ▁NULL ; ▁s -> migration _ state ▁= ▁M IG R ATION _ NONE ; ▁s -> migration _ target _ ip ▁= ▁0; ▁s -> migration _ target _ port ▁= ▁0; ▁s -> dev . speed ▁= ▁USB _ SPE ED _ FULL ; ▁s -> notify _ slot _ change ▁= ▁false ; ▁s -> power ed ▁= ▁true ; ▁s -> pending _ answers _ num ▁= ▁0; ▁s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc 4 xx _ p ob _ reset ▁( void ▁* op aque ) ▁{ ▁p pc 4 xx _ p ob _ t ▁* p ob ; ▁p ob ▁= ▁opaque ; ▁/* ▁No ▁error ▁*/ ▁p ob -> be ar ▁= ▁0 x 00000000 ; ▁p ob -> bes r [0] ▁= ▁0 x 0000000 ; ▁p ob -> bes r [1] ▁= ▁0 x 0000000 ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ a es _ init ( AVA ES ▁* a , ▁const ▁uint 8_ t ▁* key , ▁int ▁key _ bits , ▁int ▁decrypt ) ▁{ ▁int ▁i , ▁j , ▁t , ▁r con pointer ▁= ▁0; ▁uint 8_ t ▁tk [ 8 ][ 4 ]; ▁int ▁K C ▁= ▁key _ bits ▁>> ▁5; ▁int ▁rounds ▁= ▁K C ▁+ ▁6 ; ▁uint 8_ t ▁log 8 [ 256 ]; ▁uint 8_ t ▁a log 8 [ 512 ]; ▁if ▁(! enc _ mult bl [ FF _ ARRAY _ E LE MS ( enc _ mult bl ) -1 ][ FF _ ARRAY _ E LE MS ( enc _ mult bl [0]) -1 ]) ▁{ ▁j ▁= ▁1; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁255 ; ▁i ++) ▁{ ▁a log 8 [ i ] ▁= ▁a log 8 [ i ▁+ ▁255 ] ▁= ▁j ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y v 12 t ou y vy )( const ▁uint 8_ t ▁* ys rc , ▁const ▁uint 8_ t ▁* us rc , ▁const ▁uint 8_ t ▁* v src , ▁uint 8_ t ▁* dst , ▁unsigned ▁int ▁width , ▁unsigned ▁int ▁height , ▁int ▁l um Stride , ▁int ▁chrom Stride , ▁int ▁dst Stride ) ▁{ ▁// FIX ME ▁interpolate ▁chrom a ▁RE NAME ( y uv Plan art ou y vy )( ys rc , ▁us rc , ▁v src , ▁dst , ▁width , ▁height , ▁l um Stride , ▁chrom Stride , ▁dst Stride , ▁2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ populate _ cpu _ dt ( CPU State ▁* cs , ▁void ▁* fd t , ▁int ▁offset , ▁s P AP R Machine State ▁* sp ap r ) ▁{ ▁Power PC CPU ▁* cpu ▁= ▁PO WER PC _ CPU ( cs ); ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ GET _ CLASS ( cs ); ▁int ▁index ▁= ▁p pc _ get _ vc pu _ dt _ id ( cpu ); ▁uint 32_ t ▁se gs [] ▁= ▁{ cpu _ to _ be 32 ( 28 ), ▁cpu _ to _ be 32 ( 40 ), ▁0 xffffffff , ▁0 xffffffff }; ▁uint 32_ t ▁tb freq ▁= ▁k vm _ enabled () ▁? ▁k 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x h ci _ k ick _ ep ctx ( X H CI EP Context ▁* ep ctx , ▁unsigned ▁int ▁stream id ) ▁{ ▁X H CI State ▁* x h ci ▁= ▁ep ctx -> x h ci ; ▁X H CI Stream Context ▁* st ctx ; ▁X H C IT rans fer ▁* x fer ; ▁X H CI Ring ▁* ring ; ▁USB Endpoint ▁* ep ▁= ▁NULL ; ▁uint 64_ t ▁mf index ; ▁int ▁length ; ▁int ▁i ; ▁trace _ usb _ x h ci _ ep _ k ick ( ep ctx -> slot id , ▁ep ctx -> ep id , ▁stream id ); ▁/* ▁If ▁the ▁device ▁has ▁been ▁detached , ▁but ▁the ▁guest ▁has ▁not ▁noticed ▁this ▁yet ▁the ▁2 ▁abo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁opt _ preset ( const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁FILE ▁* f = NULL ; ▁char ▁filename [1 000 ], ▁tmp [1 000 ], ▁tmp 2 [1 000 ], ▁line [1 000 ]; ▁int ▁i ; ▁const ▁char ▁* base [3] = ▁{ ▁getenv (" HOME "), ▁"/ usr / local / share ", ▁"/ usr / share ", ▁}; ▁for ( i = ! base [0]; ▁i < 3 ▁&& ▁! f ; ▁i ++){ ▁sn printf ( filename , ▁sizeof ( filename ), ▁"% s /% s ff mpeg /% s . ff preset ", ▁base [ i ], ▁i ▁? ▁"" ▁: ▁". ", ▁arg ); ▁f = ▁f open ( filename , ▁" r "); ▁if (! f ){ ▁char ▁* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁as f _ read _ ext _ content ( AV Format Context ▁* s , ▁const ▁GUID Parse Table ▁* g ) ▁{ ▁AS F Context ▁* as f ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁uint 64_ t ▁size ▁= ▁av io _ rl 64 ( pb ); ▁uint 16_ t ▁nb _ desc ▁= ▁av io _ rl 16 ( pb ); ▁int ▁i , ▁ret ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁nb _ desc ; ▁i ++) ▁{ ▁uint 16_ t ▁name _ len , ▁type , ▁val _ len ; ▁uint 8_ t ▁* name ▁= ▁NULL ; ▁name _ len ▁= ▁av io _ rl 16 ( pb ); ▁if ▁(! name _ len ) ▁return ▁A VER ROR _ IN V ALI DD A

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vh dx _ log _ write ( Block Driver State ▁* bs , ▁B DR V V HD X State ▁* s , ▁void ▁* data , ▁uint 32_ t ▁length , ▁uint 64_ t ▁offset ) ▁{ ▁int ▁ret ▁= ▁0; ▁void ▁* buffer ▁= ▁NULL ; ▁void ▁* merged _ sect or ▁= ▁NULL ; ▁void ▁* data _ tmp , ▁* sect or _ write ; ▁unsigned ▁int ▁i ; ▁int ▁sector _ offset ; ▁uint 32_ t ▁desc _ sect ors , ▁sector s , ▁total _ length ; ▁uint 32_ t ▁sector s _ written ▁= ▁0; ▁uint 32_ t ▁aligned _ length ; ▁uint 32_ t ▁leading _ length ▁= ▁0; ▁uint 32_ t ▁traili

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm x net 3_ net _ un init ( VM X NET 3 State ▁* s ) ▁{ ▁g _ free ( s -> m cast _ list ); ▁vm x net _ tx _ pk t _ reset ( s -> tx _ pk t ); ▁vm x net _ tx _ pk t _ un init ( s -> tx _ pk t ); ▁vm x net _ rx _ pk t _ un init ( s -> rx _ pk t ); ▁qemu _ del _ nic ( s -> nic ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁http _ prepare _ data ( HTTP Context ▁* c ) ▁{ ▁int ▁i ; ▁switch ( c -> state ) ▁{ ▁case ▁HTTP STATE _ SEND _ DATA _ HEADER : ▁mem set ( & c -> fmt _ ctx , ▁0, ▁sizeof ( c -> fmt _ ctx )); ▁if ▁( c -> stream -> feed ) ▁{ ▁/* ▁open ▁output ▁stream ▁by ▁using ▁specified ▁codecs ▁*/ ▁c -> fmt _ ctx . o format ▁= ▁c -> stream -> fmt ; ▁c -> fmt _ ctx . nb _ streams ▁= ▁c -> stream -> nb _ streams ; ▁for ( i =0; i < c -> fmt _ ctx . nb _ streams ; i ++) ▁{ ▁AV Stream ▁* st ; ▁st ▁= ▁av _ m alloc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁input _ callback ( MM AL _ PORT _ T ▁* port , ▁MM AL _ BUFFER _ HEADER _ T ▁* buffer ) ▁{ ▁if ▁(! buffer -> cmd ) ▁{ ▁AV Buffer Ref ▁* buf ▁= ▁buffer -> user _ data ; ▁av _ buffer _ un ref ( & buf ); ▁} ▁mm al _ buffer _ header _ release ( buffer ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁CPU Arch State ▁* cpu _ copy ( CPU Arch State ▁* env ) ▁{ ▁CPU State ▁* cpu ▁= ▁ENV _ GET _ CPU ( env ); ▁CPU State ▁* new _ cpu ▁= ▁cpu _ init ( cpu _ model ); ▁CPU Arch State ▁* new _ env ▁= ▁cpu -> env _ ptr ; ▁CP UB reak point ▁* bp ; ▁CPU Watch point ▁* wp ; ▁/* ▁Reset ▁non ▁arch ▁specific ▁state ▁*/ ▁cpu _ reset ( new _ cpu ); ▁mem c py ( new _ env , ▁env , ▁sizeof ( CPU Arch State )); ▁/* ▁Clone ▁all ▁break / watch points . ▁Note : ▁Once ▁we ▁support ▁p trace ▁with ▁hw - debug ▁register ▁access , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ l um a _ vt _ and _ aver _ dst _16 x 16_ ms a ( const ▁uint 8_ t ▁* src , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride ) ▁{ ▁int 32_ t ▁loop _ cnt ; ▁int 16_ t ▁filt _ const 0 ▁= ▁0 xf b 01 ; ▁int 16_ t ▁filt _ const 1 ▁= ▁0 x 14 14 ; ▁int 16_ t ▁filt _ const 2 ▁= ▁0 x 1 fb ; ▁v 16 u 8 ▁dst 0, ▁dst 1, ▁dst 2, ▁dst 3; ▁v 16 i 8 ▁src 0, ▁src 1, ▁src 2, ▁src 3, ▁src 4, ▁src 5, ▁src 6, ▁src 7, ▁src 8 ; ▁v 16 i 8 ▁src 10_ r , ▁src 32_ r , ▁src 54 _ r , ▁src 76 _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ socket _ can _ send ( void ▁* op aque ) ▁{ ▁Net Socket State ▁* s ▁= ▁opaque ; ▁return ▁qemu _ can _ send _ packet ( & s -> nc ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ prep _ init ▁( ram _ addr _ t ▁ram _ size , ▁const ▁char ▁* boot _ device , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁CPU State ▁* env ▁= ▁NULL ; ▁char ▁* filename ; ▁nv ram _ t ▁nv ram ; ▁M 48 t 59 State ▁* m 48 t 59 ; ▁int ▁P PC _ io _ memory ; ▁int ▁linux _ boot , ▁i , ▁nb _ n ics 1, ▁b ios _ size ; ▁ram _ addr _ t ▁ram _ offset , ▁b ios _ offset ; ▁uint 32_ t ▁kernel _ base , ▁init

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁copy _ picture _ field ( Inter lace Context ▁* s , ▁AV Frame ▁* src _ frame , ▁AV Frame ▁* dst _ frame , ▁AV Filter Link ▁* in link , ▁enum ▁FieldType ▁field _ type , ▁int ▁low pass ) ▁{ ▁const ▁AV Pix F mt Descriptor ▁* desc ▁= ▁av _ pix _ fmt _ desc _ get ( in link -> format ); ▁int ▁h sub ▁= ▁desc -> log 2_ chrom a _ w ; ▁int ▁v sub ▁= ▁desc -> log 2_ chrom a _ h ; ▁int ▁plane , ▁j ; ▁for ▁( plane ▁= ▁0; ▁plane ▁< ▁desc -> nb _ components ; ▁plane ++) ▁{ ▁int ▁cols ▁= ▁( plane ▁== ▁1 ▁||

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁helper _ rd h wr _ cp un um ( CP UM IP S State ▁* env ) ▁{ ▁check _ hw ren a ( env , ▁0); ▁return ▁env -> CP 0_ E Base ▁& ▁0 x 3 ff ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ inject _ n mi ( Error ▁** err p ) ▁{ ▁# if ▁defined ( TARGET _ I 38 6) ▁CPU State ▁* cs ; ▁CPU _ FORE A CH ( cs ) ▁{ ▁X 86 CPU ▁* cpu ▁= ▁X 86_ CPU ( cs ); ▁if ▁(! cpu -> ap ic _ state ) ▁{ ▁cpu _ interrupt ( cs , ▁CPU _ INTER R UP T _ N MI ); ▁} ▁else ▁{ ▁ap ic _ del iver _ n mi ( cpu -> ap ic _ state ); ▁} ▁} ▁# el if ▁defined ( TARGET _ S 390 X ) ▁CPU State ▁* cs ; ▁S 390 CPU ▁* cpu ; ▁CPU _ FORE A CH ( cs ) ▁{ ▁cpu ▁= ▁S 39 0_ CPU ( cs ); ▁if ▁( cpu -> env . cpu _ num ▁== ▁monitor _ get 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ single _ step ( CPU X 86 State ▁* env ) ▁{ ▁# if nd ef ▁CONFIG _ USER _ ONLY ▁check _ hw _ break points ( env , ▁1); ▁env -> dr [ 6] ▁|= ▁DR 6_ BS ; ▁# end if ▁raise _ exception ( env , ▁EX CP 01_ DB ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁rv 40 _ weak _ loop _ filter ( uint 8_ t ▁* src , ▁const ▁int ▁step , ▁const ▁int ▁stride , ▁const ▁int ▁filter _ p 1, ▁const ▁int ▁filter _ q 1, ▁const ▁int ▁alpha , ▁const ▁int ▁beta , ▁const ▁int ▁lim _ p 0 q 0, ▁const ▁int ▁lim _ q 1, ▁const ▁int ▁lim _ p 1) ▁{ ▁uint 8_ t ▁* cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ; ▁int ▁i , ▁t , ▁u , ▁diff ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++, ▁src ▁+= ▁stride ) ▁{ ▁int ▁diff _ p 1 p 0 ▁= ▁src [ -2 * step ] ▁- ▁src [-1 * step ]

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁con _ disconnect ( struct ▁X en Device ▁* x end ev ) ▁{ ▁struct ▁X en Console ▁* con ▁= ▁container _ of ( x end ev , ▁struct ▁X en Console , ▁x end ev ); ▁if ▁( con -> chr ) ▁{ ▁qemu _ chr _ add _ handlers ( con -> chr , ▁NULL , ▁NULL , ▁NULL , ▁NULL ); ▁qemu _ chr _ fe _ release ( con -> chr ); ▁} ▁xen _ be _ un bind _ evt chn ( & con -> x end ev ); ▁if ▁( con -> s ring ) ▁{ ▁if ▁(! x end ev -> dev ) ▁{ ▁m un map ( con -> s ring , ▁X C _ PAGE _ SIZE ); ▁} ▁else ▁{ ▁x eng nt tab _ un map ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁normalize _ bits ( int ▁num , ▁int ▁width ) ▁{ ▁if ▁(! num ) ▁return ▁0; ▁if ▁( num ▁== ▁-1) ▁return ▁width ; ▁if ▁( num ▁< ▁0) ▁num ▁= ▁~ num ; ▁return ▁width ▁- ▁av _ log 2( num ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁xen _ pc i _ pas sthrough _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁PC ID evice Class ▁* k ▁= ▁P CI _ DEVICE _ CLASS ( k lass ); ▁k -> real ize ▁= ▁xen _ pt _ real ize ; ▁k -> exit ▁= ▁xen _ pt _ un register _ device ; ▁k -> config _ read ▁= ▁xen _ pt _ pc i _ read _ config ; ▁k -> config _ write ▁= ▁xen _ pt _ pc i _ write _ config ; ▁set _ bit ( DEVICE _ CATEGORY _ MI SC , ▁dc -> categories ); ▁dc -> desc ▁= ▁" Assign 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁oh ci _ bus _ start ( O H CI State ▁* oh ci ) ▁{ ▁oh ci -> eof _ timer ▁= ▁timer _ new _ ns ( Q EM U _ C LOCK _ VI RTUAL , ▁oh ci _ frame _ boundary , ▁oh ci ); ▁if ▁( oh ci -> eof _ timer ▁== ▁NULL ) ▁{ ▁trace _ usb _ oh ci _ bus _ eof _ timer _ failed ( oh ci -> name ); ▁oh ci _ d ie ( oh ci ); ▁return ▁0; ▁} ▁trace _ usb _ oh ci _ start ( oh ci -> name ); ▁/* ▁Delay ▁the ▁first ▁SO F ▁event ▁by ▁one ▁frame ▁time ▁as ▁* ▁linux ▁driver ▁is ▁not ▁ready ▁to ▁receive ▁it ▁and ▁* ▁can ▁meet ▁so

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ image _ info _ specific _ dump ( f printf _ function ▁func _ f printf , ▁void ▁* f , ▁Image Info Specific ▁* info _ spec ) ▁{ ▁Q Object ▁* obj , ▁* data ; ▁Visitor ▁* v ▁= ▁q mp _ output _ visitor _ new ( & obj ); ▁visit _ type _ Image Info Specific ( v , ▁NULL , ▁& info _ spec , ▁& error _ abort ); ▁visit _ complete ( v , ▁& obj ); ▁assert ( q object _ type ( obj ) ▁== ▁Q TYPE _ Q DICT ); ▁data ▁= ▁q dict _ get ( q object _ to _ q dict ( obj ), ▁" data "); ▁dump _ q object ( func _ f prin

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁srt _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ sub _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁AV Sub title ▁* sub ▁= ▁data ; ▁AV B Print ▁buffer ; ▁int ▁x 1 ▁= ▁-1, ▁y 1 ▁= ▁-1, ▁x 2 ▁= ▁-1, ▁y 2 ▁= ▁-1; ▁int ▁size , ▁ret ; ▁const ▁uint 8_ t ▁* p ▁= ▁av _ packet _ get _ side _ data ( av pk t , ▁AV _ PK T _ DATA _ SUB TITLE _ POSITION , ▁& size ); ▁F FA SS Decoder Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁if ▁( p ▁&& ▁size ▁== ▁16 ) ▁{ ▁x 1 ▁= ▁AV _ RL 32 ( p ▁); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁filter _ slice ( AV Filter Context ▁* ctx , ▁void ▁* arg , ▁int ▁job nr , ▁int ▁nb _ jobs ) ▁{ ▁Y AD IF Context ▁* s ▁= ▁ctx -> priv ; ▁Thread Data ▁* td ▁= ▁arg ; ▁int ▁refs ▁= ▁s -> cur -> lines ize [ td -> plane ]; ▁int ▁df ▁= ▁( s -> c sp -> comp [ td -> plane ]. depth _ minus 1 ▁+ ▁8) ▁/ ▁8 ; ▁int ▁pix _3 ▁= ▁3 ▁* ▁df ; ▁int ▁slice _ h ▁= ▁td -> h ▁/ ▁nb _ jobs ; ▁int ▁slice _ start ▁= ▁job nr ▁* ▁slice _ h ; ▁int ▁slice _ end ▁= ▁( job nr ▁== ▁nb _ jobs ▁- ▁1) ▁? ▁td -> h ▁: ▁( job nr 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁p pc 64_ v 3_ handle _ mm u _ fault ( Power PC CPU ▁* cpu , ▁v addr ▁e addr , ▁int ▁r wx , ▁int ▁mm u _ idx ) ▁{ ▁if ▁( pp c 64_ rad ix _ guest ( cpu )) ▁{ ▁/* ▁Gu est ▁uses ▁radix ▁*/ ▁/* ▁TODO ▁- ▁Unsupported ▁*/ ▁error _ report (" Guest ▁Rad ix ▁Support ▁Un implemented "); ▁exit (1); ▁} ▁else ▁{ ▁/* ▁Gu est ▁uses ▁hash ▁*/ ▁return ▁p pc _ hash 64_ handle _ mm u _ fault ( cpu , ▁e addr , ▁r wx , ▁mm u _ idx ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ img _ read _ packet ( AV Format Context ▁* s 1, ▁AV Packet ▁* pk t ) ▁{ ▁Video Dem ux Data ▁* s ▁= ▁s 1 -> priv _ data ; ▁char ▁filename _ bytes [10 24 ]; ▁char ▁* filename ▁= ▁filename _ bytes ; ▁int ▁i ; ▁int ▁size [3] ▁= ▁{ ▁0 ▁}, ▁ret [3] ▁= ▁{ ▁0 ▁}; ▁AV IO Context ▁* f [3] ▁= ▁{ ▁NULL ▁}; ▁AV Codec Context ▁* codec ▁= ▁s 1 -> streams [0] -> codec ; ▁if ▁(! s -> is _ pipe ) ▁{ ▁/* ▁loop ▁over ▁input ▁*/ ▁if ▁( s -> loop ▁&& ▁s -> img _ number ▁> ▁s -> img _ last ) ▁{ ▁s -> img _ number ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ide _ data _ writ ew ( void ▁* op aque , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁IDE Bus ▁* bus ▁= ▁opaque ; ▁IDE State ▁* s ▁= ▁id eb us _ active _ if ( bus ); ▁uint 8_ t ▁* p ; ▁/* ▁P IO ▁data ▁access ▁allowed ▁only ▁when ▁DR Q ▁bit ▁is ▁set ▁*/ ▁if ▁(! ( s -> status ▁& ▁DR Q _ STAT )) ▁return ; ▁p ▁= ▁s -> data _ ptr ; ▁* ( uint 16_ t ▁* ) p ▁= ▁le 16_ to _ cpu ( val ); ▁p ▁+= ▁2; ▁s -> data _ ptr ▁= ▁p ; ▁if ▁( p ▁>= ▁s -> data _ end ) ▁s -> end _ transfer _ func ( s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁quantize _ and _ encode _ band _ cost _ S PA IR _ m ips ( struct ▁A AC Enc Context ▁* s , ▁Put Bit Context ▁* pb , ▁const ▁float ▁* in , ▁float ▁* out , ▁const ▁float ▁* scaled , ▁int ▁size , ▁int ▁scale _ idx , ▁int ▁cb , ▁const ▁float ▁lambda , ▁const ▁float ▁u pl im , ▁int ▁* bits , ▁const ▁float ▁ROUND ING ) ▁{ ▁const ▁float ▁Q 34 ▁= ▁ff _ a ac _ pow 34 sf _ tab [ PO W _ S F 2_ ZERO ▁- ▁scale _ idx ▁+ ▁S CALE _ ONE _ POS ▁- ▁S CALE _ DIV _5 12 ]; ▁const ▁float ▁I Q ▁= ▁ff _ a ac _ pow 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁stream _ component _ open ( Player State ▁* is , ▁int ▁stream _ index ) ▁{ ▁AV Format Context ▁* ic ▁= ▁is -> ic ; ▁AV Codec Context ▁* av ctx ; ▁AV Codec ▁* codec ; ▁SDL _ Audio Spec ▁wanted _ spec , ▁spec ; ▁AV Dictionary ▁* opts ; ▁AV Dictionary Entry ▁* t ▁= ▁NULL ; ▁int ▁ret ▁= ▁0; ▁if ▁( stream _ index ▁< ▁0 ▁|| ▁stream _ index ▁>= ▁ic -> nb _ streams ) ▁return ▁-1; ▁av ctx ▁= ▁ic -> streams [ stream _ index ] -> codec ; ▁opts ▁= ▁filter _ codec _ opts ( codec _ opts , ▁av ctx -> codec

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁keyword _ literal ( void ) ▁{ ▁Q Object ▁* obj ; ▁Q Bool ▁* q bool ; ▁Q Object ▁* null ; ▁Q String ▁* str ; ▁obj ▁= ▁q object _ from _ json (" true ", ▁NULL ); ▁q bool ▁= ▁q object _ to _ q bool ( obj ); ▁g _ assert ( q bool ); ▁g _ assert ( q bool _ get _ bool ( q bool ) ▁== ▁true ); ▁str ▁= ▁q object _ to _ json ( obj ); ▁g _ assert ( str cmp ( q string _ get _ str ( str ), ▁" true ") ▁== ▁0); ▁Q DE CRE F ( str ); ▁Q DE CRE F ( q bool ); ▁obj ▁= ▁q object _ from _ json (" false ", ▁NULL )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ core 99 _ init ▁( ram _ addr _ t ▁ram _ size , ▁const ▁char ▁* boot _ device , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁CPU State ▁* env ▁= ▁NULL , ▁* envs [ MAX _ CP US ]; ▁char ▁* filename ; ▁qemu _ irq ▁* pic , ▁** open pic _ ir qs ; ▁int ▁un in _ memory ; ▁int ▁linux _ boot , ▁i ; ▁ram _ addr _ t ▁ram _ offset , ▁b ios _ offset , ▁v ga _ b ios _ offset ; ▁uint 32_ t ▁kernel _ base

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁D MA _ run ( void ) ▁{ ▁/* ▁X XXXX ▁*/ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁IN LINE ▁int 16 ▁extract Float 64 Exp ( ▁float 64 ▁a ▁) ▁{ ▁return ▁( ▁a >> 52 ▁) ▁& ▁0 x 7 FF ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁helper _ fc mp _ un ( uint 32_ t ▁a , ▁uint 32_ t ▁b ) ▁{ ▁CPU _ Float U ▁fa , ▁fb ; ▁uint 32_ t ▁r ▁= ▁0; ▁fa . l ▁= ▁a ; ▁fb . l ▁= ▁b ; ▁if ▁( float 32_ is _ signal ing _ nan ( fa . f ) ▁|| ▁float 32_ is _ signal ing _ nan ( fb . f )) ▁{ ▁update _ f pu _ flags ( float _ flag _ invalid ); ▁r ▁= ▁1; ▁} ▁if ▁( float 32_ is _ nan ( fa . f ) ▁|| ▁float 32_ is _ nan ( fb . f )) ▁{ ▁r ▁= ▁1; ▁} ▁return ▁r ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v host _ user _ start ( V host User State ▁* s ) ▁{ ▁V host Net Options ▁options ; ▁if ▁( v host _ user _ running ( s )) ▁{ ▁return ▁0; ▁} ▁options . backend _ type ▁= ▁V HOST _ BACK END _ TYPE _ USER ; ▁options . net _ backend ▁= ▁& s -> nc ; ▁options . op aque ▁= ▁s -> chr ; ▁s -> v host _ net ▁= ▁v host _ net _ init ( & options ); ▁return ▁v host _ user _ running ( s ) ▁? ▁0 ▁: ▁-1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a la c _ set _ info ( AL AC Context ▁* al ac ) ▁{ ▁Get Byte Context ▁gb ; ▁by test ream 2_ init ( & gb , ▁a la c -> av ctx -> ex tr ad ata , ▁a la c -> av ctx -> ex tr ad ata _ size ); ▁by test ream 2_ skip u ( & gb , ▁12 ); ▁// ▁size : 4, ▁a la c : 4, ▁version :4 ▁a la c -> max _ samples _ per _ frame ▁= ▁by test ream 2_ get _ be 32 u ( & gb ); ▁if ▁( al ac -> max _ samples _ per _ frame ▁>= ▁U INT _ MAX /4 ){ ▁av _ log ( al ac -> av ctx , ▁AV _ LOG _ ERROR , ▁" max _ samples _ per _ frame 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd h ci _ send _ command ( SD H CI State ▁* s ) ▁{ ▁SD Request ▁request ; ▁uint 8_ t ▁response [ 16 ]; ▁int ▁r len ; ▁s -> er rint st s ▁= ▁0; ▁s -> ac md 12 err st s ▁= ▁0; ▁request . cmd ▁= ▁s -> cmd reg ▁>> ▁8 ; ▁request . arg ▁= ▁s -> argument ; ▁D PRI NT _ L 1 (" s ending ▁CMD % u ▁ARG [0 x % 08 x ]\ n ", ▁request . cmd , ▁request . arg ); ▁r len ▁= ▁s db us _ do _ command ( & s -> s db us , ▁& request , ▁response ); ▁if ▁( s -> cmd reg ▁& ▁SD H C _ CMD _ RESPONSE ) ▁{ ▁if ▁( rl en ▁==

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ de alloc _ types ( void ) ▁{ ▁User Def One ▁* ud 1 test , ▁* ud 1 a , ▁* ud 1 b ; ▁User Def One List ▁* ud 1 list ; ▁ud 1 test ▁= ▁g _ m alloc 0( size of ( User Def One )); ▁ud 1 test -> base ▁= ▁g _ new 0( User Def Zero , ▁1); ▁ud 1 test -> base -> integer ▁= ▁42 ; ▁ud 1 test -> string ▁= ▁g _ str dup (" hi ▁there ▁42 "); ▁q api _ free _ User Def One ( ud 1 test ); ▁ud 1 a ▁= ▁g _ m alloc 0( size of ( User Def One )); ▁ud 1 a -> base ▁= ▁g _ new 0( User Def Zero , ▁1); ▁ud 1 a -> ba

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁net _ checksum _ calculate ( uint 8_ t ▁* data , ▁int ▁length ) ▁{ ▁int ▁h len , ▁pl en , ▁proto , ▁c sum _ offset ; ▁uint 16_ t ▁c sum ; ▁if ▁(( data [ 14 ] ▁& ▁0 xf 0) ▁!= ▁0 x 40 ) ▁return ; ▁/* ▁not ▁IPv 4 ▁*/ ▁h len ▁= ▁( data [ 14 ] ▁& ▁0 x 0 f ) ▁* ▁4; ▁pl en ▁= ▁( data [ 16 ] ▁<< ▁8 ▁| ▁data [ 17 ]) ▁- ▁h len ; ▁proto ▁= ▁data [ 23 ]; ▁switch ▁( proto ) ▁{ ▁case ▁PRO TO _ TCP : ▁c sum _ offset ▁= ▁16 ; ▁break ; ▁case ▁PRO TO _ UDP : ▁c sum _ offset ▁= ▁6 ; ▁break ; ▁default : ▁return ; ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x 86_ cpu _ parse _ feature str ( const ▁char ▁* typ ename , ▁char ▁* features , ▁Error ▁** err p ) ▁{ ▁char ▁* feature str ; ▁/* ▁Single ▁' key = value " ▁string ▁being ▁parsed ▁*/ ▁static ▁bool ▁cpu _ globals _ initialized ; ▁bool ▁ambiguous ▁= ▁false ; ▁if ▁( cpu _ globals _ initialized ) ▁{ ▁return ; ▁} ▁cpu _ globals _ initialized ▁= ▁true ; ▁if ▁(! features ) ▁{ ▁return ; ▁} ▁for ▁( feature str ▁= ▁str tok ( features , ▁", "); ▁feature str ; ▁feature str ▁= ▁str tok ( NULL , ▁", ")) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁V irt IO SC SI V ring ▁* virt io _ sc si _ v ring _ init ( V irt IO SC SI ▁* s , ▁V irt Queue ▁* v q , ▁Event Notifier Handler ▁* handler , ▁int ▁n ) ▁{ ▁Bus State ▁* q bus ▁= ▁B US ( q dev _ get _ parent _ bus ( DEVICE ( s ))); ▁V irt io Bus Class ▁* k ▁= ▁VI RT IO _ B US _ GET _ CLASS ( q bus ); ▁V irt IO SC SI V ring ▁* r ▁= ▁g _ slice _ new ( V irt IO SC SI V ring ); ▁int ▁rc ; ▁/* ▁Set ▁up ▁virt queue ▁notify ▁*/ ▁rc ▁= ▁k -> set _ host _ notifier ( q bus -> parent , ▁n , ▁true ); ▁if ▁( rc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ net _ queue _ pur ge ( Net Queue ▁* queue , ▁Net Client State ▁* from ) ▁{ ▁Net Packet ▁* packet , ▁* next ; ▁Q TAIL Q _ FORE A CH _ SAFE ( packet , ▁& queue -> pack ets , ▁entry , ▁next ) ▁{ ▁if ▁( packet -> sender ▁== ▁from ) ▁{ ▁Q TAIL Q _ REMOVE ( & queue -> pack ets , ▁packet , ▁entry ); ▁g _ free ( packet ); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁s size _ t ▁v nc _ client _ read _ tls ( gn ut ls _ session _ t ▁* session , ▁uint 8_ t ▁* data , ▁size _ t ▁dat al en ) ▁{ ▁s size _ t ▁ret ▁= ▁gn ut ls _ read (* session , ▁data , ▁dat al en ); ▁if ▁( ret ▁< ▁0) ▁{ ▁if ▁( ret ▁== ▁G N UT LS _ E _ AG AIN ) ▁{ ▁errno ▁= ▁E AG AIN ; ▁} ▁else ▁{ ▁errno ▁= ▁E IO ; ▁} ▁ret ▁= ▁-1; ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁slice _ end ( AV Codec Context ▁* av ctx , ▁AV Frame ▁* p ict ) ▁{ ▁M peg 1 Context ▁* s 1 ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& s 1 -> mpeg _ enc _ ctx ; ▁if ▁(! s 1 -> mpeg _ enc _ ctx _ allocated ▁|| ▁! s -> current _ picture _ ptr ) ▁return ▁0; ▁if ▁( s -> av ctx -> hw accel ) ▁{ ▁if ▁( s -> av ctx -> hw accel -> end _ frame ( s -> av ctx ) ▁< ▁0) ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" h ardware ▁accel erator ▁failed ▁to ▁decode ▁picture \ n "); ▁} ▁# if ▁FF _ AP

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁m peg 2_ fast _ decode _ block _ non _ in tra ( M peg Enc Context ▁* s , ▁int 16_ t ▁* block , ▁int ▁n ) ▁{ ▁int ▁level , ▁i , ▁j , ▁run ; ▁R L Table ▁* rl ▁= ▁& ff _ rl _ mpeg 1; ▁uint 8_ t ▁* ▁const ▁sc ant able ▁= ▁s -> in tra _ sc ant able . perm ut ated ; ▁const ▁int ▁q scale ▁= ▁s -> q scale ; ▁OPEN _ RE ADER ( re , ▁& s -> gb ); ▁i ▁= ▁-1; ▁// ▁special ▁case ▁for ▁first ▁coefficient , ▁no ▁need ▁to ▁add ▁second ▁V LC ▁table ▁UPDATE _ CACHE ( re , ▁& s -> gb ); ▁if ▁( (( int 32

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁stream _ close ( Video State ▁* is ) ▁{ ▁Video Picture ▁* vp ; ▁int ▁i ; ▁/* ▁XXX : ▁use ▁a ▁special ▁url _ shutdown ▁call ▁to ▁abort ▁parse ▁clean ly ▁*/ ▁is -> abort _ request ▁= ▁1; ▁SDL _ Wait Thread ( is -> read _ tid , ▁NULL ); ▁SDL _ Wait Thread ( is -> refresh _ tid , ▁NULL ); ▁packet _ queue _ destroy ( & is -> video q ); ▁packet _ queue _ destroy ( & is -> audio q ); ▁packet _ queue _ destroy ( & is -> sub title q ); ▁/* ▁free ▁all ▁pictures ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁VI DEO _ PI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ gain _ table ( CO OK Context ▁* q ) ▁{ ▁int ▁i ; ▁q -> gain _ size _ factor ▁= ▁q -> samples _ per _ channel /8 ; ▁for ▁( i =0 ▁; ▁i < 23 ▁; ▁i ++) ▁{ ▁q -> gain _ table [ i ] ▁= ▁pow (( double ) q -> pow 2 tab [ i + 5 2] ▁, ▁( 1.0 /( double ) q -> gain _ size _ factor )); ▁} ▁mem set ( & q -> gain _ copy , ▁0, ▁sizeof ( CO OK gain )); ▁mem set ( & q -> gain _ current , ▁0, ▁sizeof ( CO OK gain )); ▁mem set ( & q -> gain _ now , ▁0, ▁sizeof ( CO OK gain )); ▁mem set ( & q -> gain _ p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q pa _ f ini _ out ▁( H W Voice Out ▁* hw ) ▁{ ▁void ▁* ret ; ▁PA Voice Out ▁* pa ▁= ▁( PA Voice Out ▁* ) ▁hw ; ▁audio _ pt _ lock ▁( & pa -> pt , ▁AU DIO _ F UNC ); ▁pa -> done ▁= ▁1; ▁audio _ pt _ un lock _ and _ signal ▁( & pa -> pt , ▁AU DIO _ F UNC ); ▁audio _ pt _ join ▁( & pa -> pt , ▁& ret , ▁AU DIO _ F UNC ); ▁if ▁( pa -> s ) ▁{ ▁pa _ simple _ free ▁( pa -> s ); ▁pa -> s ▁= ▁NULL ; ▁} ▁audio _ pt _ f ini ▁( & pa -> pt , ▁AU DIO _ F UNC ); ▁g _ free ▁( pa -> pc m _ buf ); ▁pa -> pc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ device _ init ( SC S ID evice ▁* s ) ▁{ ▁S CS ID evice Class ▁* sc ▁= ▁SC SI _ DEVICE _ GET _ CLASS ( s ); ▁if ▁( sc -> init ) ▁{ ▁return ▁sc -> init ( s ); ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁set _ dirty _ bitmap ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int ▁dirty ) ▁{ ▁int 64_ t ▁start , ▁end ; ▁unsigned ▁long ▁val , ▁idx , ▁bit ; ▁start ▁= ▁sector _ num ▁/ ▁B DR V _ SE CT ORS _ PER _ DIR TY _ CHUNK ; ▁end ▁= ▁( sect or _ num ▁+ ▁nb _ sect ors ▁- ▁1) ▁/ ▁B DR V _ SE CT ORS _ PER _ DIR TY _ CHUNK ; ▁for ▁( ; ▁start ▁<= ▁end ; ▁start ++) ▁{ ▁idx ▁= ▁start ▁/ ▁( size of ( un signed ▁long ) ▁* ▁8 ); ▁bit ▁= ▁start ▁% ▁( size of ( un signed ▁lon

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁size _ t ▁net _ tx _ pk t _ fetch _ fragment ( struct ▁Net Tx P kt ▁* pk t , ▁int ▁* src _ idx , ▁size _ t ▁* src _ offset , ▁struct ▁i ove c ▁* dst , ▁int ▁* dst _ idx ) ▁{ ▁size _ t ▁fetched ▁= ▁0; ▁struct ▁i ove c ▁* src ▁= ▁pkt -> vec ; ▁* dst _ idx ▁= ▁NET _ TX _ PK T _ FR AGMENT _ HEADER _ NUM ; ▁while ▁( f etched ▁< ▁pkt -> virt _ hdr . gs o _ size ) ▁{ ▁/* ▁no ▁more ▁place ▁in ▁fragment ▁i ov ▁*/ ▁if ▁(* dst _ idx ▁== ▁NET _ MAX _ FR AG _ S G _ LIST ) ▁{ ▁break ; ▁} ▁/* ▁no ▁more ▁data ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l si _ ram _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁L SI State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁new val ; ▁uint 32_ t ▁mask ; ▁int ▁shift ; ▁new val ▁= ▁s -> script _ ram [ addr ▁>> ▁2 ]; ▁shift ▁= ▁( addr ▁& ▁3) ▁* ▁8 ; ▁mask ▁= ▁(( uint 64_ t ) 1 ▁<< ▁( size ▁* ▁8 )) ▁- ▁1; ▁new val ▁&= ▁~ ( mask ▁<< ▁shift ); ▁new val ▁|= ▁val ▁<< ▁shift ; ▁s -> script _ ram [ addr ▁>> ▁2] ▁= ▁new val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ buffer _ s ao ( HE VC Context ▁* s , ▁AV Frame ▁* frame , ▁const ▁HE VC SP S ▁* sp s ) ▁{ ▁int ▁ret , ▁i ; ▁frame -> width ▁= ▁s -> av ctx -> width ▁+ ▁2; ▁frame -> height ▁= ▁s -> av ctx -> height ▁+ ▁2; ▁if ▁(( ret ▁= ▁ff _ get _ buffer ( s -> av ctx , ▁frame , ▁AV _ GET _ BUFFER _ FLAG _ REF )) ▁< ▁0) ▁return ▁ret ; ▁for ▁( i ▁= ▁0; ▁frame -> data [ i ]; ▁i ++) ▁{ ▁int ▁offset ▁= ▁frame -> lines ize [ i ] ▁+ ▁(1 ▁<< ▁sp s -> pixel _ shift ); ▁frame -> data [ i ] ▁+= ▁offset ; ▁} ▁fr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ l um a _ vt _16 w _ ms a ( const ▁uint 8_ t ▁* src , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride , ▁int 32_ t ▁height ) ▁{ ▁int 32_ t ▁loop _ cnt ; ▁int 16_ t ▁filt _ const 0 ▁= ▁0 xf b 01 ; ▁int 16_ t ▁filt _ const 1 ▁= ▁0 x 14 14 ; ▁int 16_ t ▁filt _ const 2 ▁= ▁0 x 1 fb ; ▁v 16 i 8 ▁src 0, ▁src 1, ▁src 2, ▁src 3, ▁src 4, ▁src 5, ▁src 6, ▁src 7, ▁src 8 ; ▁v 16 i 8 ▁src 10_ r , ▁src 32_ r , ▁src 54 _ r , ▁src 76 _ r , ▁src 2 1_ r , ▁src 4 3_ r , ▁src 65 _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁img _ commit ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁int ▁c , ▁ret , ▁flags ; ▁const ▁char ▁* filename , ▁* fmt , ▁* cache , ▁* base ; ▁Block Backend ▁* blk ; ▁Block Driver State ▁* bs , ▁* base _ bs ; ▁bool ▁progress ▁= ▁false , ▁quiet ▁= ▁false , ▁drop ▁= ▁false ; ▁bool ▁writ eth rough ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁Common Block Job CB Info ▁cb i ; ▁bool ▁image _ opts ▁= ▁false ; ▁A io Context ▁* a io _ context ; ▁fmt ▁= ▁NULL ; ▁cache ▁= ▁B DR V _ DEFAULT _ CACHE ; ▁base ▁= ▁NULL ; ▁for 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁unsigned ▁long ▁setup _ arg _ pages ( void ▁* ▁mh , ▁char ▁** ▁argv , ▁char ▁** ▁env ) ▁{ ▁unsigned ▁long ▁stack _ base , ▁error , ▁size ; ▁int ▁i ; ▁int ▁* ▁stack ; ▁int ▁arg c , ▁env c ; ▁/* ▁Create ▁enough ▁stack ▁to ▁hold ▁everything . ▁If ▁we ▁don ' t ▁use ▁* ▁it ▁for ▁args , ▁we ' ll ▁use ▁it ▁for ▁something ▁else ... ▁*/ ▁size ▁= ▁stack _ size ; ▁error ▁= ▁target _ m map (0, ▁size ▁+ ▁qemu _ host _ page _ size , ▁PRO T _ READ ▁| ▁PRO T _ WRITE , ▁MAP _ PRIVATE ▁| ▁MAP _ AN ONY MO US , ▁-1, ▁0); ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sd _ do _ command ( SD State ▁* sd , ▁SD Request ▁* req , ▁uint 8_ t ▁* response ) ▁{ ▁uint 32_ t ▁last _ status ▁= ▁sd -> card _ status ; ▁sd _ r sp _ type _ t ▁r type ; ▁int ▁rs pl en ; ▁if ▁(! sd -> b dr v ▁|| ▁! b dr v _ is _ insert ed ( sd -> b dr v ) ▁|| ▁! sd -> enable ) ▁{ ▁return ▁0; ▁} ▁if ▁( sd _ req _ crc _ validate ( req )) ▁{ ▁sd -> card _ status ▁|= ▁COM _ C RC _ ERROR ; ▁r type ▁= ▁sd _ il legal ; ▁goto ▁send _ response ; ▁} ▁sd -> card _ status ▁&= ▁~ C ARD _ STATUS _ B ; ▁sd _ set 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ x 86_ cp uid ( CPU X 86 State ▁* env , ▁uint 32_ t ▁index , ▁uint 32_ t ▁count , ▁uint 32_ t ▁* e ax , ▁uint 32_ t ▁* eb x , ▁uint 32_ t ▁* ec x , ▁uint 32_ t ▁* ed x ) ▁{ ▁X 86 CPU ▁* cpu ▁= ▁x 86_ env _ get _ cpu ( env ); ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁uint 32_ t ▁pkg _ offset ; ▁/* ▁test ▁if ▁maximum ▁index ▁reached ▁*/ ▁if ▁( index ▁& ▁0 x 8 0000000 ) ▁{ ▁if ▁( index ▁> ▁env -> cp uid _ x level ) ▁{ ▁if ▁( env -> cp uid _ x level 2 ▁> ▁0) ▁{ ▁/* ▁Handle ▁the ▁Cent aur ' s ▁CP UID ▁ins

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁prepare _ app _ arguments ( int ▁* arg c _ ptr , ▁char ▁*** argv _ ptr ) ▁{ ▁char ▁* arg str _ flat ; ▁w char _ t ▁** argv _ w ; ▁int ▁i , ▁buff size ▁= ▁0, ▁offset ▁= ▁0; ▁if ▁( win 32_ argv _ utf 8) ▁{ ▁* arg c _ ptr ▁= ▁win 32_ arg c ; ▁* argv _ ptr ▁= ▁win 32_ argv _ utf 8 ; ▁return ; ▁} ▁win 32_ arg c ▁= ▁0; ▁argv _ w ▁= ▁CommandLine To Arg v W ( Get CommandLine W (), ▁& win 32_ arg c ); ▁if ▁( win 32_ arg c ▁<= ▁0 ▁|| ▁! argv _ w ) ▁return ; ▁/* ▁determine ▁the ▁UTF -8 ▁buffer ▁size ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ ne on _ add l _ s atur ate ( TC G v ▁op 0, ▁TC G v ▁op 1, ▁int ▁size ) ▁{ ▁switch ▁( size ) ▁{ ▁case ▁1: ▁gen _ helper _ ne on _ add l _ s atur ate _ s 32 ( op 0, ▁cpu _ env , ▁op 0, ▁op 1); ▁break ; ▁case ▁2: ▁gen _ helper _ ne on _ add l _ s atur ate _ s 64 ( op 0, ▁cpu _ env , ▁op 0, ▁op 1); ▁break ; ▁default : ▁abort (); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁MP 3 l ame _ encode _ frame ( AV Codec Context ▁* av ctx , ▁unsigned ▁char ▁* frame , ▁int ▁buf _ size , ▁void ▁* data ) ▁{ ▁M p 3 Audio Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁num , ▁i ; ▁// av _ log ( av ctx , ▁AV _ LOG _ DEBUG , ▁"% X ▁% d ▁% X \ n ", ▁( int ) frame , ▁buf _ size , ▁( int ) data ); ▁// ▁if ( data == NULL ) ▁// ▁return ▁l ame _ encode _ flush ( s -> g fp , ▁frame , ▁buf _ size ); ▁/* ▁l ame ▁3. 91 ▁d ies ▁on ▁'1 - channel ▁inter le aved ' ▁data ▁*/ ▁if ▁( s -> st ere o ) ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ chr _ fe _ read _ all ( Char Driver State ▁* s , ▁uint 8_ t ▁* buf , ▁int ▁len ) ▁{ ▁int ▁offset ▁= ▁0, ▁counter ▁= ▁10; ▁int ▁res ; ▁if ▁(! s -> chr _ sync _ read ) ▁{ ▁return ▁0; ▁} ▁if ▁( s -> re play ▁&& ▁replay _ mode ▁== ▁RE PLAY _ MODE _ PLAY ) ▁{ ▁return ▁replay _ char _ read _ all _ load ( buf ); ▁} ▁while ▁( offset ▁< ▁len ) ▁{ ▁do ▁{ ▁res ▁= ▁s -> chr _ sync _ read ( s , ▁buf ▁+ ▁offset , ▁len ▁- ▁offset ); ▁if ▁( res ▁== ▁-1 ▁&& ▁errno ▁== ▁E AG AIN ) ▁{ ▁g _ us leep (100 ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ b _ picture _ secondary _ header ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁int ▁status ; ▁bit plane _ dec oding ( & v -> skip _ mb _ plane , ▁v ); ▁if ▁( status ▁< ▁0) ▁return ▁-1; ▁# if ▁TRACE ▁if ▁( v -> mv _ mode ▁== ▁MV _ P MODE _ MI X ED _ M V ) ▁{ ▁status ▁= ▁bit plane _ dec oding ( & v -> mv _ type _ mb _ plane , ▁v ); ▁if ▁( status ▁< ▁0) ▁return ▁-1; ▁# if ▁TRACE ▁av _ log ( v -> s . av ctx , ▁AV _ LOG _ DEBUG , ▁" MB ▁MV ▁Type ▁plane ▁encoding : 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ get _ stream _ index ( AV Format Context ▁* s , ▁K LV Packet ▁* kl v ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> nb _ streams ; ▁i ++) ▁{ ▁M XF Track ▁* track ▁= ▁s -> streams [ i ] -> priv _ data ; ▁/* ▁S MP TE ▁3 79 M ▁7. 3 ▁*/ ▁if ▁(! mem cmp ( kl v -> key ▁+ ▁sizeof ( mx f _ ess ence _ element _ key ), ▁track -> track _ number , ▁sizeof ( track -> track _ number ))) ▁return ▁i ; ▁} ▁/* ▁return ▁0 ▁if ▁only ▁one ▁stream , ▁for ▁OP ▁Atom ▁files ▁with ▁0 ▁as ▁track ▁number ▁*/ ▁retur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vc 1_ mc _1 mv ( VC 1 Context ▁* v , ▁int ▁dir ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& v -> s ; ▁H 264 Chrom a Context ▁* h 264 chrom a ▁= ▁& v -> h 264 chrom a ; ▁uint 8_ t ▁* src Y , ▁* src U , ▁* src V ; ▁int ▁d xy , ▁mx , ▁my , ▁u vm x , ▁uv my , ▁src _ x , ▁src _ y , ▁uv src _ x , ▁uv src _ y ; ▁int ▁v _ edge _ pos ▁= ▁s -> v _ edge _ pos ▁>> ▁v -> field _ mode ; ▁int ▁i ; ▁uint 8_ t ▁(* l uty )[ 256 ], ▁(* l ut uv )[ 256 ]; ▁int ▁use _ ic ; ▁if ▁(( ! v -> field _ mode ▁|| ▁( v -> ref _ fie

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uy 2 To UV )( uint 8_ t ▁* dst U , ▁uint 8_ t ▁* dst V , ▁uint 8_ t ▁* src 1, ▁uint 8_ t ▁* src 2, ▁int ▁width ) ▁{ ▁# if ▁defined ▁( HA VE _ MM X 2) ▁|| ▁defined ▁( HA VE _3 D NOW ) ▁asm ▁volatile ( ▁" mov q ▁" M ANG LE ( bm 0101 0101 )", ▁%% mm 4\ n \ t " ▁" mov ▁% 0, ▁% %" REG _ a " ▁\ n \ t " ▁" 1: ▁\ n \ t " ▁" mov q ▁( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁8 ( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 1 ▁\ n \ t " ▁" mov q ▁( % 2, ▁% %" REG _ a ", 4 ), ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mt v _ read _ header ( AV Format Context ▁* s ) ▁{ ▁MT VD em ux Context ▁* mt v ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ; ▁unsigned ▁int ▁audio _ sub segments ; ▁av io _ skip ( pb , ▁3 ); ▁mt v -> file _ size ▁= ▁av io _ rl 32 ( pb ); ▁mt v -> segments ▁= ▁av io _ rl 32 ( pb ); ▁av io _ skip ( pb , ▁32 ); ▁mt v -> audio _ identifier ▁= ▁av io _ rl 24 ( pb ); ▁mt v -> audio _ br ▁= ▁av io _ rl 16 ( pb ); ▁mt v -> img _ color fmt ▁= ▁av io _ rl 24 ( pb ); ▁mt

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁q ht _ insert __ locked ( struct ▁q ht ▁* ht , ▁struct ▁q ht _ map ▁* map , ▁struct ▁q ht _ bucket ▁* head , ▁void ▁* p , ▁uint 32_ t ▁hash , ▁bool ▁* needs _ resize ) ▁{ ▁struct ▁q ht _ bucket ▁* b ▁= ▁head ; ▁struct ▁q ht _ bucket ▁* prev ▁= ▁NULL ; ▁struct ▁q ht _ bucket ▁* new ▁= ▁NULL ; ▁int ▁i ; ▁do ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁Q HT _ BUCKET _ ENT RIES ; ▁i ++) ▁{ ▁if ▁( b -> pointer s [ i ]) ▁{ ▁if ▁( un likely ( b -> pointer s [ i ] ▁== ▁p )) ▁{ ▁return ▁false ; ▁} ▁} ▁else ▁{ ▁goto ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁copy _ packet _ data ( AV Packet ▁* pk t , ▁AV Packet ▁* src , ▁int ▁dup ) ▁{ ▁pkt -> data ▁= ▁NULL ; ▁pkt -> side _ data ▁= ▁NULL ; ▁if ▁( pk t -> buf ) ▁{ ▁AV Buffer Ref ▁* ref ▁= ▁av _ buffer _ ref ( src -> buf ); ▁if ▁(! ref ) ▁return ▁A VER ROR ( EN O ME M ); ▁pkt -> buf ▁= ▁ref ; ▁pkt -> data ▁= ▁ref -> data ; ▁} ▁else ▁{ ▁DUP _ DATA ( pk t -> data , ▁src -> data , ▁pkt -> size , ▁1, ▁AL LOC _ BU F ); ▁} ▁# if ▁FF _ API _ DE STRUCT _ PA CKET ▁FF _ DIS ABLE _ DE PRE CATION _ WARNING S ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ crypto _ instance _ init ( Object ▁* obj ) ▁{ ▁V irt IO Crypto ▁* vc rypto ▁= ▁VI RT IO _ CRY P TO ( obj ); ▁/* ▁* ▁The ▁default ▁config _ size ▁is ▁sizeof ( struct ▁virt io _ crypto _ config ). ▁* ▁Can ▁be ▁overr iden ▁with ▁virt io _ crypto _ set _ config _ size . ▁*/ ▁vc rypto -> config _ size ▁= ▁sizeof ( struct ▁virt io _ crypto _ config ); ▁object _ property _ add _ link ( obj , ▁" crypt ode v ", ▁TYPE _ CRY P TO DEV _ BACK END , ▁( Object ▁** ) & vc rypto -> conf . crypt od

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ sh 4_ handle _ mm u _ fault ( CPU State ▁* ▁env , ▁target _ ulong ▁address , ▁int ▁rw , ▁int ▁mm u _ idx , ▁int ▁is _ soft mm u ) ▁{ ▁target _ ulong ▁physical ; ▁int ▁prot , ▁ret , ▁access _ type ; ▁access _ type ▁= ▁ACCESS _ INT ; ▁ret ▁= ▁get _ ph ysical _ address ( env , ▁& ph ysical , ▁& prot , ▁address , ▁rw , ▁access _ type ); ▁if ▁( ret ▁!= ▁MM U _ OK ) ▁{ ▁env -> te a ▁= ▁address ; ▁switch ▁( ret ) ▁{ ▁case ▁MM U _ IT LB _ MISS : ▁case ▁MM U _ DT LB _ MISS _ READ : ▁env -> exception _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ blk _ device _ exit ( Device State ▁* dev ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( dev ); ▁V irt IO Block ▁* s ▁= ▁VI RT IO _ BL K ( dev ); ▁# if def ▁CONFIG _ VI RT IO _ BL K _ DATA _ PLA NE ▁remove _ migration _ state _ change _ notifier ( & s -> migration _ state _ notifier ); ▁virt io _ blk _ data _ plane _ destroy ( s -> data plane ); ▁s -> data plane ▁= ▁NULL ; ▁# end if ▁qemu _ del _ vm _ change _ state _ handler ( s -> change ); ▁unregister _ save vm ( dev , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ dim m _ get _ size ( Object ▁* obj , ▁Visitor ▁* v , ▁const ▁char ▁* name , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁uint 64_ t ▁value ; ▁Memory Region ▁* mr ; ▁PC DI MM Device ▁* dim m ▁= ▁PC _ DI MM ( obj ); ▁PC DI MM Device Class ▁* dd c ▁= ▁PC _ DI MM _ GET _ CLASS ( obj ); ▁mr ▁= ▁dd c -> get _ memory _ region ( dim m ); ▁value ▁= ▁memory _ region _ size ( mr ); ▁visit _ type _ uint 64 ( v , ▁name , ▁& value , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁sp ap r _ rt as _ call ( s P AP R Environment ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁if ▁(( token ▁>= ▁TOKEN _ BASE ) ▁&& ▁(( token ▁- ▁TOKEN _ BASE ) ▁< ▁TOKEN _ MAX )) ▁{ ▁struct ▁rt as _ call ▁* call ▁= ▁rt as _ table ▁+ ▁( token ▁- ▁TOKEN _ BASE ); ▁if ▁( call -> fn ) ▁{ ▁call -> fn ( sp ap r , ▁token , ▁nargs , ▁args , ▁n ret , ▁ret s ); ▁h call _ d printf (" Unknown ▁RT AS ▁token ▁0 x % x \ n "

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 32_ t ▁sc si _ send _ command ( SC SI Request ▁* req , ▁uint 8_ t ▁* cmd ) ▁{ ▁SC SI Generic State ▁* s ▁= ▁DO _ UP CAST ( SC SI Generic State , ▁q dev , ▁req -> dev ); ▁SC SI Generic Req ▁* r ▁= ▁DO _ UP CAST ( SC SI Generic Req , ▁req , ▁req ); ▁int ▁ret ; ▁if ▁( cmd [0] ▁!= ▁REQUEST _ SE NSE ▁&& ▁req -> lun ▁!= ▁s -> q dev . lun ) ▁{ ▁D PRI NT F (" Un implemented ▁L UN ▁% d \ n ", ▁req -> lun ); ▁sc si _ req _ build _ s ense ( & r -> req , ▁SE NSE _ CODE ( L UN _ NOT _ SUPPORTED )); ▁sc si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ip 6_ input ( struct ▁m buf ▁* m ) ▁{ ▁struct ▁ip 6 ▁* ip 6 ; ▁DEBUG _ CALL (" ip 6_ input "); ▁DEBUG _ ARG (" m ▁= ▁% l x ", ▁( long ) m ); ▁DEBUG _ ARG (" m _ len ▁= ▁% d ", ▁m -> m _ len ); ▁if ▁( m -> m _ len ▁< ▁sizeof ( struct ▁ip 6 )) ▁{ ▁goto ▁bad ; ▁} ▁ip 6 ▁= ▁mt od ( m , ▁struct ▁ip 6 ▁* ); ▁if ▁( ip 6 -> ip _ v ▁!= ▁IP 6 VERSION ) ▁{ ▁goto ▁bad ; ▁} ▁/* ▁check ▁ip _ ttl ▁for ▁a ▁correct ▁IC MP ▁reply ▁*/ ▁if ▁( ip 6 -> ip _ hl ▁== ▁0) ▁{ ▁/* ic mp _ send _ error ( m , ▁IC MP _ T IM X CE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁fork _ start ( void ) ▁{ ▁p thread _ mut ex _ lock ( & tc g _ ctx . tb _ ctx . tb _ lock ); ▁p thread _ mut ex _ lock ( & exclusive _ lock ); ▁mmap _ fork _ start (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ dump _ pages ( Dump State ▁* s ) ▁{ ▁int ▁ret ▁= ▁0; ▁Data Cache ▁page _ desc , ▁page _ data ; ▁size _ t ▁len _ buf _ out , ▁size _ out ; ▁# if def ▁CONFIG _ L Z O ▁l zo _ by t ep ▁wr k mem ▁= ▁NULL ; ▁# end if ▁uint 8_ t ▁* buf _ out ▁= ▁NULL ; ▁off _ t ▁offset _ desc , ▁offset _ data ; ▁Page Descriptor ▁pd , ▁pd _ zero ; ▁uint 8_ t ▁* buf ; ▁int ▁endian ▁= ▁s -> dump _ info . d _ endian ; ▁Gu est Ph ys Block ▁* block _ iter ▁= ▁NULL ; ▁uint 64_ t ▁p fn _ iter ; ▁/* ▁get ▁offset ▁of

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ ext _ interrupt ( CP US 390 X State ▁* env ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁s 39 0_ env _ get _ cpu ( env ); ▁uint 64_ t ▁mask , ▁addr ; ▁Low Core ▁* low core ; ▁Ext Queue ▁* q ; ▁if ▁(! ( env -> p sw . mask ▁& ▁PS W _ MASK _ EXT )) ▁{ ▁cpu _ abort ( CPU ( cpu ), ▁" Ext ▁int ▁w / o ▁ext ▁mask \ n "); ▁} ▁low core ▁= ▁cpu _ map _ low core ( env ); ▁if ▁( env -> pending _ int ▁& ▁INTER R UP T _ EXT _ C LOCK _ COM PARATOR ) ▁{ ▁low core -> ext _ int _ code ▁= ▁cpu _ to _ be 16 ( EXT _ C LOCK _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ver d ex _ init ( Machine State ▁* machine ) ▁{ ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁P XA 2 xx State ▁* cpu ; ▁Drive Info ▁* d info ; ▁int ▁be ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁uint 32_ t ▁ver d ex _ rom ▁= ▁0 x 02 000000 ; ▁uint 32_ t ▁ver d ex _ ram ▁= ▁0 x 1 0000000 ; ▁cpu ▁= ▁p xa 27 0_ init ( address _ space _ mem , ▁ver d ex _ ram , ▁cpu _ model ▁? : ▁" px a 270 - c 0 "); ▁d info ▁= ▁drive _ get ( IF _ P FL ASH , ▁0, ▁0); ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b och s _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁B DR VB och s State ▁* s ▁= ▁bs -> op aque ; ▁uint 32_ t ▁i ; ▁struct ▁b och s _ header ▁b och s ; ▁int ▁ret ; ▁bs -> read _ only ▁= ▁1; ▁// ▁no ▁write ▁support ▁yet ▁ret ▁= ▁b dr v _ p read ( bs -> file , ▁0, ▁& bo ch s , ▁sizeof ( bo ch s )); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁if ▁( str cmp ( bo ch s . magic , ▁HEADER _ M AGIC ) ▁|| ▁str cmp ( bo ch s . type , ▁RED OL OG _ TYPE ) ▁|| ▁st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁offset _ t ▁url _ f seek ( Byte IO Context ▁* s , ▁offset _ t ▁offset , ▁int ▁whence ) ▁{ ▁offset _ t ▁offset 1; ▁offset _ t ▁pos = ▁s -> pos ▁- ▁( s -> write _ flag ▁? ▁0 ▁: ▁( s -> buf _ end ▁- ▁s -> buffer )); ▁if ▁( wh ence ▁!= ▁SE EK _ CUR ▁&& ▁whence ▁!= ▁SE EK _ SET ) ▁return ▁- E IN VAL ; ▁if ▁( wh ence ▁== ▁SE EK _ CUR ) ▁{ ▁offset 1 ▁= ▁pos ▁+ ▁( s -> buf _ ptr ▁- ▁s -> buffer ); ▁if ▁( offset ▁== ▁0) ▁return ▁offset 1; ▁offset ▁+= ▁offset 1; ▁} ▁offset 1 ▁= ▁offset ▁- ▁pos ; ▁if ▁(! s -> must 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p pc _ translate _ init ( void ) ▁{ ▁int ▁i ; ▁char * ▁p ; ▁size _ t ▁cpu _ reg _ names _ size ; ▁static ▁int ▁done _ init ▁= ▁0; ▁if ▁( done _ init ) ▁return ; ▁cpu _ env ▁= ▁tc g _ global _ reg _ new _ ptr ( TC G _ A REG 0, ▁" env "); ▁p ▁= ▁cpu _ reg _ names ; ▁cpu _ reg _ names _ size ▁= ▁sizeof ( cpu _ reg _ names ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁{ ▁sn printf ( p , ▁cpu _ reg _ names _ size , ▁" cr f % d ", ▁i ); ▁cpu _ cr f [ i ] ▁= ▁tc g _ global _ mem _ new _ i 32 ( TC G _ A REG 0, ▁o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ mt fs fi ( Dis as Context ▁* ctx ) ▁{ ▁int ▁bf , ▁sh ; ▁TC G v _ i 64 ▁t 0; ▁TC G v _ i 32 ▁t 1; ▁if ▁( un likely (! ctx -> f pu _ enabled )) ▁{ ▁gen _ exception ( ctx , ▁PO WER PC _ EX CP _ F PU ); ▁return ; ▁} ▁bf ▁= ▁cr b D ( ctx -> op code ) ▁>> ▁2; ▁sh ▁= ▁7 ▁- ▁bf ; ▁/* ▁N IP ▁cannot ▁be ▁restored ▁if ▁the ▁memory ▁exception ▁comes ▁from ▁an ▁helper ▁*/ ▁gen _ update _ n ip ( ctx , ▁ctx -> n ip ▁- ▁4 ); ▁gen _ reset _ fp status (); ▁t 0 ▁= ▁tc g _ const _ i 64 ( F PI MM ( ctx ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁os _ mem _ pre alloc ( int ▁fd , ▁char ▁* area , ▁size _ t ▁memory , ▁Error ▁** err p ) ▁{ ▁int ▁i ; ▁size _ t ▁pages ize ▁= ▁get pages ize (); ▁memory ▁= ▁( memory ▁+ ▁pages ize ▁- ▁1) ▁& ▁- pages ize ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁memory ▁/ ▁pages ize ; ▁i ++) ▁{ ▁mem set ( area ▁+ ▁pages ize ▁* ▁i , ▁0, ▁1); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cu vid _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁C uv id Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁AV H W Device Context ▁* device _ ctx ▁= ▁( AV H W Device Context *) ctx -> h wd evice -> data ; ▁A VC UD AD evice Context ▁* device _ hw ctx ▁= ▁device _ ctx -> hw ctx ; ▁CU context ▁dummy , ▁cuda _ ctx ▁= ▁device _ hw ctx -> cuda _ ctx ; ▁AV Frame ▁* frame ▁= ▁data ; ▁C UV ID SOURCE DAT AP ACK ET ▁c up kt ; ▁AV Packet ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁hot plug ( void ) ▁{ ▁q test _ start ("- device ▁virt io - net - pc i "); ▁q pc i _ plug _ device _ test (" virt io - net - pc i ", ▁" net 1", ▁P CI _ SL OT _ HP , ▁NULL ); ▁q pc i _ un plug _ ac pi _ device _ test (" net 1", ▁P CI _ SL OT _ HP ); ▁test _ end (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ff _ h 2 64_ id ct 8_ add _ s se 2( uint 8_ t ▁* dst , ▁int 16_ t ▁* block , ▁int ▁stride ) ▁{ ▁__ asm __ ▁volatile ( ▁" mov d qa ▁0 x 10 ( % 1), ▁%% x mm 1 ▁\ n " ▁" mov d qa ▁0 x 20 ( % 1), ▁%% x mm 2 ▁\ n " ▁" mov d qa ▁0 x 30 ( % 1), ▁%% x mm 3 ▁\ n " ▁" mov d qa ▁0 x 50 ( % 1), ▁%% x mm 5 ▁\ n " ▁" mov d qa ▁0 x 60 ( % 1), ▁%% x mm 6 ▁\ n " ▁" mov d qa ▁0 x 70 ( % 1), ▁%% x mm 7 ▁\ n " ▁H 2 64_ ID CT 8 _1 D _ SS E 2( % % x mm 0, ▁%% x mm 1, ▁%% x mm 2, ▁%% x mm 3, ▁%% x mm 4, ▁%% x mm 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ide _ ident ify ( IDE State ▁* s ) ▁{ ▁uint 16_ t ▁* p ; ▁unsigned ▁int ▁old size ; ▁mem set ( s -> io _ buffer , ▁0, ▁512 ); ▁p ▁= ▁( uint 16_ t ▁* ) s -> io _ buffer ; ▁st w ( p ▁+ ▁0, ▁0 x 00 40 ); ▁st w ( p ▁+ ▁1, ▁s -> cy l ind ers ); ▁st w ( p ▁+ ▁3, ▁s -> head s ); ▁st w ( p ▁+ ▁4, ▁512 ▁* ▁s -> sect ors ); ▁/* ▁sector s ▁*/ ▁st w ( p ▁+ ▁5, ▁512 ); ▁/* ▁sector ▁size ▁*/ ▁st w ( p ▁+ ▁6, ▁s -> sect ors ); ▁st w ( p ▁+ ▁20, ▁3 ); ▁/* ▁buffer ▁type ▁*/ ▁st w ( p ▁+ ▁21, ▁512 ); ▁/* ▁ca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ ap ng ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* p ict , ▁int ▁* got _ packet ) ▁{ ▁PNG Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁ret ; ▁int ▁enc _ row _ size ; ▁size _ t ▁max _ packet _ size ; ▁AP NG F ctl Chunk ▁f ctl _ chunk ▁= ▁{0 }; ▁if ▁( p ict ▁&& ▁av ctx -> codec _ id ▁== ▁AV _ CODE C _ ID _ AP NG ▁&& ▁s -> color _ type ▁== ▁PNG _ COLOR _ TYPE _ PA LET TE ) ▁{ ▁uint 32_ t ▁checksum ▁= ▁~ av _ crc ( av _ crc _ get _ table ( AV _ C RC _ 32

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Driver A IO CB ▁* b dr v _ a io _ read v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁Block Driver A IO CB ▁* ret ; ▁trace _ b dr v _ a io _ read v ( bs , ▁sector _ num , ▁nb _ sect ors , ▁opaque ); ▁if ▁(! dr v ) ▁return ▁NULL ; ▁if ▁( b dr v _ check _ request ( bs , ▁sector _ num , ▁nb _ sect ors )) ▁return ▁NULL ; ▁ret ▁= ▁drv -> b dr 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁migrate _ set _ d ow nt ime ( Q Test State ▁* who , ▁const ▁char ▁* value ) ▁{ ▁Q Dict ▁* r sp ; ▁g char ▁* cmd ; ▁cmd ▁= ▁g _ str dup _ printf ("{ ▁' execute ': ▁' migrate _ set _ d ow nt ime ', " ▁"' arguments ': ▁{ ▁' value ': ▁% s ▁} ▁} ", ▁value ); ▁rsp ▁= ▁q test _ q mp ( who , ▁cmd ); ▁g _ free ( cmd ); ▁g _ assert ( q dict _ has key ( r sp , ▁" return ")); ▁Q DE CRE F ( r sp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁do _ arm _ se mi hosting ( CPU ARM State ▁* env ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁arm _ env _ get _ cpu ( env ); ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁target _ ulong ▁args ; ▁target _ ulong ▁arg 0, ▁arg 1, ▁arg 2, ▁arg 3; ▁char ▁* ▁s ; ▁int ▁nr ; ▁uint 32_ t ▁ret ; ▁uint 32_ t ▁len ; ▁# if def ▁CONFIG _ USER _ ONLY ▁Task State ▁* ts ▁= ▁cs -> op aque ; ▁# else ▁CPU ARM State ▁* ts ▁= ▁env ; ▁# end if ▁if ▁( is _ a 64 ( env )) ▁{ ▁/* ▁Note ▁that ▁the ▁sy scall ▁number ▁is ▁in ▁W 0, ▁not ▁X 0 ▁*/ ▁nr ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ un registered _ user _ data ( H 264 SE I Un registered ▁* h , ▁Get Bit Context ▁* gb , ▁void ▁* log ctx , ▁int ▁size ) ▁{ ▁uint 8_ t ▁* user _ data ; ▁int ▁e , ▁build , ▁i ; ▁if ▁( size ▁< ▁16 ▁|| ▁size ▁>= ▁INT _ MAX ▁- ▁16 ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁user _ data ▁= ▁av _ m alloc (16 ▁+ ▁size ▁+ ▁1); ▁if ▁(! user _ data ) ▁return ▁A VER ROR ( EN O ME M ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁size ▁+ ▁16 ; ▁i ++) ▁user _ data [ i ] ▁= ▁get _ bits ( gb , ▁8 ); ▁user _ data [ i ] ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁av filter _ filter _ samples ( AV Filter Link ▁* link , ▁AV Filter Buffer Ref ▁* samples ref ) ▁{ ▁void ▁(* filter _ samples )( AV Filter Link ▁* , ▁AV Filter Buffer Ref ▁* ); ▁AV Filter Pad ▁* dst ▁= ▁link -> dst pad ; ▁int ▁i ; ▁FF _ DP RI NT F _ START ( NULL , ▁filter _ samples ); ▁ff _ d log _ link ( NULL , ▁link , ▁1); ▁if ▁(! ( filter _ samples ▁= ▁dst -> filter _ samples )) ▁filter _ samples ▁= ▁av filter _ default _ filter _ samples ; ▁/* ▁prepare ▁to ▁copy ▁the ▁samples ▁if ▁the ▁buffer ▁h

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁qemu _ irq ▁* pp ce 500 _ init _ mp ic ( PP CE 500 Params ▁* params , ▁Memory Region ▁* cc sr , ▁qemu _ irq ▁** ir qs ) ▁{ ▁qemu _ irq ▁* mp ic ; ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁int ▁i , ▁j , ▁k ; ▁mp ic ▁= ▁g _ new ( q emu _ irq , ▁256 ); ▁dev ▁= ▁q dev _ create ( NULL , ▁" open pic "); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" nb _ cpus ", ▁s mp _ cpus ); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" model ", ▁params -> mp ic _ version ); ▁q dev _ init _ n of ail ( dev ); ▁s ▁= ▁SY S _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Char Driver State ▁* q emu _ chr _ new ( const ▁char ▁* label , ▁const ▁char ▁* filename , ▁void ▁(* init )( struct ▁Char Driver State ▁* s )) ▁{ ▁const ▁char ▁* p ; ▁Char Driver State ▁* chr ; ▁Q emu Opts ▁* opts ; ▁Error ▁* err ▁= ▁NULL ; ▁if ▁( str start ( filename , ▁" ch ard ev :", ▁& p )) ▁{ ▁return ▁qemu _ chr _ find ( p ); ▁} ▁opts ▁= ▁qemu _ chr _ parse _ compat ( label , ▁filename ); ▁if ▁(! opts ) ▁return ▁NULL ; ▁chr ▁= ▁qemu _ chr _ new _ from _ opts ( opts , ▁init , ▁& err ); ▁if ▁( err ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ init _ tap _ one ( const ▁Net dev Tap Options ▁* tap , ▁Net Client State ▁* peer , ▁const ▁char ▁* model , ▁const ▁char ▁* name , ▁const ▁char ▁* if name , ▁const ▁char ▁* script , ▁const ▁char ▁* down script , ▁const ▁char ▁* v host fd name , ▁int ▁v net _ hdr , ▁int ▁fd ) ▁{ ▁T AP State ▁* s ; ▁s ▁= ▁net _ tap _ fd _ init ( peer , ▁model , ▁name , ▁fd , ▁v net _ hdr ); ▁if ▁(! s ) ▁{ ▁close ( fd ); ▁return ▁-1; ▁} ▁if ▁( tap _ set _ s nd buf ( s -> fd , ▁tap ) ▁< ▁0) ▁{ ▁return ▁-1; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁q dev _ prop _ check _ globals ( void ) ▁{ ▁G List ▁* l ; ▁int ▁ret ▁= ▁0; ▁for ▁( l ▁= ▁global _ props ; ▁l ; ▁l ▁= ▁l -> next ) ▁{ ▁Global Property ▁* prop ▁= ▁l -> data ; ▁Object Class ▁* oc ; ▁Device Class ▁* dc ; ▁if ▁( prop -> used ) ▁{ ▁continue ; ▁} ▁if ▁(! prop -> user _ provided ) ▁{ ▁continue ; ▁} ▁oc ▁= ▁object _ class _ by _ name ( prop -> driver ); ▁oc ▁= ▁object _ class _ dynamic _ cast ( oc , ▁TYPE _ DEVICE ); ▁if ▁(! oc ) ▁{ ▁error _ report (" Warning : ▁global ▁% s . % s ▁has ▁inva

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q es d _ init _ out ▁( H W Voice Out ▁* hw , ▁aud settings _ t ▁* as ) ▁{ ▁ES D Voice Out ▁* es d ▁= ▁( ES D Voice Out ▁* ) ▁hw ; ▁aud settings _ t ▁obt _ as ▁= ▁* as ; ▁int ▁es df mt ▁= ▁ES D _ STREAM ▁| ▁ES D _ PLAY ; ▁int ▁err ; ▁sig set _ t ▁set , ▁old _ set ; ▁sig fill set ▁( & set ); ▁es df mt ▁|= ▁( as -> n channels ▁== ▁2) ▁? ▁ES D _ ST ERE O ▁: ▁ES D _ MON O ; ▁switch ▁( as -> fmt ) ▁{ ▁case ▁A UD _ F MT _ S 8: ▁case ▁A UD _ F MT _ U 8: ▁es df mt ▁|= ▁ES D _ BITS 8 ; ▁obt _ as . fmt

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁monitor _ find _ completion ( const ▁char ▁* cmdline ) ▁{ ▁const ▁char ▁* cmd name ; ▁char ▁* args [ MAX _ ARGS ]; ▁int ▁nb _ args , ▁i , ▁len ; ▁const ▁char ▁* ptype , ▁* str ; ▁const ▁mon _ cmd _ t ▁* cmd ; ▁const ▁Key Def ▁* key ; ▁parse _ cmdline ( cmdline , ▁& nb _ args , ▁args ); ▁# if def ▁DEBUG _ COMP LET ION ▁for ( i ▁= ▁0; ▁i ▁< ▁nb _ args ; ▁i ++) ▁{ ▁monitor _ printf ( cur _ mon , ▁" arg % d ▁= ▁'% s '\ n ", ▁i , ▁( char ▁* ) args [ i ]); ▁} ▁# end if ▁/* ▁if ▁the ▁line ▁ends ▁w

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd _ response _ r 1_ make ( SD State ▁* sd , ▁uint 8_ t ▁* response , ▁uint 32_ t ▁last _ status ) ▁{ ▁uint 32_ t ▁mask ▁= ▁C ARD _ STATUS _ B ▁^ ▁I L LEG AL _ COMMAND ; ▁uint 32_ t ▁status ; ▁status ▁= ▁( sd -> card _ status ▁& ▁~ mask ) ▁| ▁( last _ status ▁& ▁mask ); ▁sd -> card _ status ▁&= ▁~ C ARD _ STATUS _ C ▁| ▁APP _ CMD ; ▁response [0] ▁= ▁( status ▁>> ▁24 ) ▁& ▁0 xff ; ▁response [1] ▁= ▁( status ▁>> ▁16 ) ▁& ▁0 xff ; ▁response [2] ▁= ▁( status ▁>> ▁8) ▁& ▁0 xff ; ▁response [3] ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m pc 8_ decode _ frame ( AV Codec Context ▁* ▁av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁M PC Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁Get Bit Context ▁gb 2, ▁* gb ▁= ▁& gb 2; ▁int ▁i , ▁j , ▁k , ▁ch , ▁cnt , ▁res , ▁t ; ▁Band ▁* b ands ▁= ▁c -> b ands ; ▁int ▁off ; ▁int ▁max band , ▁key frame ; ▁int ▁last [2 ]; ▁key frame ▁= ▁c -> cur _ frame ▁== ▁0; ▁if ( key frame ){ ▁mem

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Device State ▁* q dev _ try _ create ( Bus State ▁* bus , ▁const ▁char ▁* name ) ▁{ ▁Device State ▁* dev ; ▁if ▁( object _ class _ by _ name ( name ) ▁== ▁NULL ) ▁{ ▁return ▁NULL ; ▁} ▁dev ▁= ▁DEVICE ( object _ new ( name )); ▁if ▁(! dev ) ▁{ ▁return ▁NULL ; ▁} ▁if ▁(! bus ) ▁{ ▁bus ▁= ▁sys bus _ get _ default (); ▁} ▁q dev _ set _ parent _ bus ( dev , ▁bus ); ▁q dev _ prop _ set _ globals ( dev ); ▁return ▁dev ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Visitor ▁* q object _ input _ visitor _ new _ key val ( Q Object ▁* obj ) ▁{ ▁Q Object Input Visitor ▁* v ▁= ▁q object _ input _ visitor _ base _ new ( obj ); ▁v -> visitor . type _ int 64 ▁= ▁q object _ input _ type _ int 64_ key val ; ▁v -> visitor . type _ uint 64 ▁= ▁q object _ input _ type _ uint 64_ key val ; ▁v -> visitor . type _ bool ▁= ▁q object _ input _ type _ bool _ key val ; ▁v -> visitor . type _ str ▁= ▁q object _ input _ type _ str ; ▁v -> visitor . type _ number ▁= ▁q object _ input _ t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* pl 0 80 _ init ( uint 32_ t ▁base , ▁qemu _ irq ▁irq , ▁int ▁n channels ) ▁{ ▁int ▁i om em type ; ▁pl 0 80 _ state ▁* s ; ▁s ▁= ▁( pl 0 80 _ state ▁* ) q emu _ m alloc z ( size of ( pl 0 80 _ state )); ▁i om em type ▁= ▁cpu _ register _ io _ memory (0, ▁pl 0 80 _ read fn , ▁pl 0 80 _ writ ef n , ▁s ); ▁cpu _ register _ ph ysical _ memory ( base , ▁0 x 00000 fff , ▁i om em type ); ▁s -> base ▁= ▁base ; ▁s -> irq ▁= ▁irq ; ▁s -> n channels ▁= ▁n channels ; ▁/* ▁??? ▁Save / restore . ▁*/ ▁return ▁s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁init _ coef _ vlc ( V LC ▁* vlc , ▁uint 16_ t ▁** pr un _ table , ▁float ▁** plevel _ table , ▁uint 16_ t ▁** p int _ table , ▁const ▁Co ef V L CT able ▁* vlc _ table ) ▁{ ▁int ▁n ▁= ▁vl c _ table -> n ; ▁const ▁uint 8_ t ▁* table _ bits ▁= ▁vl c _ table -> h uff bits ; ▁const ▁uint 32_ t ▁* table _ codes ▁= ▁vl c _ table -> h uff codes ; ▁const ▁uint 16_ t ▁* levels _ table ▁= ▁vl c _ table -> levels ; ▁uint 16_ t ▁* run _ table , ▁* level _ table , ▁* int _ table ; ▁float ▁* f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁parse _ nal _ units ( AV Codec Parser Context ▁* s , ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁H 264 Parse Context ▁* p ▁= ▁s -> priv _ data ; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf ▁+ ▁buf _ size ; ▁H 264 5 NAL ▁n al ▁= ▁{ ▁NULL ▁}; ▁unsigned ▁int ▁p ps _ id ; ▁unsigned ▁int ▁slice _ type ; ▁int ▁state ▁= ▁-1, ▁got _ reset ▁= ▁0; ▁int ▁field _ p oc [2 ]; ▁int ▁ret ; ▁/* ▁set ▁some ▁s ane ▁default ▁values ▁*/ ▁s -> p ict _ type ▁= ▁AV _ PI CT URE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁F UNC ( in tra _ pred )( HE VC Context ▁* s , ▁int ▁x 0, ▁int ▁y 0, ▁int ▁log 2_ size , ▁int ▁c _ idx ) ▁{ ▁# define ▁P U ( x ) ▁\ ▁(( x ) ▁>> ▁s -> ps . sp s -> log 2_ min _ pu _ size ) ▁# define ▁MV F ( x , ▁y ) ▁\ ▁( s -> ref -> tab _ mv f [( x ) ▁+ ▁( y ) ▁* ▁min _ pu _ width ]) ▁# define ▁MV F _ PU ( x , ▁y ) ▁\ ▁MV F ( PU ( x 0 ▁+ ▁(( x ) ▁<< ▁h shift )), ▁P U ( y 0 ▁+ ▁(( y ) ▁<< ▁v shift ))) ▁# define ▁IS _ INT RA ( x , ▁y ) ▁\ ▁( M V F _ PU ( x , ▁y ). pred _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁end _ last _ frame ( AV Filter Context ▁* ctx ) ▁{ ▁Tile Context ▁* tile ▁= ▁ctx -> priv ; ▁AV Filter Link ▁* out link ▁= ▁ctx -> outputs [0]; ▁AV Filter Buffer Ref ▁* out _ buf ▁= ▁out link -> out _ buf ; ▁out link -> out _ buf ▁= ▁NULL ; ▁ff _ start _ frame ( out link , ▁out _ buf ); ▁while ▁( tile -> current ▁< ▁tile -> nb _ frames ) ▁draw _ blank _ frame ( ctx , ▁out _ buf ); ▁ff _ draw _ slice ( out link , ▁0, ▁out _ buf -> video -> h , ▁1); ▁ff _ end _ frame ( out link ); ▁tile -> cur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁av _ register _ output _ format ( AV OutputFormat ▁* format ) ▁{ ▁AV OutputFormat ▁** p ▁= ▁& first _ o format ; ▁while ▁(* p ▁!= ▁NULL ) ▁p ▁= ▁& (* p ) -> next ; ▁* p ▁= ▁format ; ▁format -> next ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _32 Bit _ op c ( CP UT ri Core State ▁* env , ▁Dis as Context ▁* ctx ) ▁{ ▁int ▁op 1; ▁int 32_ t ▁r 1, ▁r 2, ▁r 3; ▁int 32_ t ▁address , ▁const 16 ; ▁int 8_ t ▁b , ▁const 4; ▁int 32_ t ▁b pos ; ▁TC G v ▁temp , ▁temp 2, ▁temp 3; ▁op 1 ▁= ▁MASK _ OP _ MA J OR ( ctx -> op code ); ▁/* ▁handle ▁J N Z . T ▁opcode ▁only ▁being ▁7 ▁bit ▁long ▁*/ ▁if ▁( un likely (( op 1 ▁& ▁0 x 7 f ) ▁== ▁O PC M _ 32_ BR N _ J TT )) ▁{ ▁op 1 ▁= ▁O PC M _ 32_ BR N _ J TT ; ▁} ▁switch ▁( op 1) ▁{ ▁/* ▁AB S - f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV Filter Buffer Ref ▁* av filter _ get _ video _ buffer _ ref _ from _ frame ( const ▁AV Frame ▁* frame , ▁int ▁perms ) ▁{ ▁AV Filter Buffer Ref ▁* pic ref ▁= ▁av filter _ get _ video _ buffer _ ref _ from _ arrays ( frame -> data , ▁frame -> lines ize , ▁perms , ▁frame -> width , ▁frame -> height , ▁frame -> format ); ▁if ▁(! pic ref ) ▁return ▁NULL ; ▁av filter _ copy _ frame _ props ( pic ref , ▁frame ); ▁return ▁pic ref ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* g _ real loc ( void ▁* ptr , ▁size _ t ▁size ) ▁{ ▁size _ t ▁old _ size , ▁copy ; ▁void ▁* new _ ptr ; ▁if ▁(! ptr ) ▁return ▁g _ m alloc ( size ); ▁old _ size ▁= ▁* ( size _ t ▁* ) (( char ▁* ) ptr ▁- ▁16 ); ▁copy ▁= ▁old _ size ▁< ▁size ▁? ▁old _ size ▁: ▁size ; ▁new _ ptr ▁= ▁g _ m alloc ( size ); ▁mem c py ( new _ ptr , ▁ptr , ▁copy ); ▁g _ free ( ptr ); ▁return ▁new _ ptr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁OutputStream ▁* new _ audio _ stream ( Options Context ▁* o , ▁AV Format Context ▁* oc ) ▁{ ▁AV Stream ▁* st ; ▁OutputStream ▁* ost ; ▁AV Codec Context ▁* audio _ enc ; ▁o st ▁= ▁new _ output _ stream ( o , ▁oc , ▁AV MEDIA _ TYPE _ AU DIO ); ▁st ▁= ▁o st -> st ; ▁audio _ enc ▁= ▁st -> codec ; ▁audio _ enc -> codec _ type ▁= ▁AV MEDIA _ TYPE _ AU DIO ; ▁if ▁(! ost -> stream _ copy ) ▁{ ▁char ▁* sample _ fmt ▁= ▁NULL ; ▁MATCH _ PER _ STREAM _ OPT ( audio _ channels , ▁i , ▁audio _ enc -> channels ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pc x _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁AV Frame ▁* const ▁p ▁= ▁data ; ▁int ▁compressed , ▁xmin , ▁ymin , ▁xmax , ▁ymax ; ▁unsigned ▁int ▁w , ▁h , ▁bits _ per _ pixel , ▁bytes _ per _ line , ▁n plan es , ▁stride , ▁y , ▁x , ▁bytes _ per _ scan line ; ▁uint 8_ t ▁* ptr ; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf ▁+ ▁buf _ size ; ▁co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁i op ort _ write ( void ▁* op aque , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁P CI Q X L Device ▁* d ▁= ▁opaque ; ▁uint 32_ t ▁io _ port ▁= ▁addr ▁- ▁d -> io _ base ; ▁switch ▁( io _ port ) ▁{ ▁case ▁Q X L _ IO _ RE SET : ▁case ▁Q X L _ IO _ SET _ MODE : ▁case ▁Q X L _ IO _ ME MS L OT _ ADD : ▁case ▁Q X L _ IO _ ME MS L OT _ DE L : ▁case ▁Q X L _ IO _ CREATE _ PRI MARY : ▁break ; ▁default : ▁if ▁( d -> mode ▁== ▁Q X L _ MODE _ N ATIVE ▁|| ▁d -> mode ▁== ▁Q X L _ MODE _ COMP AT ) ▁break ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h 2 64_ slice _ header _ parse ( H 264 Context ▁* h , ▁H 264 Slice Context ▁* sl ) ▁{ ▁const ▁S PS ▁* sp s ; ▁const ▁P PS ▁* pp s ; ▁unsigned ▁int ▁first _ mb _ in _ slice ; ▁unsigned ▁int ▁p ps _ id ; ▁int ▁ret ; ▁unsigned ▁int ▁slice _ type , ▁tmp , ▁i ; ▁int ▁last _ pic _ structure , ▁last _ pic _ dro ppable ; ▁int ▁needs _ re init ▁= ▁0; ▁int ▁field _ pic _ flag , ▁bottom _ field _ flag ; ▁int ▁frame _ num , ▁dro ppable , ▁picture _ structure ; ▁int ▁mb _ aff _ frame ▁= ▁0; ▁first _ mb _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff url _ shutdown ( URL Context ▁* h , ▁int ▁flags ) ▁{ ▁if ▁(! h -> prot -> url _ shutdown ) ▁return ▁A VER ROR ( E IN VAL ); ▁return ▁h -> prot -> url _ shutdown ( h , ▁flags ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁i 8 23 78 _ init ( Device State ▁* dev , ▁I 8 23 78 State ▁* s ) ▁{ ▁IS AB us ▁* is ab us ▁= ▁DO _ UP CAST ( IS AB us , ▁q bus , ▁q dev _ get _ child _ bus ( dev , ▁" isa .0 ")); ▁IS AD evice ▁* p it ; ▁qemu _ irq ▁* out 0_ irq ; ▁/* ▁This ▁device ▁has : ▁2 ▁82 C 59 ▁( irq ) ▁1 ▁82 C 54 ▁( p it ) ▁2 ▁82 C 37 ▁( d ma ) ▁N MI ▁Utility ▁Bus ▁Support ▁Reg ist ers ▁All ▁devices ▁accept ▁byte ▁access ▁only , ▁except ▁timer ▁*/ ▁q dev _ init _ gp io _ out ( dev , ▁s -> out , ▁2); ▁q dev _ init _ g

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁real view _ init ( ram _ addr _ t ▁ram _ size , ▁int ▁v ga _ ram _ size , ▁const ▁char ▁* boot _ device , ▁Display State ▁* ds , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁CPU State ▁* env ; ▁qemu _ irq ▁* pic ; ▁void ▁* sc si _ h ba ; ▁P CI Bus ▁* pc i _ bus ; ▁N IC Info ▁* nd ; ▁int ▁n ; ▁int ▁done _ sm c ▁= ▁0; ▁qemu _ irq ▁cpu _ irq [4 ]; ▁int ▁n cpu ; ▁int ▁index ; ▁if ▁(! cpu _ model ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q String ▁* q string _ from _ substr ( const ▁char ▁* str , ▁int ▁start , ▁int ▁end ) ▁{ ▁Q String ▁* q string ; ▁q string ▁= ▁g _ m alloc ( size of (* q string )); ▁q string -> length ▁= ▁end ▁- ▁start ▁+ ▁1; ▁q string -> capacity ▁= ▁q string -> length ; ▁q string -> string ▁= ▁g _ m alloc ( q string -> capacity ▁+ ▁1); ▁mem c py ( q string -> string , ▁str ▁+ ▁start , ▁q string -> length ); ▁q string -> string [ q string -> length ] ▁= ▁0; ▁Q OBJECT _ INIT ( q string , ▁& q string _ type ); ▁return ▁q

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ source _ wait _ event _ notifier ( void ) ▁{ ▁Event Notifier TestData ▁data ▁= ▁{ ▁. n ▁= ▁0, ▁. active ▁= ▁1 ▁}; ▁event _ notifier _ init ( & data . e , ▁false ); ▁aio _ set _ event _ notifier ( ctx , ▁& data . e , ▁event _ ready _ cb ); ▁g _ assert ( g _ main _ context _ iteration ( NULL , ▁false )); ▁g _ assert _ cmp int ( data . n , ▁== , ▁0); ▁g _ assert _ cmp int ( data . active , ▁== , ▁1); ▁event _ notifier _ set ( & data . e ); ▁g _ assert ( g _ main _ context _ iteration ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁is _ allocated _ base ( Block Driver State ▁* top , ▁Block Driver State ▁* base , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int ▁* p num ) ▁{ ▁Block Driver State ▁* inter mediate ; ▁int ▁ret , ▁n ; ▁ret ▁= ▁b dr v _ co _ is _ allocated ( top , ▁sector _ num , ▁nb _ sect ors , ▁& n ); ▁if ▁( ret ) ▁{ ▁* p num ▁= ▁n ; ▁return ▁ret ; ▁} ▁/* ▁* ▁Is ▁the ▁un allocated ▁chunk ▁[ sect or _ num , ▁n ] ▁also ▁* ▁un allocated ▁between ▁base ▁and ▁top ? ▁*/ ▁intermediate ▁= ▁top

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Display Type ▁select _ display ( const ▁char ▁* p ) ▁{ ▁Error ▁* err ▁= ▁NULL ; ▁const ▁char ▁* opts ; ▁Display Type ▁display ▁= ▁DT _ DEFAULT ; ▁if ▁( str start ( p , ▁" sdl ", ▁& opts )) ▁{ ▁# if def ▁CONFIG _ S DL ▁display ▁= ▁DT _ S DL ; ▁while ▁(* opts ) ▁{ ▁const ▁char ▁* next opt ; ▁if ▁( str start ( opts , ▁", frame =" , ▁& next opt )) ▁{ ▁opts ▁= ▁next opt ; ▁if ▁( str start ( opts , ▁" on ", ▁& next opt )) ▁{ ▁no _ frame ▁= ▁0; ▁} ▁else ▁if ▁( str start ( opts , ▁" off ", ▁& next opt ))

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ pack eth eader ( N UT Context ▁* n ut , ▁Byte IO Context ▁* bc , ▁int ▁prefix _ length , ▁int ▁calculate _ checksum ) ▁{ ▁int 64_ t ▁start , ▁size , ▁last _ size ; ▁start = ▁url _ ft ell ( bc ) ▁- ▁prefix _ length ; ▁if ( start ▁!= ▁nut -> packet _ start ▁+ ▁nut -> written _ packet _ size ){ ▁av _ log ( n ut -> av f , ▁AV _ LOG _ ERROR , ▁" get _ pack eth eader ▁called ▁at ▁weird ▁position \ n "); ▁return ▁-1; ▁} ▁if ( calculate _ checksum ) ▁init _ checksum ( bc , ▁update _ ad ler 32,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁meg as as _ un map _ frame ( M eg as as State ▁* s , ▁M eg as as Cmd ▁* cmd ) ▁{ ▁PC ID evice ▁* p ▁= ▁P CI _ DEVICE ( s ); ▁pci _ d ma _ un map ( p , ▁cmd -> frame , ▁cmd -> pa _ size , ▁0, ▁0); ▁cmd -> frame ▁= ▁NULL ; ▁cmd -> pa ▁= ▁0; ▁clear _ bit ( cmd -> index , ▁s -> frame _ map ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v 9 fs _ co _ open 2( V 9 fs State ▁* s , ▁V 9 fs F id State ▁* f id p , ▁char ▁* fullname , ▁gid _ t ▁gid , ▁int ▁flags , ▁int ▁mode ) ▁{ ▁int ▁err ; ▁Fs Cred ▁cred ; ▁cred _ init ( & cred ); ▁cred . fc _ mode ▁= ▁mode ▁& ▁0 7777 ; ▁cred . fc _ uid ▁= ▁fid p -> uid ; ▁cred . fc _ gid ▁= ▁gid ; ▁v 9 fs _ co _ run _ in _ worker ( ▁{ ▁fid p -> fs . fd ▁= ▁s -> ops -> open 2( & s -> ctx , ▁fullname , ▁flags , ▁& cred ); ▁err ▁= ▁0; ▁if ▁( f id p -> fs . fd ▁== ▁-1) ▁{ ▁err ▁= ▁- err no ; ▁} ▁}); ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁receive _ filter ( V irt ION et ▁* n , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size ) ▁{ ▁static ▁const ▁uint 8_ t ▁b cast [] ▁= ▁{0 xff , ▁0 xff , ▁0 xff , ▁0 xff , ▁0 xff , ▁0 xff }; ▁static ▁const ▁uint 8_ t ▁vlan [] ▁= ▁{0 x 8 1, ▁0 x 00 }; ▁uint 8_ t ▁* ptr ▁= ▁( uint 8_ t ▁* ) buf ; ▁int ▁i ; ▁if ▁( n -> prom isc ) ▁return ▁1; ▁if ▁(! mem cmp ( & ptr [ 12 ], ▁vlan , ▁sizeof ( vlan ))) ▁{ ▁int ▁vid ▁= ▁be 16_ to _ cp up (( uint 16_ t ▁* )( ptr ▁+ ▁14 )) ▁& ▁0 xff f ; ▁if ▁(! ( n -> vl ans [ vi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁output _ packet ( InputStream ▁* ist , ▁int ▁ist _ index , ▁OutputStream ▁* ost _ table , ▁int ▁nb _ ost ream s , ▁const ▁AV Packet ▁* pk t ) ▁{ ▁AV Format Context ▁* os ; ▁OutputStream ▁* ost ; ▁int ▁ret , ▁i ; ▁int ▁got _ output ; ▁void ▁* buffer _ to _ free ▁= ▁NULL ; ▁static ▁unsigned ▁int ▁samples _ size = ▁0; ▁AV Sub title ▁subtitle , ▁* sub title _ to _ free ; ▁int 64_ t ▁pkt _ pts ▁= ▁AV _ NO PT S _ VALUE ; ▁# if ▁CONFIG _ AV FILTER ▁int ▁frame _ available ; ▁# end if ▁float ▁quality

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ tl bs x _4 40 ( Dis as Context ▁* ctx ) ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ OP C ); ▁# else ▁TC G v ▁t 0; ▁if ▁( un likely ( ctx -> pr )) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ OP C ); ▁return ; ▁} ▁t 0 ▁= ▁tc g _ temp _ new (); ▁gen _ addr _ reg _ index ( ctx , ▁t 0); ▁gen _ helper _4 40 _ tl bs x ( cpu _ g pr [ r D ( ctx -> op code )], ▁cpu _ env , ▁t 0); ▁tc g _ temp _ free ( t 0); ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁G Source ▁* io handler _ get _ g _ source ( void ) ▁{ ▁io handler _ init (); ▁return ▁aio _ get _ g _ source ( io handler _ ctx ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ mpeg 1_ find _ frame _ end ( Parse Context ▁* pc , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁int ▁i ; ▁uint 32_ t ▁state = ▁pc -> state ; ▁/* ▁EOF ▁considered ▁as ▁end ▁of ▁frame ▁*/ ▁if ▁( buf _ size ▁== ▁0) ▁return ▁0; ▁/* ▁0 ▁frame ▁start ▁-> ▁1 /4 ▁1 ▁first _ SE Q EXT ▁-> ▁0 /2 ▁2 ▁first ▁field ▁start ▁-> ▁3 /0 ▁3 ▁second _ SE Q EXT ▁-> ▁2 /0 ▁4 ▁searching ▁end ▁*/ ▁for ( i =0; ▁i < buf _ size ; ▁i ++){ ▁assert ( pc -> frame _ start _ found > =0 ▁&& ▁pc -> frame _ start _ found <= 4

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁FF V 1 Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁const ▁AV Pix F mt Descriptor ▁* desc ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> pix _ fmt ); ▁int ▁i , ▁j , ▁k , ▁m , ▁ret ; ▁if ▁(( ret ▁= ▁ff _ ff v 1_ common _ init ( av ctx )) ▁< ▁0) ▁return ▁ret ; ▁s -> version ▁= ▁0; ▁if ▁(( av ctx -> flags ▁& ▁( AV _ CODE C _ FLAG _ PASS 1 ▁| ▁AV _ CODE C _ FLAG _ PASS 2)) ▁|| ▁av ctx -> slices ▁> ▁1) ▁s -> version ▁= ▁FF MAX ( s -> version 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ls _ slice _ data _ w pp ( HE VC Context ▁* s , ▁const ▁HE VC NAL ▁* nal ) ▁{ ▁const ▁uint 8_ t ▁* data ▁= ▁n al -> data ; ▁int ▁length ▁= ▁n al -> size ; ▁HE VC Local Context ▁* lc ▁= ▁s -> HE V Cl c ; ▁int ▁* ret ▁= ▁av _ m alloc _ array ( s -> sh . num _ entry _ point _ offsets ▁+ ▁1, ▁sizeof ( int )); ▁int ▁* arg ▁= ▁av _ m alloc _ array ( s -> sh . num _ entry _ point _ offsets ▁+ ▁1, ▁sizeof ( int )); ▁int 64_ t ▁offset ; ▁int ▁star th eader , ▁cm pt ▁= ▁0; ▁int ▁i , ▁j , ▁res ▁= ▁0;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p xa 2 xx _ l cd c _ d ma 0_ red raw _ rot 0( P XA 2 xx L CD State ▁* s , ▁hw addr ▁addr , ▁int ▁* min y , ▁int ▁* max y ) ▁{ ▁Display Surface ▁* surface ▁= ▁qemu _ console _ surface ( s -> con ); ▁int ▁src _ width , ▁dest _ width ; ▁draw fn ▁fn ▁= ▁NULL ; ▁if ▁( s -> dest _ width ) ▁fn ▁= ▁s -> line _ fn [ s -> trans p ][ s -> b pp ]; ▁if ▁(! fn ) ▁return ; ▁src _ width ▁= ▁( s -> x res ▁+ ▁3) ▁& ▁~ 3; ▁/* ▁P ad ▁to ▁a ▁4 ▁pixels ▁multiple ▁*/ ▁if ▁( s -> b pp ▁== ▁p xa _ l cd c _1 9 pb pp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ d mar _ q 35 ( G Array ▁* table _ data , ▁G Array ▁* link er ) ▁{ ▁int ▁d mar _ start ▁= ▁table _ data -> len ; ▁Ac pi Table D mar ▁* d mar ; ▁Ac pi D mar Hardware Unit ▁* dr hd ; ▁d mar ▁= ▁ac pi _ data _ push ( table _ data , ▁sizeof (* d mar )); ▁d mar -> host _ address _ width ▁= ▁V TD _ HOST _ ADDRESS _ WIDTH ▁- ▁1; ▁d mar -> flags ▁= ▁0; ▁/* ▁No ▁intr _ re map ▁for ▁now ▁*/ ▁/* ▁DM AR ▁Rem apping ▁H ardware ▁Unit ▁Definition ▁structure ▁*/ ▁dr hd ▁= ▁ac pi _ data _ push ( table _ data , ▁si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Gtk Widget ▁* gd _ create _ menu _ machine ( G tk Display State ▁* s , ▁Gtk Accel Group ▁* accel _ group ) ▁{ ▁Gtk Widget ▁* machine _ menu ; ▁Gtk Widget ▁* separator ; ▁machine _ menu ▁= ▁gtk _ menu _ new (); ▁gtk _ menu _ set _ accel _ group ( GT K _ MENU ( machine _ menu ), ▁accel _ group ); ▁s -> pause _ item ▁= ▁gtk _ check _ menu _ item _ new _ with _ mn emonic (_ (" _ Pause ")); ▁gtk _ menu _ shell _ append ( GT K _ MENU _ SH ELL ( machine _ menu ), ▁s -> pause _ item ); ▁separator ▁= ▁gtk

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mv 88 w 86 18 _ flash cfg _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁uint 64_ t ▁value , ▁unsigned ▁size ) ▁{ ▁mv 88 w 86 18 _ flash cfg _ state ▁* s ▁= ▁opaque ; ▁switch ▁( offset ) ▁{ ▁case ▁MP _ FL ASH CF G _ CF GR 0: ▁s -> cf gr 0 ▁= ▁value ; ▁break ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ rd ma _ get _ fd ( void ▁* op aque ) ▁{ ▁Q EM U File RD MA ▁* r file ▁= ▁opaque ; ▁R D MA Context ▁* rd ma ▁= ▁rfile -> rd ma ; ▁return ▁rd ma -> comp _ channel -> fd ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dump _ pp c _ ins ns ▁( CP UP PC State ▁* env ) ▁{ ▁op c _ handler _ t ▁** table , ▁* handler ; ▁const ▁char ▁* p , ▁* q ; ▁uint 8_ t ▁op c 1, ▁op c 2, ▁op c 3; ▁printf (" Instructions ▁set :\ n "); ▁/* ▁op c 1 ▁is ▁6 ▁bits ▁long ▁*/ ▁for ▁( op c 1 ▁= ▁0 x 00 ; ▁op c 1 ▁< ▁P PC _ CPU _ OP CODES _ LEN ; ▁op c 1 ++) ▁{ ▁table ▁= ▁env -> op codes ; ▁handler ▁= ▁table [ op c 1 ]; ▁if ▁( is _ ind irect _ op code ( handler )) ▁{ ▁/* ▁op c 2 ▁is ▁5 ▁bits ▁long ▁*/ ▁for ▁( op c 2 ▁= ▁0; ▁op c 2 ▁< 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 rgb _2_ c _ template ( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* buf [2], ▁const ▁int 16_ t ▁* ub uf [2], ▁const ▁int 16_ t ▁* v buf [2], ▁const ▁int 16_ t ▁* ab uf [2], ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁y alpha , ▁int ▁u val pha , ▁int ▁y , ▁enum ▁Pixel Format ▁target , ▁int ▁has Alpha ) ▁{ ▁const ▁int 16_ t ▁* buf 0 ▁= ▁buf [0], ▁* buf 1 ▁= ▁buf [1], ▁* ub uf 0 ▁= ▁u buf [0], ▁* ub uf 1 ▁= ▁u buf [1], ▁* v buf 0 ▁= ▁v buf [0], ▁* v buf 1 ▁= ▁v buf [1], ▁* ab uf 0 ▁= ▁ab uf [0], ▁* ab uf 1 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁minimum _ frame _ bits ( VC 2 Enc Context ▁* s ) ▁{ ▁int ▁slice _ x , ▁slice _ y , ▁bits ▁= ▁0; ▁s -> size _ scaler ▁= ▁64 ; ▁for ▁( slice _ y ▁= ▁0; ▁slice _ y ▁< ▁s -> num _ y ; ▁slice _ y ++) ▁{ ▁for ▁( slice _ x ▁= ▁0; ▁slice _ x ▁< ▁s -> num _ x ; ▁slice _ x ++) ▁{ ▁bits ▁+= ▁count _ hq _ slice ( s , ▁NULL , ▁slice _ x , ▁slice _ y , ▁s -> q _ ceil ); ▁} ▁} ▁return ▁bits ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fd _ cor outine _ enter ( void ▁* op aque ) ▁{ ▁F DY ield Until Data ▁* data ▁= ▁opaque ; ▁qemu _ set _ fd _ handler ( data -> fd , ▁NULL , ▁NULL , ▁NULL ); ▁qemu _ cor outine _ enter ( data -> co , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qc ow _ a io _ write _ cb ( void ▁* op aque , ▁int ▁ret ) ▁{ ▁Q C ow A IO CB ▁* ac b ▁= ▁opaque ; ▁Block Driver State ▁* bs ▁= ▁ac b -> common . bs ; ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁index _ in _ cluster ; ▁uint 64_ t ▁cluster _ offset ; ▁const ▁uint 8_ t ▁* src _ buf ; ▁int ▁n _ end ; ▁ac b -> hd _ ai oc b ▁= ▁NULL ; ▁if ▁( ret ▁< ▁0) ▁{ ▁fail : ▁ac b -> common . cb ( ac b -> common . op aque , ▁ret ); ▁qemu _ a io _ release ( ac b ); ▁return ; ▁} ▁ac b -> nb _ sect ors 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁opt _ input _ file ( const ▁char ▁* opt , ▁const ▁char ▁* filename ) ▁{ ▁AV Format Context ▁* ic ; ▁AV InputFormat ▁* file _ iform at ▁= ▁NULL ; ▁int ▁err , ▁i , ▁ret , ▁rf ps , ▁rf ps _ base ; ▁int 64_ t ▁timestamp ; ▁uint 8_ t ▁buf [ 128 ]; ▁AV Dictionary ▁** opts ; ▁int ▁orig _ nb _ streams ; ▁// ▁number ▁of ▁streams ▁before ▁av format _ find _ stream _ info ▁if ▁( last _ ask ed _ format ) ▁{ ▁if ▁(! ( file _ iform at ▁= ▁av _ find _ input _ format ( last _ ask ed _ format ))) ▁{ ▁f print

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ hub _ handle _ control ( US B Device ▁* dev , ▁USB Packet ▁* p , ▁int ▁request , ▁int ▁value , ▁int ▁index , ▁int ▁length , ▁uint 8_ t ▁* data ) ▁{ ▁USB Hub State ▁* s ▁= ▁( US B Hub State ▁* ) dev ; ▁int ▁ret ; ▁ret ▁= ▁usb _ desc _ handle _ control ( dev , ▁p , ▁request , ▁value , ▁index , ▁length , ▁data ); ▁if ▁( ret ▁>= ▁0) ▁{ ▁return ▁ret ; ▁} ▁switch ( request ) ▁{ ▁case ▁Endpoint Out Request ▁| ▁USB _ REQ _ CLEAR _ FEATURE : ▁if ▁( value ▁== ▁0 ▁&& ▁index ▁!= ▁0 x 8 1) ▁{ ▁/* ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ write _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁M XF Context ▁* mx f ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ▁= ▁s -> streams [ pk t -> stream _ index ]; ▁M XF Stream Context ▁* sc ▁= ▁st -> priv _ data ; ▁M XF Index Entry ▁ie ▁= ▁{0 }; ▁if ▁(! mx f -> edit _ unit _ byte _ count ▁&& ▁! ( mx f -> edit _ units _ count ▁% ▁EDIT _ UN ITS _ PER _ BODY )) ▁{ ▁mx f -> index _ entries ▁= ▁av _ real loc ( mx f -> index _ entries , ▁( mx f -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ arm _ handle _ mm u _ fault ▁( CPU State ▁* env , ▁target _ ulong ▁address , ▁int ▁access _ type , ▁int ▁mm u _ idx , ▁int ▁is _ soft mm u ) ▁{ ▁uint 32_ t ▁phys _ addr ; ▁target _ ulong ▁page _ size ; ▁int ▁prot ; ▁int ▁ret , ▁is _ user ; ▁is _ user ▁= ▁mm u _ idx ▁== ▁MM U _ USER _ ID X ; ▁ret ▁= ▁get _ ph ys _ addr ( env , ▁address , ▁access _ type , ▁is _ user , ▁& ph ys _ addr , ▁& prot , ▁& page _ size ); ▁if ▁( ret ▁== ▁0) ▁{ ▁/* ▁Map ▁a ▁single ▁[ sub ] page . ▁*/ ▁phys _ addr ▁&= ▁~ (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁get _ chrom a _ qp ( H 264 Context ▁* h , ▁int ▁t , ▁int ▁q scale ){ ▁return ▁h -> pp s . chrom a _ qp _ table [ t ][ q scale ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b ink b _ decode _ plane ( B ink Context ▁* c , ▁AV Frame ▁* frame , ▁Bit stream Context ▁* bc , ▁int ▁plane _ idx , ▁int ▁is _ key , ▁int ▁is _ chrom a ) ▁{ ▁int ▁blk , ▁ret ; ▁int ▁i , ▁j , ▁bx , ▁by ; ▁uint 8_ t ▁* dst , ▁* ref , ▁* ref _ start , ▁* ref _ end ; ▁int ▁v , ▁col [2 ]; ▁const ▁uint 8_ t ▁* scan ; ▁int ▁x off , ▁y off ; ▁LOCAL _ ALI G NED _16 ( int 16_ t , ▁block , ▁[ 64 ]); ▁LOCAL _ ALI G NED _16 ( int 32_ t , ▁dct block , ▁[ 64 ]); ▁int ▁coord map [ 64 ]; ▁int ▁y bias ▁= ▁is

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ c ps r ( Q EM U File ▁* f , ▁void ▁* op aque , ▁size _ t ▁size ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁opaque ; ▁CPU ARM State ▁* env ▁= ▁& cpu -> env ; ▁uint 32_ t ▁val ▁= ▁qemu _ get _ be 32 ( f ); ▁env -> a arch 64 ▁= ▁(( val ▁& ▁P STATE _ n R W ) ▁== ▁0); ▁if ▁( is _ a 64 ( env )) ▁{ ▁p state _ write ( env , ▁val ); ▁return ▁0; ▁} ▁/* ▁Avoid ▁mode ▁switch ▁when ▁rest oring ▁C PS R ▁*/ ▁env -> unc ached _ c ps r ▁= ▁val ▁& ▁C PS R _ M ; ▁c ps r _ write ( env , ▁val , ▁0 xffffffff , ▁C PS R Write R

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁term _ handle _ byte ( int ▁ch ) ▁{ ▁switch ( term _ esc _ state ) ▁{ ▁case ▁IS _ N ORM : ▁switch ( ch ) ▁{ ▁case ▁1: ▁term _ b ol (); ▁break ; ▁case ▁4: ▁term _ delete _ char (); ▁break ; ▁case ▁5: ▁term _ e ol (); ▁break ; ▁case ▁9 : ▁term _ completion (); ▁break ; ▁case ▁10: ▁case ▁13 : ▁term _ cmd _ buf [ term _ cmd _ buf _ size ] ▁= ▁'\ 0 '; ▁term _ hist _ add ( term _ cmd _ buf ); ▁term _ printf ("\ n "); ▁term _ handle _ command ( term _ cmd _ buf ); ▁term _ show _ prompt (); ▁break 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ l 4_ s ▁* om ap _ l 4_ init ( target _ ph ys _ addr _ t ▁base , ▁int ▁ta _ num ) ▁{ ▁struct ▁o map _ l 4_ s ▁* bus ▁= ▁g _ m alloc 0( ▁sizeof (* bus ) ▁+ ▁ta _ num ▁* ▁sizeof (* bus -> ta )); ▁bus -> ta _ num ▁= ▁ta _ num ; ▁bus -> base ▁= ▁base ; ▁# if def ▁L 4_ MU X _ H ACK ▁o map _ l 4_ io _ entries ▁= ▁1; ▁o map _ l 4_ io _ entry ▁= ▁g _ m alloc 0( 125 ▁* ▁sizeof (* om ap _ l 4_ io _ entry )); ▁o map _ cpu _ io _ entry ▁= ▁cpu _ register _ io _ memory ( om ap _ l 4_ io _ read fn , ▁o 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q bus _ list _ bus ( Device State ▁* dev , ▁char ▁* dest , ▁int ▁len ) ▁{ ▁Bus State ▁* child ; ▁const ▁char ▁* sep ▁= ▁" ▁"; ▁int ▁pos ▁= ▁0; ▁pos ▁+= ▁sn printf ( dest + pos , ▁len - pos ," child ▁bu ss es ▁at ▁\" % s \": ", ▁dev -> id ▁? ▁dev -> id ▁: ▁dev -> info -> name ); ▁LIST _ FORE A CH ( child , ▁& dev -> child _ bus , ▁sibling ) ▁{ ▁pos ▁+= ▁sn printf ( dest + pos , ▁len - pos , ▁"% s \" % s \" ", ▁sep , ▁child -> name ); ▁sep ▁= ▁", ▁"; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ directory ( B DR V V V F AT State * ▁s , ▁int ▁mapping _ index ) ▁{ ▁mapping _ t * ▁mapping ▁= ▁array _ get ( & ( s -> mapping ), ▁mapping _ index ); ▁dire n try _ t * ▁dire n try ; ▁const ▁char * ▁dirname ▁= ▁mapping -> path ; ▁int ▁first _ cluster ▁= ▁mapping -> begin ; ▁int ▁parent _ index ▁= ▁mapping -> info . dir . parent _ mapping _ index ; ▁mapping _ t * ▁parent _ mapping ▁= ▁( mapping _ t *) ▁( parent _ index ▁>= ▁0 ▁? ▁array _ get ( & ( s -> mapping ), ▁parent _ index ) ▁: ▁N

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁replace _ int _ data _ in _ filename ( char ▁* buf , ▁int ▁buf _ size , ▁const ▁char ▁* filename , ▁char ▁placeholder , ▁int 64_ t ▁number ) ▁{ ▁const ▁char ▁* p ; ▁char ▁* q , ▁buf 1[ 20 ], ▁c ; ▁int ▁nd , ▁len , ▁add char _ count ; ▁int ▁found _ count ▁= ▁0; ▁q ▁= ▁buf ; ▁p ▁= ▁filename ; ▁for ▁( ; ;) ▁{ ▁c ▁= ▁* p ; ▁if ▁( c ▁== ▁'\ 0 ') ▁break ; ▁if ▁( c ▁== ▁'% ' ▁&& ▁* ( p +1) ▁== ▁'% ') ▁// ▁%% ▁add char _ count ▁= ▁2; ▁else ▁if ▁( c ▁== ▁'% ' ▁&& ▁( av _ is digit (* ( p +1 )) ▁|| ▁* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cub i eb o ard _ init ( Q EM UM achine Init Args ▁* args ) ▁{ ▁C ub ie Board State ▁* s ▁= ▁g _ new ( C ub ie Board State , ▁1); ▁Error ▁* err ▁= ▁NULL ; ▁s -> a 10 ▁= ▁AW _ A 10 ( object _ new ( TYPE _ AW _ A 10 )); ▁object _ property _ set _ bool ( OBJECT ( s -> a 10 ), ▁true , ▁" real ized ", ▁& err ); ▁if ▁( err ▁!= ▁NULL ) ▁{ ▁error _ report (" Could n ' t ▁realize ▁All w inner ▁A 10 : ▁% s \ n ", ▁error _ get _ pretty ( err )); ▁exit (1); ▁} ▁memory _ region _ init _ ram ( & s -> sd r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁es p _ init ( target _ ph ys _ addr _ t ▁es p addr , ▁int ▁it _ shift , ▁E SP D MA Memory Read Write Func ▁d ma _ memory _ read , ▁E SP D MA Memory Read Write Func ▁d ma _ memory _ write , ▁void ▁* d ma _ op aque , ▁qemu _ irq ▁irq , ▁qemu _ irq ▁* reset , ▁qemu _ irq ▁* d ma _ enable ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁Sys Bus ES P State ▁* sys bus ; ▁E SP State ▁* es p ; ▁dev ▁= ▁q dev _ create ( NULL , ▁" es p "); ▁sys bus ▁= ▁DO _ UP CAST ( Sys Bus ES P State , ▁bus dev . q dev 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁apply _ window _ and _ md ct ( AV Codec Context ▁* av ctx , ▁const ▁AV Frame ▁* frame ) ▁{ ▁W MA Codec Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁float ▁** audio ▁= ▁( float ▁** ) ▁frame -> extended _ data ; ▁int ▁len ▁= ▁frame -> nb _ samples ; ▁int ▁window _ index ▁= ▁s -> frame _ len _ bits ▁- ▁s -> block _ len _ bits ; ▁FFT Context ▁* md ct ▁= ▁& s -> md ct _ ctx [ window _ index ]; ▁int ▁ch ; ▁const ▁float ▁* win ▁= ▁s -> windows [ window _ index ]; ▁int ▁window _ len ▁= ▁1 ▁<< ▁s -> bl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁diff _ pixels _ alt ive c ( int 16_ t ▁* restrict ▁block , ▁const ▁uint 8_ t ▁* s 1, ▁const ▁uint 8_ t ▁* s 2, ▁int ▁stride ) ▁{ ▁int ▁i ; ▁vec _ u 8 ▁perm 1 ▁= ▁vec _ lv sl (0, ▁s 1); ▁vec _ u 8 ▁perm 2 ▁= ▁vec _ lv sl (0, ▁s 2); ▁const ▁vec _ u 8 ▁zero ▁= ▁( const ▁vec _ u 8) vec _ s plat _ u 8 (0); ▁vec _ s 16 ▁short s 1, ▁short s 2; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++) ▁{ ▁/* ▁Read ▁potentially ▁un aligned ▁pixels . ▁* ▁We ' re ▁reading ▁16 ▁pixels , ▁and ▁actually ▁only ▁want ▁8, ▁* ▁but 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ thread _ get _ buffer ( AV Codec Context ▁* av ctx , ▁AV Frame ▁* f ) ▁{ ▁Per Thread Context ▁* p ▁= ▁av ctx -> thread _ op aque ; ▁int ▁* progress , ▁err ; ▁f -> owner ▁= ▁av ctx ; ▁ff _ init _ buffer _ info ( av ctx , ▁f ); ▁if ▁(! ( av ctx -> active _ thread _ type & FF _ THREAD _ FRAME )) ▁{ ▁f -> thread _ op aque ▁= ▁NULL ; ▁return ▁av ctx -> get _ buffer ( av ctx , ▁f ); ▁} ▁if ▁( p -> state ▁!= ▁STATE _ SETTING _ UP ▁&& ▁( av ctx -> codec -> update _ thread _ context ▁|| ▁(! av ctx -> th

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁q io _ task _ propag ate _ error ( Q IO Task ▁* task , ▁Error ▁** err p ) ▁{ ▁if ▁( task -> err ) ▁{ ▁error _ propag ate ( err p , ▁task -> err ); ▁return ▁true ; ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h ds _ free ( AV Format Context ▁* s ) ▁{ ▁H DS Context ▁* c ▁= ▁s -> priv _ data ; ▁int ▁i , ▁j ; ▁if ▁(! c -> streams ) ▁return ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> nb _ streams ; ▁i ++) ▁{ ▁OutputStream ▁* os ▁= ▁& c -> streams [ i ]; ▁if ▁( os -> out ) ▁av io _ close ( os -> out ); ▁os -> out ▁= ▁NULL ; ▁if ▁( os -> ctx ▁&& ▁os -> ctx _ init ed ) ▁av _ write _ trail er ( os -> ctx ); ▁if ▁( os -> ctx ▁&& ▁os -> ctx -> pb ) ▁av _ free ( os -> ctx -> pb ); ▁if ▁( os -> ctx ) ▁av format _ free _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 ya 8 _2_ c ( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* buf [2], ▁const ▁int 16_ t ▁* ub uf [2], ▁const ▁int 16_ t ▁* v buf [2], ▁const ▁int 16_ t ▁* ab uf [2], ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁y alpha , ▁int ▁u val pha , ▁int ▁y ) ▁{ ▁int ▁has Alpha ▁= ▁ab uf [0] ▁&& ▁ab uf [1]; ▁const ▁int 16_ t ▁* buf 0 ▁= ▁buf [0], ▁* buf 1 ▁= ▁buf [1], ▁* ab uf 0 ▁= ▁has Alpha ▁? ▁ab uf [0] ▁: ▁NULL , ▁* ab uf 1 ▁= ▁has Alpha ▁? ▁ab uf [1] ▁: ▁NULL ; ▁int ▁y alpha 1 ▁= ▁4096 ▁- ▁y alpha ; ▁int ▁i ; ▁for

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁device _ un parent ( Object ▁* obj ) ▁{ ▁Device State ▁* dev ▁= ▁DEVICE ( obj ); ▁Bus State ▁* bus ; ▁if ▁( dev -> real ized ) ▁{ ▁object _ property _ set _ bool ( obj , ▁false , ▁" real ized ", ▁NULL ); ▁} ▁while ▁( dev -> num _ child _ bus ) ▁{ ▁bus ▁= ▁Q LIST _ FIRST ( & dev -> child _ bus ); ▁object _ un parent ( OBJECT ( bus )); ▁} ▁if ▁( dev -> parent _ bus ) ▁{ ▁bus _ remove _ child ( dev -> parent _ bus , ▁dev ); ▁object _ un ref ( OBJECT ( dev -> parent _ bus )); ▁dev -> parent _ b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q Bool ▁* q bool _ from _ bool ( bool ▁value ) ▁{ ▁Q Bool ▁* q b ; ▁qb ▁= ▁g _ m alloc ( size of (* q b )); ▁qb -> value ▁= ▁value ; ▁Q OBJECT _ INIT ( q b , ▁& q bool _ type ); ▁return ▁qb ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁setup _ rt _ frame ( int ▁us ig , ▁struct ▁em ulated _ sig action ▁* ka , ▁target _ sig info _ t ▁* info , ▁target _ sig set _ t ▁* set , ▁CPU State ▁* env ) ▁{ ▁struct ▁rt _ sig frame ▁* frame ▁= ▁get _ sig frame ( ka , ▁env , ▁sizeof (* frame )); ▁int ▁err ▁= ▁0; ▁# if ▁0 ▁if ▁(! access _ ok ( VER IFY _ WRITE , ▁frame , ▁sizeof ▁(* frame ))) ▁return ▁1; ▁# end if ▁__ put _ user _ error ( & frame -> info , ▁( target _ ulong ▁* ) & frame -> p info , ▁err ); ▁__ put _ user _ error ( & frame 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ ph b _ placement ( s P AP R Machine State ▁* sp ap r , ▁uint 32_ t ▁index , ▁uint 64_ t ▁* b uid , ▁hw addr ▁* p io , ▁hw addr ▁* mm io 32, ▁hw addr ▁* mm io 64, ▁unsigned ▁n _ d ma , ▁uint 32_ t ▁* li ob ns , ▁Error ▁** err p ) ▁{ ▁/* ▁* ▁New - style ▁PH B ▁window ▁placement . ▁* ▁* ▁Go als : ▁G ives ▁large ▁(1 T iB ), ▁naturally ▁aligned ▁64- bit ▁MM IO ▁window ▁* ▁for ▁each ▁PH B , ▁in ▁addition ▁to ▁2 G iB ▁32- bit ▁MM IO ▁and ▁64 ki B ▁P IO ▁* ▁windows . ▁* ▁* ▁Some ▁guest ▁k

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc 405 ep _ compute _ clock s ▁( pp c 405 ep _ c pc _ t ▁* c pc ) ▁{ ▁uint 32_ t ▁CPU _ cl k , ▁PL B _ cl k , ▁OP B _ cl k , ▁E BC _ cl k , ▁M AL _ cl k , ▁P CI _ cl k ; ▁uint 32_ t ▁U ART 0_ cl k , ▁U ART 1_ cl k ; ▁uint 64_ t ▁V CO _ out , ▁P LL _ out ; ▁int ▁M , ▁D ; ▁V CO _ out ▁= ▁0; ▁if ▁(( c pc -> pl l mr [1] ▁& ▁0 x 8 0000000 ) ▁&& ▁! ( c pc -> pl l mr [1] ▁& ▁0 x 4 0000000 )) ▁{ ▁M ▁= ▁( (( c pc -> pl l mr [1] ▁>> ▁20 ) ▁- ▁1) ▁& ▁0 xF ) ▁+ ▁1; ▁/* ▁F BM UL ▁*/ ▁# if def ▁DEBUG _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ w mv 2_ common _ init ( W mv 2 Context ▁* ▁w ){ ▁M peg Enc Context ▁* ▁const ▁s = ▁& w -> s ; ▁ff _ init _ sc ant able ( s -> d sp . id ct _ perm utation , ▁& w -> ab t _ sc ant able [0], ▁ff _ w mv 2_ sc ant able A ); ▁ff _ init _ sc ant able ( s -> d sp . id ct _ perm utation , ▁& w -> ab t _ sc ant able [1], ▁ff _ w mv 2_ sc ant able B ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tap _ fd _ set _ off load ( int ▁fd , ▁int ▁c sum , ▁int ▁t so 4, ▁int ▁t so 6, ▁int ▁ec n , ▁int ▁u fo ) ▁{ ▁unsigned ▁int ▁off load ▁= ▁0; ▁if ▁( c sum ) ▁{ ▁off load ▁|= ▁T UN _ F _ CS UM ; ▁if ▁( t so 4) ▁off load ▁|= ▁T UN _ F _ T SO 4; ▁if ▁( t so 6) ▁off load ▁|= ▁T UN _ F _ T SO 6 ; ▁if ▁(( t so 4 ▁|| ▁t so 6) ▁&& ▁ec n ) ▁off load ▁|= ▁T UN _ F _ T SO _ EC N ; ▁if ▁( u fo ) ▁off load ▁|= ▁T UN _ F _ U FO ; ▁if ▁( io ctl ( fd , ▁T UN SE TO FF LOAD , ▁off load ) ▁!= ▁0) ▁{ ▁off load ▁&= ▁~ T

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ mpeg 1_ encode _ init ( M peg Enc Context ▁* s ) ▁{ ▁static ▁int ▁done =0; ▁common _ init ( s ); ▁if (! done ){ ▁int ▁f _ code ; ▁int ▁mv ; ▁int ▁i ; ▁done =1; ▁init _ rl ( & rl _ mpeg 1); ▁for ( i =0; ▁i < 64 ; ▁i ++) ▁{ ▁m peg 1_ max _ level [0] [ i ]= ▁rl _ mpeg 1. max _ level [0] [ i ]; ▁m peg 1_ index _ run [0] [ i ]= ▁rl _ mpeg 1. index _ run [0] [ i ]; ▁} ▁init _ uni _ ac _ vlc ( & rl _ mpeg 1, ▁uni _ mpeg 1_ ac _ vlc _ bits , ▁uni _ mpeg 1_ ac _ vlc _ len ); ▁/* ▁build ▁unified ▁dc ▁en

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ac 3_ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁AC 3 Decode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> av ctx ▁= ▁av ctx ; ▁ff _ ac 3_ common _ init (); ▁ac 3_ tables _ init (); ▁ff _ md ct _ init ( & s -> im d ct _ 25 6, ▁8, ▁1, ▁1.0 ); ▁ff _ md ct _ init ( & s -> im d ct _5 12, ▁9, ▁1, ▁1.0 ); ▁ff _ k bd _ window _ init ( s -> window , ▁5 .0, ▁256 ); ▁ds put il _ init ( & s -> d sp , ▁av ctx ); ▁ff _ fmt _ convert _ init ( & s -> fmt _ conv , ▁av ctx ); ▁av _ l fg _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁count _ frame _ bits _ fixed ( AC 3 Encode Context ▁* s ) ▁{ ▁static ▁const ▁int ▁frame _ bits _ inc [ 8] ▁= ▁{ ▁0, ▁0, ▁2, ▁2, ▁2, ▁4, ▁2, ▁4 ▁}; ▁int ▁blk ; ▁int ▁frame _ bits ; ▁/* ▁assumptions : ▁* ▁no ▁dynamic ▁range ▁codes ▁* ▁bit ▁allocation ▁parameters ▁do ▁not ▁change ▁between ▁blocks ▁* ▁no ▁delta ▁bit ▁allocation ▁* ▁no ▁skipped ▁data ▁* ▁no ▁aux illi ary ▁data ▁* ▁no ▁E - AC -3 ▁metadata ▁*/ ▁/* ▁header ▁*/ ▁frame _ bits ▁= ▁16 ; ▁/* ▁sync ▁info ▁*/ ▁if ▁( s -> e ac 3) ▁{ ▁/* ▁b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av _ n oin line ▁filter _ mb _ ed g ev ( ▁uint 8_ t ▁* pix , ▁int ▁stride , ▁int 16_ t ▁b S [4 ], ▁unsigned ▁int ▁qp , ▁H 264 Context ▁* h ) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁52 ▁+ ▁qp ▁+ ▁h -> slice _ alpha _ c 0_ offset ; ▁const ▁int ▁alpha ▁= ▁alpha _ table [ index _ a ]; ▁const ▁int ▁beta ▁= ▁( beta _ table + 5 2) [ qp ▁+ ▁h -> slice _ beta _ offset ]; ▁if ▁( alpha ▁== 0 ▁|| ▁beta ▁== ▁0) ▁return ; ▁if ( ▁b S [0] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc [4 ]; ▁tc [0] ▁= ▁tc 0_ table [ index _ a 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av codec _ decode _ audio ( AV Codec Context ▁* av ctx , ▁int 16_ t ▁* samples , ▁int ▁* frame _ size _ ptr , ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁int ▁ret ; ▁* frame _ size _ ptr = ▁0; ▁if (( av ctx -> codec -> capabilities ▁& ▁CODE C _ CAP _ DELAY ) ▁|| ▁buf _ size ){ ▁ret ▁= ▁av ctx -> codec -> decode ( av ctx , ▁samples , ▁frame _ size _ ptr , ▁buf , ▁buf _ size ); ▁av ctx -> frame _ number ++; ▁} else ▁ret = ▁0; ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁vp 8_ decode _ m vs ( VP 8 Context ▁* s , ▁V P 8 Macro block ▁* mb , ▁int ▁mb _ x , ▁int ▁mb _ y , ▁int ▁layout ) ▁{ ▁V P 8 Macro block ▁* mb _ edge [3] ▁= ▁{ ▁0 ▁/* ▁top ▁*/ , ▁mb ▁- ▁1 ▁/* ▁left ▁*/ , ▁0 ▁/* ▁top - left ▁*/ ▁}; ▁enum ▁{ ▁C NT _ ZERO , ▁C NT _ NE A REST , ▁C NT _ NE AR , ▁C NT _ SP LI TM V ▁}; ▁enum ▁{ ▁V P 8_ ED GE _ TOP , ▁V P 8_ ED GE _ LEFT , ▁V P 8_ ED GE _ TOP LEFT ▁}; ▁int ▁idx ▁= ▁C NT _ ZERO ; ▁int ▁cur _ sign _ bias ▁= ▁s -> sign _ bias [ mb -> ref _ frame ]; ▁int 8_ t ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁main () ▁{ ▁int ▁rd , ▁rt , ▁d sp ; ▁int ▁result , ▁result d sp ; ▁rt ▁= ▁0 x 12345678 ; ▁result ▁= ▁0 xA 000 C 000; ▁result d sp ▁= ▁1; ▁__ asm ▁(" sh ll . ph ▁% 0, ▁% 2, ▁0 x 0 B \ n \ t " ▁" r dd sp ▁% 1\ n \ t " ▁: ▁" = r " ( rd ), ▁" = r " ( d sp ) ▁: ▁" r " ( rt ) ▁); ▁d sp ▁= ▁( d sp ▁>> ▁2 2) ▁& ▁0 x 01 ; ▁assert ( d sp ▁== ▁result d sp ); ▁assert ( rd ▁== ▁result ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ r le _ encode ( uint 8_ t ▁* out buf , ▁int ▁out _ size , ▁const ▁uint 8_ t ▁* ptr ▁, ▁int ▁b pp , ▁int ▁w , ▁int 8_ t ▁add , ▁uint 8_ t ▁xor ) ▁{ ▁int ▁count , ▁x ; ▁uint 8_ t ▁* out ; ▁out ▁= ▁out buf ; ▁for ( x ▁= ▁0; ▁x ▁< ▁w ; ▁x ▁+= ▁count ) ▁{ ▁/* ▁see ▁if ▁we ▁can ▁encode ▁the ▁next ▁set ▁of ▁pixels ▁with ▁R LE ▁*/ ▁if (( count ▁= ▁count _ pixels ( ptr , ▁w - x , ▁b pp , ▁1)) ▁> ▁1) ▁{ ▁if ( out ▁+ ▁b pp ▁+ ▁1 ▁> ▁out buf ▁+ ▁out _ size ) ▁return ▁-1; ▁* out ++ ▁= ▁( count ▁^ ▁xor ) ▁+ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v d pa u _ frames _ init ( AV H W Frames Context ▁* ctx ) ▁{ ▁V D PA U Device Context ▁* device _ priv ▁= ▁ctx -> device _ ctx -> internal -> priv ; ▁V D PA U Frames Context ▁* priv ▁= ▁ctx -> internal -> priv ; ▁int ▁i ; ▁switch ▁( ctx -> sw _ format ) ▁{ ▁case ▁AV _ PI X _ F MT _ Y UV 4 20 P : ▁priv -> chrom a _ type ▁= ▁V DP _ CH ROM A _ TYPE _4 20 ; ▁break ; ▁case ▁AV _ PI X _ F MT _ Y UV 4 22 P : ▁priv -> chrom a _ type ▁= ▁V DP _ CH ROM A _ TYPE _4 22 ; ▁break ; ▁case ▁AV _ PI X _ F MT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁vm _ stop ( Run State ▁state ) ▁{ ▁if ▁( q emu _ in _ vc pu _ thread ()) ▁{ ▁qemu _ system _ vm stop _ request ( state ); ▁/* ▁* ▁FIX ME : ▁should ▁not ▁return ▁to ▁device ▁code ▁in ▁case ▁* ▁vm _ stop () ▁has ▁been ▁requested . ▁*/ ▁cpu _ stop _ current (); ▁return ▁0; ▁} ▁return ▁do _ vm _ stop ( state ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁d ca _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁AV Frame ▁* frame ▁= ▁data ; ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁int ▁l fe _ samples ; ▁int ▁num _ core _ channels ▁= ▁0; ▁int ▁i , ▁ret ; ▁float ▁** samples _ f lt ; ▁D CA Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁channels , ▁full _ channels ; ▁int ▁core _ ss _ end ; ▁s -> x ch _ present ▁= ▁0; ▁s -> d ca _ buffe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁do _ st f le ( CP US 390 X State ▁* env , ▁uint 64_ t ▁words [ MAX _ ST FL _ WORDS ]) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁s 39 0_ env _ get _ cpu ( env ); ▁const ▁unsigned ▁long ▁* features ▁= ▁cpu -> model -> features ; ▁unsigned ▁max _ bit ▁= ▁0; ▁S 390 Feat ▁feat ; ▁mem set ( words , ▁0, ▁sizeof ( uint 64_ t ) ▁* ▁MAX _ ST FL _ WORDS ); ▁if ▁( test _ bit ( S 39 0_ FE AT _ Z ARCH , ▁features )) ▁{ ▁/* ▁z / Arch itecture ▁is ▁always ▁active ▁if ▁around ▁*/ ▁words [0] ▁= ▁1 ull ▁<< ▁( 63 ▁- ▁2); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ est ablish _ connection ( Block Driver State ▁* bs ) ▁{ ▁B DR V N BD State ▁* s ▁= ▁bs -> op aque ; ▁int ▁sock ; ▁int ▁ret ; ▁off _ t ▁size ; ▁size _ t ▁blocksize ; ▁if ▁( s -> host _ spec [0] ▁== ▁'/ ') ▁{ ▁sock ▁= ▁unix _ socket _ out going ( s -> host _ spec ); ▁} ▁else ▁{ ▁sock ▁= ▁tcp _ socket _ out going _ spec ( s -> host _ spec ); ▁} ▁/* ▁Failed ▁to ▁establish ▁connection ▁*/ ▁if ▁( sock ▁< ▁0) ▁{ ▁logout (" Failed ▁to ▁establish ▁connection ▁to ▁N BD ▁server \ n "); ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁vc 2_ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Pl ane ▁* p ; ▁Sub Band ▁* b ; ▁int ▁i , ▁j , ▁level , ▁o , ▁shift ; ▁const ▁AV Pix F mt Descriptor ▁* fmt ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> pix _ fmt ); ▁const ▁int ▁depth ▁= ▁fmt -> comp [0]. depth ; ▁VC 2 Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> picture _ number ▁= ▁0; ▁/* ▁Total ▁allowed ▁quant ization ▁range ▁*/ ▁s -> q _ ceil ▁= ▁DI RA C _ MAX _ QU ANT _ INDEX ; ▁s -> ver . major ▁= ▁2; ▁s -> ver . m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ fix _ long _ b _ m vs ( M peg Enc Context ▁* ▁s , ▁int 16_ t ▁(* mv _ table ) [2], ▁int ▁f _ code , ▁int ▁type ) ▁{ ▁int ▁y ; ▁uint 8_ t ▁* ▁f code _ tab = ▁s -> f code _ tab ; ▁// ▁R AL : ▁8 ▁in ▁M PEG -1, ▁16 ▁in ▁M PEG -4 ▁int ▁range ▁= ▁( (( s -> codec _ id ▁== ▁CODE C _ ID _ M PEG 1 VI DEO ) ▁? ▁8 ▁: ▁16 ) ▁<< ▁f _ code ); ▁/* ▁clip ▁/ ▁convert ▁to ▁in tra ▁16 x 16 ▁type ▁M Vs ▁*/ ▁for ( y =0; ▁y < s -> mb _ height ; ▁y ++){ ▁int ▁x ; ▁int ▁xy = ▁( y +1) * ▁( s -> mb _ width + 2) +1 ; ▁in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁S 390 CPU ▁* s 390 x _ new _ cpu ( const ▁char ▁* cpu _ model , ▁uint 32_ t ▁core _ id , ▁Error ▁** err p ) ▁{ ▁S 390 CPU ▁* cpu ; ▁Error ▁* err ▁= ▁NULL ; ▁cpu ▁= ▁cpu _ s 390 x _ create ( cpu _ model , ▁& err ); ▁if ▁( err ▁!= ▁NULL ) ▁{ ▁goto ▁out ; ▁} ▁object _ property _ set _ int ( OBJECT ( cpu ), ▁core _ id , ▁" core - id ", ▁& err ); ▁if ▁( err ▁!= ▁NULL ) ▁{ ▁goto ▁out ; ▁} ▁object _ property _ set _ bool ( OBJECT ( cpu ), ▁true , ▁" real ized ", ▁& err ); ▁out : ▁if ▁( err ) ▁{ ▁error _ propag 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁aio _ compute _ timeout ( A io Context ▁* ctx ) ▁{ ▁int 64_ t ▁deadline ; ▁int ▁timeout ▁= ▁-1; ▁Q EM UB H ▁* b h ; ▁for ▁( b h ▁= ▁atomic _ rc u _ read ( & ctx -> first _ b h ); ▁bh ; ▁bh ▁= ▁atomic _ rc u _ read ( & b h -> next )) ▁{ ▁if ▁( b h -> s cheduled ) ▁{ ▁if ▁( b h -> idle ) ▁{ ▁/* ▁idle ▁bottom ▁hal ves ▁will ▁be ▁pol led ▁at ▁least ▁* ▁every ▁10 ms ▁*/ ▁timeout ▁= ▁10000 000; ▁} ▁else ▁{ ▁/* ▁non - idle ▁bottom ▁hal ves ▁will ▁be ▁executed ▁* ▁immediately ▁*/ ▁return ▁0; ▁} ▁} ▁} ▁deadline ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁create _ cel _ eval s ( Ro q Context ▁* enc , ▁R o q Tem pd ata ▁* temp Data ) ▁{ ▁int ▁n =0, ▁x , ▁y , ▁i ; ▁temp Data -> cel _ eval s ▁= ▁av _ m alloc ( enc -> width * enc -> height / 64 ▁* ▁sizeof ( C el Evaluation )); ▁/* ▁Map ▁to ▁the ▁RO Q ▁quad tree ▁order ▁*/ ▁for ▁( y =0; ▁y < enc -> height ; ▁y += 16) ▁for ▁( x =0; ▁x < enc -> width ; ▁x += 16) ▁for ( i =0; ▁i < 4; ▁i ++) ▁{ ▁temp Data -> cel _ eval s [ n ▁] . source X ▁= ▁x ▁+ ▁( i & 1) * 8 ; ▁temp Data -> cel _ eval s [ n ++ ]. 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ea _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁E a Dem ux Context ▁* ea ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁ret ▁= ▁0; ▁int ▁packet _ read ▁= ▁0; ▁unsigned ▁int ▁chunk _ type , ▁chunk _ size ; ▁int ▁key ▁= ▁0; ▁int ▁av _ un init ( num _ samples ); ▁while ▁(! packet _ read ) ▁{ ▁chunk _ type ▁= ▁av io _ rl 32 ( pb ); ▁chunk _ size ▁= ▁( ea -> big _ endian ▁? ▁av io _ rb 32 ( pb ) ▁: ▁av io _ rl 32 ( pb )) ▁- ▁8 ; ▁switch ▁( chunk _ type ) ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁type _ initialize _ interface ( Type Impl ▁* ti , ▁const ▁char ▁* parent ) ▁{ ▁Interface Class ▁* new _ iface ; ▁Type Info ▁info ▁= ▁{ ▁}; ▁Type Impl ▁* iface _ impl ; ▁info . parent ▁= ▁parent ; ▁info . name ▁= ▁g _ str dup _ printf ("% s :: % s ", ▁ti -> name , ▁info . parent ); ▁info . abstract ▁= ▁true ; ▁iface _ impl ▁= ▁type _ register ( & info ); ▁type _ initialize ( iface _ impl ); ▁g _ free (( char ▁* ) info . name ); ▁new _ iface ▁= ▁( Interface Class ▁* ) iface _ impl -> class ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁video _ open ( Video State ▁* is ){ ▁int ▁flags ▁= ▁SDL _ H WS UR FACE | S DL _ AS Y NC B LIT | S DL _ H W AC CEL ; ▁int ▁w , h ; ▁if ( is _ full _ screen ) ▁flags ▁|= ▁SDL _ FULL SCREEN ; ▁else ▁flags ▁|= ▁SDL _ RE SI Z ABLE ; ▁if ▁( is _ full _ screen ▁&& ▁fs _ screen _ width ) ▁{ ▁w ▁= ▁fs _ screen _ width ; ▁h ▁= ▁fs _ screen _ height ; ▁} ▁else ▁if (! is _ full _ screen ▁&& ▁screen _ width ){ ▁w ▁= ▁screen _ width ; ▁h ▁= ▁screen _ height ; ▁} else ▁if ▁( is -> video _ st ▁&& ▁is -> vid

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁n and _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁struct ▁n and _ state _ t ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁r ; ▁int ▁rd y ; ▁r ▁= ▁n and _ get io ( s -> n and ); ▁n and _ get p ins ( s -> n and , ▁& rd y ); ▁s -> rd y ▁= ▁rd y ; ▁DN AND ( printf ("% s ▁addr =% x ▁r =% x \ n ", ▁__ func __, ▁addr , ▁r )); ▁return ▁r ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ migrate _ set _ speed ( int 64_ t ▁value , ▁Error ▁** err p ) ▁{ ▁Migration State ▁* s ; ▁if ▁( value ▁< ▁0) ▁{ ▁value ▁= ▁0; ▁} ▁s ▁= ▁migrate _ get _ current (); ▁s -> band width _ limit ▁= ▁value ; ▁qemu _ file _ set _ rate _ limit ( s -> file , ▁s -> band width _ limit ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁block _ job _ resume _ all ( void ) ▁{ ▁Block Job ▁* job ▁= ▁NULL ; ▁while ▁(( job ▁= ▁block _ job _ next ( job ))) ▁{ ▁A io Context ▁* a io _ context ▁= ▁blk _ get _ a io _ context ( job -> blk ); ▁aio _ context _ acquire ( a io _ context ); ▁block _ job _ resume ( job ); ▁aio _ context _ release ( a io _ context ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ option ( void ▁* opt ctx , ▁const ▁Option Def ▁* po , ▁const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁/* ▁new - style ▁options ▁contain ▁an ▁offset ▁into ▁opt ctx , ▁old - style ▁address ▁of ▁* ▁a ▁global ▁var */ ▁void ▁* dst ▁= ▁po -> flags ▁& ▁( OPT _ OFFSET ▁| ▁OPT _ SPEC ) ▁? ▁( uint 8_ t ▁* ) opt ctx ▁+ ▁po -> u . off ▁: ▁po -> u . dst _ ptr ; ▁int ▁* dst count ; ▁if ▁( po -> flags ▁& ▁OPT _ SPEC ) ▁{ ▁Spec ifier Opt ▁** so ▁= ▁dst ; ▁char ▁* p ▁= ▁str chr ( opt , ▁': '); ▁dst c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁put _ uint 8 ( Q EM U File ▁* f , ▁void ▁* pv , ▁size _ t ▁size ) ▁{ ▁uint 8_ t ▁* v ▁= ▁pv ; ▁qemu _ put _8 s ( f , ▁v ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Remove Result ▁remove _ h pt e ( Power PC CPU ▁* cpu , ▁target _ ulong ▁pt ex , ▁target _ ulong ▁av pn , ▁target _ ulong ▁flags , ▁target _ ulong ▁* vp , ▁target _ ulong ▁* rp ) ▁{ ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁uint 64_ t ▁token ; ▁target _ ulong ▁v , ▁r , ▁rb ; ▁if ▁(! valid _ pt e _ index ( env , ▁pt ex )) ▁{ ▁return ▁REMOVE _ PAR M ; ▁} ▁token ▁= ▁p pc _ hash 64_ start _ access ( cpu , ▁pt ex ); ▁v ▁= ▁p pc _ hash 64_ load _ h pt e 0( cpu , ▁token , ▁0); ▁r ▁= ▁p pc _ hash 64_ loa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁pc ie _ a er _ init ( PC ID evice ▁* dev , ▁uint 16_ t ▁offset , ▁uint 16_ t ▁size ) ▁{ ▁P CI Exp ress Device ▁* exp ; ▁pc ie _ add _ cap ability ( dev , ▁P CI _ EXT _ CAP _ ID _ ERR , ▁P CI _ ERR _ VER , ▁offset , ▁size ); ▁exp ▁= ▁& dev -> exp ; ▁exp -> a er _ cap ▁= ▁offset ; ▁/* ▁log _ max ▁is ▁property ▁*/ ▁if ▁( dev -> exp . a er _ log . log _ max ▁== ▁P CI E _ A ER _ LOG _ MAX _ UN SET ) ▁{ ▁dev -> exp . a er _ log . log _ max ▁= ▁P CI E _ A ER _ LOG _ MAX _ DEFAULT ; ▁} ▁/* ▁clip ▁down ▁the 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ tc g _ init _ vc pu ( CPU State ▁* cpu ) ▁{ ▁char ▁thread _ name [ V CPU _ THREAD _ NAME _ SIZE ]; ▁static ▁Q emu Cond ▁* tc g _ h alt _ cond ; ▁static ▁Q emu Thread ▁* tc g _ cpu _ thread ; ▁/* ▁share ▁a ▁single ▁thread ▁for ▁all ▁cpus ▁with ▁TC G ▁*/ ▁if ▁(! tc g _ cpu _ thread ) ▁{ ▁cpu -> thread ▁= ▁g _ m alloc 0( size of ( Q emu Thread )); ▁cpu -> h alt _ cond ▁= ▁g _ m alloc 0( size of ( Q emu Cond )); ▁qemu _ cond _ init ( cpu -> h alt _ cond ); ▁tc g _ h alt _ cond ▁= ▁cpu ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁s size _ t ▁v nc _ client _ write _ buf ( V nc State ▁* vs , ▁const ▁uint 8_ t ▁* data , ▁size _ t ▁dat al en ) ▁{ ▁s size _ t ▁ret ; ▁# if def ▁CONFIG _ V NC _ TLS ▁if ▁( vs -> tls . session ) ▁{ ▁ret ▁= ▁v nc _ client _ write _ tls ( & vs -> tls . session , ▁data , ▁dat al en ); ▁} ▁else ▁{ ▁# end if ▁/* ▁CONFIG _ V NC _ TLS ▁*/ ▁ret ▁= ▁send ( vs -> cs ock , ▁( const ▁void ▁* ) data , ▁dat al en , ▁0); ▁# if def ▁CONFIG _ V NC _ TLS ▁} ▁# end if ▁/* ▁CONFIG _ V NC _ TLS ▁*/ ▁V NC _ DEBUG (" W rote ▁wi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁decode _ init ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁MP AD ecode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁static ▁int ▁init =0; ▁int ▁i , ▁j , ▁k ; ▁s -> av ctx ▁= ▁av ctx ; ▁ff _ mp ad sp _ init ( & s -> mp ad sp ); ▁av ctx -> sample _ fmt = ▁OUT _ F MT ; ▁s -> error _ rec ognition = ▁av ctx -> error _ rec ognition ; ▁if ▁(! init ▁&& ▁! av ctx -> parse _ only ) ▁{ ▁int ▁offset ; ▁/* ▁scale ▁factors ▁table ▁for ▁layer ▁1 /2 ▁*/ ▁for ( i =0; i < 64 ; i ++) ▁{ ▁int ▁shift , ▁mod ; ▁/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lib gs m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁int ▁out _ size ▁= ▁av ctx -> frame _ size ▁* ▁av _ get _ bytes _ per _ sample ( av ctx -> sample _ fmt ); ▁if ▁(* data _ size ▁< ▁out _ size ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Output ▁buffer ▁is ▁too ▁small \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁if ▁( buf _ size ▁< ▁av ctx

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁memory _ access _ size ( Memory Region ▁* mr , ▁unsigned ▁l , ▁hw addr ▁addr ) ▁{ ▁unsigned ▁access _ size _ min ▁= ▁mr -> ops -> impl . min _ access _ size ; ▁unsigned ▁access _ size _ max ▁= ▁mr -> ops -> impl . max _ access _ size ; ▁/* ▁Reg ions ▁are ▁assumed ▁to ▁support ▁1 -4 ▁byte ▁accesses ▁unless ▁otherwise ▁specified . ▁*/ ▁if ▁( access _ size _ min ▁== ▁0) ▁{ ▁access _ size _ min ▁= ▁1; ▁} ▁if ▁( access _ size _ max ▁== ▁0) ▁{ ▁access _ size _ max ▁= ▁4; ▁} ▁/* ▁Bound ▁the ▁maximu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁fw _ cfg _ add _ file _ callback ( FW Cfg State ▁* s , ▁const ▁char ▁* filename , ▁F W Cfg Callback ▁select _ cb , ▁F W Cfg Write Callback ▁write _ cb , ▁void ▁* callback _ op aque , ▁void ▁* data , ▁size _ t ▁len , ▁bool ▁read _ only ) ▁{ ▁int ▁i , ▁index , ▁count ; ▁size _ t ▁d size ; ▁Machine Class ▁* mc ▁= ▁MA CHINE _ GET _ CLASS ( q dev _ get _ machine ()); ▁int ▁order ▁= ▁0; ▁if ▁(! s -> files ) ▁{ ▁d size ▁= ▁sizeof ( uint 32_ t ) ▁+ ▁sizeof ( FW Cfg File ) ▁* ▁fw _ cfg _ file _ slots ( s );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁st ell aris _ enet _ save ( Q EM U File ▁* f , ▁void ▁* op aque ) ▁{ ▁st ell aris _ enet _ state ▁* s ▁= ▁( st ell aris _ enet _ state ▁* ) op aque ; ▁int ▁i ; ▁qemu _ put _ be 32 ( f , ▁s -> ris ); ▁qemu _ put _ be 32 ( f , ▁s -> im ); ▁qemu _ put _ be 32 ( f , ▁s -> r ctl ); ▁qemu _ put _ be 32 ( f , ▁s -> t ctl ); ▁qemu _ put _ be 32 ( f , ▁s -> th r ); ▁qemu _ put _ be 32 ( f , ▁s -> m ctl ); ▁qemu _ put _ be 32 ( f , ▁s -> md v ); ▁qemu _ put _ be 32 ( f , ▁s -> m tx d ); ▁qemu _ put _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁exit _ program ( void ) ▁{ ▁int ▁i , ▁j ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁nb _ filter graphs ; ▁i ++) ▁{ ▁av filter _ graph _ free ( & filter graphs [ i ] -> graph ); ▁for ▁( j ▁= ▁0; ▁j ▁< ▁filter graphs [ i ] -> nb _ inputs ; ▁j ++) ▁{ ▁av _ fre ep ( & filter graphs [ i ] -> inputs [ j ] -> name ); ▁av _ fre ep ( & filter graphs [ i ] -> inputs [ j ]); ▁} ▁av _ fre ep ( & filter graphs [ i ] -> inputs ); ▁for ▁( j ▁= ▁0; ▁j ▁< ▁filter graphs [ i ] -> nb _ outputs ; ▁j ++) ▁{ ▁av _ fre ep ( & filt

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁cow _ co _ is _ allocated ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int ▁* num _ same ) ▁{ ▁int 64_ t ▁bit num ▁= ▁sector _ num ▁+ ▁sizeof ( struct ▁cow _ header _ v 2) ▁* ▁8 ; ▁uint 64_ t ▁offset ▁= ▁( bit num ▁/ ▁8) ▁& ▁- B DR V _ SE CTOR _ SIZE ; ▁uint 8_ t ▁bitmap [ B DR V _ SE CTOR _ SIZE ]; ▁int ▁ret ; ▁int ▁changed ; ▁ret ▁= ▁b dr v _ p read ( bs -> file , ▁offset , ▁& bitmap , ▁sizeof ( bitmap )); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁timer list _ expired ( Q EM UT imer List ▁* timer _ list ) ▁{ ▁int 64_ t ▁expire _ time ; ▁if ▁(! atomic _ read ( & timer _ list -> active _ tim ers )) ▁{ ▁return ▁false ; ▁} ▁qemu _ mut ex _ lock ( & timer _ list -> active _ tim ers _ lock ); ▁if ▁(! timer _ list -> active _ tim ers ) ▁{ ▁qemu _ mut ex _ un lock ( & timer _ list -> active _ tim ers _ lock ); ▁return ▁false ; ▁} ▁expire _ time ▁= ▁timer _ list -> active _ tim ers -> expire _ time ; ▁qemu _ mut ex _ un lock ( & timer _ list -> activ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁check _ ref counts ( Block Driver State ▁* bs ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁size ; ▁int ▁nb _ clusters , ▁ref count 1, ▁ref count 2, ▁i ; ▁Q C ow Snapshot ▁* sn ; ▁uint 16_ t ▁* refcount _ table ; ▁size ▁= ▁b dr v _ get length ( s -> hd ); ▁nb _ clusters ▁= ▁size _ to _ clusters ( s , ▁size ); ▁ref count _ table ▁= ▁qemu _ m alloc z ( nb _ clusters ▁* ▁sizeof ( uint 16_ t )); ▁/* ▁header ▁*/ ▁inc _ ref counts ( bs , ▁ref count _ table , ▁nb _ clusters , ▁0, 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ip oct al _ init ( I Pack Device ▁* ip ) ▁{ ▁IP Oct al State ▁* s ▁= ▁IP O CT AL ( ip ); ▁unsigned ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁N _ CH AN NE LS ; ▁i ++) ▁{ ▁S CC 26 98 Channel ▁* ch ▁= ▁& s -> ch [ i ]; ▁ch -> ip oct al ▁= ▁s ; ▁/* ▁Redirect ▁IP - Oct al ▁channels ▁to ▁host ▁character ▁devices ▁*/ ▁if ▁( ch -> dev path ) ▁{ ▁const ▁char ▁chr _ name [] ▁= ▁" ip oct al "; ▁char ▁label [ ARRAY _ SIZE ( chr _ name ) ▁+ ▁2 ]; ▁static ▁int ▁index ; ▁sn printf ( label , ▁sizeof ( label ), ▁"% s % d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Add r Range ▁addr range _ intersection ( Addr Range ▁r 1, ▁Add r Range ▁r 2) ▁{ ▁uint 64_ t ▁start ▁= ▁MAX ( r 1. start , ▁r 2. start ); ▁/* ▁off - by - one ▁arithmetic ▁to ▁prevent ▁overflow ▁*/ ▁uint 64_ t ▁end ▁= ▁MIN ( addr range _ end ( r 1) ▁- ▁1, ▁addr range _ end ( r 2) ▁- ▁1); ▁return ▁addr range _ make ( start , ▁end ▁- ▁start ▁+ ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁wc 3_ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁W c 3 Dem ux Context ▁* wc 3 ▁= ▁s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁s -> pb ; ▁unsigned ▁int ▁four cc _ tag ; ▁unsigned ▁int ▁size ; ▁AV Stream ▁* st ; ▁unsigned ▁char ▁pre amble [ WC 3_ PRE A MB LE _ SIZE ]; ▁int ▁ret ▁= ▁0; ▁int ▁current _ palette ▁= ▁0; ▁int ▁bytes _ to _ read ; ▁int ▁i ; ▁unsigned ▁char ▁rotate ; ▁/* ▁default ▁context ▁members ▁*/ ▁wc 3 -> width ▁= ▁W C 3_ DEFAULT _ WIDTH ; ▁wc 3 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁do _ str tos z ( const ▁char ▁* np tr , ▁char ▁** end , ▁const ▁char ▁default _ suffix , ▁int 64_ t ▁unit ) ▁{ ▁int 64_ t ▁retval ; ▁char ▁* end ptr ; ▁unsigned ▁char ▁c ; ▁int ▁mul _ required ▁= ▁0; ▁double ▁val , ▁mul , ▁integral , ▁fraction ; ▁errno ▁= ▁0; ▁val ▁= ▁str tod ( np tr , ▁& end ptr ); ▁if ▁( is nan ( val ) ▁|| ▁end ptr ▁== ▁np tr ▁|| ▁errno ▁!= ▁0) ▁{ ▁retval ▁= ▁- E IN VAL ; ▁goto ▁out ; ▁} ▁fraction ▁= ▁mod f ( val , ▁& integ ral ); ▁if ▁( fraction ▁!= ▁0) ▁{ ▁mul _ re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ ref counts _ l 1( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁uint 16_ t ▁** refcount _ table , ▁int 64_ t ▁* refcount _ table _ size , ▁int 64_ t ▁l 1_ table _ offset , ▁int ▁l 1_ size , ▁int ▁flags ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁* l 1_ table ▁= ▁NULL , ▁l 2_ offset , ▁l 1_ size 2; ▁int ▁i , ▁ret ; ▁l 1_ size 2 ▁= ▁l 1_ size ▁* ▁sizeof ( uint 64_ t ); ▁/* ▁Mark ▁L 1 ▁table ▁as ▁used ▁*/ ▁ret ▁= ▁inc _ ref counts ( bs , ▁res , ▁ref count

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁d cr _ read _ p ob ▁( void ▁* op aque , ▁int ▁d cr n ) ▁{ ▁p pc 4 xx _ p ob _ t ▁* p ob ; ▁uint 32_ t ▁ret ; ▁p ob ▁= ▁opaque ; ▁switch ▁( d cr n ) ▁{ ▁case ▁PO B 0_ BE AR : ▁ret ▁= ▁p ob -> be ar ; ▁break ; ▁case ▁PO B 0_ B ES R 0: ▁case ▁PO B 0_ B ES R 1: ▁ret ▁= ▁p ob -> bes r [ d cr n ▁- ▁PO B 0_ B ES R 0 ]; ▁break ; ▁default : ▁/* ▁Avoid ▁gcc ▁warning ▁*/ ▁ret ▁= ▁0; ▁break ; ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁on en and _ er ase ( One N AND State ▁* s , ▁int ▁sec , ▁int ▁num ) ▁{ ▁uint 8_ t ▁* blank buf , ▁* tmp buf ; ▁blank buf ▁= ▁g _ m alloc (5 12 ); ▁if ▁(! blank buf ) ▁{ ▁return ▁1; ▁} ▁tmp buf ▁= ▁g _ m alloc (5 12 ); ▁if ▁(! tmp buf ) ▁{ ▁g _ free ( blank buf ); ▁return ▁1; ▁} ▁mem set ( blank buf , ▁0 xff , ▁512 ); ▁for ▁( ; ▁num ▁> ▁0; ▁num -- , ▁sec ++) ▁{ ▁if ▁( s -> b dr v _ cur ) ▁{ ▁int ▁er ases ec ▁= ▁s -> secs _ cur ▁+ ▁( sec ▁>> ▁5 ); ▁if ▁( b dr v _ write ( s -> b dr v _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ parse _ ext ents ( const ▁char ▁* desc , ▁Block Driver State ▁* bs , ▁const ▁char ▁* desc _ file _ path , ▁Error ▁** err p ) ▁{ ▁int ▁ret ; ▁char ▁access [ 11 ]; ▁char ▁type [ 11 ]; ▁char ▁fname [ 512 ]; ▁const ▁char ▁* p ▁= ▁desc ; ▁int 64_ t ▁sector s ▁= ▁0; ▁int 64_ t ▁flat _ offset ; ▁char ▁extent _ path [ PATH _ MAX ]; ▁Block Driver State ▁* extent _ file ; ▁B DR V V mdk State ▁* s ▁= ▁bs -> op aque ; ▁V mdk Extent ▁* extent ; ▁while ▁(* p ) ▁{ ▁/* ▁parse ▁extent ▁line : ▁* ▁R W

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁default _ lock mgr _ cb ( void ▁** arg , ▁enum ▁AV Lock Op ▁op ) ▁{ ▁void ▁* ▁volatile ▁* ▁mutex ▁= ▁arg ; ▁int ▁err ; ▁switch ▁( op ) ▁{ ▁case ▁AV _ LOCK _ CREATE : ▁return ▁0; ▁case ▁AV _ LOCK _ OB T AIN : ▁if ▁(! * mut ex ) ▁{ ▁p thread _ mut ex _ t ▁* tmp ▁= ▁av _ m alloc ( size of ( pth read _ mut ex _ t )); ▁if ▁(! tmp ) ▁return ▁A VER ROR ( EN O ME M ); ▁if ▁(( err ▁= ▁p thread _ mut ex _ init ( tmp , ▁NULL ))) ▁{ ▁av _ free ( tmp ); ▁return ▁A VER ROR ( err ); ▁} ▁if ▁( av priv _ ato

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁check _ input _ m otion ( M peg Enc Context ▁* ▁s , ▁int ▁mb _ x , ▁int ▁mb _ y , ▁int ▁p _ type ){ ▁M otion Est Context ▁* ▁const ▁c = ▁& s -> me ; ▁Picture ▁* p = ▁s -> current _ picture _ ptr ; ▁int ▁mb _ xy = ▁mb _ x ▁+ ▁mb _ y * s -> mb _ stride ; ▁int ▁xy = ▁2* mb _ x ▁+ ▁2* mb _ y * s -> b 8_ stride ; ▁int ▁mb _ type = ▁s -> current _ picture . mb _ type [ mb _ xy ]; ▁int ▁flags = ▁c -> flags ; ▁int ▁shift = ▁( flags & FLAG _ Q PEL ) ▁+ ▁1; ▁int ▁mask = ▁(1 << shift ) -1; ▁int

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ est imate _ p _ frame _ m otion ( M peg Enc Context ▁* ▁s , ▁int ▁mb _ x , ▁int ▁mb _ y ) ▁{ ▁U INT 8 ▁* pix , ▁* pp ix ; ▁int ▁sum , ▁var c , ▁var d , ▁mx , ▁my , ▁range , ▁d min , ▁xx , ▁yy ; ▁int ▁xmin , ▁ymin , ▁xmax , ▁ymax ; ▁int ▁rel _ x min , ▁rel _ y min , ▁rel _ x max , ▁rel _ y max ; ▁int ▁pred _ x =0, ▁pred _ y =0; ▁int ▁P [6 ][ 2 ]; ▁const ▁int ▁shift = ▁1 + s -> qu arter _ sample ; ▁int ▁mb _ type =0; ▁uint 8_ t ▁* ref _ picture = ▁s -> last _ picture [0]; ▁get _ limits ( s , ▁& 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff _ va api _ encode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁V A API Encode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁V A API Encode Picture ▁* pic , ▁* next ; ▁for ▁( pic ▁= ▁ctx -> pic _ start ; ▁pic ; ▁pic ▁= ▁next ) ▁{ ▁next ▁= ▁pic -> next ; ▁va api _ encode _ free ( av ctx , ▁pic ); ▁} ▁if ▁( ctx -> va _ context ▁!= ▁V A _ INVALID _ ID ) ▁{ ▁va Destroy Context ( ctx -> hw ctx -> display , ▁ctx -> va _ context ); ▁ctx -> va _ context ▁= ▁V A _ INVALID _ ID ; ▁} ▁if ▁( ctx -> va

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁s size _ t ▁socket _ read ( int ▁sock fd , ▁void ▁* buff , ▁size _ t ▁size ) ▁{ ▁s size _ t ▁retval , ▁total ▁= ▁0; ▁while ▁( size ) ▁{ ▁retval ▁= ▁read ( sock fd , ▁buff , ▁size ); ▁if ▁( ret val ▁== ▁0) ▁{ ▁return ▁- E IO ; ▁} ▁if ▁( ret val ▁< ▁0) ▁{ ▁if ▁( err no ▁== ▁E INT R ) ▁{ ▁continue ; ▁} ▁return ▁- err no ; ▁} ▁size ▁-= ▁retval ; ▁buff ▁+= ▁retval ; ▁total ▁+= ▁retval ; ▁} ▁return ▁total ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁A io Context ▁* blk _ get _ a io _ context ( Block Backend ▁* blk ) ▁{ ▁return ▁b dr v _ get _ a io _ context ( blk -> bs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vf io _ load _ rom ( V FI O Device ▁* v dev ) ▁{ ▁uint 64_ t ▁size ▁= ▁v dev -> rom _ size ; ▁char ▁name [ 32 ]; ▁off _ t ▁off ▁= ▁0, ▁vo ff ▁= ▁v dev -> rom _ offset ; ▁s size _ t ▁bytes ; ▁void ▁* ptr ; ▁/* ▁If ▁loading ▁R OM ▁from ▁file , ▁pci ▁handles ▁it ▁*/ ▁if ▁( v dev -> pd ev . rom file ▁|| ▁! v dev -> pd ev . rom _ bar ▁|| ▁! size ) ▁{ ▁return ▁0; ▁} ▁D PRI NT F ("% s ( % 04 x :% 02 x :% 02 x . % x )\ n ", ▁__ func __, ▁v dev -> host . domain , ▁v dev -> host . bus , ▁v dev -> host

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁U uid Info ▁* q mp _ query _ uuid ( Error ▁** err p ) ▁{ ▁U uid Info ▁* info ▁= ▁g _ m alloc 0( size of (* info )); ▁char ▁uuid [ 64 ]; ▁sn printf ( uuid , ▁sizeof ( uuid ), ▁UUID _ F MT , ▁qemu _ uuid [0], ▁qemu _ uuid [1], ▁qemu _ uuid [2], ▁qemu _ uuid [3 ], ▁qemu _ uuid [4 ], ▁qemu _ uuid [5 ], ▁qemu _ uuid [6 ], ▁qemu _ uuid [ 7 ], ▁qemu _ uuid [ 8 ], ▁qemu _ uuid [ 9 ], ▁qemu _ uuid [10 ], ▁qemu _ uuid [ 11 ], ▁qemu _ uuid [ 12 ], ▁qemu _ uuid [1 3], ▁qemu _ uuid [ 14 ], ▁qemu _ uuid [ 15 ]); ▁info

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m pc 7_ decode _ frame ( AV Codec Context ▁* ▁av ctx , ▁void ▁* data , ▁int ▁* got _ frame _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ; ▁M PC Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁Get Bit Context ▁gb ; ▁int ▁i , ▁ch ; ▁int ▁mb ▁= ▁-1; ▁Band ▁* b ands ▁= ▁c -> b ands ; ▁int ▁off , ▁ret , ▁last _ frame , ▁skip ; ▁int ▁bits _ used , ▁bits _ avail ; ▁mem set ( b ands , ▁0, ▁sizeof (* b ands ) ▁* ▁( c -> max b ands ▁+ ▁1 )); ▁buf _ size 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁r le _ unpack ( const ▁unsigned ▁char ▁* src , ▁int ▁src _ len , ▁int ▁src _ count , ▁unsigned ▁char ▁* dest , ▁int ▁dest _ len ) ▁{ ▁const ▁unsigned ▁char ▁* ps ; ▁const ▁unsigned ▁char ▁* ps _ end ; ▁unsigned ▁char ▁* pd ; ▁int ▁i , ▁l ; ▁unsigned ▁char ▁* dest _ end ▁= ▁dest ▁+ ▁dest _ len ; ▁ps ▁= ▁src ; ▁ps _ end ▁= ▁src ▁+ ▁src _ len ; ▁pd ▁= ▁dest ; ▁if ▁( src _ count ▁& ▁1) ▁{ ▁if ▁( ps _ end ▁- ▁ps ▁< ▁1) ▁return ▁0; ▁* pd ++ ▁= ▁* ps ++; ▁} ▁src _ count ▁>>= ▁1; ▁i ▁= ▁0; ▁do ▁{ ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁vc 1_ decode _ sequence _ header ( AV Codec Context ▁* av ctx , ▁VC 1 Context ▁* v , ▁Get Bit Context ▁* gb ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ DEBUG , ▁" Header : ▁% 0 X \ n ", ▁show _ bits ( gb , ▁32 )); ▁v -> profile ▁= ▁get _ bits ( gb , ▁2); ▁if ▁( v -> profile ▁== ▁PROFILE _ COMP LEX ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ WARNING , ▁" WM V 3 ▁Complex ▁Profile ▁is ▁not ▁fully ▁supported \ n "); ▁} ▁if ▁( v -> profile ▁== ▁PROFILE _ AD V ANCE D ) ▁{ ▁v -> zz _8 x 4 ▁= ▁ff _ vc 1_ ad v _ progres

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁s 39 0_ virt io _ rng _ init ( V irt IOS 390 Device ▁* s 39 0_ dev ) ▁{ ▁V irt I OR NG S 390 ▁* dev ▁= ▁VI RT IO _ R NG _ S 39 0( s 39 0_ dev ); ▁Device State ▁* v dev ▁= ▁DEVICE ( & dev -> v dev ); ▁q dev _ set _ parent _ bus ( v dev , ▁B US ( & s 39 0_ dev -> bus )); ▁if ▁( q dev _ init ( v dev ) ▁< ▁0) ▁{ ▁return ▁-1; ▁} ▁object _ property _ set _ link ( OBJECT ( dev ), ▁OBJECT ( dev -> v dev . conf . default _ backend ), ▁" rng ", ▁NULL ); ▁return ▁s 39 0_ virt io _ device _ init ( s 39 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ap ic _ update _ irq ( API C State ▁* s ) ▁{ ▁int ▁ir rv , ▁p pr ; ▁if ▁(! ( s -> sp ur ious _ vec ▁& ▁API C _ SV _ ENABLE )) ▁return ; ▁ir rv ▁= ▁get _ high est _ priority _ int ( s -> ir r ); ▁if ▁( ir rv ▁< ▁0) ▁return ; ▁p pr ▁= ▁ap ic _ get _ pp r ( s ); ▁if ▁( pp r ▁&& ▁( ir rv ▁& ▁0 xf 0) ▁<= ▁( pp r ▁& ▁0 xf 0 )) ▁return ; ▁cpu _ interrupt ( s -> cpu _ env , ▁CPU _ INTER R UP T _ H ARD ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁setup _ sig context ( struct ▁target _ sig context ▁* sc , ▁struct ▁target _ fp state ▁* fp state , ▁CPU X 86 State ▁* env , ▁abi _ ulong ▁mask , ▁abi _ ulong ▁fp state _ addr ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( x 86_ env _ get _ cpu ( env )); ▁int ▁err ▁= ▁0; ▁uint 16_ t ▁magic ; ▁/* ▁already ▁locked ▁in ▁setup _ frame () ▁*/ ▁__ put _ user ( env -> se gs [ R _ GS ]. selector , ▁( un signed ▁int ▁* ) & sc -> gs ); ▁__ put _ user ( env -> se gs [ R _ FS ]. selector , ▁( un signed ▁int ▁* ) & sc -> fs ); ▁__ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁coroutine _ fn ▁q ed _ a io _ complete ( Q ED A IO CB ▁* ac b ) ▁{ ▁B DR V Q ED State ▁* s ▁= ▁ac b _ to _ s ( ac b ); ▁/* ▁Free ▁resources ▁*/ ▁qemu _ i ove c _ destroy ( & ac b -> cur _ q io v ); ▁q ed _ un ref _ l 2_ cache _ entry ( ac b -> request . l 2_ table ); ▁/* ▁Free ▁the ▁buffer ▁we ▁may ▁have ▁allocated ▁for ▁zero ▁writes ▁*/ ▁if ▁( ac b -> flags ▁& ▁Q ED _ A IO CB _ ZERO ) ▁{ ▁qemu _ v free ( ac b -> q io v -> io v [0]. io v _ base ); ▁ac b -> q io v -> io v [0]. io v _ base ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁v td _ do _ iom mu _ translate ( VT D Address Space ▁* v td _ as , ▁P CI Bus ▁* bus , ▁uint 8_ t ▁dev fn , ▁hw addr ▁addr , ▁bool ▁is _ write , ▁IO MM UT LB Entry ▁* entry ) ▁{ ▁Intel I OM MU State ▁* s ▁= ▁v td _ as -> iom mu _ state ; ▁V TD Context Entry ▁ce ; ▁uint 8_ t ▁bus _ num ▁= ▁pci _ bus _ num ( bus ); ▁V TD Context CacheEntry ▁* cc _ entry ▁= ▁& v td _ as -> context _ cache _ entry ; ▁uint 64_ t ▁sl pt e , ▁page _ mask ; ▁uint 32_ t ▁level ; ▁uint 16_ t ▁source _ id ▁= ▁v td _ ma

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁load _ mult ib oot ( void ▁* fw _ cfg , ▁FILE ▁* f , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁int ▁kernel _ file _ size , ▁uint 8_ t ▁* header ) ▁{ ▁int ▁i , ▁is _ mult ib oot ▁= ▁0; ▁uint 32_ t ▁flags ▁= ▁0; ▁uint 32_ t ▁mh _ entry _ addr ; ▁uint 32_ t ▁mh _ load _ addr ; ▁uint 32_ t ▁mb _ kernel _ size ; ▁Mult ib oot State ▁m bs ; ▁uint 8_ t ▁boot info [ MB I _ SIZE ]; ▁uint 8_ t ▁* mb _ boot info _ data ; ▁/* ▁Ok , ▁let ' s ▁see 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁F UNC ( h ev c _ h _ loop _ filter _ l um a )( uint 8_ t ▁* pix , ▁ptr diff _ t ▁stride , ▁int ▁* beta , ▁int ▁* tc , ▁uint 8_ t ▁* no _ p , ▁uint 8_ t ▁* no _ q ) ▁{ ▁F UNC ( h ev c _ loop _ filter _ l um a )( pix , ▁stride , ▁sizeof ( pixel ), ▁beta , ▁tc , ▁no _ p , ▁no _ q ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ br cond ( TC G Context ▁* s , ▁TC G Mem Op ▁ext , ▁TC G Cond ▁c , ▁TC G Arg ▁a , ▁TC G Arg ▁b , ▁bool ▁b _ const , ▁TC G Label ▁* l ) ▁{ ▁int ptr _ t ▁offset ; ▁bool ▁need _ cmp ; ▁if ▁( b _ const ▁&& ▁b ▁== ▁0 ▁&& ▁( c ▁== ▁TC G _ COND _ EQ ▁|| ▁c ▁== ▁TC G _ COND _ NE )) ▁{ ▁need _ cmp ▁= ▁false ; ▁} ▁else ▁{ ▁need _ cmp ▁= ▁true ; ▁tc g _ out _ cmp ( s , ▁ext , ▁a , ▁b , ▁b _ const ); ▁} ▁if ▁(! l -> has _ value ) ▁{ ▁tc g _ out _ re loc ( s , ▁s -> code _ ptr , ▁R _ A ARCH 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ neg ot iate _ options ( N BD Client ▁* client , ▁Error ▁** err p ) ▁{ ▁uint 32_ t ▁flags ; ▁bool ▁fixed New style ▁= ▁false ; ▁/* ▁Client ▁sends : ▁[ ▁0 ▁.. ▁3] ▁client ▁flags ▁[ ▁0 ▁.. ▁7 ] ▁N BD _ OPTS _ M AGIC ▁[ ▁8 ▁.. ▁11 ] ▁N BD ▁option ▁[12 ▁.. ▁15 ] ▁Data ▁length ▁... ▁Rest ▁of ▁request ▁[ ▁0 ▁.. ▁7 ] ▁N BD _ OPTS _ M AGIC ▁[ ▁8 ▁.. ▁11 ] ▁Second ▁N BD ▁option ▁[12 ▁.. ▁15 ] ▁Data ▁length ▁... ▁Rest ▁of ▁request ▁*/ ▁if ▁( nb d _ read ( client -> i oc , ▁& flags , ▁sizeof ( fl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pl 18 1_ f ifo _ run ( pl 18 1_ state ▁* s ) ▁{ ▁uint 32_ t ▁bits ; ▁uint 32_ t ▁value ; ▁int ▁n ; ▁int ▁is _ read ; ▁is _ read ▁= ▁( s -> data ctrl ▁& ▁PL 18 1_ DATA _ DI RECTION ) ▁!= ▁0; ▁if ▁( s -> data cnt ▁!= ▁0 ▁&& ▁(! is _ read ▁|| ▁sd _ data _ ready ( s -> card )) ▁&& ▁! s -> linux _ hack ) ▁{ ▁if ▁( is _ read ) ▁{ ▁n ▁= ▁0; ▁value ▁= ▁0; ▁while ▁( s -> data cnt ▁&& ▁s -> f ifo _ len ▁< ▁PL 18 1_ FI FO _ LEN ) ▁{ ▁value ▁|= ▁( uint 32_ t ) sd _ read _ data ( s -> card ) ▁<< ▁( n ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fl v _ read _ met ab ody ( AV Format Context ▁* s , ▁int 64_ t ▁next _ pos ) ▁{ ▁AM F DataType ▁type ; ▁AV Stream ▁* stream , ▁* ast ream , ▁* v stream ; ▁AV IO Context ▁* i oc ; ▁int ▁i ; ▁// ▁only ▁needs ▁to ▁hold ▁the ▁string ▁" on MetaData ". ▁// ▁Anything ▁longer ▁is ▁something ▁we ▁don ' t ▁want . ▁char ▁buffer [ 11 ]; ▁a stream ▁= ▁NULL ; ▁v stream ▁= ▁NULL ; ▁i oc ▁= ▁s -> pb ; ▁// ▁first ▁object ▁needs ▁to ▁be ▁" on MetaData " ▁string ▁type ▁= ▁av io _ r 8 ( i oc ); ▁if ▁( type ▁!= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m pts as _ sc si _ init ( PC ID evice ▁* dev , ▁Error ▁** err p ) ▁{ ▁Device State ▁* d ▁= ▁DEVICE ( dev ); ▁M PT S AS State ▁* s ▁= ▁M PT _ S AS ( dev ); ▁Error ▁* err ▁= ▁NULL ; ▁int ▁ret ; ▁dev -> config [ PC I _ LATE NCY _ T IMER ] ▁= ▁0; ▁dev -> config [ PC I _ INTER R UP T _ P IN ] ▁= ▁0 x 01 ; ▁if ▁( s -> m si ▁!= ▁ON _ OFF _ AUTO _ OFF ) ▁{ ▁ret ▁= ▁m si _ init ( dev , ▁0, ▁1, ▁true , ▁false , ▁& err ); ▁/* ▁Any ▁error ▁other ▁than ▁- EN OT SUP ( board ' s ▁M SI ▁support ▁is ▁broken

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ arm _ g ic _ real ize ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁int ▁i ; ▁G IC State ▁* s ▁= ▁K VM _ ARM _ G IC ( dev ); ▁Sys Bus Device ▁* s bd ▁= ▁SY S _ B US _ DEVICE ( dev ); ▁K VM ARM G IC Class ▁* kg c ▁= ▁K VM _ ARM _ G IC _ GET _ CLASS ( s ); ▁k gc -> parent _ real ize ( dev , ▁err p ); ▁if ▁( error _ is _ set ( err p )) ▁{ ▁return ; ▁} ▁i ▁= ▁s -> num _ irq ▁- ▁G IC _ INTERNAL ; ▁/* ▁For ▁the ▁G IC , ▁also ▁expose ▁incoming ▁GPIO ▁lines ▁for ▁P PI s ▁for ▁each ▁CPU . ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ fragments ( struct ▁Track s ▁* tracks , ▁int ▁start _ index , ▁AV IO Context ▁* in ) ▁{ ▁char ▁dirname [ 100 ], ▁filename [ 500 ]; ▁int ▁i , ▁j ; ▁for ▁( i ▁= ▁start _ index ; ▁i ▁< ▁tracks -> nb _ tracks ; ▁i ++) ▁{ ▁struct ▁Track ▁* track ▁= ▁tracks -> tracks [ i ]; ▁const ▁char ▁* type ▁= ▁track -> is _ video ▁? ▁" video " ▁: ▁" audio "; ▁sn printf ( dirname , ▁sizeof ( dirname ), ▁" Quality Levels ( % d )", ▁track -> bit rate ); ▁mkdir ( dirname , ▁0 777 ); ▁for ▁( j ▁= ▁0; ▁j ▁<

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁char ▁* q emu _ find _ file ( int ▁type , ▁const ▁char ▁* name ) ▁{ ▁int ▁len ; ▁const ▁char ▁* subdir ; ▁char ▁* buf ; ▁/* ▁If ▁name ▁contains ▁path ▁separators ▁then ▁try ▁it ▁as ▁a ▁straight ▁path . ▁*/ ▁if ▁(( str chr ( name , ▁'/ ') ▁|| ▁str chr ( name , ▁' \\ ')) ▁&& ▁access ( name , ▁R _ OK ) ▁== ▁0) ▁{ ▁return ▁g _ str dup ( name ); ▁} ▁switch ▁( type ) ▁{ ▁case ▁Q EM U _ FILE _ TYPE _ B IOS : ▁subdir ▁= ▁""; ▁break ; ▁case ▁Q EM U _ FILE _ TYPE _ KEY MAP : ▁subdir ▁= ▁" key maps / "; ▁break ; ▁d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁term _ flush ( void ) ▁{ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁el cr _ i op ort _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁P IC Common State ▁* s ▁= ▁opaque ; ▁return ▁s -> el cr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁inc _ ref counts ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁uint 16_ t ▁* refcount _ table , ▁int 64_ t ▁ref count _ table _ size , ▁int 64_ t ▁offset , ▁int 64_ t ▁size ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁start , ▁last , ▁cluster _ offset , ▁k ; ▁if ▁( size ▁<= ▁0) ▁{ ▁return ▁0; ▁} ▁start ▁= ▁start _ of _ cluster ( s , ▁offset ); ▁last ▁= ▁start _ of _ cluster ( s , ▁offset ▁+ ▁size ▁- ▁1); ▁for ( cluster _ offset ▁= ▁start ; ▁cluster _ offset ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ co _ request ( Block Driver State ▁* bs , ▁N BD Request ▁* request , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁N BD Client Session ▁* client ▁= ▁nb d _ get _ client _ session ( bs ); ▁int ▁ret ; ▁if ▁( q io v ) ▁{ ▁assert ( request -> type ▁== ▁N BD _ CMD _ WRITE ▁|| ▁request -> type ▁== ▁N BD _ CMD _ READ ); ▁assert ( request -> len ▁== ▁i ov _ size ( q io v -> io v , ▁q io v -> nio v )); ▁} ▁else ▁{ ▁assert ( request -> type ▁!= ▁N BD _ CMD _ WRITE ▁&& ▁request -> type ▁!= ▁N BD _ CMD _ REA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Exit Status ▁trans _ log ( Dis as Context ▁* ctx , ▁uint 32_ t ▁insn , ▁const ▁Dis as Insn ▁* di ) ▁{ ▁unsigned ▁r 2 ▁= ▁extract 32 ( ins n , ▁21, ▁5 ); ▁unsigned ▁r 1 ▁= ▁extract 32 ( ins n , ▁16, ▁5 ); ▁unsigned ▁cf ▁= ▁extract 32 ( ins n , ▁12, ▁4 ); ▁unsigned ▁rt ▁= ▁extract 32 ( ins n , ▁0, ▁5 ); ▁TC G v ▁tc g _ r 1, ▁tc g _ r 2; ▁Exit Status ▁ret ; ▁if ▁( cf ) ▁{ ▁null ify _ over ( ctx ); ▁} ▁tc g _ r 1 ▁= ▁load _ g pr ( ctx , ▁r 1); ▁tc g _ r 2 ▁= ▁load _ g pr ( ctx , ▁r 2); ▁ret ▁= ▁do _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁x ch g _ mb _ border ( H 264 Context ▁* h , ▁uint 8_ t ▁* src _ y , ▁uint 8_ t ▁* src _ cb , ▁uint 8_ t ▁* src _ cr , ▁int ▁lines ize , ▁int ▁uv lines ize , ▁int ▁x ch g , ▁int ▁chrom a 44 4, ▁int ▁simple , ▁int ▁pixel _ shift ) ▁{ ▁int ▁deb lock _ to pleft ; ▁int ▁deb lock _ top ; ▁int ▁top _ idx ▁= ▁1; ▁uint 8_ t ▁* top _ border _ m 1; ▁uint 8_ t ▁* top _ border ; ▁if ▁(! simple ▁&& ▁FRAME _ MB A FF ( h )) ▁{ ▁if ▁( h -> mb _ y ▁& ▁1) ▁{ ▁if ▁(! MB _ MB A FF ( h )) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gif _ image _ write _ image ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁** by test ream , ▁uint 8_ t ▁* end , ▁const ▁uint 8_ t ▁* buf , ▁int ▁lines ize ) ▁{ ▁GIF Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁len , ▁height ; ▁const ▁uint 8_ t ▁* ptr ; ▁/* ▁image ▁block ▁*/ ▁by test ream _ put _ byte ( by test ream , ▁0 x 2 c ); ▁by test ream _ put _ le 16 ( by test ream , ▁0); ▁by test ream _ put _ le 16 ( by test ream , ▁0); ▁by test ream _ put _ le 16 ( by test ream , ▁av ctx -> width ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ write _ st bl _ tag ( AV IO Context ▁* pb , ▁MO V Track ▁* track ) ▁{ ▁int 64_ t ▁pos ▁= ▁av io _ t ell ( pb ); ▁av io _ wb 32 ( pb , ▁0); ▁/* ▁size ▁*/ ▁ff io _ w four cc ( pb , ▁" st bl "); ▁mov _ write _ st sd _ tag ( pb , ▁track ); ▁mov _ write _ st ts _ tag ( pb , ▁track ); ▁if ▁(( track -> enc -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ▁|| ▁track -> enc -> codec _ tag ▁== ▁M K TAG (' r ',' t ',' p ',' ▁' )) ▁&& ▁track -> has _ keyframes ▁&& ▁track -> has _ keyframes ▁< ▁track 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁qc ow 2_ get _ cluster _ offset ( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁int ▁* num ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁l 1_ index , ▁l 2_ index ; ▁uint 64_ t ▁l 2_ offset , ▁* l 2_ table , ▁cluster _ offset ; ▁int ▁l 1_ bits , ▁c ; ▁int ▁index _ in _ cluster , ▁nb _ available , ▁nb _ needed , ▁nb _ clusters ; ▁index _ in _ cluster ▁= ▁( offset ▁>> ▁9 ) ▁& ▁( s -> cluster _ sect ors ▁- ▁1); ▁nb _ needed ▁= ▁* num ▁+ ▁index _ in _ cluster ; ▁l 1_ bits ▁= ▁s -> l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁RE NAME ( y uv 4 20 _ rgb 16 )( Sw s Context ▁* c , ▁uint 8_ t * ▁src [], ▁int ▁src Stride [], ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁uint 8_ t * ▁dst [], ▁int ▁dst Stride [] ){ ▁int ▁y , ▁h _ size ; ▁if ( c -> src Format ▁== ▁PI X _ F MT _ Y UV 4 22 P ){ ▁src Stride [1] ▁*= ▁2; ▁src Stride [2] ▁*= ▁2; ▁} ▁h _ size = ▁( c -> dst W + 7) & ~ 7 ; ▁if ( h _ size * 2 ▁> ▁FF AB S ( dst Stride [0] )) ▁h _ size - =8 ; ▁__ asm __ ▁__ vol atile __ ▁(" px or ▁% mm 4, ▁% mm 4 ;" ▁/* ▁zero ▁mm 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁memory _ region _ add _ event fd ( Memory Region ▁* mr , ▁hw addr ▁addr , ▁unsigned ▁size , ▁bool ▁match _ data , ▁uint 64_ t ▁data , ▁Event Notifier ▁* e ) ▁{ ▁Memory Region Io event fd ▁m rf d ▁= ▁{ ▁. addr . start ▁= ▁int 128 _ make 64 ( addr ), ▁. addr . size ▁= ▁int 128 _ make 64 ( size ), ▁. match _ data ▁= ▁match _ data , ▁. data ▁= ▁data , ▁. e ▁= ▁e , ▁}; ▁unsigned ▁i ; ▁adjust _ endian ness ( mr , ▁& m rf d . data , ▁size ); ▁memory _ region _ transaction _ begin (); ▁for ▁( i ▁= ▁0; ▁i ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁enum ▁AV Pixel Format ▁choose _ pixel _ fmt ( AV Stream ▁* st , ▁AV Codec ▁* codec , ▁enum ▁AV Pixel Format ▁target ) ▁{ ▁if ▁( codec ▁&& ▁codec -> pix _ fmt s ) ▁{ ▁const ▁enum ▁AV Pixel Format ▁* p ▁= ▁codec -> pix _ fmt s ; ▁int ▁has _ alpha = ▁av _ pix _ fmt _ desc _ get ( target ) -> nb _ components ▁% ▁2 ▁== ▁0; ▁enum ▁AV Pixel Format ▁best = ▁AV _ PI X _ F MT _ NONE ; ▁if ▁( st -> codec -> strict _ std _ compl iance ▁<= ▁FF _ COMP LI ANCE _ U NO F FI CIAL ) ▁{ ▁if ▁( st -> codec -> codec _ id ▁== 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁g ic _ set _ irq ( void ▁* op aque , ▁int ▁irq , ▁int ▁level ) ▁{ ▁/* ▁Meaning ▁of ▁the ▁' irq ' ▁parameter : ▁* ▁[0 .. N -1] ▁: ▁external ▁interrupt s ▁* ▁[ N .. N + 31 ] ▁: ▁P PI ▁( internal ) ▁interrupt s ▁for ▁CPU ▁0 ▁* ▁[ N + 32 .. N + 6 3] ▁: ▁P PI ▁( internal ▁interrupt s ▁for ▁CPU ▁1 ▁* ▁... ▁*/ ▁G IC State ▁* s ▁= ▁( G IC State ▁* ) op aque ; ▁int ▁cm , ▁target ; ▁if ▁( irq ▁< ▁( s -> num _ irq ▁- ▁G IC _ INTERNAL )) ▁{ ▁/* ▁The ▁first ▁external ▁input ▁line ▁is ▁internal ▁interrup

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ mb _ info ( I VI 5 Dec Context ▁* ctx , ▁I VI Band Desc ▁* band , ▁IV IT ile ▁* tile , ▁AV Codec Context ▁* av ctx ) ▁{ ▁int ▁x , ▁y , ▁mv _ x , ▁mv _ y , ▁mv _ delta , ▁offs , ▁mb _ offset , ▁mv _ scale , ▁bl ks _ per _ mb ; ▁I VI Mb Info ▁* mb , ▁* ref _ mb ; ▁int ▁row _ offset ▁= ▁band -> mb _ size ▁* ▁band -> p itch ; ▁mb ▁= ▁tile -> mb s ; ▁ref _ mb ▁= ▁tile -> ref _ mb s ; ▁offs ▁= ▁tile -> yp os ▁* ▁band -> p itch ▁+ ▁tile -> x pos ; ▁/* ▁scale ▁factor ▁for ▁motion ▁vectors ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁V IO s P AP R Device ▁* v ty _ lookup ( s P AP R Machine State ▁* sp ap r , ▁target _ ulong ▁reg ) ▁{ ▁V IO s P AP R Device ▁* s dev ; ▁s dev ▁= ▁sp ap r _ v io _ find _ by _ reg ( sp ap r -> v io _ bus , ▁reg ); ▁if ▁(! s dev ▁&& ▁reg ▁== ▁0) ▁{ ▁/* ▁H ack ▁for ▁kernel ▁early ▁debug , ▁which ▁always ▁specifies ▁reg ==0. ▁* ▁We ▁search ▁all ▁V IO ▁devices , ▁and ▁grab ▁the ▁v ty ▁with ▁the ▁lowest ▁* ▁reg . ▁This ▁attempts ▁to ▁mimic ▁existing ▁Power VM ▁behaviour ▁* ▁( ear ly ▁debug ▁does ▁work ▁there ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁coroutine _ fn ▁block _ job _ pause _ point ( Block Job ▁* job ) ▁{ ▁assert ( job ▁&& ▁block _ job _ started ( job )); ▁if ▁(! block _ job _ should _ pause ( job )) ▁{ ▁return ; ▁} ▁if ▁( block _ job _ is _ cancel led ( job )) ▁{ ▁return ; ▁} ▁if ▁( job -> driver -> pause ) ▁{ ▁job -> driver -> pause ( job ); ▁} ▁if ▁( block _ job _ should _ pause ( job ) ▁&& ▁! block _ job _ is _ cancel led ( job )) ▁{ ▁job -> pa used ▁= ▁true ; ▁job -> bus y ▁= ▁false ; ▁qemu _ cor outine _ yield (); ▁/* ▁wait ▁f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ p read ( Block Driver State ▁* bs , ▁int 64_ t ▁offset , ▁void ▁* buf 1, ▁int ▁count 1) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁if ▁(! dr v ) ▁return ▁- EN O MEDI UM ; ▁if ▁(! dr v -> b dr v _ p read ) ▁return ▁b dr v _ p read _ em ( bs , ▁offset , ▁buf 1, ▁count 1); ▁return ▁drv -> b dr v _ p read ( bs , ▁offset , ▁buf 1, ▁count 1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av priv _ d ca _ convert _ bit stream ( const ▁uint 8_ t ▁* src , ▁int ▁src _ size , ▁uint 8_ t ▁* dst , ▁int ▁max _ size ) ▁{ ▁uint 32_ t ▁mr k ; ▁int ▁i , ▁tmp ; ▁const ▁uint 16_ t ▁* ss rc ▁= ▁( const ▁uint 16_ t ▁* ) ▁src ; ▁uint 16_ t ▁* sd st ▁= ▁( uint 16_ t ▁* ) ▁dst ; ▁Put Bit Context ▁pb ; ▁if ▁(( un signed ) ▁src _ size ▁> ▁( un signed ) ▁max _ size ) ▁src _ size ▁= ▁max _ size ; ▁mr k ▁= ▁AV _ RB 32 ( src ); ▁switch ▁( mr k ) ▁{ ▁case ▁D CA _ SYNC WORD _ CORE _ BE : ▁mem c py ( dst , ▁sr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁TR BC Code ▁x h ci _ disable _ ep ( X H CI State ▁* x h ci , ▁unsigned ▁int ▁slot id , ▁unsigned ▁int ▁ep id ) ▁{ ▁X H C IS lot ▁* slot ; ▁X H CI EP Context ▁* ep ctx ; ▁int ▁i ; ▁trace _ usb _ x h ci _ ep _ disable ( slot id , ▁ep id ); ▁assert ( slot id ▁>= ▁1 ▁&& ▁slot id ▁<= ▁x h ci -> num slots ); ▁assert ( ep id ▁>= ▁1 ▁&& ▁ep id ▁<= ▁31 ); ▁slot ▁= ▁& x h ci -> slots [ slot id -1 ]; ▁if ▁(! slot -> eps [ ep id -1 ]) ▁{ ▁D PRI NT F (" x h ci : ▁slot ▁% d ▁ep ▁% d ▁already ▁disabled \ n ", ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁pv pan ic _ init ( IS AB us ▁* bus ) ▁{ ▁isa _ create _ simple ( bus , ▁TYPE _ IS A _ P VP AN IC _ DEVICE ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁g ic _ dist _ read b ( void ▁* op aque , ▁hw addr ▁offset , ▁Mem Tx Attrs ▁attrs ) ▁{ ▁G IC State ▁* s ▁= ▁( G IC State ▁* ) op aque ; ▁uint 32_ t ▁res ; ▁int ▁irq ; ▁int ▁i ; ▁int ▁cpu ; ▁int ▁cm ; ▁int ▁mask ; ▁cpu ▁= ▁g ic _ get _ current _ cpu ( s ); ▁cm ▁= ▁1 ▁<< ▁cpu ; ▁if ▁( offset ▁< ▁0 x 100 ) ▁{ ▁if ▁( offset ▁== ▁0) ▁return ▁s -> enabled ; ▁if ▁( offset ▁== ▁4) ▁/* ▁Inter rupt ▁Controller ▁Type ▁Register ▁*/ ▁return ▁(( s -> num _ irq ▁/ ▁3 2) ▁- ▁1) ▁| ▁(( NUM _ CPU ( s ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁get _ segment _6 xx _ tl b ( CP UP PC State ▁* env , ▁mm u _ ctx _ t ▁* ctx , ▁target _ ulong ▁e addr , ▁int ▁rw , ▁int ▁type ) ▁{ ▁hw addr ▁hash ; ▁target _ ulong ▁vs id ; ▁int ▁ds , ▁pr , ▁target _ page _ bits ; ▁int ▁ret ; ▁target _ ulong ▁sr , ▁pg idx ; ▁pr ▁= ▁ms r _ pr ; ▁ctx -> ead dr ▁= ▁e addr ; ▁sr ▁= ▁env -> sr [ ead dr ▁>> ▁28 ]; ▁ctx -> key ▁= ▁( (( sr ▁& ▁0 x 2 0000000 ) ▁&& ▁( pr ▁!= ▁0 )) ▁|| ▁(( sr ▁& ▁0 x 4 0000000 ) ▁&& ▁( pr ▁== ▁0 ))) ▁? ▁1 ▁: ▁0; ▁ds ▁= ▁sr ▁& ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sl ir p _ socket _ save ( Q EM U File ▁* f , ▁struct ▁socket ▁* so ) ▁{ ▁qemu _ put _ be 32 ( f , ▁so -> so _ ur gc ); ▁qemu _ put _ be 16 ( f , ▁so -> so _ ff amily ); ▁switch ▁( so -> so _ ff amily ) ▁{ ▁case ▁AF _ INET : ▁qemu _ put _ be 32 ( f , ▁so -> so _ f addr . s _ addr ); ▁qemu _ put _ be 16 ( f , ▁so -> so _ f port ); ▁break ; ▁default : ▁error _ report ( ▁" so _ ff amily ▁unknown , ▁unable ▁to ▁save ▁so _ f addr ▁and ▁so _ f port \ n "); ▁} ▁qemu _ put _ be 16 ( f , ▁so -> so _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁object _ property _ allow _ set _ link ( Object ▁* obj , ▁const ▁char ▁* name , ▁Object ▁* val , ▁Error ▁** err p ) ▁{ ▁/* ▁Allow ▁the ▁link ▁to ▁be ▁set , ▁always ▁*/ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁mix _3 f _1 r _ to _ mon o ( AC 3 Decode Context ▁* ctx ) ▁{ ▁int ▁i ; ▁float ▁(* output )[ 256 ] ▁= ▁ctx -> audio _ block . block _ output ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁256 ; ▁i ++) ▁output [1] [ i ] ▁= ▁( output [2 ][ i ] ▁+ ▁output [3 ][ i ] ▁+ ▁output [4 ][ i ]); ▁mem set ( output [2], ▁0, ▁sizeof ( output [2]) ); ▁mem set ( output [3 ], ▁0, ▁sizeof ( output [3 ])); ▁mem set ( output [4 ], ▁0, ▁sizeof ( output [4 ])); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( nv 21 To UV )( uint 8_ t ▁* dst U , ▁uint 8_ t ▁* dst V , ▁const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁long ▁width , ▁uint 32_ t ▁* unused ) ▁{ ▁RE NAME ( nv XX to UV )( dst V , ▁dst U , ▁src 1, ▁width ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁l an 9 11 8_ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁unsigned ▁size ) ▁{ ▁l an 9 11 8_ state ▁* s ▁= ▁( lan 9 11 8_ state ▁* ) op aque ; ▁// DP RI NT F (" Read ▁reg ▁0 x % 02 x \ n ", ▁( int ) offset ); ▁if ▁( offset ▁< ▁0 x 20) ▁{ ▁/* ▁RX ▁FIFO ▁*/ ▁return ▁rx _ f ifo _ pop ( s ); ▁} ▁switch ▁( offset ) ▁{ ▁case ▁0 x 40 : ▁return ▁rx _ status _ f ifo _ pop ( s ); ▁case ▁0 x 44 : ▁return ▁s -> rx _ status _ f ifo [ s -> tx _ status _ f ifo _ head ]; ▁case ▁0 x

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ low _ coeff s ( AV Codec Context ▁* av ctx , ▁int 16_ t ▁* dst , ▁int ▁size , ▁int ▁width , ▁ptr diff _ t ▁stride ) ▁{ ▁P ix let Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁Get Bit Context ▁* b ▁= ▁& ctx -> g bit ; ▁unsigned ▁cnt 1, ▁nb its , ▁k , ▁j ▁= ▁0, ▁i ▁= ▁0; ▁int 64_ t ▁value , ▁state ▁= ▁3; ▁int ▁r len , ▁escape , ▁flag ▁= ▁0; ▁while ▁( i ▁< ▁size ) ▁{ ▁nb its ▁= ▁FF MIN ( ff _ cl z (( state ▁>> ▁8) ▁+ ▁3) ▁^ ▁0 x 1 F , ▁14 ); ▁cnt 1 ▁= ▁get _ unary ( b , ▁0, ▁8 ); ▁if ▁( cn

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ co _ read v _1 ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁Q EM UI O Vector ▁* q io v , ▁int ▁offset ) ▁{ ▁B DR V N BD State ▁* s ▁= ▁bs -> op aque ; ▁struct ▁nb d _ request ▁request ; ▁struct ▁nb d _ reply ▁reply ; ▁request . type ▁= ▁N BD _ CMD _ READ ; ▁request . from ▁= ▁sector _ num ▁* ▁512 ; ▁request . len ▁= ▁nb _ sect ors ▁* ▁512 ; ▁nb d _ cor outine _ start ( s , ▁& request ); ▁if ▁( nb d _ co _ send _ request ( s , ▁& request , ▁NULL , ▁0) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁request _ frame ( AV Filter Link ▁* link ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁link -> src ; ▁IDE T Context ▁* id et ▁= ▁ctx -> priv ; ▁do ▁{ ▁int ▁ret ; ▁if ▁( id et -> eof ) ▁return ▁A VER ROR _ EOF ; ▁ret ▁= ▁ff _ request _ frame ( link -> src -> inputs [0]); ▁if ▁( ret ▁== ▁A VER ROR _ EOF ▁&& ▁id et -> cur ) ▁{ ▁AV Frame ▁* next ▁= ▁av _ frame _ clone ( id et -> next ); ▁if ▁(! next ) ▁return ▁A VER ROR ( EN O ME M ); ▁filter _ frame ( link -> src -> inputs [0], ▁next ); ▁id et -> eof ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁d pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁D PC M Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁in , ▁out ▁= ▁0; ▁int ▁predict or [2 ]; ▁int ▁channel _ number ▁= ▁0; ▁short ▁* output _ samples ▁= ▁data ; ▁int ▁shift [2 ]; ▁unsigned ▁char ▁byte ; ▁short ▁diff ; ▁if ▁(! buf _ size ) ▁return ▁0; ▁switch ( av ctx -> codec -> id ) ▁{ ▁case ▁CODE C _ ID _ RO Q _ D PC M : ▁if ▁( s -> channels ▁== ▁1) ▁pred

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ rm _ read _ md pr _ codec data ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Stream ▁* st , ▁RM Stream ▁* rst , ▁unsigned ▁int ▁codec _ data _ size , ▁const ▁uint 8_ t ▁* mime ) ▁{ ▁unsigned ▁int ▁v ; ▁int ▁size ; ▁int 64_ t ▁codec _ pos ; ▁int ▁ret ; ▁if ▁( codec _ data _ size ▁> ▁INT _ MAX ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁av priv _ set _ pts _ info ( st , ▁64, ▁1, ▁1000); ▁codec _ pos ▁= ▁av io _ t ell ( pb ); ▁v ▁= ▁av io _ rb 32 ( pb ); ▁if ▁( v ▁== ▁M KB ET AG (' M ', ▁' L

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sd _ do _ command ( SD State ▁* sd , ▁SD Request ▁* req , ▁uint 8_ t ▁* response ) ▁{ ▁uint 32_ t ▁last _ status ▁= ▁sd -> card _ status ; ▁sd _ r sp _ type _ t ▁r type ; ▁int ▁rs pl en ; ▁if ▁(! sd -> b dr v ▁|| ▁! b dr v _ is _ insert ed ( sd -> b dr v ) ▁|| ▁! sd -> enable ) ▁{ ▁return ▁0; ▁} ▁if ▁( sd _ req _ crc _ validate ( req )) ▁{ ▁sd -> card _ status ▁&= ▁~ COM _ C RC _ ERROR ; ▁return ▁0; ▁} ▁sd -> card _ status ▁&= ▁~ C ARD _ STATUS _ B ; ▁sd _ set _ status ( sd ); ▁if ▁( last _ status ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁d pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁D PC M Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁in , ▁out ▁= ▁0; ▁int ▁predict or [2 ]; ▁int ▁ch ▁= ▁0; ▁int ▁st ere o ▁= ▁s -> channels ▁- ▁1; ▁short ▁* output _ samples ▁= ▁data ; ▁int ▁shift [2 ]; ▁unsigned ▁char ▁byte ; ▁short ▁diff ; ▁if ▁(! buf _ size ) ▁return ▁0; ▁// ▁almost

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pic mem set ( Pic Context ▁* s , ▁AV Frame ▁* frame , ▁unsigned ▁value , ▁int ▁run , ▁int ▁* x , ▁int ▁* y , ▁int ▁* plane , ▁int ▁bits _ per _ plane ) ▁{ ▁uint 8_ t ▁* d ; ▁int ▁shift ▁= ▁* plane ▁* ▁bits _ per _ plane ; ▁unsigned ▁mask ▁= ▁( (1 ▁<< ▁bits _ per _ plane ) ▁- ▁1) ▁<< ▁shift ; ▁value ▁<<= ▁shift ; ▁while ▁( run ▁> ▁0) ▁{ ▁int ▁j ; ▁for ▁( j ▁= ▁8 - bits _ per _ plane ; ▁j ▁>= ▁0; ▁j ▁-= ▁bits _ per _ plane ) ▁{ ▁d ▁= ▁frame -> data [0] ▁+ ▁* y ▁* ▁frame -> lines ize [0]; ▁d [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁mp _ image _ t * ▁vf _ get _ image ( vf _ instance _ t * ▁vf , ▁unsigned ▁int ▁out fmt , ▁int ▁mp _ img type , ▁int ▁mp _ img flag , ▁int ▁w , ▁int ▁h ){ ▁MP Context ▁* m = ▁( MP Context *) (( ( uint 8_ t *) vf ) ▁- ▁offset of ( MP Context , ▁next _ vf )); ▁mp _ image _ t * ▁mpi = NULL ; ▁int ▁w 2; ▁int ▁number ▁= ▁mp _ img type ▁>> ▁16 ; ▁av _ assert 0( vf -> next ▁== ▁NULL ); ▁// ▁all ▁existing ▁filters ▁call ▁this ▁just ▁on ▁next ▁// vf _ d int ▁needs ▁these ▁as ▁it ▁calls ▁vf _ get _ image () ▁before

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ MP 4 SL Descr Tag ( MP 4 Descr Parse Context ▁* d , ▁int 64_ t ▁off , ▁int ▁len ) ▁{ ▁M p 4 Descr ▁* descr ▁= ▁d -> active _ descr ; ▁int ▁predefined ; ▁if ▁(! descr ) ▁return ▁-1; ▁predefined ▁= ▁av io _ r 8 ( & d -> pb ); ▁if ▁(! pred efined ) ▁{ ▁int ▁lengths ; ▁int ▁flags ▁= ▁av io _ r 8 ( & d -> pb ); ▁descr -> sl . use _ au _ start ▁= ▁!! ( flags ▁& ▁0 x 80 ); ▁descr -> sl . use _ au _ end ▁= ▁!! ( flags ▁& ▁0 x 40 ); ▁descr -> sl . use _ rand _ acc _ pt ▁= ▁!! ( flags ▁& ▁0 x 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁helper _ mul _ su ov ( CP UT ri Core State ▁* env , ▁target _ ulong ▁r 1, ▁target _ ulong ▁r 2) ▁{ ▁int 64_ t ▁t 1 ▁= ▁extract 64 ( r 1, ▁0, ▁32 ); ▁int 64_ t ▁t 2 ▁= ▁extract 64 ( r 2, ▁0, ▁32 ); ▁int 64_ t ▁result ▁= ▁t 1 ▁* ▁t 2; ▁return ▁su ov 32 ( env , ▁result ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ chunks ( AV Format Context ▁* s , ▁int ▁mode , ▁int 64_ t ▁seek ts , ▁int ▁* len _ ptr ) ▁{ ▁W tv Context ▁* wt v ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁w tv -> pb ; ▁while ▁(! url _ fe of ( pb )) ▁{ ▁ff _ as f _ guid ▁g ; ▁int ▁len , ▁sid , ▁consumed ; ▁ff _ get _ guid ( pb , ▁& g ); ▁len ▁= ▁av io _ rl 32 ( pb ); ▁if ▁( len ▁< ▁3 2) ▁break ; ▁sid ▁= ▁av io _ rl 32 ( pb ) ▁& ▁0 x 7 FFF ; ▁av io _ skip ( pb , ▁8 ); ▁consumed ▁= ▁32 ; ▁if ▁(! ff _ guid cmp ( g , ▁ff _ S BE 2_

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ rng _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁V irt io Device Class ▁* v dc ▁= ▁VI RT IO _ DEVICE _ CLASS ( k lass ); ▁dc -> props ▁= ▁virt io _ rng _ properties ; ▁set _ bit ( DEVICE _ CATEGORY _ MI SC , ▁dc -> categories ); ▁v dc -> real ize ▁= ▁virt io _ rng _ device _ real ize ; ▁v dc -> un real ize ▁= ▁virt io _ rng _ device _ un real ize ; ▁v dc -> get _ features ▁= ▁get _ features ; ▁v dc -> load ▁= ▁vir

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ init ( int ▁s mp _ cpus ) ▁{ ▁K VM State ▁* s ; ▁int ▁ret ; ▁int ▁i ; ▁if ▁( s mp _ cpus ▁> ▁1) ▁return ▁- E IN VAL ; ▁s ▁= ▁qemu _ m alloc z ( size of ( K VM State )); ▁if ▁( s ▁== ▁NULL ) ▁return ▁- EN O ME M ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( s -> slots ); ▁i ++) ▁s -> slots [ i ]. slot ▁= ▁i ; ▁s -> vm fd ▁= ▁-1; ▁s -> fd ▁= ▁open ("/ dev / k vm ", ▁O _ RD WR ); ▁if ▁( s -> fd ▁== ▁-1) ▁{ ▁f printf ( stderr , ▁" Could ▁not ▁access ▁K VM ▁kernel ▁module : ▁% m \ n "); ▁ret ▁= ▁- err 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁nfs _ client _ open ( N FS Client ▁* client , ▁const ▁char ▁* filename , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁int ▁ret ▁= ▁- E IN VAL , ▁i ; ▁struct ▁stat ▁st ; ▁URI ▁* uri ; ▁Query Params ▁* qp ▁= ▁NULL ; ▁char ▁* file ▁= ▁NULL , ▁* str p ▁= ▁NULL ; ▁uri ▁= ▁uri _ parse ( filename ); ▁if ▁(! uri ) ▁{ ▁error _ set g ( err p , ▁" Invalid ▁URL ▁specified "); ▁goto ▁fail ; ▁} ▁if ▁(! uri -> server ) ▁{ ▁error _ set g ( err p , ▁" Invalid ▁URL ▁specified "); ▁goto ▁fail ; ▁} ▁str p ▁= ▁str

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nut _ read _ header ( AV Format Context ▁* ▁av f , ▁AV Format Parameters ▁* ▁ap ) ▁{ ▁N UT Context ▁* ▁priv ▁= ▁av f -> priv _ data ; ▁AV IO Context ▁* ▁bc ▁= ▁av f -> pb ; ▁nut _ dem ux er _ opts _ tt ▁do pts ▁= ▁{ ▁. input ▁= ▁{ ▁. priv ▁= ▁bc , ▁. seek ▁= ▁av _ seek , ▁. read ▁= ▁av _ read , ▁. eof ▁= ▁NULL , ▁. file _ pos ▁= ▁0, ▁}, ▁. alloc ▁= ▁{ ▁av _ m alloc , ▁av _ real loc , ▁av _ free ▁}, ▁. read _ index ▁= ▁1, ▁. cache _ sync points ▁= ▁1, ▁}; ▁nut _ context _ tt ▁* ▁nut ▁= ▁priv 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ cpu _ real iz ef n ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( dev ); ▁Power PC CPU ▁* cpu ▁= ▁PO WER PC _ CPU ( dev ); ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ GET _ CLASS ( cpu ); ▁Error ▁* local _ err ▁= ▁NULL ; ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁int ▁max _ s mt ▁= ▁k vm _ enabled () ▁? ▁k vm pp c _ s mt _ threads () ▁: ▁1; ▁# end if ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁if ▁( s mp _ threads ▁> ▁max _ s mt ) ▁{ ▁error _ set g ( er

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ram _ init ( target _ ph ys _ addr _ t ▁addr , ▁ram _ addr _ t ▁RAM _ size ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁Ram Device ▁* d ; ▁/* ▁allocate ▁RAM ▁*/ ▁dev ▁= ▁q dev _ create ( NULL , ▁" memory "); ▁s ▁= ▁sys bus _ from _ q dev ( dev ); ▁d ▁= ▁FROM _ SY SB US ( R am Device , ▁s ); ▁d -> size ▁= ▁RAM _ size ; ▁q dev _ init ( dev ); ▁sys bus _ mm io _ map ( s , ▁0, ▁addr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q emu Opts ▁* q emu _ chr _ parse _ compat ( const ▁char ▁* label , ▁const ▁char ▁* filename ) ▁{ ▁char ▁host [ 65 ], ▁port [ 33 ], ▁width [ 8 ], ▁height [ 8 ]; ▁int ▁pos ; ▁const ▁char ▁* p ; ▁Q emu Opts ▁* opts ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁opts ▁= ▁qemu _ opts _ create ( q emu _ find _ opts (" ch ard ev "), ▁label , ▁1, ▁& local _ err ); ▁if ▁( error _ is _ set ( & local _ err )) ▁{ ▁q error _ report _ err ( local _ err ); ▁error _ free ( local _ err ); ▁return ▁NULL ; ▁} ▁if ▁( str start ( file

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁PO WER PC _ FAMILY ( PO WER 8) ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( oc ); ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ CLASS ( oc ); ▁dc -> fw _ name ▁= ▁" Power PC , PO WER 8 "; ▁dc -> desc ▁= ▁" PO WER 8 "; ▁p cc -> pv r ▁= ▁CPU _ PO WER PC _ PO WER 8_ BASE ; ▁p cc -> pv r _ mask ▁= ▁CPU _ PO WER PC _ PO WER 8_ MASK ; ▁p cc -> init _ proc ▁= ▁init _ proc _ PO WER 7 ; ▁p cc -> check _ pow ▁= ▁check _ pow _ no check ; ▁p cc -> ins ns _ flags ▁= ▁P PC _ I

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ object _ segment ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁PG SS ub Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁PG SS ub Object ▁* object ; ▁uint 8_ t ▁sequence _ desc ; ▁unsigned ▁int ▁r le _ bitmap _ len , ▁width , ▁height ; ▁int ▁id ; ▁if ▁( buf _ size ▁<= ▁4) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁buf _ size ▁-= ▁4; ▁id ▁= ▁by test ream _ get _ be 16 ( & buf ); ▁object ▁= ▁find _ object ( id , ▁& ctx -> objects ); ▁if ▁(! object ) ▁{ ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ rd ma _ register _ and _ get _ keys ( RD MA Context ▁* rd ma , ▁R DM AL ocal Block ▁* block , ▁uint ptr _ t ▁host _ addr , ▁uint 32_ t ▁* l key , ▁uint 32_ t ▁* r key , ▁int ▁chunk , ▁uint 8_ t ▁* chunk _ start , ▁uint 8_ t ▁* chunk _ end ) ▁{ ▁if ▁( block -> mr ) ▁{ ▁if ▁( l key ) ▁{ ▁* l key ▁= ▁block -> mr -> l key ; ▁} ▁if ▁( r key ) ▁{ ▁* r key ▁= ▁block -> mr -> r key ; ▁} ▁return ▁0; ▁} ▁/* ▁allocate ▁memory ▁to ▁store ▁chunk ▁MR s ▁*/ ▁if ▁(! block -> pm r ) ▁{ ▁block -> pm r 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v ga _ draw _ graph ic ( V GA State ▁* s , ▁int ▁full _ update ) ▁{ ▁int ▁y 1, ▁y , ▁update , ▁page _ min , ▁page _ max , ▁lines ize , ▁y _ start , ▁double _ scan , ▁mask , ▁depth ; ▁int ▁width , ▁height , ▁shift _ control , ▁line _ offset , ▁page 0, ▁page 1, ▁b width , ▁bits ; ▁int ▁disp _ width , ▁multi _ scan , ▁multi _ run ; ▁uint 8_ t ▁* d ; ▁uint 32_ t ▁v , ▁addr 1, ▁addr ; ▁v ga _ draw _ line _ func ▁* v ga _ draw _ line ; ▁full _ update ▁|= ▁update _ basic _ params ( s ); ▁if ▁(! fu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ sign alf d _ compat ( const ▁sig set _ t ▁* mask ) ▁{ ▁p thread _ attr _ t ▁attr ; ▁p thread _ t ▁tid ; ▁struct ▁sig fd _ compat _ info ▁* info ; ▁int ▁f ds [2 ]; ▁info ▁= ▁m alloc ( size of (* info )); ▁if ▁( info ▁== ▁NULL ) ▁{ ▁errno ▁= ▁ENO ME M ; ▁return ▁-1; ▁} ▁if ▁( pipe ( fds ) ▁== ▁-1) ▁{ ▁free ( info ); ▁return ▁-1; ▁} ▁mem c py ( & info -> mask , ▁mask , ▁sizeof (* mask )); ▁info -> fd ▁= ▁f ds [1]; ▁p thread _ attr _ init ( & attr ); ▁p thread _ attr _ set detach state ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁protocol _ client _ auth _ s asl _ start _ len ( V nc State ▁* vs , ▁uint 8_ t ▁* data , ▁size _ t ▁len ) ▁{ ▁uint 32_ t ▁start len ▁= ▁read _ u 32 ( data , ▁0); ▁V NC _ DEBUG (" Got ▁client ▁start ▁len ▁% d \ n ", ▁start len ); ▁if ▁( start len ▁> ▁SAS L _ DATA _ MAX _ LEN ) ▁{ ▁V NC _ DEBUG (" Too ▁much ▁SAS L ▁data ▁% d \ n ", ▁start len ); ▁v nc _ client _ error ( vs ); ▁return ▁-1; ▁} ▁if ▁( start len ▁== ▁0) ▁return ▁protocol _ client _ auth _ s asl _ start ( vs , ▁NULL , ▁0); ▁v nc _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁mv _ pred _ direct ( AV S Context ▁* h , ▁c av s _ vector ▁* pm v _ fw , ▁c av s _ vector ▁* col _ mv ) ▁{ ▁c av s _ vector ▁* pm v _ bw ▁= ▁pm v _ fw ▁+ ▁MV _ B WD _ OFF S ; ▁int ▁den ▁= ▁h -> direct _ den [ col _ mv -> ref ]; ▁int ▁m ▁= ▁FF _ SIGN BIT ( col _ mv -> x ); ▁pm v _ fw -> dist ▁= ▁h -> dist [1]; ▁pm v _ bw -> dist ▁= ▁h -> dist [0]; ▁pm v _ fw -> ref ▁= ▁1; ▁pm v _ bw -> ref ▁= ▁0; ▁/* ▁scale ▁the ▁co - located ▁motion ▁vector ▁according ▁to ▁its ▁temporal ▁span ▁*/ ▁p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁h 2 64_ deb lock _ q 1( register ▁vector ▁unsigned ▁char ▁p 0, ▁register ▁vector ▁unsigned ▁char ▁p 1, ▁register ▁vector ▁unsigned ▁char ▁p 2, ▁register ▁vector ▁unsigned ▁char ▁q 0, ▁register ▁vector ▁unsigned ▁char ▁tc 0) ▁{ ▁register ▁vector ▁unsigned ▁char ▁average ▁= ▁vec _ avg ( p 0, ▁q 0); ▁register ▁vector ▁unsigned ▁char ▁temp ; ▁register ▁vector ▁unsigned ▁char ▁un clip ed ; ▁register ▁vector ▁unsigned ▁char ▁ones ; ▁register ▁vector ▁unsigned ▁char ▁max ; ▁register ▁vecto

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ branch _ a ( Dis as Context ▁* dc , ▁target _ ulong ▁pc 1, ▁target _ ulong ▁pc 2, ▁TC G v ▁r _ cond ) ▁{ ▁int ▁l 1; ▁l 1 ▁= ▁gen _ new _ label (); ▁tc g _ gen _ br con di _ tl ( TC G _ COND _ EQ , ▁r _ cond , ▁0, ▁l 1); ▁gen _ goto _ tb ( dc , ▁0, ▁pc 2, ▁pc 1); ▁gen _ set _ label ( l 1); ▁gen _ goto _ tb ( dc , ▁1, ▁pc 2 ▁+ ▁4, ▁pc 2 ▁+ ▁8 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁qc ow 2_ alloc _ cluster _ offset ( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁int ▁n _ start , ▁int ▁n _ end , ▁int ▁* num , ▁Q C ow L 2 Meta ▁* m ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁l 2_ index , ▁ret ; ▁uint 64_ t ▁l 2_ offset , ▁* l 2_ table , ▁cluster _ offset ; ▁int ▁nb _ clusters , ▁i ▁= ▁0; ▁Q C ow L 2 Meta ▁* old _ alloc ; ▁ret ▁= ▁get _ cluster _ table ( bs , ▁offset , ▁& l 2_ table , ▁& l 2_ offset , ▁& l 2_ index ); ▁if ▁( ret ▁== ▁0) ▁return ▁0; ▁nb _ c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁tx _ consume ( R ocker ▁* r , ▁Desc Info ▁* info ) ▁{ ▁PC ID evice ▁* dev ▁= ▁P CI _ DEVICE ( r ); ▁char ▁* buf ▁= ▁desc _ get _ buf ( info , ▁true ); ▁R ocker Tlv ▁* tl v _ f rag ; ▁R ocker Tlv ▁* tl vs [ RO CKER _ TL V _ TX _ MAX ▁+ ▁1 ]; ▁struct ▁i ove c ▁i ov [ RO CKER _ TX _ FR AG S _ MAX ] ▁= ▁{ ▁{ ▁0, ▁}, ▁}; ▁uint 32_ t ▁p port ; ▁uint 32_ t ▁port ; ▁uint 16_ t ▁tx _ off load ▁= ▁RO CKER _ TX _ OFF LOAD _ NONE ; ▁uint 16_ t ▁tx _ l 3_ c sum _ off ▁= ▁0; ▁uint 16_ t ▁tx _ t so _ m ss 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV Filter Formats ▁* av filter _ all _ color spaces ( void ) ▁{ ▁return ▁av filter _ make _ format _ list (3 5, ▁PI X _ F MT _ Y UV 444 P , ▁PI X _ F MT _ Y UV 4 22 P , ▁PI X _ F MT _ Y UV 4 20 P , ▁PI X _ F MT _ Y UV 4 11 P , ▁PI X _ F MT _ Y UV 4 10 P , ▁PI X _ F MT _ Y U Y V 42 2, ▁PI X _ F MT _ U Y V Y 42 2, ▁PI X _ F MT _ U YY V YY 41 1, ▁PI X _ F MT _ Y UV J 444 P , ▁PI X _ F MT _ Y UV J 4 22 P , ▁PI X _ F MT _ Y UV J 4 20 P , ▁PI X _ F MT _ Y UV 4 40 P , ▁PI X _ F MT _ Y UV J 4 40 P , ▁PI X _ F MT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Memory Region ▁* es cc _ init ( target _ ph ys _ addr _ t ▁base , ▁qemu _ irq ▁irq A , ▁qemu _ irq ▁irq B , ▁Char Driver State ▁* chr A , ▁Char Driver State ▁* chr B , ▁int ▁clock , ▁int ▁it _ shift ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁Serial State ▁* d ; ▁dev ▁= ▁q dev _ create ( NULL , ▁" es cc "); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" disabled ", ▁0); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" frequency ", ▁clock ); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" it _ shift ", ▁it _ shift ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁free _ ge ot ags ( T iff Context ▁* const ▁s ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> ge ot ag _ count ; ▁i ++) ▁{ ▁if ▁( s -> ge ot ags [ i ]. val ) ▁av _ fre ep ( & s -> ge ot ags [ i ]. val ); ▁} ▁av _ fre ep ( & s -> ge ot ags ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ b ink _ id ct _ c ( D CT E LE M ▁* block ) ▁{ ▁int ▁i ; ▁D CT E LE M ▁temp [ 64 ]; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁b ink _ id ct _ col ( & temp [ i ], ▁& block [ i ]); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁{ ▁ID CT _ ROW ( ▁( & block [ 8 * i ]), ▁( & temp [ 8 * i ]) ▁); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P CI Bus ▁* pc i _ p mac _ init ( q emu _ irq ▁* pic ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁UN IN State ▁* d ; ▁/* ▁Use ▁values ▁found ▁on ▁a ▁real ▁Power Mac ▁*/ ▁/* ▁Un in orth ▁main ▁bus ▁*/ ▁dev ▁= ▁q dev _ create ( NULL , ▁" Un i - n orth ▁main "); ▁q dev _ init _ n of ail ( dev ); ▁s ▁= ▁sys bus _ from _ q dev ( dev ); ▁d ▁= ▁FROM _ SY SB US ( UN IN State , ▁s ); ▁d -> host _ state . bus ▁= ▁pci _ register _ bus ( & d -> bus dev . q dev , ▁" pc i ", ▁pci _ un in _ set _ irq , ▁pci _ un

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁json _ message _ process _ token ( JSON Lexer ▁* lexer , ▁G String ▁* input , ▁JS ONT oken Type ▁type , ▁int ▁x , ▁int ▁y ) ▁{ ▁JSON Message Parser ▁* parser ▁= ▁container _ of ( lexer , ▁JSON Message Parser , ▁lexer ); ▁Q Dict ▁* dict ; ▁switch ▁( type ) ▁{ ▁case ▁JSON _ LC URL Y : ▁parser -> b race _ count ++; ▁break ; ▁case ▁JSON _ RC URL Y : ▁parser -> b race _ count --; ▁break ; ▁case ▁JSON _ LS QU A RE : ▁parser -> b racket _ count ++; ▁break ; ▁case ▁JSON _ RS QU A RE : ▁parser -> b 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁p pc 4 xx _ tl b _ in validate _ virt ( CP UP PC State ▁* env , ▁target _ ulong ▁e addr , ▁uint 32_ t ▁pid ) ▁{ ▁# if ▁! defined ( FL USH _ ALL _ TL BS ) ▁CPU State ▁* cs ▁= ▁CPU ( pp c _ env _ get _ cpu ( env )); ▁pp ce mb _ tl b _ t ▁* tl b ; ▁hw addr ▁r addr ; ▁target _ ulong ▁page , ▁end ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁env -> nb _ tl b ; ▁i ++) ▁{ ▁tl b ▁= ▁& env -> tl b . tl be [ i ]; ▁if ▁( pp ce mb _ tl b _ check ( env , ▁tl b , ▁& r addr , ▁e addr , ▁pid , ▁0, ▁i ) ▁== ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pci _ bridge _ init fn ( PC ID evice ▁* dev , ▁const ▁char ▁* typ ename ) ▁{ ▁P CI Bus ▁* parent ▁= ▁dev -> bus ; ▁P CI Bridge ▁* br ▁= ▁P CI _ BR ID GE ( dev ); ▁P CI Bus ▁* sec _ bus ▁= ▁& br -> sec _ bus ; ▁pci _ word _ test _ and _ set _ mask ( dev -> config ▁+ ▁P CI _ STATUS , ▁P CI _ STATUS _ 66 M H Z ▁| ▁P CI _ STATUS _ FA ST _ BACK ); ▁/* ▁* ▁TODO : ▁We ▁implement ▁V GA ▁Enable ▁in ▁the ▁Bridge ▁Control ▁Register ▁* ▁therefore ▁per ▁the ▁P CI ▁to ▁P CI ▁bridge ▁spec ▁we ▁must ▁also ▁impleme

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ pix man _ line buf _ fill ( pix man _ image _ t ▁* line buf , ▁pix man _ image _ t ▁* fb , ▁int ▁width , ▁int ▁y ) ▁{ ▁pix man _ image _ composite ( PI X MAN _ OP _ SRC , ▁fb , ▁NULL , ▁line buf , ▁0, ▁y , ▁0, ▁0, ▁0, ▁0, ▁width , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁abi _ long ▁target _ to _ host _ c msg ( struct ▁msg hdr ▁* msg h , ▁struct ▁target _ msg hdr ▁* target _ msg h ) ▁{ ▁struct ▁c msg hdr ▁* c msg ▁= ▁C MSG _ FIRST H DR ( msg h ); ▁abi _ long ▁msg _ cont roll en ; ▁abi _ ulong ▁target _ c msg _ addr ; ▁struct ▁target _ c msg hdr ▁* target _ c msg ; ▁sock len _ t ▁space ▁= ▁0; ▁msg _ cont roll en ▁= ▁t swap al ( target _ msg h -> msg _ cont roll en ); ▁if ▁( msg _ cont roll en ▁< ▁sizeof ▁( struct ▁target _ c msg hdr )) ▁goto ▁the _ end ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁ga _ open _ pid file ( const ▁char ▁* pid file ) ▁{ ▁int ▁pid fd ; ▁char ▁pid str [ 32 ]; ▁pid fd ▁= ▁open ( pid file , ▁O _ CRE AT | O _ WR ONLY , ▁S _ IR USR | S _ I W USR ); ▁if ▁( pid fd ▁== ▁-1 ▁|| ▁lock f ( pid fd , ▁F _ T LOCK , ▁0 )) ▁{ ▁g _ cr itical (" Cannot ▁lock ▁pid ▁file , ▁% s ", ▁strerror ( err no )); ▁if ▁( pid fd ▁!= ▁-1) ▁{ ▁close ( pid fd ); ▁} ▁return ▁false ; ▁} ▁if ▁( f truncate ( pid fd , ▁0) ▁|| ▁l seek ( pid fd , ▁0, ▁SE EK _ SET )) ▁{ ▁g _ cr itical (" Failed ▁to

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ pending _ signal ( CPU Arch State ▁* cpu _ env , ▁int ▁sig ) ▁{ ▁CPU State ▁* cpu ▁= ▁ENV _ GET _ CPU ( cpu _ env ); ▁abi _ ulong ▁handler ; ▁sig set _ t ▁set , ▁old _ set ; ▁target _ sig set _ t ▁target _ old _ set ; ▁struct ▁target _ sig action ▁* sa ; ▁struct ▁sig queue ▁* q ; ▁Task State ▁* ts ▁= ▁cpu -> op aque ; ▁struct ▁em ulated _ sig table ▁* k ▁= ▁& ts -> sig tab [ sig ▁- ▁1 ]; ▁trace _ user _ handle _ signal ( cpu _ env , ▁sig ); ▁/* ▁dequeue ▁signal ▁*/ ▁q ▁= ▁k -> firs

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc ie _ pc i _ bridge _ write _ config ( PC ID evice ▁* d , ▁uint 32_ t ▁address , ▁uint 32_ t ▁val , ▁int ▁len ) ▁{ ▁pci _ bridge _ write _ config ( d , ▁address , ▁val , ▁len ); ▁m si _ write _ config ( d , ▁address , ▁val , ▁len ); ▁sh pc _ cap _ write _ config ( d , ▁address , ▁val , ▁len ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁ram _ addr _ t ▁find _ ram _ offset ( ram _ addr _ t ▁size ) ▁{ ▁RAM Block ▁* block , ▁* next _ block ; ▁ram _ addr _ t ▁offset ▁= ▁RAM _ ADDR _ MAX , ▁m ing ap ▁= ▁RAM _ ADDR _ MAX ; ▁assert ( size ▁!= ▁0); ▁/* ▁it ▁would ▁hand ▁out ▁same ▁offset ▁multiple ▁times ▁*/ ▁if ▁( Q TAIL Q _ EMPTY ( & ram _ list . blocks )) ▁return ▁0; ▁Q TAIL Q _ FORE A CH ( block , ▁& ram _ list . blocks , ▁next ) ▁{ ▁ram _ addr _ t ▁end , ▁next ▁= ▁RAM _ ADDR _ MAX ; ▁end ▁= ▁block -> offset ▁+ ▁block -> length ; ▁Q

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Char Driver State ▁* q emu _ chr _ alloc ( void ) ▁{ ▁Char Driver State ▁* chr ▁= ▁g _ m alloc 0( size of ( Char Driver State )); ▁qemu _ mut ex _ init ( & chr -> chr _ write _ lock ); ▁return ▁chr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ disk _ em ulate _ command ( SC S ID isk Req ▁* r , ▁uint 8_ t ▁* out buf ) ▁{ ▁SC SI Request ▁* req ▁= ▁& r -> req ; ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁req -> dev ); ▁uint 64_ t ▁nb _ sect ors ; ▁int ▁buf len ▁= ▁0; ▁int ▁ret ; ▁switch ▁( req -> cmd . buf [0]) ▁{ ▁case ▁TEST _ UNIT _ READY : ▁if ▁(! b dr v _ is _ insert ed ( s -> bs )) ▁goto ▁not _ ready ; ▁break ; ▁case ▁REQUEST _ SE NSE : ▁if ▁( req -> cmd . x fer ▁< ▁4) ▁goto ▁illegal _ reques

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁flush _ queued _ work ( CPU State ▁* cpu ) ▁{ ▁struct ▁qemu _ work _ item ▁* wi ; ▁if ▁( cpu -> queued _ work _ first ▁== ▁NULL ) ▁{ ▁return ; ▁} ▁while ▁(( wi ▁= ▁cpu -> queued _ work _ first )) ▁{ ▁cpu -> queued _ work _ first ▁= ▁wi -> next ; ▁wi -> func ( wi -> data ); ▁wi -> done ▁= ▁true ; ▁if ▁( wi -> free ) ▁{ ▁g _ free ( wi ); ▁} ▁} ▁cpu -> queued _ work _ last ▁= ▁NULL ; ▁qemu _ cond _ broadcast ( & q emu _ work _ cond ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁validate _ guest _ space ( un signed ▁long ▁guest _ base , ▁unsigned ▁long ▁guest _ size ) ▁{ ▁unsigned ▁long ▁real _ start , ▁test _ page _ addr ; ▁/* ▁We ▁need ▁to ▁check ▁that ▁we ▁can ▁force ▁a ▁fault ▁on ▁access ▁to ▁the ▁* ▁comm page ▁at ▁0 xffff 0 f xx ▁*/ ▁test _ page _ addr ▁= ▁guest _ base ▁+ ▁(0 xffff 0 f 00 ▁& ▁qemu _ host _ page _ mask ); ▁/* ▁If ▁the ▁comm page ▁lies ▁within ▁the ▁already ▁allocated ▁guest ▁space , ▁* ▁then ▁there ▁is ▁no ▁way ▁we ▁can ▁allocate ▁it . ▁*/ ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁long ▁do _ sig return ( CP UC RI S State ▁* env ) ▁{ ▁struct ▁target _ signal _ frame ▁* frame ; ▁abi _ ulong ▁frame _ addr ; ▁target _ sig set _ t ▁target _ set ; ▁sig set _ t ▁set ; ▁int ▁i ; ▁frame _ addr ▁= ▁env -> re gs [ R _ SP ]; ▁/* ▁Make ▁sure ▁the ▁guest ▁isn ' t ▁playing ▁games . ▁*/ ▁if ▁(! lock _ user _ struct ( VER IFY _ WRITE , ▁frame , ▁frame _ addr , ▁1)) ▁goto ▁bad frame ; ▁/* ▁Restore ▁blocked ▁signals ▁*/ ▁if ▁( __ get _ user ( target _ set . sig [0], ▁& frame -> sc . old mask )) ▁got

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb re dir _ interrupt _ packet ( void ▁* priv , ▁uint 32_ t ▁id , ▁struct ▁usb _ re dir _ interrupt _ packet _ header ▁* interrupt _ packet , ▁uint 8_ t ▁* data , ▁int ▁data _ len ) ▁{ ▁USB Red ir Device ▁* dev ▁= ▁priv ; ▁uint 8_ t ▁ep ▁= ▁interrupt _ packet -> endpoint ; ▁D PRI NT F (" interrupt - in ▁status ▁% d ▁ep ▁%02 X ▁len ▁% d ▁id ▁% u \ n ", ▁interrupt _ packet -> status , ▁ep , ▁data _ len , ▁id ); ▁if ▁( dev -> endpoint [ EP 2 I ( ep ) ]. type ▁!= ▁USB _ ENDPOINT _ X FER _ INT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁m peg 1_ encode _ mb ( M peg Enc Context ▁* s , ▁D CT E LE M ▁block [6 ][ 64 ], ▁int ▁motion _ x , ▁int ▁motion _ y ) ▁{ ▁int ▁i , ▁cb p ; ▁const ▁int ▁mb _ x ▁= ▁s -> mb _ x ; ▁const ▁int ▁mb _ y ▁= ▁s -> mb _ y ; ▁const ▁int ▁first _ mb = ▁mb _ x ▁== ▁s -> res ync _ mb _ x ▁&& ▁mb _ y ▁== ▁s -> res ync _ mb _ y ; ▁/* ▁compute ▁cb p ▁*/ ▁cb p ▁= ▁0; ▁for ( i =0; i < 6 ; i ++) ▁{ ▁if ▁( s -> block _ last _ index [ i ] ▁>= ▁0) ▁cb p ▁|= ▁1 ▁<< ▁(5 ▁- ▁i ); ▁} ▁if ▁( cb p ▁== ▁0 ▁&& ▁! first _ mb ▁&&

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ cc w _ device _ real ize ( V irt io C cw Device ▁* dev , ▁Error ▁** err p ) ▁{ ▁unsigned ▁int ▁css id ▁= ▁0; ▁unsigned ▁int ▁ssid ▁= ▁0; ▁unsigned ▁int ▁sch id ; ▁unsigned ▁int ▁dev no ; ▁bool ▁have _ dev no ▁= ▁false ; ▁bool ▁found ▁= ▁false ; ▁Sub ch Dev ▁* sch ; ▁int ▁num ; ▁Device State ▁* parent ▁= ▁DEVICE ( dev ); ▁Error ▁* err ▁= ▁NULL ; ▁V irt IO CC W Device Class ▁* k ▁= ▁VI RT IO _ CC W _ DEVICE _ GET _ CLASS ( dev ); ▁V irt IO Device ▁* v dev ; ▁sch ▁= ▁g _ m alloc 0( s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁op _ cp 1_ regist ers ( void ) ▁{ ▁if ▁(! ( env -> CP 0_ Status ▁& ▁(1 ▁<< ▁CP 0 St _ FR )) ▁&& ▁( PARAM 1 ▁& ▁1)) ▁{ ▁CALL _ FROM _ TB 1( do _ raise _ exception , ▁EX CP _ RI ); ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( rgb 24 to b gr 24 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁long ▁src _ size ) ▁{ ▁unsigned ▁i ; ▁# if def ▁HAVE _ MM X ▁long ▁mm x _ size = ▁23 ▁- ▁src _ size ; ▁asm ▁volatile ▁( ▁" test ▁% %" REG _ a ", ▁% %" REG _ a " ▁\ n \ t " ▁" j ns ▁2 f ▁\ n \ t " ▁" mov q ▁" M ANG LE ( mask 24 r )", ▁%% mm 5 ▁\ n \ t " ▁" mov q ▁" M ANG LE ( mask 24 g )", ▁%% mm 6 ▁\ n \ t " ▁" mov q ▁" M ANG LE ( mask 24 b )", ▁%% mm 7 ▁\ n \ t " ▁AS M ALIGN (4) ▁" 1: ▁\ n \ t " ▁PREF ETC

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v da _ h 2 64_ end _ frame ( AV Codec Context ▁* av ctx ) ▁{ ▁H 264 Context ▁* h ▁= ▁av ctx -> priv _ data ; ▁struct ▁v da _ context ▁* v da _ ctx ▁= ▁av ctx -> hw accel _ context ; ▁AV Frame ▁* frame ▁= ▁& h -> cur _ pic _ ptr -> f ; ▁struct ▁v da _ buffer ▁* context ; ▁AV Buffer Ref ▁* buffer ; ▁int ▁status ; ▁if ▁(! v da _ ctx -> decoder ▁|| ▁! v da _ ctx -> priv _ bit stream ) ▁status ▁= ▁v da _ sync _ decode ( v da _ ctx ); ▁frame -> data [3] ▁= ▁( void *) v da _ ctx -> cv _ buffer ; ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁H 264 Context ▁* h ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁int ▁buf _ index ▁= ▁0; ▁Picture ▁* out ; ▁int ▁i , ▁out _ idx ; ▁int ▁ret ; ▁h -> flags ▁= ▁av ctx -> flags ; ▁/* ▁end ▁of ▁stream , ▁output ▁what ▁is ▁still ▁in ▁the ▁buffers ▁*/ ▁if ▁( buf _ size ▁== ▁0) ▁{ ▁out : ▁h 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁G IO Status ▁ga _ channel _ write _ all ( GA Channel ▁* c , ▁const ▁char ▁* buf , ▁size _ t ▁size ) ▁{ ▁G IO Status ▁status ▁= ▁G _ IO _ STATUS _ NORMAL ; ▁size _ t ▁count ; ▁while ▁( size ) ▁{ ▁status ▁= ▁ga _ channel _ write ( c , ▁buf , ▁size , ▁& count ); ▁if ▁( status ▁== ▁G _ IO _ STATUS _ NORMAL ) ▁{ ▁size ▁-= ▁count ; ▁buf ▁+= ▁count ; ▁} ▁else ▁if ▁( status ▁!= ▁G _ IO _ STATUS _ AG AIN ) ▁{ ▁break ; ▁} ▁} ▁return ▁status ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁channel map _ query _ formats ( AV Filter Context ▁* ctx ) ▁{ ▁Channel Map Context ▁* s ▁= ▁ctx -> priv ; ▁ff _ set _ common _ formats ( ctx , ▁ff _ plan ar _ sample _ fmt s ()); ▁ff _ set _ common _ s ampler ates ( ctx , ▁ff _ all _ s ampler ates ()); ▁ff _ channel _ layout s _ ref ( ff _ all _ channel _ layout s (), ▁& ctx -> inputs [0] -> out _ channel _ layout s ); ▁ff _ channel _ layout s _ ref ( s -> channel _ layout s , ▁& ctx -> outputs [0] -> in _ channel _ layout s ); ▁return ▁0; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁flush _ queued _ work ( CPU State ▁* env ) ▁{ ▁struct ▁qemu _ work _ item ▁* wi ; ▁if ▁(! env -> queued _ work _ first ) ▁return ; ▁while ▁(( wi ▁= ▁env -> queued _ work _ first )) ▁{ ▁env -> queued _ work _ first ▁= ▁wi -> next ; ▁wi -> func ( wi -> data ); ▁wi -> done ▁= ▁true ; ▁} ▁env -> queued _ work _ last ▁= ▁NULL ; ▁qemu _ cond _ broadcast ( & q emu _ work _ cond ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁add _ a io _ request ( B DR V Sh eep dog State ▁* s , ▁A IO Req ▁* a io _ req , ▁struct ▁i ove c ▁* io v , ▁int ▁nio v , ▁bool ▁create , ▁enum ▁A IO CB State ▁ai oc b _ type ) ▁{ ▁int ▁nr _ cop ies ▁= ▁s -> in ode . nr _ cop ies ; ▁Sh eep dog Obj Req ▁hdr ; ▁unsigned ▁int ▁w len ; ▁int ▁ret ; ▁uint 64_ t ▁oid ▁= ▁aio _ req -> oid ; ▁unsigned ▁int ▁dat al en ▁= ▁aio _ req -> data _ len ; ▁uint 64_ t ▁offset ▁= ▁aio _ req -> offset ; ▁uint 8_ t ▁flags ▁= ▁aio _ req -> flags ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁img _ write _ packet ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁U INT 8 ▁* buf , ▁int ▁size ) ▁{ ▁Video Data ▁* img ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st ▁= ▁s -> streams [ stream _ index ]; ▁Byte IO Context ▁pb 1, ▁* pb ; ▁AV Picture ▁picture ; ▁int ▁width , ▁height , ▁ret , ▁size 1; ▁char ▁filename [10 24 ]; ▁width ▁= ▁st -> codec . width ; ▁height ▁= ▁st -> codec . height ; ▁switch ( st -> codec . pix _ fmt ) ▁{ ▁case ▁PI X _ F MT _ Y UV 4 20 P : ▁size 1 ▁= ▁( width ▁* ▁height ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁pci _ drive _ hot _ add ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict , ▁Drive Info ▁* d info ) ▁{ ▁/* ▁On ▁non - x 86 ▁we ▁don ' t ▁do ▁P CI ▁hot plug ▁*/ ▁monitor _ printf ( mon , ▁" Can ' t ▁hot - add ▁drive ▁to ▁type ▁% d \ n ", ▁d info -> type ); ▁return ▁-1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁y v 12 to y uy 2_ un scaled _ alt ive c ( Sw s Context ▁* c , ▁uint 8_ t * ▁src [], ▁int ▁src Stride [], ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁uint 8_ t * ▁dst Param [], ▁int ▁dst Stride _ a []) ▁{ ▁uint 8_ t ▁* dst = dst Param [0] ▁+ ▁dst Stride _ a [0] * src Slice Y ; ▁// ▁y v 12 to y uy 2( ▁src [0], src [1], src [2], dst , c -> src W , src Slice H , src Stride [0], src Stride [1], dst Stride [0] ▁); ▁uint 8_ t ▁* ys rc ▁= ▁src [0]; ▁uint 8_ t ▁* us rc ▁= ▁src [1]; ▁uint 8_ t ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ loop ( CPU Alpha State ▁* env ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( alpha _ env _ get _ cpu ( env )); ▁int ▁tra pn r ; ▁target _ sig info _ t ▁info ; ▁abi _ long ▁sys ret ; ▁while ▁(1) ▁{ ▁cpu _ exec _ start ( cs ); ▁tra pn r ▁= ▁cpu _ alpha _ exec ( cs ); ▁cpu _ exec _ end ( cs ); ▁/* ▁All ▁of ▁the ▁tra ps ▁imply ▁a ▁transition ▁through ▁P AL code , ▁which ▁implies ▁an ▁RE I ▁instruction ▁has ▁been ▁executed . ▁Which ▁means ▁that ▁the ▁intr _ flag ▁should ▁be ▁cleared . ▁*/ ▁env -> in tr _ flag ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁S 390 PC I Bus Device ▁* s 39 0_ pc i _ find _ dev _ by _ target ( const ▁char ▁* target ) ▁{ ▁int ▁i ; ▁S 390 PC I Bus Device ▁* pb dev ; ▁S 390 pc i State ▁* s ▁= ▁s 39 0_ get _ ph b (); ▁if ▁(! target ) ▁{ ▁return ▁NULL ; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁P CI _ SL OT _ MAX ; ▁i ++) ▁{ ▁pb dev ▁= ▁s -> pb dev [ i ]; ▁if ▁(! pb dev ) ▁{ ▁continue ; ▁} ▁if ▁(! str cmp ( pb dev -> target , ▁target )) ▁{ ▁return ▁pb dev ; ▁} ▁} ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁c in _ decode _ l z ss ( const ▁unsigned ▁char ▁* src , ▁int ▁src _ size , ▁unsigned ▁char ▁* dst , ▁int ▁dst _ size ) ▁{ ▁uint 16_ t ▁cmd ; ▁int ▁i , ▁sz , ▁offset , ▁code ; ▁unsigned ▁char ▁* dst _ end ▁= ▁dst ▁+ ▁dst _ size ; ▁const ▁unsigned ▁char ▁* src _ end ▁= ▁src ▁+ ▁src _ size ; ▁while ▁( src ▁< ▁src _ end ▁&& ▁dst ▁< ▁dst _ end ) ▁{ ▁code ▁= ▁* src ++; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ▁&& ▁src ▁< ▁src _ end ▁&& ▁dst ▁< ▁dst _ end ; ▁++ i ) ▁{ ▁if ▁( code ▁& ▁(1 ▁<< ▁i )) ▁{ ▁* dst ++ ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ff _ r dt _ parse _ open ( AV Format Context ▁* ic , ▁int ▁first _ stream _ of _ set _ idx , ▁void ▁* priv _ data , ▁R TP Dynamic Protocol Handler ▁* handler ) ▁{ ▁R DTD em ux Context ▁* s ▁= ▁av _ m alloc z ( size of ( R DTD em ux Context )); ▁if ▁(! s ) ▁return ▁NULL ; ▁s -> ic ▁= ▁ic ; ▁s -> streams ▁= ▁& ic -> streams [ first _ stream _ of _ set _ idx ]; ▁do ▁{ ▁s -> n _ streams ++; ▁} ▁while ▁( first _ stream _ of _ set _ idx ▁+ ▁s -> n _ streams ▁< ▁ic -> nb _ streams ▁&& ▁s -> streams [ s -> n _ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ co _ write v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁remaining _ sect ors , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁index _ in _ cluster ; ▁int ▁n _ end ; ▁int ▁ret ; ▁int ▁cur _ nr _ sect ors ; ▁/* ▁number ▁of ▁sector s ▁in ▁current ▁iteration ▁*/ ▁Q C ow L 2 Meta ▁l 2 meta ; ▁uint 64_ t ▁cluster _ offset ; ▁Q EM UI O Vector ▁hd _ q io v ; ▁uint 64_ t ▁bytes _ done ▁= ▁0; ▁uint 8_ t ▁* cluster _ data ▁= ▁NULL ; ▁l 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v host _ dev _ init ( struct ▁v host _ dev ▁* h dev , ▁void ▁* op aque , ▁V host Backend Type ▁backend _ type , ▁bool ▁force ) ▁{ ▁uint 64_ t ▁features ; ▁int ▁i , ▁r ; ▁if ▁( v host _ set _ backend _ type ( h dev , ▁backend _ type ) ▁< ▁0) ▁{ ▁close (( uint ptr _ t ) op aque ); ▁return ▁-1; ▁} ▁if ▁( h dev -> v host _ ops -> v host _ backend _ init ( h dev , ▁opaque ) ▁< ▁0) ▁{ ▁close (( uint ptr _ t ) op aque ); ▁return ▁- err no ; ▁} ▁r ▁= ▁h dev -> v host _ ops -> v host _ call ( h dev , ▁V HOST

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ set _ system atic _ pal 2( uint 32_ t ▁pal [ 256 ], ▁enum ▁AV Pixel Format ▁pix _ fmt ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁256 ; ▁i ++) ▁{ ▁int ▁r , ▁g , ▁b ; ▁switch ▁( pix _ fmt ) ▁{ ▁case ▁AV _ PI X _ F MT _ RGB 8: ▁r ▁= ▁( i >> 5 ▁) * 36 ; ▁g ▁= ▁(( i >> 2) & 7) * 36 ; ▁b ▁= ▁( i & 3 ▁) * 85 ; ▁break ; ▁case ▁AV _ PI X _ F MT _ B GR 8: ▁b ▁= ▁( i >> 6 ▁) * 85 ; ▁g ▁= ▁(( i >> 3) & 7) * 36 ; ▁r ▁= ▁( i & 7 ▁) * 36 ; ▁break ; ▁case ▁AV _ PI X _ F MT _ RGB 4_ BYTE : ▁r ▁= ▁( i >> 3 ▁) * 255 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ transaction ( Transaction Action List ▁* dev _ list , ▁Error ▁** err p ) ▁{ ▁Transaction Action List ▁* dev _ entry ▁= ▁dev _ list ; ▁Bl k Transaction State ▁* state , ▁* next ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁Q SI MPLE Q _ HEAD ( snap _ b dr v _ states , ▁Bl k Transaction State ) ▁snap _ b dr v _ states ; ▁Q SI MPLE Q _ INIT ( & snap _ b dr v _ states ); ▁/* ▁drain ▁all ▁i / o ▁before ▁any ▁operations ▁*/ ▁b dr v _ d rain _ all (); ▁/* ▁We ▁don ' t ▁do ▁anything ▁in ▁this ▁loop ▁that ▁com

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁intel _ h da _ init ( PC ID evice ▁* pc i ) ▁{ ▁Intel H DA State ▁* d ▁= ▁DO _ UP CAST ( Int el H DA State , ▁pci , ▁pci ); ▁uint 8_ t ▁* conf ▁= ▁d -> pc i . config ; ▁d -> name ▁= ▁d -> pc i . q dev . info -> name ; ▁pci _ config _ set _ vendor _ id ( conf , ▁P CI _ VE ND OR _ ID _ INT EL ); ▁pci _ config _ set _ device _ id ( conf , ▁0 x 26 68 ); ▁pci _ config _ set _ revision ( conf , ▁1); ▁pci _ config _ set _ class ( conf , ▁P CI _ CLASS _ MULT IME DI A _ HD _ AU DIO ); ▁pci _ config _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block Driver A IO CB ▁* raw _ a io _ write v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁Raw A IO CB ▁* ac b ; ▁ac b ▁= ▁raw _ a io _ setup ( bs , ▁sector _ num , ▁q io v , ▁nb _ sect ors , ▁cb , ▁opaque ); ▁if ▁(! ac b ) ▁return ▁NULL ; ▁if ▁( q emu _ pa io _ write ( & ac b -> ai oc b ) ▁< ▁0) ▁{ ▁raw _ a io _ remove ( ac b ); ▁return ▁NULL ; ▁} ▁return ▁& ac b -> common ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁pred _ direct _ m otion ( H 264 Context ▁* ▁const ▁h , ▁int ▁* mb _ type ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁const ▁int ▁mb _ xy ▁= ▁s -> mb _ x ▁+ ▁s -> mb _ y * s -> mb _ stride ; ▁const ▁int ▁b 8_ xy ▁= ▁2* s -> mb _ x ▁+ ▁2* s -> mb _ y * h -> b 8_ stride ; ▁const ▁int ▁b 4_ xy ▁= ▁4 * s -> mb _ x ▁+ ▁4 * s -> mb _ y * h -> b _ stride ; ▁const ▁int ▁mb _ type _ col ▁= ▁h -> ref _ list [1] [0]. mb _ type [ mb _ xy ]; ▁const ▁int 16_ t ▁(* l 1 mv 0) [2] ▁= ▁( const 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁uint 32_ t ▁insn _ get ( CPU X 86 State ▁* env , ▁Dis as Context ▁* s , ▁TC G Mem Op ▁ot ) ▁{ ▁uint 32_ t ▁ret ; ▁switch ▁( ot ) ▁{ ▁case ▁MO _8 : ▁ret ▁= ▁cpu _ ld ub _ code ( env , ▁s -> pc ); ▁s -> pc ++; ▁break ; ▁case ▁MO _16 : ▁ret ▁= ▁cpu _ ld u w _ code ( env , ▁s -> pc ); ▁s -> pc ▁+= ▁2; ▁break ; ▁case ▁MO _32 : ▁# if def ▁TARGET _ X 86_64 ▁case ▁MO _64 : ▁# end if ▁ret ▁= ▁cpu _ ld l _ code ( env , ▁s -> pc ); ▁s -> pc ▁+= ▁4; ▁break ; ▁default : ▁tc g _ abort (); ▁} ▁return ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ th rottle _ write _ timer _ cb ( void ▁* op aque ) ▁{ ▁Block Driver State ▁* bs ▁= ▁opaque ; ▁qemu _ co _ enter _ next ( & bs -> th rott led _ reqs [1]); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁find _ pt e 32 ( CP UP PC State ▁* env , ▁mm u _ ctx _ t ▁* ctx , ▁int ▁h , ▁int ▁rw , ▁int ▁type , ▁int ▁target _ page _ bits ) ▁{ ▁hw addr ▁pt eg _ off ; ▁target _ ulong ▁p te 0, ▁p te 1; ▁int ▁i , ▁good ▁= ▁-1; ▁int ▁ret , ▁r ; ▁ret ▁= ▁-1; ▁/* ▁No ▁entry ▁found ▁*/ ▁pt eg _ off ▁= ▁get _ pt eg _ offset ( env , ▁ctx -> hash [ h ], ▁HASH _ P TE _ SIZE _32 ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁{ ▁if ▁( env -> external _ ht ab ) ▁{ ▁p te 0 ▁= ▁ld l _ p ( env -> external _ ht ab ▁+ ▁pt eg _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ put _ x cr s ( CPU State ▁* env ) ▁{ ▁# if def ▁K VM _ CAP _ X C RS ▁struct ▁k vm _ x cr s ▁x cr s ; ▁if ▁(! k vm _ has _ x cr s ()) ▁return ▁0; ▁x cr s . nr _ x cr s ▁= ▁1; ▁x cr s . flags ▁= ▁0; ▁x cr s . x cr s [0]. x cr ▁= ▁0; ▁x cr s . x cr s [0]. value ▁= ▁env -> x cr 0; ▁return ▁k vm _ vc pu _ io ctl ( env , ▁K VM _ SET _ X C RS , ▁& x cr s ); ▁# else ▁return ▁0; ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Exit Status ▁gen _ b cond _ internal ( Dis as Context ▁* ctx , ▁TC G Cond ▁cond , ▁TC G v ▁cmp , ▁int 32_ t ▁disp ) ▁{ ▁uint 64_ t ▁dest ▁= ▁ctx -> pc ▁+ ▁( dis p ▁<< ▁2); ▁int ▁lab _ true ▁= ▁gen _ new _ label (); ▁if ▁( use _ goto _ tb ( ctx , ▁dest )) ▁{ ▁tc g _ gen _ br con di _ i 64 ( cond , ▁cmp , ▁0, ▁lab _ true ); ▁tc g _ gen _ goto _ tb (0); ▁tc g _ gen _ mov i _ i 64 ( cpu _ pc , ▁ctx -> pc ); ▁tc g _ gen _ exit _ tb (( uint ptr _ t ) ctx -> tb ); ▁gen _ set _ label ( lab _ true ); ▁tc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁gt 64 12 0_ read _ config ( PC ID evice ▁* d , ▁uint 32_ t ▁address , ▁int ▁len ) ▁{ ▁uint 32_ t ▁val ▁= ▁pci _ default _ read _ config ( d , ▁address , ▁len ); ▁# if def ▁TARGET _ WORDS _ B IG ENDIAN ▁val ▁= ▁b swap 32 ( val ); ▁# end if ▁return ▁val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt as _ get _ time _ of _ day ( Power PC CPU ▁* cpu , ▁s P AP R Environment ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁struct ▁tm ▁tm ; ▁if ▁( n ret ▁!= ▁8) ▁{ ▁rt as _ st ( ret s , ▁0, ▁RT AS _ OUT _ PARAM _ ERROR ); ▁return ; ▁} ▁qemu _ get _ tim ed ate ( & tm , ▁sp ap r -> rt c _ offset ); ▁rt as _ st ( ret s , ▁0, ▁RT AS _ OUT _ SUCCESS ); ▁rt as _ st ( ret s , ▁1, ▁tm . tm _ year ▁+ ▁1900 ); ▁rt as _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ block _ job _ set _ speed ( const ▁char ▁* device , ▁int 64_ t ▁speed , ▁Error ▁** err p ) ▁{ ▁Block Job ▁* job ▁= ▁find _ block _ job ( device ); ▁if ▁(! job ) ▁{ ▁error _ set ( err p , ▁Q ERR _ BLOCK _ JOB _ NOT _ ACTIVE , ▁device ); ▁return ; ▁} ▁block _ job _ set _ speed ( job , ▁speed , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁create _ stream ( AV Format Context ▁* s ) ▁{ ▁X CB Grab Context ▁* c ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st ▁= ▁av format _ new _ stream ( s , ▁NULL ); ▁x cb _ get _ geometry _ cookie _ t ▁gc ; ▁x cb _ get _ geometry _ reply _ t ▁* geo ; ▁int ▁ret ; ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁ret ▁= ▁av _ parse _ video _ size ( & c -> width , ▁& c -> height , ▁c -> video _ size ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁ret ▁= ▁av _ parse _ video _ rate ( & st -> avg _ frame _ rate , ▁c -> f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v orb is _ parse _ setup _ hdr _ code books ( vor b is _ context ▁* vc ) ▁{ ▁unsigned ▁cb ; ▁uint 8_ t ▁* tmp _ vlc _ bits ; ▁uint 32_ t ▁* tmp _ vlc _ codes ; ▁Get Bit Context ▁* gb ▁= ▁& vc -> gb ; ▁uint 16_ t ▁* code book _ multip lic ands ; ▁int ▁ret ▁= ▁0; ▁vc -> code book _ count ▁= ▁get _ bits ( gb , ▁8) ▁+ ▁1; ▁av _ d log ( NULL , ▁" ▁Code books : ▁% d ▁\ n ", ▁vc -> code book _ count ); ▁vc -> code books ▁= ▁av _ m alloc z ( vc -> code book _ count ▁* ▁sizeof (* vc -> code books ));

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ht ab _ save _ later _ pass ( Q EM U File ▁* f , ▁s P AP R Environment ▁* sp ap r , ▁int 64_ t ▁max _ ns ) ▁{ ▁bool ▁final ▁= ▁max _ ns ▁< ▁0; ▁int ▁ht ab slots ▁= ▁HT AB _ SIZE ( sp ap r ) ▁/ ▁HASH _ P TE _ SIZE _64 ; ▁int ▁exam ined ▁= ▁0, ▁sent ▁= ▁0; ▁int ▁index ▁= ▁sp ap r -> ht ab _ save _ index ; ▁int 64_ t ▁starttime ▁= ▁qemu _ clock _ get _ ns ( Q EM U _ C LOCK _ RE AL TIME ); ▁assert (! sp ap r -> ht ab _ first _ pass ); ▁do ▁{ ▁int ▁chunk start , ▁invalid start ; ▁/* ▁Consume ▁non

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁abi _ long ▁do _ socket ( int ▁domain , ▁int ▁type , ▁int ▁protocol ) ▁{ ▁int ▁target _ type ▁= ▁type ; ▁int ▁ret ; ▁ret ▁= ▁target _ to _ host _ sock _ type ( & type ); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁if ▁( domain ▁== ▁P F _ NET LINK ) ▁return ▁- TARGET _ E AF NO SUP PORT ; ▁if ▁( domain ▁== ▁AF _ PA CKET ▁|| ▁( domain ▁== ▁AF _ INET ▁&& ▁type ▁== ▁SOCK _ PA CKET )) ▁{ ▁protocol ▁= ▁t swap 16 ( protocol ); ▁} ▁ret ▁= ▁get _ err no ( socket ( domain , ▁type , ▁protocol )); ▁if ▁( ret ▁>= ▁0) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm pp c _ get _ hyper call ( CP UP PC State ▁* env , ▁uint 8_ t ▁* buf , ▁int ▁buf _ len ) ▁{ ▁Power PC CPU ▁* cpu ▁= ▁p pc _ env _ get _ cpu ( env ); ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁uint 32_ t ▁* hc ▁= ▁( uint 32_ t *) buf ; ▁struct ▁k vm _ pp c _ pv info ▁pv info ; ▁if ▁( k vm _ check _ extension ( cs -> k vm _ state , ▁K VM _ CAP _ P PC _ GET _ P V INFO ) ▁&& ▁! k vm _ vm _ io ctl ( cs -> k vm _ state , ▁K VM _ P PC _ GET _ P V INFO , ▁& pv info )) ▁{ ▁mem c py ( buf , ▁pv info . h call , ▁b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁process _ incoming _ migration ( Q EM U File ▁* f ) ▁{ ▁if ▁( q emu _ load vm _ state ( f ) ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" load ▁of ▁migration ▁failed \ n "); ▁exit (0); ▁} ▁qemu _ ann ounce _ self (); ▁D PRI NT F (" successfully ▁loaded ▁vm ▁state \ n "); ▁incoming _ expected ▁= ▁false ; ▁if ▁( aut ost art ) ▁{ ▁vm _ start (); ▁} ▁else ▁{ ▁run state _ set ( R STATE _ PRE _ LA UNCH ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rv 40 _ decode _ mb _ info ( RV 34 Dec Context ▁* r ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& r -> s ; ▁Get Bit Context ▁* gb ▁= ▁& s -> gb ; ▁int ▁q , ▁i ; ▁int ▁prev _ type ▁= ▁0; ▁int ▁mb _ pos ▁= ▁s -> mb _ x ▁+ ▁s -> mb _ y ▁* ▁s -> mb _ stride ; ▁int ▁blocks [ RV 34 _ MB _ TYPES ] ▁= ▁{0 }; ▁int ▁count ▁= ▁0; ▁if (! r -> s . mb _ skip _ run ) ▁r -> s . mb _ skip _ run ▁= ▁sv q 3_ get _ ue _ g ol omb ( gb ) ▁+ ▁1; ▁if ( -- r -> s . mb _ skip _ run ) ▁return ▁R V 34 _ MB _ SK IP ; ▁if ( r -> av

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y v u 9_ to _ y uy 2) ( const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁const ▁uint 8_ t ▁* src 3, ▁uint 8_ t ▁* dst , ▁long ▁width , ▁long ▁height , ▁long ▁src Stride 1, ▁long ▁src Stride 2, ▁long ▁src Stride 3, ▁long ▁dst Stride ) ▁{ ▁x 86_ reg ▁x ; ▁long ▁y , w , h ; ▁w = width /2 ; ▁h = height ; ▁for ▁( y =0; y < h ; y ++) ▁{ ▁const ▁uint 8_ t * ▁y p = src 1+ src Stride 1 * y ; ▁const ▁uint 8_ t * ▁up = src 2 + src Stride 2 *( y >> 2); ▁const ▁uint 8_ t * ▁vp =

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁PC M Decode ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁sample _ size , ▁c , ▁n , ▁i ; ▁uint 8_ t ▁* samples ; ▁const ▁uint 8_ t ▁* src , ▁* src 8, ▁* src 2[ MAX _ CH AN NE LS ]; ▁int 32_ t ▁* dst _ int 32_ t ; ▁samples ▁= ▁data ; ▁src ▁= ▁buf ; ▁if ▁( av ctx -> sample _ fmt != av ctx -> codec -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ present ation _ segment ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁int 64_ t ▁pts ) ▁{ ▁PG SS ub Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁int ▁x , ▁y , ▁ret ; ▁int ▁w ▁= ▁by test ream _ get _ be 16 ( & buf ); ▁int ▁h ▁= ▁by test ream _ get _ be 16 ( & buf ); ▁ctx -> present ation . pts ▁= ▁pts ; ▁av _ d log ( av ctx , ▁" Video ▁Dim ensions ▁% dx % d \ n ", ▁w , ▁h ); ▁ret ▁= ▁ff _ set _ dimensions ( av ctx , ▁w , ▁h ); ▁if ▁( ret ▁< ▁0) ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ cor outine _ delete ( Cor outine ▁* co _ ) ▁{ ▁Cor outine Thread State ▁* s ▁= ▁coroutine _ get _ thread _ state (); ▁Cor outine U Context ▁* co ▁= ▁DO _ UP CAST ( Cor outine U Context , ▁base , ▁co _ ); ▁if ▁( s -> pool _ size ▁< ▁PO OL _ MAX _ SIZE ) ▁{ ▁Q LIST _ INSERT _ HEAD ( & s -> pool , ▁& co -> base , ▁pool _ next ); ▁co -> base . caller ▁= ▁NULL ; ▁s -> pool _ size ++; ▁return ; ▁} ▁g _ free ( co -> stack ); ▁g _ free ( co ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁float 64_ eq _ signal ing ( ▁float 64 ▁a , ▁float 64 ▁b ▁STATUS _ PARAM ▁) ▁{ ▁if ▁( ▁( ▁( ▁extract Float 64 Exp ( ▁a ▁) ▁== ▁0 x 7 FF ▁) ▁&& ▁extract Float 64 F rac ( ▁a ▁) ▁) ▁|| ▁( ▁( ▁extract Float 64 Exp ( ▁b ▁) ▁== ▁0 x 7 FF ▁) ▁&& ▁extract Float 64 F rac ( ▁b ▁) ▁) ▁) ▁{ ▁float _ raise ( ▁float _ flag _ invalid ▁STATUS _ VAR ); ▁return ▁0; ▁} ▁return ▁( ▁a ▁== ▁b ▁) ▁|| ▁( ▁( bits 64) ▁( ▁( ▁a ▁| ▁b ▁) << 1 ▁) ▁== ▁0 ▁); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁t pm _ pas sthrough _ unix _ tx _ buf s ( int ▁t pm _ fd , ▁const ▁uint 8_ t ▁* in , ▁uint 32_ t ▁in _ len , ▁uint 8_ t ▁* out , ▁uint 32_ t ▁out _ len ) ▁{ ▁int ▁ret ; ▁ret ▁= ▁t pm _ pas sthrough _ unix _ write ( tp m _ fd , ▁in , ▁in _ len ); ▁if ▁( ret ▁!= ▁in _ len ) ▁{ ▁error _ report (" tp m _ pas sthrough : ▁error ▁while ▁transmit ting ▁data ▁" ▁" to ▁T PM : ▁% s ▁( % i )\ n ", ▁strerror ( err no ), ▁errno ); ▁goto ▁err _ exit ; ▁} ▁ret ▁= ▁t pm _ pas sthrough _ unix _ read ( tp m _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ memory _ rw _ debug ( CPU Arch State ▁* env , ▁target _ ulong ▁addr , ▁uint 8_ t ▁* buf , ▁int ▁len , ▁int ▁is _ write ) ▁{ ▁int ▁l ; ▁target _ ph ys _ addr _ t ▁phys _ addr ; ▁target _ ulong ▁page ; ▁while ▁( len ▁> ▁0) ▁{ ▁page ▁= ▁addr ▁& ▁TARGET _ PAGE _ MASK ; ▁phys _ addr ▁= ▁cpu _ get _ ph ys _ page _ debug ( env , ▁page ); ▁/* ▁if ▁no ▁physical ▁page ▁mapped , ▁return ▁an ▁error ▁*/ ▁if ▁( ph ys _ addr ▁== ▁-1) ▁return ▁-1; ▁l ▁= ▁( page ▁+ ▁TARGET _ PAGE _ SIZE ) ▁- ▁addr ; ▁if ▁( l ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ u wire _ s ▁* om ap _ u wire _ init ( Memory Region ▁* system _ memory , ▁target _ ph ys _ addr _ t ▁base , ▁qemu _ irq ▁* irq , ▁qemu _ irq ▁d ma , ▁o map _ cl k ▁cl k ) ▁{ ▁struct ▁o map _ u wire _ s ▁* s ▁= ▁( struct ▁o map _ u wire _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ u wire _ s )); ▁s -> tx irq ▁= ▁irq [0]; ▁s -> rx irq ▁= ▁irq [1]; ▁s -> tx dr q ▁= ▁d ma ; ▁o map _ u wire _ reset ( s ); ▁memory _ region _ init _ io ( & s -> iom em , ▁& om ap _ u wire _ ops , ▁s , ▁" om

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁send _ sub _ rect ( V nc State ▁* vs , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h ) ▁{ ▁V nc Palette ▁* palette ▁= ▁& color _ count _ palette ; ▁uint 32_ t ▁bg ▁= ▁0, ▁fg ▁= ▁0; ▁int ▁colors ; ▁int ▁ret ▁= ▁0; ▁# if def ▁CONFIG _ V NC _ J PEG ▁bool ▁force _ jpeg ▁= ▁false ; ▁bool ▁allow _ jpeg ▁= ▁true ; ▁# end if ▁v nc _ frame buffer _ update ( vs , ▁x , ▁y , ▁w , ▁h , ▁vs -> t ight . type ); ▁v nc _ t ight _ start ( vs ); ▁v nc _ raw _ send _ frame buffer _ update ( vs , ▁x , ▁y , ▁w , ▁h ); ▁v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Exit Status ▁translate _ one ( Dis as Context ▁* ctx , ▁uint 32_ t ▁insn ) ▁{ ▁uint 32_ t ▁pal code ; ▁int 32_ t ▁disp 21, ▁disp 16 ; ▁# if nd ef ▁CONFIG _ USER _ ONLY ▁int 32_ t ▁disp 12 ; ▁# end if ▁uint 16_ t ▁fn 11 ; ▁uint 8_ t ▁op c , ▁ra , ▁rb , ▁rc , ▁fp fn , ▁fn 7, ▁is lit , ▁real _ is lit ; ▁uint 8_ t ▁lit ; ▁Exit Status ▁ret ; ▁/* ▁Decode ▁all ▁instruction ▁fields ▁*/ ▁op c ▁= ▁insn ▁>> ▁26 ; ▁ra ▁= ▁( ins n ▁>> ▁2 1) ▁& ▁0 x 1 F ; ▁rb ▁= ▁( ins n ▁>> ▁16 ) ▁& ▁0 x 1 F ; ▁rc ▁= ▁insn ▁&

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁inline ▁static ▁void ▁RE NAME ( h cs cale )( Sw s Context ▁* c , ▁uint 16_ t ▁* dst , ▁long ▁dst Width , ▁const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁int ▁src W , ▁int ▁x Inc , ▁int ▁flags , ▁const ▁int 16_ t ▁* h Ch r Filter , ▁const ▁int 16_ t ▁* h Ch r Filter Pos , ▁int ▁h Ch r Filter Size , ▁int ▁src Format , ▁uint 8_ t ▁* format Conv Buffer , ▁uint 32_ t ▁* pal ) ▁{ ▁int 32_ t ▁av _ unused ▁* mm x 2 Filter Pos ▁= ▁c -> chr M mx 2 Filter Pos ; ▁int 16_ t ▁av _ unused ▁* mm x 2 Filter ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁float 32 ▁HEL PER ( uc f 64_ ab ss )( float 32 ▁a ) ▁{ ▁return ▁float 32_ abs ( a ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ thread _ equal ( Q emu Thread ▁* thread 1, ▁Q emu Thread ▁* thread 2) ▁{ ▁return ▁p thread _ equal ( thread 1 -> thread , ▁thread 2 -> thread ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁iv sh mem _ io _ writ el ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁IV Sh mem State ▁* s ▁= ▁opaque ; ▁uint 64_ t ▁write _ one ▁= ▁1; ▁uint 16_ t ▁dest ▁= ▁val ▁>> ▁16 ; ▁uint 16_ t ▁vector ▁= ▁val ▁& ▁0 xff ; ▁addr ▁&= ▁0 x fc ; ▁IV SH ME M _ DP RI NT F (" writing ▁to ▁addr ▁" ▁TARGET _ F MT _ pl x ▁"\ n ", ▁addr ); ▁switch ▁( addr ) ▁{ ▁case ▁INT RM ASK : ▁iv sh mem _ In tr Mask _ write ( s , ▁val ); ▁break ; ▁case ▁INT R STATUS : ▁iv sh mem _ In tr Stat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ outs ( Dis as Context ▁* s , ▁TC G Mem Op ▁ot ) ▁{ ▁if ▁( use _ ic ount ) ▁gen _ io _ start (); ▁gen _ string _ mov l _ A 0_ E SI ( s ); ▁gen _ op _ ld _ v ( s , ▁ot , ▁cpu _ T [0], ▁cpu _ A 0); ▁tc g _ gen _ trunc _ tl _ i 32 ( cpu _ tmp 2_ i 32, ▁cpu _ re gs [ R _ ED X ]); ▁tc g _ gen _ and i _ i 32 ( cpu _ tmp 2_ i 32, ▁cpu _ tmp 2_ i 32, ▁0 xffff ); ▁tc g _ gen _ trunc _ tl _ i 32 ( cpu _ tmp 3_ i 32, ▁cpu _ T [0]); ▁gen _ helper _ out _ func ( ot , ▁cpu _ tmp 2_ i 32, ▁cp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁test _ fc mp ( double ▁a , ▁double ▁b ) ▁{ ▁long ▁ef lags , ▁fp us ; ▁f pu _ clear _ exceptions (); ▁asm (" f com ▁% 2\ n " ▁" f st sw ▁%% ax \ n " ▁: ▁" = a " ▁( fp us ) ▁: ▁" t " ▁( a ), ▁" u " ▁( b )); ▁printf (" f com ( % f ▁% f ) =% 04 l x ▁\ n ", ▁a , ▁b , ▁fp us ▁& ▁(0 x 45 00 ▁| ▁F P US _ EM ASK )); ▁f pu _ clear _ exceptions (); ▁asm (" f u com ▁% 2\ n " ▁" f st sw ▁%% ax \ n " ▁: ▁" = a " ▁( fp us ) ▁: ▁" t " ▁( a ), ▁" u " ▁( b )); ▁printf (" f u com ( % f ▁% f ) =% 04 l x \ n ", ▁a , ▁b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ set _ page _ with _ attrs ( CPU State ▁* cpu , ▁target _ ulong ▁v addr , ▁hw addr ▁p addr , ▁Mem Tx Attrs ▁attrs , ▁int ▁prot , ▁int ▁mm u _ idx , ▁target _ ulong ▁size ) ▁{ ▁CPU Arch State ▁* env ▁= ▁cpu -> env _ ptr ; ▁Memory Region Section ▁* section ; ▁unsigned ▁int ▁index ; ▁target _ ulong ▁address ; ▁target _ ulong ▁code _ address ; ▁uint ptr _ t ▁add end ; ▁C PUT LB Entry ▁* te ; ▁hw addr ▁i ot lb , ▁x lat , ▁sz ; ▁unsigned ▁v idx ▁= ▁env -> v tl b _ index ++ ▁% ▁CPU _ VT LB _ SIZE ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q crypto _ cipher _ init _ des _ rf b ( Q Crypto Cipher ▁* cipher , ▁const ▁uint 8_ t ▁* key , ▁size _ t ▁n key , ▁Error ▁** err p ) ▁{ ▁Q Crypto Cipher Builtin ▁* ctxt ; ▁if ▁( cipher -> mode ▁!= ▁Q CRY P TO _ C IP HER _ MODE _ EC B ) ▁{ ▁error _ set g ( err p , ▁" Unsupported ▁cipher ▁mode ▁% d ", ▁cipher -> mode ); ▁return ▁-1; ▁} ▁ctxt ▁= ▁g _ new 0( Q Crypto Cipher Builtin , ▁1); ▁ctxt -> state . des rf b . key ▁= ▁g _ new 0( uint 8_ t , ▁n key ); ▁mem c py ( ctxt -> state . des rf b . 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ cc w _ handle _ set _ v q ( Sub ch Dev ▁* sch , ▁CC W 1 ▁cc w , ▁bool ▁check _ len , ▁bool ▁is _ legacy ) ▁{ ▁int ▁ret ; ▁V q Info Block ▁info ; ▁V q Info Block Legacy ▁l info ; ▁size _ t ▁info _ len ▁= ▁is _ legacy ▁? ▁sizeof ( l info ) ▁: ▁sizeof ( info ); ▁if ▁( check _ len ) ▁{ ▁if ▁( cc w . count ▁!= ▁info _ len ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁} ▁else ▁if ▁( cc w . count ▁< ▁info _ len ) ▁{ ▁/* ▁Can ' t ▁execute ▁command . ▁*/ ▁return ▁- E IN VAL ; ▁} ▁if ▁(! cc w . c da ) ▁{ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ client _ cache _ addr ( V nc State ▁* client ) ▁{ ▁Error ▁* err ▁= ▁NULL ; ▁client -> info ▁= ▁g _ m alloc 0( size of (* client -> info )); ▁client -> info -> base ▁= ▁g _ m alloc 0( size of (* client -> info -> base )); ▁v nc _ init _ basic _ info _ from _ remote _ addr ( client -> cs ock , ▁client -> info -> base , ▁& err ); ▁if ▁( err ) ▁{ ▁q api _ free _ V nc Client Info ( client -> info ); ▁client -> info ▁= ▁NULL ; ▁error _ free ( err ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ irq ch ip _ add _ irq fd ( K VM State ▁* s , ▁int ▁fd , ▁int ▁v irq ) ▁{ ▁return ▁k vm _ irq ch ip _ assign _ irq fd ( s , ▁fd , ▁v irq , ▁true ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁udp _ chr _ read ( G IO Channel ▁* chan , ▁G IO Condition ▁cond , ▁void ▁* op aque ) ▁{ ▁Char Driver State ▁* chr ▁= ▁opaque ; ▁Net Char Driver ▁* s ▁= ▁chr -> op aque ; ▁g size ▁bytes _ read ▁= ▁0; ▁G IO Status ▁status ; ▁if ▁( s -> max _ size ▁== ▁0) ▁return ▁FALSE ; ▁status ▁= ▁g _ io _ channel _ read _ chars ( s -> chan , ▁( g char ▁* ) s -> buf , ▁sizeof ( s -> buf ), ▁& bytes _ read , ▁NULL ); ▁s -> buf cnt ▁= ▁bytes _ read ; ▁s -> buf ptr ▁= ▁s -> buf cnt ; ▁if ▁( status ▁!= ▁G 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P CI Bus ▁* pc i _ prep _ init ( q emu _ irq ▁* pic ) ▁{ ▁PRE P PC I State ▁* s ; ▁PC ID evice ▁* d ; ▁int ▁P PC _ io _ memory ; ▁s ▁= ▁qemu _ m alloc z ( size of ( PRE P PC I State )); ▁s -> bus ▁= ▁pci _ register _ bus ( prep _ set _ irq , ▁prep _ map _ irq , ▁pic , ▁0, ▁2); ▁register _ i op ort _ write (0 x cf 8, ▁4, ▁4, ▁pci _ prep _ addr _ writ el , ▁s ); ▁register _ i op ort _ read (0 x cf 8, ▁4, ▁4, ▁pci _ prep _ addr _ read l , ▁s ); ▁register _ i op ort _ write (0 x cf c , ▁4, ▁1, ▁pci _ host _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁raw _ init _ encoder ( AV Codec Context ▁* av ctx ) ▁{ ▁av ctx -> coded _ frame ▁= ▁( AV Frame ▁* ) av ctx -> priv _ data ; ▁av ctx -> coded _ frame -> p ict _ type ▁= ▁FF _ I _ TYPE ; ▁av ctx -> coded _ frame -> key _ frame ▁= ▁1; ▁av ctx -> codec _ tag ▁= ▁find Four CC ( av ctx -> pix _ fmt ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ sequence _ header _ ad v ( VC 1 Context ▁* v , ▁Get Bit Context ▁* gb ) ▁{ ▁v -> res _ rt m _ flag ▁= ▁1; ▁v -> level ▁= ▁get _ bits ( gb , ▁3 ); ▁if ( v -> level ▁>= ▁5) ▁{ ▁av _ log ( v -> s . av ctx , ▁AV _ LOG _ ERROR , ▁" Reserved ▁LEVEL ▁% i \ n ", v -> level ); ▁} ▁v -> chrom a format ▁= ▁get _ bits ( gb , ▁2); ▁if ▁( v -> chrom a format ▁!= ▁1) ▁{ ▁av _ log ( v -> s . av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁4 :2 :0 ▁chrom a ▁format ▁supported \ n "); ▁return ▁-1; ▁} ▁// ▁( f p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁page _ un prot ect ( target _ ulong ▁address , ▁uint ptr _ t ▁pc , ▁void ▁* pu c ) ▁{ ▁unsigned ▁int ▁prot ; ▁Page Desc ▁* p ; ▁target _ ulong ▁host _ start , ▁host _ end , ▁addr ; ▁/* ▁Techn ically ▁this ▁isn ' t ▁safe ▁inside ▁a ▁signal ▁handler . ▁However ▁we ▁know ▁this ▁only ▁ever ▁happens ▁in ▁a ▁synchronous ▁SE GV ▁handler , ▁so ▁in ▁practice ▁it ▁seems ▁to ▁be ▁ok . ▁*/ ▁mmap _ lock (); ▁p ▁= ▁page _ find ( address ▁>> ▁TARGET _ PAGE _ BITS ); ▁if ▁(! p ) ▁{ ▁mmap _ un lock (); ▁return ▁0; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ put _ h 2 64_ qp el 8_ mc 23 _ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ mid v _ q rt _8 w _ ms a ( src ▁- ▁(2 ▁* ▁stride ) ▁- ▁2, ▁stride , ▁dst , ▁stride , ▁8, ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fil m _ pro be ( AV Probe Data ▁* p ) ▁{ ▁if ▁( p -> buf _ size ▁< ▁4) ▁return ▁0; ▁if ▁( AV _ RB 32 ( & p -> buf [0]) ▁!= ▁FIL M _ TAG ) ▁return ▁0; ▁return ▁AV PRO BE _ S CORE _ MAX ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ store _ v 10_ conditional ( Dis as Context ▁* dc , ▁TC G v ▁addr , ▁TC G v ▁val , ▁unsigned ▁int ▁size , ▁int ▁mem _ index ) ▁{ ▁int ▁l 1 ▁= ▁gen _ new _ label (); ▁TC G v ▁t addr ▁= ▁tc g _ temp _ local _ new (); ▁TC G v ▁t val ▁= ▁tc g _ temp _ local _ new (); ▁TC G v ▁t 1 ▁= ▁tc g _ temp _ local _ new (); ▁dc -> post inc ▁= ▁0; ▁cr is _ evaluate _ flags ( dc ); ▁tc g _ gen _ mov _ tl ( t addr , ▁addr ); ▁tc g _ gen _ mov _ tl ( t val , ▁val ); ▁/* ▁Store ▁only ▁if ▁F ▁flag ▁isn ' t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ide _ trim _ b h _ cb ( void ▁* op aque ) ▁{ ▁Tr im A IO CB ▁* i oc b ▁= ▁opaque ; ▁i oc b -> common . cb ( i oc b -> common . op aque , ▁i oc b -> ret ); ▁qemu _ b h _ delete ( i oc b -> b h ); ▁i oc b -> b h ▁= ▁NULL ; ▁qemu _ a io _ un ref ( i oc b ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁abi _ long ▁do _ io ctl _ dm ( const ▁IO CT L Entry ▁* ie , ▁uint 8_ t ▁* buf _ temp , ▁int ▁fd , ▁abi _ long ▁cmd , ▁abi _ long ▁arg ) ▁{ ▁void ▁* arg ptr ; ▁struct ▁dm _ io ctl ▁* host _ dm ; ▁abi _ long ▁guest _ data ; ▁uint 32_ t ▁guest _ data _ size ; ▁int ▁target _ size ; ▁const ▁arg type ▁* arg _ type ▁= ▁ie -> arg _ type ; ▁abi _ long ▁ret ; ▁void ▁* big _ buf ▁= ▁NULL ; ▁char ▁* host _ data ; ▁arg _ type ++; ▁target _ size ▁= ▁th unk _ type _ size ( arg _ type , ▁0); ▁arg ptr ▁= ▁lock _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dx va 2_ retrieve _ data ( AV Codec Context ▁* s , ▁AV Frame ▁* frame ) ▁{ ▁InputStream ▁* ist ▁= ▁s -> op aque ; ▁D X VA 2 Context ▁* ctx ▁= ▁ist -> hw accel _ ctx ; ▁int ▁ret ; ▁ret ▁= ▁av _ hw frame _ transfer _ data ( ctx -> tmp _ frame , ▁frame , ▁0); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁ret ▁= ▁av _ frame _ copy _ props ( ctx -> tmp _ frame , ▁frame ); ▁if ▁( ret ▁< ▁0) ▁{ ▁av _ frame _ un ref ( ctx -> tmp _ frame ); ▁return ▁ret ; ▁} ▁av _ frame _ un ref ( frame ); ▁av _ frame _ move _ r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁decode _ mb _ mode ( VP 8 Context ▁* s , ▁V P 8 Macro block ▁* mb , ▁int ▁mb _ x , ▁int ▁mb _ y , ▁uint 8_ t ▁* segment , ▁uint 8_ t ▁* ref , ▁int ▁layout ) ▁{ ▁V P 56 Range Coder ▁* c ▁= ▁& s -> c ; ▁if ▁( s -> segment ation . update _ map ) ▁* segment ▁= ▁vp 8_ rac _ get _ tree ( c , ▁vp 8_ segment id _ tree , ▁s -> prob -> segment id ); ▁else ▁if ▁( s -> segment ation . enabled ) ▁* segment ▁= ▁ref ▁? ▁* ref ▁: ▁* segment ; ▁mb -> segment ▁= ▁* segment ; ▁mb -> skip ▁= ▁s -> mb skip _ enabled ▁?

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ m ic rom ips _ op c ▁( CP UM IP S State ▁* env , ▁Dis as Context ▁* ctx , ▁int ▁* is _ branch ) ▁{ ▁uint 32_ t ▁op ; ▁/* ▁make ▁sure ▁instructions ▁are ▁on ▁a ▁half word ▁boundary ▁*/ ▁if ▁( ctx -> pc ▁& ▁0 x 1) ▁{ ▁env -> CP 0_ Bad V Addr ▁= ▁ctx -> pc ; ▁generate _ exception ( ctx , ▁EX CP _ Ad EL ); ▁ctx -> b state ▁= ▁BS _ STOP ; ▁return ▁2; ▁} ▁op ▁= ▁( ctx -> op code ▁>> ▁10) ▁& ▁0 x 3 f ; ▁/* ▁En force ▁properly - s ized ▁instructions ▁in ▁a ▁delay ▁slot ▁*/ ▁if ▁( ctx -> h f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dec ouple _ info ( CO OK Context ▁* q , ▁CO OK Sub packet ▁* p , ▁int ▁* dec ouple _ tab ) ▁{ ▁int ▁i ; ▁int ▁vl c ▁= ▁get _ bits 1( & q -> gb ); ▁int ▁start ▁= ▁c pl band [ p -> js _ sub band _ start ]; ▁int ▁end ▁= ▁c pl band [ p -> sub b ands ▁- ▁1 ]; ▁int ▁length ▁= ▁end ▁- ▁start ▁+ ▁1; ▁if ▁( start ▁> ▁end ) ▁return ; ▁if ▁( vlc ) ▁for ▁( i ▁= ▁0; ▁i ▁< ▁length ; ▁i ++) ▁dec ouple _ tab [ start ▁+ ▁i ] ▁= ▁get _ vlc 2( & q -> gb , ▁p -> cc pl . table , ▁p -> cc pl . bits , ▁2); ▁else 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁prepare _ packet ( AV Packet ▁* pk t , const ▁Failing M ux er Packet Data ▁* pk t _ data , ▁int 64_ t ▁pts ) ▁{ ▁int ▁ret ; ▁Failing M ux er Packet Data ▁* data ▁= ▁av _ m alloc ( size of (* data )); ▁mem c py ( data , ▁pkt _ data , ▁sizeof ( Fail ing M ux er Packet Data )); ▁ret ▁= ▁av _ packet _ from _ data ( pk t , ▁( uint 8_ t *) ▁data , ▁sizeof (* data )); ▁pkt -> pts ▁= ▁pkt -> d ts ▁= ▁pts ; ▁pkt -> duration ▁= ▁1; ▁return ▁ret ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁find _ best _ state ( uint 8_ t ▁best _ state [ 256 ][ 256 ], ▁const ▁uint 8_ t ▁one _ state [ 256 ] ){ ▁int ▁i , j , k , m ; ▁double ▁l 2 tab [ 256 ]; ▁for ( i =1; ▁i < 256 ; ▁i ++) ▁l 2 tab [ i ]= ▁log 2( i / 256 .0 ); ▁for ( i =0; ▁i < 256 ; ▁i ++){ ▁double ▁best _ len [ 256 ]; ▁double ▁p = ▁i / 256 .0 ; ▁for ( j =0; ▁j < 256 ; ▁j ++) ▁best _ len [ j ]= ▁1 << 30 ; ▁for ( j = FF MAX ( i -10 , 1); ▁j < FF MIN ( i +1 1, 256 ); ▁j ++){ ▁double ▁occ [ 256 ] ={ 0 }; ▁double ▁len =0; ▁occ [ j ]

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ pc m ( HE VC Context ▁* s , ▁int ▁x , ▁int ▁y ) ▁{ ▁int ▁log 2_ min _ pu _ size ▁= ▁s -> sp s -> log 2_ min _ pu _ size ; ▁int ▁x _ pu ▁= ▁x ▁>> ▁log 2_ min _ pu _ size ; ▁int ▁y _ pu ▁= ▁y ▁>> ▁log 2_ min _ pu _ size ; ▁if ▁( x ▁< ▁0 ▁|| ▁x _ pu ▁>= ▁s -> sp s -> min _ pu _ width ▁|| ▁y ▁< ▁0 ▁|| ▁y _ pu ▁>= ▁s -> sp s -> min _ pu _ height ) ▁return ▁2; ▁return ▁s -> is _ pc m [ y _ pu ▁* ▁s -> sp s -> min _ pu _ width ▁+ ▁x _ pu ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h 2 64_ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁H 264 Context ▁* h ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁int ▁buf _ index ▁= ▁0; ▁int ▁ret ; ▁const ▁uint 8_ t ▁* new _ ex tr ad ata ; ▁int ▁new _ ex tr ad ata _ size ; ▁h -> flags ▁= ▁av ctx -> flags ; ▁h -> setup _ finished ▁= ▁0; ▁/* ▁end ▁of ▁stream , ▁output ▁what

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int 16_ t ▁calc _ low comp ( int 16_ t ▁a , ▁int 16_ t ▁b 0, ▁int 16_ t ▁b 1, ▁uint 8_ t ▁bin ) ▁{ ▁if ▁( bin ▁< ▁7) ▁{ ▁if ▁(( b 0 ▁+ ▁256 ) ▁== ▁b 1) ▁a ▁= ▁3 84 ; ▁else ▁if ▁( b 0 ▁> ▁b 1) ▁a ▁= ▁FF MAX (0, ▁a ▁- ▁64 ); ▁} ▁else ▁if ▁( bin ▁< ▁20 ) ▁{ ▁if ▁(( b 0 ▁+ ▁256 ) ▁== ▁b 1) ▁a ▁= ▁320 ; ▁else ▁if ▁( b 0 ▁> ▁b 1) ▁a ▁= ▁FF MAX (0, ▁a ▁- ▁64 ); ▁} ▁else ▁{ ▁a ▁= ▁FF MAX (0, ▁a ▁- ▁128 ); ▁} ▁return ▁a ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uy 2 to y v 12 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* y dst , ▁uint 8_ t ▁* ud st , ▁uint 8_ t ▁* v dst , ▁long ▁width , ▁long ▁height , ▁long ▁l um Stride , ▁long ▁chrom Stride , ▁long ▁src Stride ) ▁{ ▁long ▁y ; ▁const ▁x 86_ reg ▁chrom Width = ▁width >> 1; ▁for ▁( y =0; ▁y < height ; ▁y += 2) ▁{ ▁# if ▁COM PI LE _ TEMPLATE _ MM X ▁__ asm __ ▁volatile ( ▁" xor ▁% %" REG _ a ", ▁% %" REG _ a " ▁\ n \ t " ▁" pc m pe q w ▁%% mm 7, ▁%% mm 7 ▁\ n \ t " ▁" ps rl w ▁$ 8, 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁B dr v Dirty Bitmap ▁* block _ dirty _ bitmap _ lookup ( const ▁char ▁* node , ▁const ▁char ▁* name , ▁Block Driver State ▁** p bs , ▁A io Context ▁** pa io , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁B dr v Dirty Bitmap ▁* bitmap ; ▁A io Context ▁* a io _ context ; ▁if ▁(! node ) ▁{ ▁error _ set g ( err p , ▁" Node ▁cannot ▁be ▁NULL "); ▁return ▁NULL ; ▁} ▁if ▁(! name ) ▁{ ▁error _ set g ( err p , ▁" Bitmap ▁name ▁cannot ▁be ▁NULL "); ▁return ▁NULL ; ▁} ▁bs ▁= ▁b dr v _ lookup _ bs ( no

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pp ce 500 _ init ( Machine State ▁* machine , ▁P P CE 500 Params ▁* params ) ▁{ ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ram ▁= ▁g _ new ( Memory Region , ▁1); ▁P CI Bus ▁* pc i _ bus ; ▁CP UP PC State ▁* env ▁= ▁NULL ; ▁uint 64_ t ▁load addr ; ▁hw addr ▁kernel _ base ▁= ▁-1 LL ; ▁int ▁kernel _ size ▁= ▁0; ▁hw addr ▁dt _ base ▁= ▁0; ▁hw addr ▁init rd _ base ▁= ▁0; ▁int ▁init rd _ size ▁= ▁0; ▁hw addr ▁cur _ base ▁= ▁0; ▁char ▁* filename ; ▁hw addr ▁b i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁int ▁coeff _ abs _ level _ remaining _ decode ( HE VC Context ▁* s , ▁int ▁rc _ r ice _ param ) ▁{ ▁int ▁prefix ▁= ▁0; ▁int ▁suffix ▁= ▁0; ▁int ▁last _ coeff _ abs _ level _ remaining ; ▁int ▁i ; ▁while ▁( prefix ▁< ▁C AB AC _ MAX _ BIN ▁&& ▁get _ c ab ac _ b yp ass ( & s -> HE V Cl c -> cc )) ▁prefix ++; ▁if ▁( prefix ▁< ▁3) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁rc _ r ice _ param ; ▁i ++) ▁suffix ▁= ▁( suffix ▁<< ▁1) ▁| ▁get _ c ab ac _ b yp ass ( & s -> HE V Cl c -> cc ); ▁last _ co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁segment _ h ls _ window ( AV Format Context ▁* s , ▁int ▁last ) ▁{ ▁Segment Context ▁* seg ▁= ▁s -> priv _ data ; ▁int ▁i , ▁ret ▁= ▁0; ▁char ▁buf [10 24 ]; ▁if ▁(( ret ▁= ▁av io _ open 2( & seg -> pb , ▁seg -> list , ▁AV IO _ FLAG _ WRITE , ▁& s -> interrupt _ callback , ▁NULL )) ▁< ▁0) ▁goto ▁fail ; ▁av io _ printf ( seg -> pb , ▁"# EXT M 3 U \ n "); ▁av io _ printf ( seg -> pb , ▁"# EXT - X - VERSION :3 \ n "); ▁av io _ printf ( seg -> pb , ▁"# EXT - X - TARGET DURATION :% d \ n ", ▁( int

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁cr is _ add c _ pi _ m ( int ▁a , ▁int ▁** b ) ▁{ ▁asm ▁volatile ▁(" add c ▁[ % 1+ ], ▁% 0\ n " ▁: ▁"+ r " ▁( a ), ▁"+ b " ▁(* b )); ▁return ▁a ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm gen id _ query _ monitor _ test ( void ) ▁{ ▁Q emu UUID ▁expected , ▁measured ; ▁g char ▁* cmd ; ▁g _ assert ( q emu _ uuid _ parse ( V G ID _ G UID , ▁& expected ) ▁== ▁0); ▁cmd ▁= ▁g _ str dup _ printf ("- machine ▁accel = tc g ▁- device ▁vm gen id , id = test v gid ," ▁" guid =% s ", ▁V G ID _ G UID ); ▁q test _ start ( cmd ); ▁/* ▁Read ▁the ▁GUID ▁via ▁the ▁monitor ▁*/ ▁read _ guid _ from _ monitor ( & me asured ); ▁g _ assert ( mem cmp ( me asured . data , ▁expected . data , ▁sizeof

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame _ by ter un 1( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁If f Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> size ▁>= ▁2 ▁? ▁av pk t -> data ▁+ ▁AV _ RB 16 ( av pk t -> data ) ▁: ▁NULL ; ▁const ▁int ▁buf _ size ▁= ▁av pk t -> size ▁>= ▁2 ▁? ▁av pk t -> size ▁- ▁AV _ RB 16 ( av pk t -> data ) ▁: ▁0; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf + buf _ size ; ▁int ▁y , ▁plane , ▁res ; ▁if ▁(( res ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁alloc _ picture ( M peg Enc Context ▁* s , ▁Picture ▁* pic , ▁int ▁shared ){ ▁const ▁int ▁big _ mb _ num = ▁s -> mb _ stride *( s -> mb _ height +1) ▁+ ▁1; ▁// the ▁+1 ▁is ▁needed ▁so ▁mem set ( ,, stride * height ) ▁does ▁not ▁sig 11 ▁const ▁int ▁mb _ array _ size = ▁s -> mb _ stride * s -> mb _ height ; ▁const ▁int ▁b 8_ array _ size = ▁s -> b 8_ stride * s -> mb _ height * 2; ▁const ▁int ▁b 4_ array _ size = ▁s -> b 4_ stride * s -> mb _ height * 4; ▁int ▁i ; ▁if ( shared ){ ▁assert ( pic -> data

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ pic _ hdr ( I VI 5 Dec Context ▁* ctx , ▁AV Codec Context ▁* av ctx ) ▁{ ▁if ▁( get _ bits ( & ctx -> gb , ▁5) ▁!= ▁0 x 1 F ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Invalid ▁picture ▁start ▁code ! \ n "); ▁return ▁-1; ▁ctx -> prev _ frame _ type ▁= ▁ctx -> frame _ type ; ▁ctx -> frame _ type ▁= ▁get _ bits ( & ctx -> gb , ▁3 ); ▁if ▁( ctx -> frame _ type ▁>= ▁5) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Invalid ▁frame ▁type : ▁% d ▁\ n ", ▁ctx -> frame _ type ); ▁return

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg ts _ write _ header ( AV Format Context ▁* s ) ▁{ ▁M peg TS Write ▁* ts ▁= ▁s -> priv _ data ; ▁M peg TS Write Stream ▁* ts _ st ; ▁M peg TS Service ▁* service ; ▁AV Stream ▁* st , ▁* pc r _ st ▁= ▁NULL ; ▁AV Dictionary Entry ▁* title , ▁* provider ; ▁int ▁i , ▁j ; ▁const ▁char ▁* service _ name ; ▁const ▁char ▁* provider _ name ; ▁int ▁* p ids ; ▁int ▁ret ; ▁if ▁( s -> max _ delay ▁< ▁0) ▁/* ▁Not ▁set ▁by ▁the ▁caller ▁*/ ▁s -> max _ delay ▁= ▁0; ▁// ▁round ▁up ▁to ▁a ▁whole ▁number ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁dct 32 ( INT FLOAT ▁* out , ▁const ▁INT FLOAT ▁* tab ) ▁{ ▁INT FLOAT ▁tmp 0, ▁tmp 1; ▁INT FLOAT ▁val 0 ▁, ▁val 1 ▁, ▁val 2 ▁, ▁val 3 ▁, ▁val 4 ▁, ▁val 5 ▁, ▁val 6 ▁, ▁val 7 ▁, ▁val 8 ▁, ▁val 9 ▁, ▁val 10, ▁val 11, ▁val 12, ▁val 13, ▁val 14, ▁val 15, ▁val 16, ▁val 17, ▁val 18, ▁val 19, ▁val 20, ▁val 21, ▁val 22, ▁val 23, ▁val 24, ▁val 25, ▁val 26, ▁val 27, ▁val 28, ▁val 29, ▁val 30, ▁val 31 ; ▁/* ▁pass ▁1 ▁*/ ▁B F 0( ▁0, ▁31, ▁COS 0 _0 ▁, ▁1); ▁B F 0( 15, ▁16, ▁COS 0 _1 5, ▁5 ); ▁/* ▁pass ▁2 ▁*/ ▁B 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ mov l _ seg _ T 0_ vm ( int ▁seg _ reg ) ▁{ ▁tc g _ gen _ and i _ tl ( cpu _ T [0], ▁cpu _ T [0], ▁0 xffff ); ▁tc g _ gen _ st 32_ tl ( cpu _ T [0], ▁cpu _ env , ▁offset of ( CPU X 86 State , se gs [ seg _ reg ]. selector )); ▁tc g _ gen _ sh li _ tl ( cpu _ T [0], ▁cpu _ T [0], ▁4 ); ▁tc g _ gen _ st _ tl ( cpu _ T [0], ▁cpu _ env , ▁offset of ( CPU X 86 State , se gs [ seg _ reg ]. base )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vc 1_ v _ overlap _ c ( uint 8_ t * ▁src , ▁int ▁stride ) ▁{ ▁int ▁i ; ▁int ▁a , ▁b , ▁c , ▁d ; ▁int ▁d 1, ▁d 2; ▁int ▁rnd ▁= ▁1; ▁for ( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁{ ▁a ▁= ▁src [ -2 * stride ]; ▁b ▁= ▁src [ - stride ]; ▁c ▁= ▁src [0]; ▁d ▁= ▁src [ stride ]; ▁d 1 ▁= ▁( a ▁- ▁d ▁+ ▁3 ▁+ ▁rnd ) ▁>> ▁3; ▁d 2 ▁= ▁( a ▁- ▁d ▁+ ▁b ▁- ▁c ▁+ ▁4 ▁- ▁rnd ) ▁>> ▁3; ▁src [ -2 * stride ] ▁= ▁a ▁- ▁d 1; ▁src [ - stride ] ▁= ▁b ▁- ▁d 2; ▁src [0] ▁= ▁c ▁+ ▁d 2; ▁src [ stride ] ▁= ▁d ▁+ ▁d 1; ▁src ++; ▁rnd 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q virt io _ pc i _ set _ ms ix _ configuration _ vector ( Q V irt io PC ID evice ▁* d , ▁Q Guest Allocator ▁* alloc , ▁uint 16_ t ▁entry ) ▁{ ▁uint 16_ t ▁vector ; ▁uint 32_ t ▁control ; ▁void ▁* addr ; ▁g _ assert ( d -> pd ev -> ms ix _ enabled ); ▁addr ▁= ▁d -> pd ev -> ms ix _ table ▁+ ▁( entry ▁* ▁16 ); ▁g _ assert _ cmp int ( entry , ▁>= , ▁0); ▁g _ assert _ cmp int ( entry , ▁< , ▁q pc i _ ms ix _ table _ size ( d -> pd ev )); ▁d -> config _ ms ix _ entry ▁= ▁entry ; ▁d -> config _ ms ix _ d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ rd h wr ( Dis as Context ▁* ctx , ▁int ▁rt , ▁int ▁rd ) ▁{ ▁TC G v ▁t 0; ▁# if ▁! defined ( CONFIG _ USER _ ONLY ) ▁/* ▁The ▁Linux ▁kernel ▁will ▁emulate ▁rd h wr ▁if ▁it ' s ▁not ▁supported ▁natively . ▁Therefore ▁only ▁check ▁the ▁I SA ▁in ▁system ▁mode . ▁*/ ▁check _ ins n ( ctx , ▁I SA _ M IP S 32 R 2); ▁# end if ▁t 0 ▁= ▁tc g _ temp _ new (); ▁switch ▁( rd ) ▁{ ▁case ▁0: ▁save _ cpu _ state ( ctx , ▁1); ▁gen _ helper _ rd h wr _ cp un um ( t 0, ▁cpu _ env ); ▁gen _ store _ g pr (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb _ ms d _ real ize _ bot ( US B Device ▁* dev , ▁Error ▁** err p ) ▁{ ▁MS D State ▁* s ▁= ▁DO _ UP CAST ( MS D State , ▁dev , ▁dev ); ▁usb _ desc _ create _ serial ( dev ); ▁usb _ desc _ init ( dev ); ▁sc si _ bus _ new ( & s -> bus , ▁sizeof ( s -> bus ), ▁DEVICE ( dev ), ▁& usb _ ms d _ sc si _ info _ bot , ▁NULL ); ▁s -> bus . q bus . allow _ hot plug ▁= ▁0; ▁usb _ ms d _ handle _ reset ( dev ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ slice _ header ( FF V 1 Context ▁* f , ▁FF V 1 Context ▁* fs ) ▁{ ▁Range Coder ▁* c ▁= ▁& fs -> c ; ▁uint 8_ t ▁state [ CONTEXT _ SIZE ]; ▁unsigned ▁ps , ▁i , ▁context _ count ; ▁mem set ( state , ▁12 8, ▁sizeof ( state )); ▁if ▁( fs -> ac ▁> ▁1) ▁{ ▁for ▁( i ▁= ▁1; ▁i ▁< ▁256 ; ▁i ++) ▁{ ▁fs -> c . one _ state [ i ] ▁= ▁f -> state _ transition [ i ]; ▁fs -> c . zero _ state [ 256 ▁- ▁i ] ▁= ▁256 ▁- ▁fs -> c . one _ state [ i ]; ▁} ▁} ▁fs -> slice _ x ▁= ▁get _ symbol ( c , ▁state ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ insert _ sw _ break point ( CPU State ▁* cs , ▁struct ▁k vm _ sw _ break point ▁* bp ) ▁{ ▁if ▁( cpu _ memory _ rw _ debug ( cs , ▁bp -> pc , ▁( uint 8_ t ▁* ) & bp -> saved _ ins n , ▁sizeof ( diag _5 01 ), ▁0) ▁|| ▁cpu _ memory _ rw _ debug ( cs , ▁bp -> pc , ▁( uint 8_ t ▁* ) diag _5 01, ▁sizeof ( diag _5 01 ), ▁1)) ▁{ ▁return ▁- E IN VAL ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁uint 8_ t ▁* ram _ chunk _ start ( const ▁R DM AL ocal Block ▁* rd ma _ ram _ block , ▁uint 64_ t ▁i ) ▁{ ▁return ▁( uint 8_ t ▁* ) ▁( (( uint ptr _ t ) ▁rd ma _ ram _ block -> local _ host _ addr ) ▁+ ▁( i ▁<< ▁R D MA _ REG _ CHUNK _ SHIFT )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ element ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁ch _ index , ▁int ▁channels ) ▁{ ▁A LA C Context ▁* al ac ▁= ▁av ctx -> priv _ data ; ▁int ▁has _ size , ▁b ps , ▁is _ compressed , ▁decor r _ shift , ▁decor r _ left _ weight , ▁ret ; ▁uint 32_ t ▁output _ samples ; ▁int ▁i , ▁ch ; ▁skip _ bits ( & al ac -> gb , ▁4 ); ▁/* ▁element ▁instance ▁tag ▁*/ ▁skip _ bits ( & al ac -> gb , ▁12 ); ▁/* ▁unused ▁header ▁bits ▁*/ ▁/* ▁the ▁number ▁of ▁output ▁samples ▁is ▁stored ▁in ▁t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁float ▁quantize _ and _ encode _ band _ cost _ template ( ▁struct ▁A AC Enc Context ▁* s , ▁Put Bit Context ▁* pb , ▁const ▁float ▁* in , ▁const ▁float ▁* scaled , ▁int ▁size , ▁int ▁scale _ idx , ▁int ▁cb , ▁const ▁float ▁lambda , ▁const ▁float ▁u pl im , ▁int ▁* bits , ▁int ▁BT _ ZERO , ▁int ▁BT _ UN SIGNED , ▁int ▁BT _ PA IR , ▁int ▁BT _ E SC ) ▁{ ▁const ▁float ▁I Q ▁= ▁ff _ a ac _ pow 2 sf _ tab [ 200 ▁+ ▁scale _ idx ▁- ▁S CALE _ ONE _ POS ▁+ ▁S CALE _ DIV _5 12 ]; ▁cons

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁event _ loop ( Video State ▁* cur _ stream ) ▁{ ▁SDL _ Event ▁event ; ▁double ▁incr , ▁pos , ▁frac ; ▁for ( ; ;) ▁{ ▁double ▁x ; ▁SDL _ Wait Event ( & event ); ▁switch ( event . type ) ▁{ ▁case ▁SDL _ KEY DOWN : ▁if ▁( exit _ on _ keydown ) ▁{ ▁do _ exit ( cur _ stream ); ▁break ; ▁} ▁switch ( event . key . keys ym . sym ) ▁{ ▁case ▁SDL K _ E SCAPE : ▁case ▁SDL K _ q : ▁do _ exit ( cur _ stream ); ▁break ; ▁case ▁SDL K _ f : ▁toggle _ full _ screen ( cur _ stream ); ▁break ; ▁case ▁SDL K _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁so x _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret , ▁size ; ▁if ▁( url _ fe of ( s -> pb )) ▁return ▁A VER ROR _ EOF ; ▁size ▁= ▁SO X _ SA MP LES * s -> streams [0] -> codec -> block _ align ; ▁ret ▁= ▁av _ get _ packet ( s -> pb , ▁pkt , ▁size ); ▁if ▁( ret ▁< ▁0) ▁return ▁A VER ROR ( E IO ); ▁pkt -> stream _ index ▁= ▁0; ▁pkt -> size ▁= ▁ret ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁sv q 1_ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁SV Q 1 Context ▁* ▁const ▁s ▁= ▁av ctx -> priv _ data ; ▁ds put il _ init ( & s -> d sp , ▁av ctx ); ▁av ctx -> coded _ frame = ▁( AV Frame *) & s -> picture ; ▁s -> frame _ width ▁= ▁av ctx -> width ; ▁s -> frame _ height ▁= ▁av ctx -> height ; ▁s -> y _ block _ width ▁= ▁( s -> frame _ width ▁+ ▁15 ) ▁/ ▁16 ; ▁s -> y _ block _ height ▁= ▁( s -> frame _ height ▁+ ▁15 ) ▁/ ▁16 ; ▁s -> c _ block _ width ▁= ▁( s -> frame _ wi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ah ci _ populate _ sg list ( A H C ID evice ▁* ad , ▁Q EM US G List ▁* sg list , ▁int ▁offset ) ▁{ ▁A H C IC md H dr ▁* cmd ▁= ▁ad -> cur _ cmd ; ▁uint 32_ t ▁opts ▁= ▁le 32_ to _ cpu ( cmd -> opts ); ▁uint 64_ t ▁pr dt _ addr ▁= ▁le 64_ to _ cpu ( cmd -> tbl _ addr ) ▁+ ▁0 x 80 ; ▁int ▁sg list _ alloc _ hint ▁= ▁opts ▁>> ▁A H CI _ CMD _ H DR _ PR DT _ LEN ; ▁d ma _ addr _ t ▁pr dt _ len ▁= ▁( sg list _ alloc _ hint ▁* ▁sizeof ( A H CI _ S G )); ▁d ma _ addr _ t ▁real _ pr dt _ len ▁= ▁pr dt

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁m peg _ m otion _ low res ( M peg Enc Context ▁* s , ▁uint 8_ t ▁* dest _ y , ▁uint 8_ t ▁* dest _ cb , ▁uint 8_ t ▁* dest _ cr , ▁int ▁field _ based , ▁int ▁bottom _ field , ▁int ▁field _ select , ▁uint 8_ t ▁** ref _ picture , ▁h 2 64_ chrom a _ mc _ func ▁* pix _ op , ▁int ▁motion _ x , ▁int ▁motion _ y , ▁int ▁h , ▁int ▁mb _ y ) ▁{ ▁uint 8_ t ▁* ptr _ y , ▁* ptr _ cb , ▁* ptr _ cr ; ▁int ▁mx , ▁my , ▁src _ x , ▁src _ y , ▁uv src _ x , ▁uv src _ y , ▁uv lines ize , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁unsigned ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf ▁+ ▁buf _ size ; ▁const ▁AV Pix F mt Descriptor ▁* desc ; ▁EX R Context ▁* const ▁s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁AV Frame ▁* const ▁p ▁= ▁& s -> picture ; ▁uint 8_ t ▁* ptr ; ▁int ▁i , ▁x , ▁y , ▁stride , ▁magic _ numb

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁csr h ci _ reset ( struct ▁csr h ci _ s ▁* s ) ▁{ ▁s -> out _ len ▁= ▁0; ▁s -> out _ size ▁= ▁FIFO _ LEN ; ▁s -> in _ len ▁= ▁0; ▁s -> ba ud _ delay ▁= ▁NANOSECONDS _ PER _ SECOND ; ▁s -> enable ▁= ▁0; ▁s -> in _ hdr ▁= ▁INT _ MAX ; ▁s -> in _ data ▁= ▁INT _ MAX ; ▁s -> mod em _ state ▁= ▁0; ▁/* ▁After ▁a ▁while ... ▁( but ▁soon er ▁than ▁10 ms ) ▁*/ ▁s -> mod em _ state ▁|= ▁CH R _ T IO CM _ CT S ; ▁mem set ( & s -> bd _ addr , ▁0, ▁sizeof ( bd addr _ t )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁rgb 15 to b gr 15 ( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁unsigned ▁int ▁src _ size ) ▁{ ▁unsigned ▁i ; ▁unsigned ▁num _ pixels ▁= ▁src _ size ▁>> ▁1; ▁for ( i =0; ▁i < num _ pixels ; ▁i ++) ▁{ ▁unsigned ▁b , g , r ; ▁register ▁uint 16_ t ▁rgb ; ▁rgb ▁= ▁src [2 * i ]; ▁r ▁= ▁rgb & 0 x 1 F ; ▁g ▁= ▁( rgb & 0 x 3 E 0) >> 5; ▁b ▁= ▁( rgb & 0 x 7 C 00) >> 10 ; ▁dst [2 * i ] ▁= ▁( b & 0 x 1 F ) ▁| ▁(( g & 0 x 1 F ) << 5) ▁| ▁(( r & 0 x 1 F ) << 10 ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁net _ init _ v host _ user ( const ▁Net dev ▁* net dev , ▁const ▁char ▁* name , ▁Net Client State ▁* peer , ▁Error ▁** err p ) ▁{ ▁int ▁queues ; ▁const ▁Net dev V host User Options ▁* v host _ user _ opts ; ▁Char Driver State ▁* chr ; ▁assert ( net dev -> type ▁== ▁NET _ CLIENT _ D RIVER _ V HOST _ USER ); ▁v host _ user _ opts ▁= ▁& net dev -> u . v host _ user ; ▁chr ▁= ▁net _ v host _ parse _ ch ard ev ( v host _ user _ opts , ▁err p ); ▁if ▁(! chr ) ▁{ ▁return ▁-1; ▁} ▁/* ▁verify ▁net ▁frontend 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lag _ decode _ prob ( Get Bit Context ▁* gb , ▁uint 32_ t ▁* value ) ▁{ ▁static ▁const ▁uint 8_ t ▁series [] ▁= ▁{ ▁1, ▁2, ▁3, ▁5, ▁8, ▁13, ▁21 ▁}; ▁int ▁i ; ▁int ▁bit ▁= ▁0; ▁int ▁bits ▁= ▁0; ▁int ▁prev bit ▁= ▁0; ▁unsigned ▁val ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁7 ; ▁i ++) ▁{ ▁if ▁( prev bit ▁&& ▁bit ) ▁break ; ▁prev bit ▁= ▁bit ; ▁bit ▁= ▁get _ bits 1( gb ); ▁if ▁( bit ▁&& ▁! prev bit ) ▁bits ▁+= ▁series [ i ]; ▁} ▁bits --; ▁if ▁( bits ▁< ▁0 ▁|| ▁bits ▁> ▁3 1) ▁{ ▁* value ▁= ▁0; ▁return ▁-1; ▁} ▁e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁check _ add _ res ( HE VC DS P Context ▁h , ▁int ▁bit _ depth ) ▁{ ▁int ▁i ; ▁LOCAL _ ALI G NED _32 ( int 16_ t , ▁res 0, ▁[ 32 ▁* ▁32 ]); ▁LOCAL _ ALI G NED _32 ( int 16_ t , ▁res 1, ▁[ 32 ▁* ▁32 ]); ▁LOCAL _ ALI G NED _32 ( uint 8_ t , ▁dst 0, ▁[ 32 ▁* ▁32 ▁* ▁2 ]); ▁LOCAL _ ALI G NED _32 ( uint 8_ t , ▁dst 1, ▁[ 32 ▁* ▁32 ▁* ▁2 ]); ▁for ▁( i ▁= ▁2; ▁i ▁<= ▁5; ▁i ++) ▁{ ▁int ▁block _ size ▁= ▁1 ▁<< ▁i ; ▁int ▁size ▁= ▁block _ size ▁* ▁block _ size ; ▁ptr diff _ t ▁stride ▁= ▁block _ size 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ validate _ fail _ union _ flat ( Test Input Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁User Def Flat Union ▁* tmp ▁= ▁NULL ; ▁Error ▁* err p ▁= ▁NULL ; ▁Visitor ▁* v ; ▁v ▁= ▁validate _ test _ init ( data , ▁"{ ▁' string ': ▁' c ', ▁' integer ': ▁4 1, ▁' boolean ': ▁true ▁} "); ▁visit _ type _ User Def Flat Union ( v , ▁& tmp , ▁NULL , ▁& err p ); ▁g _ assert ( error _ is _ set ( & err p )); ▁q api _ free _ User Def Flat Union ( tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ x 86_ update _ cr 4 ( CPU X 86 State ▁* env , ▁uint 32_ t ▁new _ cr 4) ▁{ ▁# if ▁defined ( DEBUG _ MM U ) ▁printf (" CR 4 ▁update : ▁CR 4 =% 08 x \ n ", ▁( uint 32_ t ) env -> cr [4 ]); ▁# end if ▁if ▁(( new _ cr 4 ▁& ▁( CR 4_ P GE _ MASK ▁| ▁CR 4_ PA E _ MASK ▁| ▁CR 4_ P SE _ MASK )) ▁!= ▁( env -> cr [4] ▁& ▁( CR 4_ P GE _ MASK ▁| ▁CR 4_ PA E _ MASK ▁| ▁CR 4_ P SE _ MASK ))) ▁{ ▁tl b _ flush ( env , ▁1); ▁} ▁/* ▁S SE ▁handling ▁*/ ▁if ▁(! ( env -> cp uid _ features ▁& ▁CP UID _ SS E )) ▁new 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁drive _ init ( struct ▁drive _ opt ▁* arg , ▁int ▁snapshot , ▁void ▁* op aque ) ▁{ ▁char ▁buf [ 128 ]; ▁char ▁file [10 24 ]; ▁char ▁dev name [ 128 ]; ▁char ▁serial [ 21 ]; ▁const ▁char ▁* media str ▁= ▁""; ▁Block Interface Type ▁type ; ▁enum ▁{ ▁MEDIA _ DIS K , ▁MEDIA _ CD ROM ▁} ▁media ; ▁int ▁bus _ id , ▁unit _ id ; ▁int ▁cy ls , ▁heads , ▁secs , ▁translation ; ▁Block Driver State ▁* b dr v ; ▁Block Driver ▁* dr v ▁= ▁NULL ; ▁Q EM UM achine ▁* machine ▁= ▁opaque ; ▁int ▁max _ dev s ; ▁int ▁index ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁unix _ wait _ for _ connect ( int ▁fd , ▁Error ▁* err , ▁void ▁* op aque ) ▁{ ▁Migration State ▁* s ▁= ▁opaque ; ▁if ▁( fd ▁< ▁0) ▁{ ▁D PRI NT F (" migrate ▁connect ▁error : ▁% s \ n ", ▁error _ get _ pretty ( err )); ▁s -> file ▁= ▁NULL ; ▁migrate _ fd _ error ( s ); ▁} ▁else ▁{ ▁D PRI NT F (" migrate ▁connect ▁success \ n "); ▁s -> file ▁= ▁qemu _ f open _ socket ( fd , ▁" wb "); ▁migrate _ fd _ connect ( s ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁l jpeg _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* p ict , ▁int ▁* got _ packet ) ▁{ ▁L J peg Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁Put Bit Context ▁pb ; ▁const ▁int ▁width ▁= ▁av ctx -> width ; ▁const ▁int ▁height ▁= ▁av ctx -> height ; ▁const ▁int ▁mb _ width ▁= ▁( width ▁+ ▁s -> hs ample [0] ▁- ▁1) ▁/ ▁s -> hs ample [0]; ▁const ▁int ▁mb _ height ▁= ▁( height ▁+ ▁s -> vs ample [0] ▁- ▁1) ▁/ ▁s -> vs ample [0]; ▁int ▁max _ pk t _ size ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ v src _ buffer _ add _ video _ buffer _ ref ( AV Filter Context ▁* buffer _ filter , ▁AV Filter Buffer Ref ▁* pic ref ) ▁{ ▁Buffer Source Context ▁* c ▁= ▁buffer _ filter -> priv ; ▁AV Filter Link ▁* out link ▁= ▁buffer _ filter -> outputs [0]; ▁int ▁ret ; ▁if ▁( c -> pic ref ) ▁{ ▁av _ log ( buffer _ filter , ▁AV _ LOG _ ERROR , ▁" Buffer ing ▁several ▁frames ▁is ▁not ▁supported . ▁" ▁" Please ▁consume ▁all ▁available ▁frames ▁before ▁adding ▁a ▁new ▁one .\ n " ▁); ▁// return ▁-1; ▁} ▁if ▁( pi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ decode _ picture _ parameter _ set ( Get Bit Context ▁* gb , ▁AV Codec Context ▁* av ctx , ▁H 264 Param Sets ▁* ps , ▁int ▁bit _ length ) ▁{ ▁AV Buffer Ref ▁* pp s _ buf ; ▁const ▁S PS ▁* sp s ; ▁unsigned ▁int ▁p ps _ id ▁= ▁get _ ue _ g ol omb ( gb ); ▁P PS ▁* pp s ; ▁int ▁qp _ bd _ offset ; ▁int ▁bits _ left ; ▁int ▁ret ; ▁if ▁( pp s _ id ▁>= ▁MAX _ P PS _ COUNT ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" pp s _ id ▁% u ▁out ▁of ▁range \ n ", ▁p ps _ id ); ▁return ▁A VER ROR _ IN

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q xl _ sp ice _ monitor s _ config _ async ( PC I Q X L Device ▁* q xl , ▁int ▁replay ) ▁{ ▁trace _ q xl _ sp ice _ monitor s _ config ( q xl -> id ); ▁if ▁( re play ) ▁{ ▁/* ▁* ▁don ' t ▁use ▁Q X L _ COOKIE _ TYPE _ IO : ▁* ▁- ▁we ▁are ▁not ▁running ▁yet ▁( post _ load ), ▁we ▁will ▁assert ▁* ▁in ▁send _ events ▁* ▁- ▁this ▁is ▁not ▁a ▁guest ▁io , ▁but ▁a ▁reply , ▁so ▁async _ io ▁isn ' t ▁set . ▁*/ ▁sp ice _ q xl _ monitor s _ config _ async ( & q xl -> ss d . q xl , ▁q xl -> guest _ moni

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ net _ v host _ status ( V irt ION et ▁* n , ▁uint 8_ t ▁status ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( n ); ▁Net Client State ▁* nc ▁= ▁qemu _ get _ queue ( n -> nic ); ▁int ▁queues ▁= ▁n -> multi queue ▁? ▁n -> max _ queues ▁: ▁1; ▁if ▁(! get _ v host _ net ( nc -> peer )) ▁{ ▁return ; ▁} ▁if ▁( !! n -> v host _ started ▁== ▁( virt io _ net _ started ( n , ▁status ) ▁&& ▁! nc -> peer -> link _ down )) ▁{ ▁return ; ▁} ▁if ▁(! n -> v host _ started ) ▁{ ▁int ▁r ; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ cpu _ core _ host _ init fn ( Object ▁* obj ) ▁{ ▁s P AP R CPU Core ▁* core ▁= ▁SP AP R _ CPU _ CORE ( obj ); ▁char ▁* name ▁= ▁g _ str dup _ printf ("% s - " ▁TYPE _ PO WER PC _ CPU , ▁" host "); ▁Object Class ▁* oc ▁= ▁object _ class _ by _ name ( name ); ▁g _ assert ( oc ); ▁g _ free (( void ▁* ) name ); ▁core -> cpu _ class ▁= ▁oc ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ block _ mapping ( V p 3 Decode Context ▁* s ) ▁{ ▁int ▁i , ▁j ; ▁signed ▁int ▁h il bert _ walk _ y [ 16 ]; ▁signed ▁int ▁h il bert _ walk _ c [ 16 ]; ▁signed ▁int ▁h il bert _ walk _ mb [4 ]; ▁int ▁current _ fragment ▁= ▁0; ▁int ▁current _ width ▁= ▁0; ▁int ▁current _ height ▁= ▁0; ▁int ▁right _ edge ▁= ▁0; ▁int ▁bottom _ edge ▁= ▁0; ▁int ▁super block _ row _ inc ▁= ▁0; ▁int ▁* h il bert ▁= ▁NULL ; ▁int ▁mapping _ index ▁= ▁0; ▁int ▁current _ macro block ; ▁int ▁c _ fragment ; ▁signe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁m 68 k _ cpu _ list ( FILE ▁* f , ▁int ▁(* cpu _ f printf )( FILE ▁* f , ▁const ▁char ▁* fmt , ▁... )) ▁{ ▁unsigned ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁m 68 k _ cpu _ defs [ i ]. name ; ▁i ++) ▁{ ▁(* cpu _ f printf )( f , ▁"% s \ n ", ▁m 68 k _ cpu _ defs [ i ]. name ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ac pi _ pc ih p _ device _ hot plug ( Ac pi P ci H p State ▁* s , ▁PC ID evice ▁* dev , ▁P CI Hot plug State ▁state ) ▁{ ▁int ▁slot ▁= ▁P CI _ SL OT ( dev -> dev fn ); ▁int ▁b sel ▁= ▁ac pi _ pc ih p _ get _ b sel ( dev -> bus ); ▁if ▁( b sel ▁< ▁0) ▁{ ▁return ▁-1; ▁} ▁/* ▁Don ' t ▁send ▁event ▁when ▁device ▁is ▁enabled ▁during ▁qemu ▁machine ▁creation : ▁* ▁it ▁is ▁present ▁on ▁boot , ▁no ▁hot plug ▁event ▁is ▁necessary . ▁We ▁do ▁send ▁an ▁* ▁event ▁when ▁the ▁device ▁is ▁disabled ▁later . ▁*/ ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁frame _ start ( H 264 Context ▁* h ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁int ▁i ; ▁MP V _ frame _ start ( s , ▁s -> av ctx ); ▁ff _ er _ frame _ start ( s ); ▁assert ( s -> lines ize ▁&& ▁s -> uv lines ize ); ▁for ( i =0; ▁i < 16 ; ▁i ++){ ▁h -> block _ offset [ i ]= ▁4 * (( scan 8 [ i ] ▁- ▁scan 8 [0]) & 7) ▁+ ▁4 * s -> lines ize * (( scan 8 [ i ] ▁- ▁scan 8 [0]) >> 3); ▁h -> block _ offset [ 24 + i ]= ▁4 * (( scan 8 [ i ] ▁- ▁scan 8 [0]) & 7) ▁+ ▁8 * s -> lines ize * (( scan 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ flush _ node v ( void ) ▁{ ▁Q PC ID evice ▁* dev ; ▁Q PC I Bar ▁b md ma _ bar , ▁ide _ bar ; ▁ide _ test _ start (""); ▁dev ▁= ▁get _ pc i _ device ( & b md ma _ bar , ▁& ide _ bar ); ▁/* ▁FL USH ▁CACHE ▁command ▁on ▁device ▁0 */ ▁q pc i _ io _ write b ( dev , ▁ide _ bar , ▁reg _ device , ▁0); ▁q pc i _ io _ write b ( dev , ▁ide _ bar , ▁reg _ command , ▁CMD _ FL USH _ CACHE ); ▁/* ▁Just ▁testing ▁that ▁qemu ▁doesn ' t ▁crash ... ▁*/ ▁ide _ test _ quit (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ guest _ file _ flush ( int 64_ t ▁handle , ▁Error ▁** err p ) ▁{ ▁Gu est File Handle ▁* g fh ▁= ▁guest _ file _ handle _ find ( handle , ▁err p ); ▁FILE ▁* fh ; ▁int ▁ret ; ▁if ▁(! g fh ) ▁{ ▁return ; ▁} ▁fh ▁= ▁gf h -> fh ; ▁ret ▁= ▁ff lush ( fh ); ▁if ▁( ret ▁== ▁EOF ) ▁{ ▁error _ set g _ err no ( err p , ▁errno , ▁" failed ▁to ▁flush ▁file "); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fill _ col map ( H 264 Context ▁* h , ▁int ▁map [2 ][ 16 + 32 ], ▁int ▁list , ▁int ▁field , ▁int ▁col field , ▁int ▁mb af i ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁Picture ▁* ▁const ▁ref 1 ▁= ▁& h -> ref _ list [1] [0]; ▁int ▁j , ▁old _ ref , ▁r field ; ▁int ▁start = ▁mb af i ▁? ▁16 ▁: ▁0; ▁int ▁end ▁= ▁mb af i ▁? ▁16 +2 * h -> ref _ count [0] ▁: ▁h -> ref _ count [0]; ▁int ▁inter l = ▁mb af i ▁|| ▁s -> picture _ structure ▁!= ▁PI CT _ FRAME ; ▁/* ▁bogus ; ▁fills ▁in ▁for ▁missin

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ frame _ duration ( int ▁* p num , ▁int ▁* pd en , ▁AV Format Context ▁* s , ▁AV Stream ▁* st , ▁AV Codec Parser Context ▁* pc , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁frame _ size ; ▁* p num ▁= ▁0; ▁* pd en ▁= ▁0; ▁switch ( st -> codec . codec _ type ) ▁{ ▁case ▁CODE C _ TYPE _ VI DEO : ▁* p num ▁= ▁st -> codec . frame _ rate _ base ; ▁* pd en ▁= ▁st -> codec . frame _ rate ; ▁if ▁( pc ▁&& ▁pc -> repeat _ p ict ) ▁{ ▁* pd en ▁*= ▁2; ▁* p num ▁= ▁(* p num ) ▁* ▁(2 ▁+ ▁pc -> repeat _ p ict )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁os _ host _ main _ loop _ wait ( int 64_ t ▁timeout ) ▁{ ▁G Main Context ▁* context ▁= ▁g _ main _ context _ default (); ▁G Poll FD ▁poll _ fds [10 24 ▁* ▁2 ]; ▁/* ▁this ▁is ▁probably ▁overkill ▁*/ ▁int ▁select _ ret ▁= ▁0; ▁int ▁g _ poll _ ret , ▁ret , ▁i , ▁n _ poll _ fds ; ▁Pol ling Entry ▁* pe ; ▁Wait Objects ▁* w ▁= ▁& wait _ objects ; ▁g int ▁poll _ timeout ; ▁int 64_ t ▁poll _ timeout _ ns ; ▁static ▁struct ▁time val ▁tv 0; ▁fd _ set ▁rf ds , ▁wf ds , ▁x fds ; ▁int ▁nf ds ; ▁/* ▁XXX :

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ snapshot _ delete ( Block Driver State ▁* bs , ▁const ▁char ▁* snapshot _ id ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁if ▁(! dr v ) ▁{ ▁return ▁- EN O MEDI UM ; ▁} ▁if ▁( dr v -> b dr v _ snapshot _ delete ) ▁{ ▁return ▁drv -> b dr v _ snapshot _ delete ( bs , ▁snapshot _ id ); ▁} ▁if ▁( bs -> file ) ▁{ ▁return ▁b dr v _ snapshot _ delete ( bs -> file , ▁snapshot _ id ); ▁} ▁return ▁- EN OT SUP ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁pci _ ap b _ i ore ad l ▁( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁uint 32_ t ▁val ; ▁val ▁= ▁b swap 32 ( cpu _ in l ( addr ▁& ▁IO PORT S _ MASK )); ▁return ▁val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ fill _ buffer ( Q EM U File ▁* f ) ▁{ ▁int ▁len ; ▁if ▁( f -> is _ writable ) ▁return ; ▁if ▁( f -> is _ file ) ▁{ ▁f seek ( f -> out file , ▁f -> buf _ offset , ▁SE EK _ SET ); ▁len ▁= ▁f read ( f -> buf , ▁1, ▁IO _ BU F _ SIZE , ▁f -> out file ); ▁if ▁( len ▁< ▁0) ▁len ▁= ▁0; ▁} ▁else ▁{ ▁len ▁= ▁b dr v _ p read ( f -> bs , ▁f -> base _ offset ▁+ ▁f -> buf _ offset , ▁f -> buf , ▁IO _ BU F _ SIZE ); ▁if ▁( len ▁< ▁0) ▁len ▁= ▁0; ▁} ▁f -> buf _ index ▁= ▁0; ▁f -> buf _ size ▁= ▁len 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁net _ hub _ check _ clients ( void ) ▁{ ▁Net Hub ▁* hub ; ▁Net Hub Port ▁* port ; ▁Net Client State ▁* peer ; ▁Q LIST _ FORE A CH ( hub , ▁& hub s , ▁next ) ▁{ ▁int ▁has _ nic ▁= ▁0, ▁has _ host _ dev ▁= ▁0; ▁Q LIST _ FORE A CH ( port , ▁& hub -> ports , ▁next ) ▁{ ▁peer ▁= ▁port -> nc . peer ; ▁if ▁(! peer ) ▁{ ▁f printf ( stderr , ▁" Warning : ▁hub ▁port ▁% s ▁has ▁no ▁peer \ n ", ▁port -> nc . name ); ▁continue ; ▁} ▁switch ▁( peer -> info -> type ) ▁{ ▁case ▁NET _ CLIENT _ D RIVER _ N IC : ▁has

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁D VD em ux Context * ▁dv _ init _ dem ux ( AV Format Context ▁* s ) ▁{ ▁D VD em ux Context ▁* c ; ▁c ▁= ▁av _ m alloc z ( size of ( D VD em ux Context )); ▁if ▁(! c ) ▁return ▁NULL ; ▁c -> v st ▁= ▁av _ new _ stream ( s , ▁0); ▁c -> ast [0] ▁= ▁av _ new _ stream ( s , ▁0); ▁if ▁(! c -> v st ▁|| ▁! c -> ast [0]) ▁goto ▁fail ; ▁av _ set _ pts _ info ( c -> v st , ▁64, ▁1, ▁30000 ); ▁av _ set _ pts _ info ( c -> ast [0], ▁64, ▁1, ▁30000 ); ▁c -> f ctx ▁= ▁s ; ▁c -> ast [1] ▁= ▁NULL ; ▁c -> ach ▁= ▁0; ▁c -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁b dr v _ co _ do _ p write _ zero es ( Block Driver State ▁* bs , ▁int 64_ t ▁offset , ▁int ▁bytes , ▁B dr v Request Flags ▁flags ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁Q EM UI O Vector ▁q io v ; ▁struct ▁i ove c ▁i ov ▁= ▁{0 }; ▁int ▁ret ▁= ▁0; ▁bool ▁need _ flush ▁= ▁false ; ▁int ▁head ▁= ▁0; ▁int ▁tail ▁= ▁0; ▁int ▁max _ write _ zero es ▁= ▁MIN _ NON _ ZERO ( bs -> bl . max _ p write _ zero es , ▁INT _ MAX ); ▁int ▁alignment ▁= ▁MAX ( bs -> bl . p write _ zero es _ a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁open pic _ save _ IR Q _ queue ( Q EM U File * ▁f , ▁IR Q Queue ▁* q ) ▁{ ▁unsigned ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁B F _ WIDTH ( MAX _ IR Q ); ▁i ++) ▁qemu _ put _ be 32 s ( f , ▁& q -> queue [ i ]); ▁qemu _ put _ s be 32 s ( f , ▁& q -> next ); ▁qemu _ put _ s be 32 s ( f , ▁& q -> priority ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁E H CI Queue ▁* eh ci _ state _ fetch q h ( E H CI State ▁* eh ci , ▁int ▁async ) ▁{ ▁uint 32_ t ▁entry ; ▁E H CI Queue ▁* q ; ▁int ▁reload ; ▁entry ▁= ▁eh ci _ get _ fetch _ addr ( eh ci , ▁async ); ▁q ▁= ▁eh ci _ find _ queue _ by _ q h ( eh ci , ▁entry ); ▁if ▁( NULL ▁== ▁q ) ▁{ ▁q ▁= ▁eh ci _ alloc _ queue ( eh ci , ▁async ); ▁} ▁q -> q h addr ▁= ▁entry ; ▁q -> seen ++; ▁if ▁( q -> seen ▁> ▁1) ▁{ ▁/* ▁we ▁are ▁going ▁in ▁circles ▁-- ▁stop ▁processing ▁*/ ▁eh ci _ set _ state ( eh ci , ▁async 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁o map _ rt c _ reset ( struct ▁o map _ rt c _ s ▁* s ) ▁{ ▁struct ▁tm ▁tm ; ▁s -> interrupt s ▁= ▁0; ▁s -> comp _ reg ▁= ▁0; ▁s -> running ▁= ▁0; ▁s -> pm _ am ▁= ▁0; ▁s -> auto _ comp ▁= ▁0; ▁s -> round ▁= ▁0; ▁s -> tick ▁= ▁qemu _ get _ clock ( rt _ clock ); ▁mem set ( & s -> alarm _ tm , ▁0, ▁sizeof ( s -> alarm _ tm )); ▁s -> alarm _ tm . tm _ md ay ▁= ▁0 x 01 ; ▁s -> status ▁= ▁1 ▁<< ▁7 ; ▁qemu _ get _ tim ed ate ( & tm , ▁0); ▁s -> ti ▁= ▁mktime gm ( & tm ); ▁o map _ rt c _ alarm _ up

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁to sa _ init ( Machine State ▁* machine ) ▁{ ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁machine -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* rom ▁= ▁g _ new ( Memory Region , ▁1); ▁P XA 2 xx State ▁* mp u ; ▁TC 6 39 3 xb State ▁* tm io ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁get _ sensor _ evt _ enable ( IP MI B mc Sim ▁* ib s , ▁uint 8_ t ▁* cmd , ▁unsigned ▁int ▁cmd _ len , ▁uint 8_ t ▁* r sp , ▁unsigned ▁int ▁* r sp _ len , ▁unsigned ▁int ▁max _ r sp _ len ) ▁{ ▁IP M IS ensor ▁* s ens ; ▁IP MI _ CHECK _ CMD _ LEN (3); ▁if ▁(( cmd [2] ▁> ▁MAX _ SENS ORS ) ▁|| ▁! IP MI _ SENSOR _ GET _ PRE SENT ( ib s -> s ensors ▁+ ▁cmd [2] )) ▁{ ▁rsp [2] ▁= ▁IP MI _ CC _ REQ _ ENTRY _ NOT _ PRE SENT ; ▁return ; ▁} ▁sens ▁= ▁i bs -> s ensors ▁+ ▁cmd [2 ]; ▁IP MI _ ADD _ R SP 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ u art _ s ▁* om ap _ u art _ init ( hw addr ▁base , ▁qemu _ irq ▁irq , ▁o map _ cl k ▁f cl k , ▁o map _ cl k ▁i cl k , ▁qemu _ irq ▁tx d ma , ▁qemu _ irq ▁rx d ma , ▁const ▁char ▁* label , ▁Char Driver State ▁* chr ) ▁{ ▁struct ▁o map _ u art _ s ▁* s ▁= ▁( struct ▁o map _ u art _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ u art _ s )); ▁s -> base ▁= ▁base ; ▁s -> f cl k ▁= ▁f cl k ; ▁s -> irq ▁= ▁irq ; ▁s -> serial ▁= ▁serial _ mm _ init ( get _ system _ memory (), ▁base , ▁2, ▁irq

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁create _ dynamic _ disk ( int ▁fd , ▁uint 8_ t ▁* buf , ▁int 64_ t ▁total _ sect ors ) ▁{ ▁V H DD yn Disk Header ▁* dy nd isk _ header ▁= ▁( V H DD yn Disk Header ▁* ) ▁buf ; ▁size _ t ▁block _ size , ▁num _ bat _ entries ; ▁int ▁i ; ▁int ▁ret ▁= ▁- E IO ; ▁// ▁Write ▁the ▁footer ▁( tw ice : ▁at ▁the ▁beginning ▁and ▁at ▁the ▁end ) ▁block _ size ▁= ▁0 x 200 000; ▁num _ bat _ entries ▁= ▁( total _ sect ors ▁+ ▁block _ size ▁/ ▁512 ) ▁/ ▁( block _ size ▁/ ▁512 ); ▁if ▁( write ( fd , ▁buf , ▁HE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ r bd _ snap _ list ( Block Driver State ▁* bs , ▁Q EM US napshot Info ▁** ps n _ tab ) ▁{ ▁B DR VR BD State ▁* s ▁= ▁bs -> op aque ; ▁Q EM US napshot Info ▁* sn _ info , ▁* sn _ tab ▁= ▁NULL ; ▁int ▁i , ▁snap _ count ; ▁rb d _ snap _ info _ t ▁* sn aps ; ▁int ▁max _ sn aps ▁= ▁R BD _ MAX _ SN AP S ; ▁do ▁{ ▁sn aps ▁= ▁g _ m alloc ( size of (* sn aps ) ▁* ▁max _ sn aps ); ▁snap _ count ▁= ▁rb d _ snap _ list ( s -> image , ▁sn aps , ▁& max _ sn aps ); ▁if ▁( snap _ count ▁< ▁0) ▁{ ▁g _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁get _ ph ys _ addr _ p ms av 8 ( CPU ARM State ▁* env , ▁uint 32_ t ▁address , ▁MM U AccessType ▁access _ type , ▁AR MM MU Idx ▁mm u _ idx , ▁hw addr ▁* ph ys _ ptr , ▁int ▁* prot , ▁uint 32_ t ▁* fs r ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁arm _ env _ get _ cpu ( env ); ▁bool ▁is _ user ▁= ▁reg ime _ is _ user ( env , ▁mm u _ idx ); ▁int ▁n ; ▁int ▁match region ▁= ▁-1; ▁bool ▁hit ▁= ▁false ; ▁* ph ys _ ptr ▁= ▁address ; ▁* prot ▁= ▁0; ▁/* ▁Unlike ▁the ▁ARM ▁ARM ▁pseudocode , ▁we ▁don ' t ▁need ▁to ▁chec

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 9 fs _ x attr _ read ( V 9 fs State ▁* s , ▁V 9 fs P DU ▁* pd u , ▁V 9 fs F id State ▁* f id p , ▁uint 64_ t ▁off , ▁uint 32_ t ▁max _ count ) ▁{ ▁s size _ t ▁err ; ▁size _ t ▁offset ▁= ▁7 ; ▁int ▁read _ count ; ▁int 64_ t ▁x attr _ len ; ▁V 9 fs V irt io State ▁* v ▁= ▁container _ of ( s , ▁V 9 fs V irt io State , ▁state ); ▁V irt Queue Element ▁* elem ▁= ▁v -> elems [ pd u -> idx ]; ▁x attr _ len ▁= ▁fid p -> fs . x attr . len ; ▁read _ count ▁= ▁x attr _ len ▁- ▁off ; ▁if ▁( read _ coun

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁coroutine _ fn ▁int ▁v mdk _ co _ write ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁const ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors ) ▁{ ▁int ▁ret ; ▁B DR V V mdk State ▁* s ▁= ▁bs -> op aque ; ▁qemu _ co _ mut ex _ lock ( & s -> lock ); ▁ret ▁= ▁v mdk _ write ( bs , ▁sector _ num , ▁buf , ▁nb _ sect ors ); ▁qemu _ co _ mut ex _ un lock ( & s -> lock ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁x bz r le _ encode _ buffer ( uint 8_ t ▁* old _ buf , ▁uint 8_ t ▁* new _ buf , ▁int ▁sl en , ▁uint 8_ t ▁* dst , ▁int ▁d len ) ▁{ ▁uint 32_ t ▁z run _ len ▁= ▁0, ▁nz run _ len ▁= ▁0; ▁int ▁d ▁= ▁0, ▁i ▁= ▁0; ▁long ▁res , ▁xor ; ▁uint 8_ t ▁* nz run _ start ▁= ▁NULL ; ▁g _ assert (! (( ( uint ptr _ t ) old _ buf ▁| ▁( uint ptr _ t ) new _ buf ▁| ▁sl en ) ▁% ▁sizeof ( long ))); ▁while ▁( i ▁< ▁sl en ) ▁{ ▁/* ▁overflow ▁*/ ▁if ▁( d ▁+ ▁2 ▁> ▁d len ) ▁{ ▁return ▁-1; ▁} ▁/* ▁not ▁aligned ▁to ▁sizeof ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁init _ at rac 3_ transforms ( AT RA C 3 Context ▁* q ) ▁{ ▁float ▁enc _ window [ 256 ]; ▁int ▁i ; ▁/* ▁Generate ▁the ▁md ct ▁window , ▁for ▁details ▁see ▁* ▁http :// wiki . mult im edia . cx / index . php ? title = Real Audio _ at rc # Windows ▁*/ ▁for ▁( i =0 ▁; ▁i < 256 ; ▁i ++) ▁enc _ window [ i ] ▁= ▁( sin (( ( i ▁+ ▁0.5 ) ▁/ ▁256 .0 ▁- ▁0.5 ) ▁* ▁M _ PI ) ▁+ ▁1.0 ) ▁* ▁0.5 ; ▁if ▁(! md ct _ window [0]) ▁for ▁( i =0 ▁; ▁i < 256 ; ▁i ++) ▁{ ▁md ct _ window [ i ] ▁= ▁enc _ win

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gd _ resize ( Display ChangeListener ▁* d cl , ▁Display State ▁* ds ) ▁{ ▁Gtk Display State ▁* s ▁= ▁ds -> op aque ; ▁ca iro _ format _ t ▁kind ; ▁int ▁stride ; ▁D PRI NT F (" resize ( width =% d , ▁height =% d )\ n ", ▁ds _ get _ width ( ds ), ▁ds _ get _ height ( ds )); ▁if ▁( s -> surface ) ▁{ ▁ca iro _ surface _ destroy ( s -> surface ); ▁} ▁switch ▁( ds -> surface -> pf . bits _ per _ pixel ) ▁{ ▁case ▁8: ▁kind ▁= ▁CA I RO _ FORMAT _ A 8 ; ▁break ; ▁case ▁16 : ▁kind ▁= ▁CA I RO _ FORMA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁lm 32_ j u art _ set _ j tx ( Device State ▁* d , ▁uint 32_ t ▁j tx ) ▁{ ▁L M 32 J u art State ▁* s ▁= ▁L M 32_ J U ART ( d ); ▁unsigned ▁char ▁ch ▁= ▁j tx ▁& ▁0 xff ; ▁trace _ lm 32_ j u art _ set _ j tx ( s -> j tx ); ▁s -> j tx ▁= ▁j tx ; ▁if ▁( s -> chr ) ▁{ ▁qemu _ chr _ fe _ write _ all ( s -> chr , ▁& ch , ▁1); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mat ro sk a _ fix _ ass _ packet ( Mat ro sk a Dem ux Context ▁* mat ro sk a , ▁AV Packet ▁* pk t , ▁uint 64_ t ▁display _ duration ) ▁{ ▁char ▁* line , ▁* layer , ▁* ptr ▁= ▁pkt -> data , ▁* end ▁= ▁ptr + pk t -> size ; ▁for ▁( ; ▁* ptr != ',' ▁&& ▁ptr < end -1; ▁ptr ++ ); ▁if ▁(* ptr ▁== ▁', ') ▁layer ▁= ▁++ ptr ; ▁for ▁( ; ▁* ptr != ',' ▁&& ▁ptr < end -1; ▁ptr ++ ); ▁if ▁(* ptr ▁== ▁', ') ▁{ ▁int 64_ t ▁end _ pts ▁= ▁pkt -> pts ▁+ ▁display _ duration ; ▁int ▁sc ▁= ▁mat ro sk a -> time _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁send _ msg ( ▁V SC Msg Type ▁type , ▁uint 32_ t ▁reader _ id , ▁const ▁void ▁* msg , ▁unsigned ▁int ▁length ▁) ▁{ ▁V SC Msg Header ▁mh Header ; ▁qemu _ mut ex _ lock ( & socket _ to _ send _ lock ); ▁if ▁( verbose ▁> ▁10) ▁{ ▁printf (" s ending ▁type =% d ▁id =% u , ▁len ▁= % u ▁(0 x % x )\ n ", ▁type , ▁reader _ id , ▁length , ▁length ); ▁} ▁mh Header . type ▁= ▁ht on l ( type ); ▁mh Header . reader _ id ▁= ▁0; ▁mh Header . length ▁= ▁ht on l ( length ); ▁g _ byte _ array _ append ( socket _ to _ send ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁F UN CC ( ff _ h 2 64_ id ct _ dc _ add )( uint 8_ t ▁* _ dst , ▁int 16_ t ▁* block , ▁int ▁stride ){ ▁int ▁i , ▁j ; ▁int ▁dc ▁= ▁( (( d ct coef *) block )[0] ▁+ ▁3 2) ▁>> ▁6 ; ▁pixel ▁* dst ▁= ▁( pixel *) _ dst ; ▁stride ▁>>= ▁sizeof ( pixel ) -1; ▁for ( ▁j ▁= ▁0; ▁j ▁< ▁4; ▁j ++ ▁) ▁{ ▁for ( ▁i ▁= ▁0; ▁i ▁< ▁4; ▁i ++ ▁) ▁dst [ i ] ▁= ▁av _ clip _ pixel ( ▁dst [ i ] ▁+ ▁dc ▁); ▁dst ▁+= ▁stride ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ picture _ ls ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* p ict , ▁int ▁* got _ packet ) ▁{ ▁const ▁AV Frame ▁* const ▁p ▁= ▁p ict ; ▁const ▁int ▁near ▁= ▁av ctx -> prediction _ method ; ▁Put Bit Context ▁pb , ▁pb 2; ▁Get Bit Context ▁gb ; ▁uint 8_ t ▁* buf 2 ▁= ▁NULL ; ▁uint 8_ t ▁* zero ▁= ▁NULL ; ▁uint 8_ t ▁* cur ▁= ▁NULL ; ▁uint 8_ t ▁* last ▁= ▁NULL ; ▁JLS State ▁* state ; ▁int ▁i , ▁size , ▁ret ; ▁int ▁comps ; ▁if ▁( av ctx -> pix _ fmt ▁== ▁AV _ PI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ vc 1_ decode _ blocks ( VC 1 Context ▁* v ) ▁{ ▁v -> s . esc 3_ level _ length ▁= ▁0; ▁if ▁( v -> x 8_ type ) ▁{ ▁ff _ in tr ax 8_ decode _ picture ( & v -> x 8, ▁2* v -> p q ▁+ ▁v -> half p q , ▁v -> p q ▁* ▁! v -> p quant izer ); ▁ff _ er _ add _ slice ( & v -> s . er , ▁0, ▁0, ▁( v -> s . mb _ x ▁>> ▁1) ▁- ▁1, ▁( v -> s . mb _ y ▁>> ▁1) ▁- ▁1, ▁ER _ MB _ END ); ▁} ▁else ▁{ ▁v -> cur _ blk _ idx ▁= ▁0; ▁v -> left _ blk _ idx ▁= ▁-1; ▁v -> to pleft _ blk _ idx ▁= ▁1; ▁v -> top _ blk _ idx ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁paint _ mouse _ pointer ( X Image ▁* image , ▁struct ▁x 11_ grab ▁* s ) ▁{ ▁int ▁x _ off ▁= ▁s -> x _ off ; ▁int ▁y _ off ▁= ▁s -> y _ off ; ▁int ▁width ▁= ▁s -> width ; ▁int ▁height ▁= ▁s -> height ; ▁Display ▁* d py ▁= ▁s -> d py ; ▁X Fix es Cursor Image ▁* xc im ; ▁int ▁x , ▁y ; ▁int ▁line , ▁column ; ▁int ▁to _ line , ▁to _ column ; ▁int ▁image _ addr , ▁xc im _ addr ; ▁xc im ▁= ▁X Fix es Get Cursor Image ( d py ); ▁x ▁= ▁xc im -> x ▁- ▁xc im -> x hot ; ▁y ▁= ▁xc im -> y ▁- ▁xc im -> y hot ; ▁to _ li

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁b oston _ plat reg _ read ( void ▁* op aque , ▁hw addr ▁addr , ▁unsigned ▁size ) ▁{ ▁B oston State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁g ic _ freq , ▁val ; ▁if ▁( size ▁!= ▁4) ▁{ ▁qemu _ log _ mask ( LOG _ UN IMP , ▁"% u B ▁platform ▁register ▁read ", ▁size ); ▁return ▁0; ▁} ▁switch ▁( addr ▁& ▁0 xffff ) ▁{ ▁case ▁PL AT _ F PG A _ BUILD : ▁case ▁PL AT _ CORE _ CL : ▁case ▁PL AT _ WRAP PER _ CL : ▁return ▁0; ▁case ▁PL AT _ DD R 3_ STATUS : ▁return ▁PL AT _ DD R 3_ STATUS _ LOCK ED ▁| ▁PL AT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av filter _ register ( AV Filter ▁* filter ) ▁{ ▁if ▁( next _ registered _ av filter _ idx ▁== ▁MAX _ REGI STER ED _ AV FILTER S _ NB ) ▁return ▁-1; ▁registered _ av filters [ next _ registered _ av filter _ idx ++ ] ▁= ▁filter ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ migrate _ cancel ( Error ▁** err p ) ▁{ ▁migrate _ fd _ cancel ( migrate _ get _ current ()); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁load _ snapshot ( const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs , ▁* bs _ vm _ state ; ▁Q EM US napshot Info ▁sn ; ▁Q EM U File ▁* f ; ▁int ▁ret ; ▁A io Context ▁* a io _ context ; ▁Migration Incoming State ▁* mis ▁= ▁migration _ incoming _ get _ current (); ▁if ▁(! b dr v _ all _ can _ snapshot ( & bs )) ▁{ ▁error _ set g ( err p , ▁" Device ▁'% s ' ▁is ▁writable ▁but ▁does ▁not ▁support ▁snapshots ", ▁b dr v _ get _ device _ name ( bs )); ▁return ▁- EN OT SUP ; ▁} ▁ret ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ n oin line ▁void ▁em ulated _ edge _ mc _ s se ( uint 8_ t ▁* buf , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁buf _ stride , ▁ptr diff _ t ▁src _ stride , ▁int ▁block _ w , ▁int ▁block _ h , ▁int ▁src _ x , ▁int ▁src _ y , ▁int ▁w , ▁int ▁h ) ▁{ ▁em ulated _ edge _ mc ( buf , ▁src , ▁buf _ stride , ▁src _ stride , ▁block _ w , ▁block _ h , ▁src _ x , ▁src _ y , ▁w , ▁h , ▁v fix tbl _ s se , ▁& ff _ emu _ edge _ v var _ s se , ▁h fix tbl _ mm x ext , ▁& ff _ emu _ edge _ h var _ mm x ext ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ text _ tx 3 g ( AV Codec Context ▁* av ctx , ▁Mov Text Context ▁* m ) ▁{ ▁char ▁* tx 3 g _ ptr ▁= ▁av ctx -> ex tr ad ata ; ▁int ▁i , ▁box _ size , ▁font _ length ; ▁int 8_ t ▁v _ align , ▁h _ align ; ▁int ▁style _ font ID ; ▁Style Box ▁s _ default ; ▁m -> count _ f ▁= ▁0; ▁m -> ft ab _ entries ▁= ▁0; ▁box _ size ▁= ▁BO X _ SIZE _ INITIAL ; ▁/* ▁Size ▁till ▁f tab _ entries ▁*/ ▁if ▁( av ctx -> ex tr ad ata _ size ▁< ▁box _ size ) ▁return ▁-1; ▁// ▁Display ▁Flags ▁tx 3 g _ ptr ▁+= ▁4; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ms mouse _ chr _ close ▁( struct ▁Char Driver State ▁* chr ) ▁{ ▁Mouse State ▁* mouse ▁= ▁chr -> op aque ; ▁qemu _ input _ handler _ un register ( mouse -> hs ); ▁g _ free ( mouse ); ▁g _ free ( chr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ init _ main _ loop ( void ) ▁{ ▁int ▁ret ; ▁ret ▁= ▁qemu _ signal _ init (); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁qemu _ init _ sig bus (); ▁return ▁qemu _ event _ init (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁env list _ parse ( env list _ t ▁* env list , ▁const ▁char ▁* env , ▁int ▁(* callback )( env list _ t ▁* , ▁const ▁char ▁* )) ▁{ ▁char ▁* tmp env , ▁* env var ; ▁char ▁* env save ▁= ▁NULL ; ▁assert ( callback ▁!= ▁NULL ); ▁if ▁(( env list ▁== ▁NULL ) ▁|| ▁( env ▁== ▁NULL )) ▁return ▁( E IN VAL ); ▁/* ▁* ▁We ▁need ▁to ▁make ▁temporary ▁copy ▁of ▁the ▁env ▁string ▁* ▁as ▁str tok _ r (3) ▁modifies ▁it ▁while ▁it ▁token izes . ▁*/ ▁if ▁(( tmp env ▁= ▁str dup ( env )) ▁== ▁NULL ) ▁return ▁( err no ); ▁env var

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av i _ write _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁unsigned ▁char ▁tag [5 ]; ▁unsigned ▁int ▁flags ▁= ▁0; ▁const ▁int ▁stream _ index ▁= ▁pkt -> stream _ index ; ▁int ▁size ▁= ▁pkt -> size ; ▁A VI Context ▁* avi ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁A VI Stream ▁* av ist ▁= ▁s -> streams [ stream _ index ] -> priv _ data ; ▁AV Codec Parameters ▁* par ▁= ▁s -> streams [ stream _ index ] -> codec par ; ▁while ▁( par -> block _ align ▁== ▁0 ▁&& ▁pkt -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁check _ cuda _ errors ( AV Codec Context ▁* av ctx , ▁CU result ▁err , ▁const ▁char ▁* func ) ▁{ ▁if ▁( err ▁!= ▁CUDA _ SUCCESS ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ F ATAL , ▁" >> ▁% s ▁- ▁failed ▁with ▁error ▁code ▁0 x % x \ n ", ▁func , ▁err ); ▁return ▁0; ▁} ▁return ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁show _ stream ( Writer Context ▁* w , ▁AV Format Context ▁* fmt _ ctx , ▁int ▁stream _ idx , ▁int ▁in _ program ) ▁{ ▁AV Stream ▁* stream ▁= ▁fmt _ ctx -> streams [ stream _ idx ]; ▁AV Codec Context ▁* dec _ ctx ; ▁const ▁AV Codec ▁* dec ; ▁char ▁val _ str [ 128 ]; ▁const ▁char ▁* s ; ▁AV R ational ▁s ar , ▁d ar ; ▁AV B Print ▁p buf ; ▁av _ b print _ init ( & p buf , ▁1, ▁AV _ B PRI NT _ SIZE _ UN LIMIT ED ); ▁writer _ print _ section _ header ( w , ▁in _ program ▁? ▁SE CTION _ ID _ PRO GRA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁get _ block ( Get Bit Context ▁* gb , ▁D CT E LE M ▁* block , ▁const ▁uint 8_ t ▁* scan , ▁const ▁uint 32_ t ▁* quant ) ▁{ ▁int ▁coeff , ▁i , ▁n ; ▁int 8_ t ▁ac ; ▁uint 8_ t ▁dc ▁= ▁get _ bits ( gb , ▁8 ); ▁// ▁block ▁not ▁coded ▁if ▁( dc ▁== ▁255 ) ▁// ▁number ▁of ▁non - zero ▁coefficients ▁coeff ▁= ▁get _ bits ( gb , ▁6 ); ▁if ▁( get _ bits _ count ( gb ) ▁+ ▁( coeff ▁<< ▁1) ▁>= ▁gb -> size _ in _ bits ) ▁// ▁normally ▁we ▁would ▁only ▁need ▁to ▁clear ▁the ▁( 63 ▁- ▁coeff ) ▁last ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ne on _ tr n _ u 16 ( TC G v ▁t 0, ▁TC G v ▁t 1) ▁{ ▁TC G v ▁rd , ▁tmp ; ▁rd ▁= ▁new _ tmp (); ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ sh li _ i 32 ( rd , ▁t 0, ▁16 ); ▁tc g _ gen _ and i _ i 32 ( tmp , ▁t 1, ▁0 xffff ); ▁tc g _ gen _ or _ i 32 ( rd , ▁rd , ▁tmp ); ▁tc g _ gen _ sh ri _ i 32 ( t 1, ▁t 1, ▁16 ); ▁tc g _ gen _ and i _ i 32 ( tmp , ▁t 0, ▁0 xffff 0000 ); ▁tc g _ gen _ or _ i 32 ( t 1, ▁t 1, ▁tmp ); ▁tc g _ gen _ mov _ i 32 ( t 0, ▁rd ); ▁dead _ tmp ( tmp ); ▁dead _ tmp ( rd

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ header ( OutputStream ▁* os , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁if ▁( buf _ size ▁< ▁13 ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( mem cmp ( buf , ▁" FL V ", ▁3 )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁buf ▁+= ▁13 ; ▁buf _ size ▁-= ▁13 ; ▁while ▁( buf _ size ▁>= ▁11 ▁+ ▁4) ▁{ ▁int ▁type ▁= ▁buf [0]; ▁int ▁size ▁= ▁AV _ RB 24 ( & buf [1]) ▁+ ▁11 ▁+ ▁4; ▁if ▁( size ▁> ▁buf _ size ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( type ▁== ▁8 ▁|| ▁type ▁== ▁9 ) ▁{ ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁restore _ sig context ( CP UM IP S State ▁* re gs , ▁struct ▁target _ sig context ▁* sc ) ▁{ ▁int ▁err ▁= ▁0; ▁int ▁i ; ▁__ get _ user ( re gs -> CP 0_ E PC , ▁& sc -> sc _ pc ); ▁__ get _ user ( re gs -> active _ tc . HI [0], ▁& sc -> sc _ md hi ); ▁__ get _ user ( re gs -> active _ tc . LO [0], ▁& sc -> sc _ md lo ); ▁for ▁( i ▁= ▁1; ▁i ▁< ▁32 ; ▁++ i ) ▁{ ▁__ get _ user ( re gs -> active _ tc . g pr [ i ], ▁& sc -> sc _ re gs [ i ]); ▁} ▁__ get _ user ( re gs -> active _ tc . HI [1], ▁& sc -> sc _ hi 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd h ci _ write _ block _ to _ card ( SD H CI State ▁* s ) ▁{ ▁int ▁index ▁= ▁0; ▁if ▁( s -> pr n st s ▁& ▁SD H C _ SPACE _ AVAILABLE ) ▁{ ▁if ▁( s -> n or int st sen ▁& ▁SD H C _ NI SE N _ W BU FR DY ) ▁{ ▁s -> n or int st s ▁|= ▁SD H C _ N IS _ W BU FR DY ; ▁} ▁sd h ci _ update _ irq ( s ); ▁return ; ▁} ▁if ▁( s -> tr n mod ▁& ▁SD H C _ TR NS _ BL K _ C NT _ EN ) ▁{ ▁if ▁( s -> blk cnt ▁== ▁0) ▁{ ▁return ; ▁} ▁else ▁{ ▁s -> blk cnt --; ▁} ▁} ▁for ▁( index ▁= ▁0; ▁index ▁< ▁( s -> blk size

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁A H CI Q State ▁* ah ci _ boot ( void ) ▁{ ▁A H CI Q State ▁* s ; ▁const ▁char ▁* cli ; ▁s ▁= ▁g _ m alloc 0( size of ( A H CI Q State )); ▁cli ▁= ▁"- drive ▁if = none , id = drive 0, file =% s , cache = write back , serial =% s " ▁", format = q c ow 2" ▁" ▁- M ▁q 35 ▁" ▁"- device ▁ide - hd , drive = drive 0 ▁" ▁"- global ▁ide - hd . ver =% s "; ▁s -> parent ▁= ▁q test _ pc _ boot ( cli , ▁tmp _ path , ▁" test disk ", ▁" version "); ▁alloc _ set _ flags ( s -> parent -> alloc , ▁AL LOC _ LE AK _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁address _ space _ destroy _ dispatch ( Address Space ▁* as ) ▁{ ▁Address Space Dispatch ▁* d ▁= ▁as -> dispatch ; ▁memory _ listener _ un register ( & d -> listener ); ▁g _ free ( d ); ▁as -> dispatch ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁m st _ f pg a _ read b ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁m st _ irq _ state ▁* s ▁= ▁( m st _ irq _ state ▁* ) ▁opaque ; ▁switch ▁( addr ) ▁{ ▁case ▁M ST _ LE DD AT 1: ▁return ▁s -> le dd at 1; ▁case ▁M ST _ LE DD AT 2: ▁return ▁s -> le dd at 2; ▁case ▁M ST _ LED CT RL : ▁return ▁s -> led ctrl ; ▁case ▁M ST _ GPS WR : ▁return ▁s -> gp sw r ; ▁case ▁M ST _ M SC WR 1: ▁return ▁s -> m sc wr 1; ▁case ▁M ST _ M SC WR 2: ▁return ▁s -> m sc wr 2; ▁case ▁M ST _ M SC WR 3: ▁return ▁s -> m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pci _ pi ix _ ide _ init fn ( PC II DE State ▁* d ) ▁{ ▁uint 8_ t ▁* pc i _ conf ▁= ▁d -> dev . config ; ▁pci _ conf [ PC I _ CLASS _ PRO G ] ▁= ▁0 x 80 ; ▁// ▁legacy ▁AT A ▁mode ▁pci _ config _ set _ class ( pc i _ conf , ▁P CI _ CLASS _ STORAGE _ IDE ); ▁qemu _ register _ reset ( pi ix 3_ reset , ▁d ); ▁pci _ register _ bar ( & d -> dev , ▁4, ▁0 x 10, ▁P CI _ BASE _ ADDRESS _ SPACE _ IO , ▁b md ma _ map ); ▁vm state _ register ( & d -> dev . q dev , ▁0, ▁& vm state _ ide _ pc i , ▁d ); ▁pc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ net _ pc i _ real ize ( V irt IO PC I Proxy ▁* vpc i _ dev , ▁Error ▁** err p ) ▁{ ▁Device State ▁* q dev ▁= ▁DEVICE ( vpc i _ dev ); ▁V irt ION et PC I ▁* dev ▁= ▁VI RT IO _ NET _ PC I ( vpc i _ dev ); ▁Device State ▁* v dev ▁= ▁DEVICE ( & dev -> v dev ); ▁virt io _ net _ set _ config _ size ( & dev -> v dev , ▁vpc i _ dev -> host _ features ); ▁virt io _ net _ set _ net client _ name ( & dev -> v dev , ▁q dev -> id , ▁object _ get _ typ ename ( OBJECT ( q dev ))); ▁q dev _ set _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ nv ram _ real ize ( V IO s P AP R Device ▁* dev , ▁Error ▁** err p ) ▁{ ▁s P AP R NV RAM ▁* nv ram ▁= ▁V IO _ SP AP R _ NV RAM ( dev ); ▁int ▁ret ; ▁if ▁( nv ram -> blk ) ▁{ ▁nv ram -> size ▁= ▁blk _ get length ( nv ram -> blk ); ▁ret ▁= ▁blk _ set _ perm ( nv ram -> blk , ▁BL K _ PER M _ CON SISTENT _ READ ▁| ▁BL K _ PER M _ WRITE , ▁BL K _ PER M _ ALL , ▁err p ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ; ▁} ▁} ▁else ▁{ ▁nv ram -> size ▁= ▁DEFAULT _ NV RAM _ SIZE ; ▁} ▁nv ram -> buf ▁= ▁g _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ free _ packet ( E H CI Packet ▁* p ) ▁{ ▁trace _ usb _ eh ci _ packet _ action ( p -> queue , ▁p , ▁" free "); ▁if ▁( p -> async ▁== ▁E H CI _ AS Y NC _ INF LIGHT ) ▁{ ▁usb _ cancel _ packet ( & p -> packet ); ▁usb _ packet _ un map ( & p -> packet , ▁& p -> sg l ); ▁qemu _ sg list _ destroy ( & p -> sg l ); ▁Q TAIL Q _ REMOVE ( & p -> queue -> pack ets , ▁p , ▁next ); ▁usb _ packet _ cleanup ( & p -> packet ); ▁g _ free ( p );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( nv 12 To UV )( uint 8_ t ▁* dst U , ▁uint 8_ t ▁* dst V , ▁const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁long ▁width , ▁uint 32_ t ▁* unused ) ▁{ ▁RE NAME ( nv XX to UV )( dst U , ▁dst V , ▁src 1, ▁width ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ thread _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁if ▁( av ctx -> thread _ op aque ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" av codec _ thread _ init ▁is ▁ignored ▁after ▁av codec _ open \ n "); ▁return ▁-1; ▁} ▁# if ▁HAVE _ W 32 THREADS ▁w 32 thread _ init (); ▁# end if ▁if ▁( av ctx -> codec ) ▁{ ▁validate _ thread _ parameters ( av ctx ); ▁if ▁( av ctx -> active _ thread _ type & FF _ THREAD _ S LI CE ) ▁return ▁thread _ init ( av ctx ); ▁else ▁if ▁( av ctx -> active _ thread _ type & 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁bool ▁memory _ access _ is _ direct ( Memory Region ▁* mr , ▁bool ▁is _ write ) ▁{ ▁if ▁( memory _ region _ is _ ram ( mr )) ▁{ ▁return ▁! ( is _ write ▁&& ▁mr -> readonly ); ▁} ▁if ▁( memory _ region _ is _ rom d ( mr )) ▁{ ▁return ▁! is _ write ; ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁V irt IO Device ▁* virt io _ blk _ init ( Device State ▁* dev , ▁V irt IO Bl k Conf ▁* blk ) ▁{ ▁V irt IO Block ▁* s ; ▁int ▁cy l ind ers , ▁heads , ▁secs ; ▁static ▁int ▁virt io _ blk _ id ; ▁Drive Info ▁* d info ; ▁if ▁(! blk -> conf . bs ) ▁{ ▁error _ report (" drive ▁property ▁not ▁set "); ▁return ▁NULL ; ▁} ▁if ▁(! b dr v _ is _ insert ed ( blk -> conf . bs )) ▁{ ▁error _ report (" Device ▁needs ▁media , ▁but ▁drive ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁(! blk -> serial ) ▁{ ▁/* ▁try ▁to ▁fall ▁bac

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁PC M Decode ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁sample _ size , ▁c , ▁n , ▁i ; ▁short ▁* samples ; ▁const ▁uint 8_ t ▁* src , ▁* src 8, ▁* src 2[ MAX _ CH AN NE LS ]; ▁uint 8_ t ▁* dst u 8 ; ▁int 16_ t ▁* dst _ int 16_ t ; ▁int 32_ t ▁* dst _ int 32_ t ; ▁int 64_ t ▁* dst _ int 64_ t ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁arm 9 46 _ pr bs _ write ( CPU ARM State ▁* env , ▁const ▁ARM CP Reg Info ▁* ri , ▁uint 64_ t ▁value ) ▁{ ▁if ▁( ri -> cr m ▁> ▁8) ▁{ ▁return ▁EX CP _ U DEF ; ▁} ▁env -> cp 15. c 6_ region [ ri -> cr m ] ▁= ▁value ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ host _ open ( US B Host Device ▁* dev , ▁int ▁bus _ num , ▁int ▁addr , ▁const ▁char ▁* port , ▁const ▁char ▁* prod _ name , ▁int ▁speed ) ▁{ ▁int ▁fd ▁= ▁-1, ▁ret ; ▁trace _ usb _ host _ open _ started ( bus _ num , ▁addr ); ▁if ▁( dev -> fd ▁!= ▁-1) ▁{ ▁goto ▁fail ; ▁} ▁fd ▁= ▁usb _ host _ open _ device ( bus _ num , ▁addr ); ▁if ▁( fd ▁< ▁0) ▁{ ▁goto ▁fail ; ▁} ▁D PRI NT F (" h usb : ▁opened ▁% s \ n ", ▁buf ); ▁dev -> bus _ num ▁= ▁bus _ num ; ▁dev -> addr ▁= ▁addr ; ▁str c py ( dev

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁es p _ pc i _ sc si _ init ( PC ID evice ▁* dev ) ▁{ ▁P CI ES P State ▁* pc i ▁= ▁P CI _ ES P ( dev ); ▁Device State ▁* d ▁= ▁DEVICE ( dev ); ▁E SP State ▁* s ▁= ▁& pc i -> es p ; ▁uint 8_ t ▁* pc i _ conf ; ▁Error ▁* err ▁= ▁NULL ; ▁pci _ conf ▁= ▁dev -> config ; ▁/* ▁Inter rupt ▁pin ▁A ▁*/ ▁pci _ conf [ PC I _ INTER R UP T _ P IN ] ▁= ▁0 x 01 ; ▁s -> d ma _ memory _ read ▁= ▁es p _ pc i _ d ma _ memory _ read ; ▁s -> d ma _ memory _ write ▁= ▁es p _ pc i _ d ma _ memory _ write ; ▁s -> d m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁copy _ frame ( J peg 2000 Encoder Context ▁* s ) ▁{ ▁int ▁t il eno , ▁comp no , ▁i , ▁y , ▁x ; ▁uint 8_ t ▁* line ; ▁for ▁( til eno ▁= ▁0; ▁t il eno ▁< ▁s -> num X tiles ▁* ▁s -> num Y tiles ; ▁t il eno ++){ ▁J peg 2000 Tile ▁* tile ▁= ▁s -> tile ▁+ ▁t il eno ; ▁if ▁( s -> plan ar ){ ▁for ▁( comp no ▁= ▁0; ▁comp no ▁< ▁s -> n components ; ▁comp no ++){ ▁J peg 2000 Component ▁* comp ▁= ▁tile -> comp ▁+ ▁comp no ; ▁int ▁* dst ▁= ▁comp -> data ; ▁line ▁= ▁s -> picture . data [ comp no ] ▁+ ▁co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁off _ t ▁proxy _ tel ld ir ( Fs Context ▁* ctx , ▁V 9 fs F id Open State ▁* fs ) ▁{ ▁return ▁tel ld ir ( fs -> dir ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁filter _ samples ( AV Filter Link ▁* in link , ▁AV Filter Buffer Ref ▁* ins amples ref ) ▁{ ▁A Res ample Context ▁* are sample ▁= ▁in link -> dst -> priv ; ▁const ▁int ▁n _ in ▁= ▁ins amples ref -> audio -> nb _ samples ; ▁int ▁n _ out ▁= ▁FF MAX ( n _ in ▁* ▁are sample -> ratio ▁* ▁2, ▁1); ▁AV Filter Link ▁* const ▁out link ▁= ▁in link -> dst -> outputs [0]; ▁AV Filter Buffer Ref ▁* out samples ref ▁= ▁ff _ get _ audio _ buffer ( out link , ▁AV _ PER M _ WRITE , ▁n _ out ); ▁int ▁ret ; ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ ct ts ( MO V Context ▁* c , ▁Byte IO Context ▁* pb , ▁MO V _ atom _ t ▁atom ) ▁{ ▁AV Stream ▁* st ▁= ▁c -> fc -> streams [ c -> fc -> nb _ streams -1 ]; ▁MO V Stream Context ▁* sc ▁= ▁st -> priv _ data ; ▁unsigned ▁int ▁i , ▁entries ; ▁get _ byte ( pb ); ▁/* ▁version ▁*/ ▁get _ be 24 ( pb ); ▁/* ▁flags ▁*/ ▁entries ▁= ▁get _ be 32 ( pb ); ▁if ( entries ▁>= ▁U INT _ MAX ▁/ ▁sizeof ( MO V _ st ts _ t )) ▁return ▁-1; ▁sc -> ct ts _ count ▁= ▁entries ; ▁sc -> ct ts _ data ▁= ▁av _ m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int 64_ t ▁av _ get _ int ( void ▁* obj , ▁const ▁char ▁* name , ▁const ▁AV Option ▁** o _ out ) ▁{ ▁int 64_ t ▁int num =1; ▁double ▁num =1; ▁int ▁den =1; ▁av _ get _ number ( obj , ▁name , ▁o _ out , ▁& num , ▁& den , ▁& int num ); ▁return ▁num * int num / den ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁commit _ active _ start ( Block Driver State ▁* bs , ▁Block Driver State ▁* base , ▁int 64_ t ▁speed , ▁Block dev OnError ▁on _ error , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁int 64_ t ▁length , ▁base _ length ; ▁int ▁orig _ base _ flags ; ▁orig _ base _ flags ▁= ▁b dr v _ get _ flags ( base ); ▁if ▁( b dr v _ re open ( base , ▁bs -> open _ flags , ▁err p )) ▁{ ▁return ; ▁} ▁length ▁= ▁b dr v _ get length ( bs ); ▁if ▁( length ▁< ▁0) ▁{ ▁error _ set g ( err 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mat ro sk a _ decode _ buffer ( uint 8_ t ** ▁buf , ▁int * ▁buf _ size , ▁Mat ro sk a Track ▁* track ) ▁{ ▁Mat ro sk a Track Encoding ▁* encod ings ▁= ▁track -> encod ings . elem ; ▁uint 8_ t * ▁data ▁= ▁* buf ; ▁int ▁is ize ▁= ▁* buf _ size ; ▁uint 8_ t * ▁pkt _ data ▁= ▁NULL ; ▁int ▁pkt _ size ▁= ▁is ize ; ▁int ▁result ▁= ▁0; ▁int ▁o len ; ▁switch ▁( encod ings [0]. compression . al go ) ▁{ ▁case ▁MAT RO SK A _ TRA CK _ ENCODING _ COMP _ HEADER STRI P : ▁return ▁encodings [0]. compression 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁alpha _ cpu _ un assigned _ access ( CPU State ▁* cs , ▁hw addr ▁addr , ▁bool ▁is _ write , ▁bool ▁is _ exec , ▁int ▁unused , ▁unsigned ▁size ) ▁{ ▁Alpha CPU ▁* cpu ▁= ▁AL PHA _ CPU ( cs ); ▁CPU Alpha State ▁* env ▁= ▁& cpu -> env ; ▁env -> tr ap _ arg 0 ▁= ▁addr ; ▁env -> tr ap _ arg 1 ▁= ▁is _ write ▁? ▁1 ▁: ▁0; ▁dynamic _ ex cp ( env , ▁0, ▁EX CP _ M CH K , ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ serial _ init _ pc i ( PC ID evice ▁* pc i _ dev ) ▁{ ▁V irt IO PC I Proxy ▁* proxy ▁= ▁DO _ UP CAST ( V irt IO PC I Proxy , ▁pci _ dev , ▁pci _ dev ); ▁V irt IO Device ▁* v dev ; ▁if ▁( proxy -> class _ code ▁!= ▁P CI _ CLASS _ COM M UN IC ATION _ OTHER ▁&& ▁proxy -> class _ code ▁!= ▁P CI _ CLASS _ DISPLAY _ OTHER ▁&& ▁/* ▁qemu ▁0.10 ▁*/ ▁proxy -> class _ code ▁!= ▁P CI _ CLASS _ OTH ERS ) ▁/* ▁qemu - k vm ▁*/ ▁proxy -> class _ code ▁= ▁P CI _ CLASS _ COM M UN IC ATION _ OTHER ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q mp _ ch ard ev _ open _ serial ( const ▁char ▁* id , ▁Ch ard ev Backend ▁* backend , ▁Ch ard ev Return ▁* ret , ▁Error ▁** err p ) ▁{ ▁Ch ard ev Host dev ▁* serial ▁= ▁backend -> serial ; ▁int ▁fd ; ▁fd ▁= ▁q mp _ ch ard ev _ open _ file _ source ( serial -> device , ▁O _ RD WR , ▁err p ); ▁if ▁( fd ▁< ▁0) ▁{ ▁return ▁NULL ; ▁} ▁qemu _ set _ non block ( fd ); ▁return ▁qemu _ chr _ open _ tty _ fd ( fd ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁alpha _ pc i _ v ga _ setup ( PC I Bus ▁* pc i _ bus ) ▁{ ▁switch ▁( v ga _ interface _ type ) ▁{ ▁# if def ▁CONFIG _ S PI CE ▁case ▁V GA _ Q X L : ▁pci _ create _ simple ( pc i _ bus , ▁-1, ▁" q xl - v ga "); ▁return ; ▁# end if ▁case ▁V GA _ CI RR US : ▁pci _ cir r us _ v ga _ init ( pc i _ bus ); ▁return ; ▁case ▁V GA _ VM WARE : ▁if ▁( pc i _ v ms v ga _ init ( pc i _ bus )) ▁{ ▁return ; ▁} ▁break ; ▁} ▁/* ▁If ▁V GA ▁is ▁enabled ▁at ▁all , ▁and ▁one ▁of ▁the ▁above ▁didn ' t ▁work , ▁then ▁fall

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ u art _ s ▁* om ap 2_ u art _ init ( struct ▁o map _ target _ agent _ s ▁* ta , ▁qemu _ irq ▁irq , ▁o map _ cl k ▁f cl k , ▁o map _ cl k ▁i cl k , ▁qemu _ irq ▁tx d ma , ▁qemu _ irq ▁rx d ma , ▁Char Driver State ▁* chr ) ▁{ ▁target _ ph ys _ addr _ t ▁base ▁= ▁o map _ l 4_ attach ( ta , ▁0, ▁0); ▁struct ▁o map _ u art _ s ▁* s ▁= ▁o map _ u art _ init ( base , ▁irq , ▁f cl k , ▁i cl k , ▁tx d ma , ▁rx d ma , ▁chr ); ▁int ▁i om em type ▁= ▁cpu _ register _ io _ memory (0, ▁o map _ u art _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁Q EM U _ NO RETURN ▁help ( void ) ▁{ ▁const ▁char ▁* help _ msg ▁= ▁Q EM U _ IM G _ VERSION ▁" usage : ▁qemu - img ▁[ standard ▁options ] ▁command ▁[ command ▁options ]\ n " ▁" Q EM U ▁disk ▁image ▁utility \ n " ▁"\ n " ▁" ▁'- h ', ▁'-- help ' ▁display ▁this ▁help ▁and ▁exit \ n " ▁" ▁'- V ', ▁'-- version ' ▁output ▁version ▁information ▁and ▁exit \ n " ▁" ▁'- T ', ▁'-- trace ' ▁[[ enable = ] < pattern > ][ , events =< file > ][ , file =< file > ]\ n " ▁" ▁specify ▁tracing ▁options \ n " ▁"

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁coroutine _ fn ▁b dr v _ create _ co _ entry ( void ▁* op aque ) ▁{ ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁Create Co ▁* cc o ▁= ▁opaque ; ▁assert ( cc o -> dr v ); ▁ret ▁= ▁c co -> dr v -> b dr v _ create ( cc o -> filename , ▁c co -> opts , ▁& local _ err ); ▁if ▁( local _ err ) ▁{ ▁error _ propag ate ( & cc o -> err , ▁local _ err ); ▁} ▁c co -> ret ▁= ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ mt c 0_ entry hi ( CP UM IP S State ▁* env , ▁target _ ulong ▁arg 1) ▁{ ▁target _ ulong ▁old , ▁val , ▁mask ; ▁mask ▁= ▁( TARGET _ PAGE _ MASK ▁<< ▁1) ▁| ▁env -> CP 0_ Entry Hi _ AS ID _ mask ; ▁if ▁( (( env -> CP 0_ Config 4 ▁>> ▁CP 0 C 4_ IE ) ▁& ▁0 x 3) ▁>= ▁2) ▁{ ▁mask ▁|= ▁1 ▁<< ▁CP 0 En Hi _ E H IN V ; ▁} ▁/* ▁1 k ▁pages ▁not ▁implemented ▁*/ ▁# if ▁defined ( TARGET _ M IP S 64) ▁if ▁( env -> ins n _ flags ▁& ▁I SA _ M IP S 32 R 6) ▁{ ▁int ▁entry hi _ r ▁= ▁extract 64 ( arg 1, ▁6 2, 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁vm x net 3_ verify _ driver _ magic ( hw addr ▁d sh mem ) ▁{ ▁return ▁( VM X NET 3_ READ _ DR V _ SHA RED 32 ( d sh mem , ▁magic ) ▁== ▁VM X NET 3_ RE V 1_ M AGIC ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ram _ addr _ t ▁qemu _ ram _ addr _ from _ host _ n of ail ( void ▁* ptr ) ▁{ ▁ram _ addr _ t ▁ram _ addr ; ▁if ▁( q emu _ ram _ addr _ from _ host ( ptr , ▁& ram _ addr )) ▁{ ▁f printf ( stderr , ▁" Bad ▁ram ▁pointer ▁% p \ n ", ▁ptr ); ▁abort (); ▁} ▁return ▁ram _ addr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ format 80 ( V qa Context ▁* s , ▁int ▁src _ size , ▁unsigned ▁char ▁* dest , ▁int ▁dest _ size , ▁int ▁check _ size ) ▁{ ▁int ▁dest _ index ▁= ▁0; ▁int ▁count , ▁opcode , ▁start ; ▁int ▁src _ pos ; ▁unsigned ▁char ▁color ; ▁int ▁i ; ▁start ▁= ▁by test ream 2_ t ell ( & s -> gb ); ▁while ▁( by test ream 2_ t ell ( & s -> gb ) ▁- ▁start ▁< ▁src _ size ) ▁{ ▁opcode ▁= ▁by test ream 2_ get _ byte ( & s -> gb ); ▁av _ d log ( s -> av ctx , ▁" op code ▁%02 X : ▁", ▁opcode ); ▁/* ▁0 x 80 ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁zero 12 v _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁int ▁line ▁= ▁0, ▁ret ; ▁const ▁int ▁width ▁= ▁av ctx -> width ; ▁AV Frame ▁* pic ▁= ▁data ; ▁uint 16_ t ▁* y , ▁* u , ▁* v ; ▁const ▁uint 8_ t ▁* line _ end , ▁* src ▁= ▁av pk t -> data ; ▁int ▁stride ▁= ▁av ctx -> width ▁* ▁8 ▁/ ▁3; ▁if ▁( width ▁== ▁1) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Width ▁1 ▁not ▁supported .\ n "); ▁return ▁A VER ROR _ IN V ALI DD AT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁test _ bit ( uint 32_ t ▁* field , ▁int ▁bit ) ▁{ ▁return ▁( field [ bit ▁>> ▁5] ▁& ▁1 ▁<< ▁( bit ▁& ▁0 x 1 F )) ▁!= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str t oul _ decimal ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁"01 23 "; ▁char ▁f ▁= ▁' X '; ▁const ▁char ▁* end ptr ▁= ▁& f ; ▁unsigned ▁long ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str t oul ( str , ▁& end ptr , ▁10, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert _ cmp int ( res , ▁== , ▁123 ); ▁g _ assert ( end ptr ▁== ▁str ▁+ ▁str len ( str )); ▁str ▁= ▁"123 "; ▁res ▁= ▁999 ; ▁end ptr ▁= ▁& f ; ▁err ▁= ▁qemu _ str t oul ( str , ▁& end ptr , ▁0, ▁& res ); ▁g _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pi ix 3_ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁PC ID evice Class ▁* k ▁= ▁P CI _ DEVICE _ CLASS ( k lass ); ▁dc -> desc ▁= ▁" IS A ▁bridge "; ▁dc -> v ms d ▁= ▁& vm state _ pi ix 3; ▁dc -> no _ user ▁= ▁1, ▁k -> no _ hot plug ▁= ▁1; ▁k -> init ▁= ▁pi ix 3_ init fn ; ▁k -> config _ write ▁= ▁pi ix 3_ write _ config ; ▁k -> vendor _ id ▁= ▁P CI _ VE ND OR _ ID _ INT EL ; ▁/* ▁82 37 1 SB ▁PI IX 3 ▁P CI - to - IS A ▁bridge

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁q io _ channel _ web sock _ source _ dispatch ( G Source ▁* source , ▁G Source Func ▁callback , ▁g pointer ▁user _ data ) ▁{ ▁Q IO Channel Func ▁func ▁= ▁( Q IO Channel Func ) callback ; ▁Q IO Channel Web sock Source ▁* w source ▁= ▁( Q IO Channel Web sock Source ▁* ) source ; ▁G IO Condition ▁cond ▁= ▁0; ▁if ▁( w source -> wi oc -> raw input . offset ) ▁{ ▁cond ▁|= ▁G _ IO _ IN ; ▁} ▁if ▁( w source -> wi oc -> raw output . offset ▁< ▁Q IO _ CHANNEL _ WEB SO CK _ MAX _ BUFFER ) ▁{ ▁cond ▁|= ▁G _ IO _ OUT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ac pi _ ds dt _ add _ pc i ( A ml ▁* scope , ▁const ▁Mem Map Entry ▁* mem map , ▁uint 32_ t ▁irq , ▁bool ▁use _ high mem ) ▁{ ▁A ml ▁* method , ▁* cr s , ▁* if ctx , ▁* UUID , ▁* if ctx 1, ▁* else ctx , ▁* buf ; ▁int ▁i , ▁bus _ no ; ▁hw addr ▁base _ mm io ▁= ▁mem map [ VI RT _ PC IE _ MM IO ]. base ; ▁hw addr ▁size _ mm io ▁= ▁mem map [ VI RT _ PC IE _ MM IO ]. size ; ▁hw addr ▁base _ p io ▁= ▁mem map [ VI RT _ PC IE _ PIO ]. base ; ▁hw addr ▁size _ p io ▁= ▁mem map [ VI RT _ PC IE _ PIO ]

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ parent _ open ( Block Driver State ▁* bs ) ▁{ ▁char ▁* p _ name ; ▁char ▁desc [ DESC _ SIZE ▁+ ▁1 ]; ▁B DR V V mdk State ▁* s ▁= ▁bs -> op aque ; ▁desc [ DESC _ SIZE ] ▁= ▁'\ 0 '; ▁if ▁( b dr v _ p read ( bs -> file , ▁s -> desc _ offset , ▁desc , ▁DESC _ SIZE ) ▁!= ▁DESC _ SIZE ) ▁{ ▁return ▁-1; ▁} ▁if ▁(( p _ name ▁= ▁str str ( desc ," parent FileName Hint ")) ▁!= ▁NULL ) ▁{ ▁char ▁* end _ name ; ▁p _ name ▁+= ▁sizeof (" parent FileName Hint ") ▁+ ▁1; ▁if ▁(( end _ name ▁= ▁str chr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Memory Region Section ▁address _ space _ do _ translate ( Address Space ▁* as , ▁hw addr ▁addr , ▁hw addr ▁* x lat , ▁hw addr ▁* pl en , ▁bool ▁is _ write , ▁bool ▁is _ mm io ) ▁{ ▁IO MM UT LB Entry ▁i ot lb ; ▁Memory Region Section ▁* section ; ▁Memory Region ▁* mr ; ▁for ▁( ; ;) ▁{ ▁Address Space Dispatch ▁* d ▁= ▁atomic _ rc u _ read ( & as -> dispatch ); ▁section ▁= ▁address _ space _ translate _ internal ( d , ▁addr , ▁& addr , ▁pl en , ▁is _ mm io ); ▁mr ▁= ▁section -> mr ; ▁if ▁(! mr -> io

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁read _ guest _ mem ( void ) ▁{ ▁uint 32_ t ▁* guest _ mem ; ▁g int 64 ▁end _ time ; ▁int ▁i , ▁j ; ▁size _ t ▁size ; ▁g _ mut ex _ lock ( data _ mut ex ); ▁end _ time ▁= ▁g _ get _ mon otonic _ time () ▁+ ▁5 ▁* ▁G _ TIME _ SP AN _ SECOND ; ▁while ▁(! fds _ num ) ▁{ ▁if ▁(! _ cond _ wait _ until ( data _ cond , ▁data _ mut ex , ▁end _ time )) ▁{ ▁/* ▁timeout ▁has ▁passed ▁*/ ▁g _ assert ( fds _ num ); ▁break ; ▁} ▁} ▁/* ▁check ▁for ▁sanity ▁*/ ▁g _ assert _ cmp int ( fds _ num , ▁> , ▁0); ▁g

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁qemu _ rd ma _ poll ( RD MA Context ▁* rd ma , ▁uint 64_ t ▁* wr _ id _ out , ▁uint 32_ t ▁* byte _ len ) ▁{ ▁int ▁ret ; ▁struct ▁ib v _ wc ▁wc ; ▁uint 64_ t ▁wr _ id ; ▁ret ▁= ▁ib v _ poll _ c q ( rd ma -> c q , ▁1, ▁& wc ); ▁if ▁(! ret ) ▁{ ▁* wr _ id _ out ▁= ▁R D MA _ WR ID _ NONE ; ▁return ▁0; ▁} ▁if ▁( ret ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" ib v _ poll _ c q ▁return ▁% d ! \ n ", ▁ret ); ▁return ▁ret ; ▁} ▁wr _ id ▁= ▁wc . wr _ id ▁& ▁R D MA _ WR ID _ TYPE _ MASK ; ▁if ▁( wc . st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ ft yp ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁uint 32_ t ▁minor _ ver ; ▁int ▁comp _ brand _ size ; ▁char ▁minor _ ver _ str [ 11 ]; ▁/* ▁32 ▁bit ▁integer ▁-> ▁10 ▁digits ▁+ ▁null ▁*/ ▁char * ▁comp _ br ands _ str ; ▁uint 8_ t ▁type [5] ▁= ▁{0 }; ▁av io _ read ( pb , ▁type , ▁4 ); ▁if ▁( str cmp ( type , ▁" qt ▁")) ▁c -> is om ▁= ▁1; ▁av _ log ( c -> fc , ▁AV _ LOG _ DEBUG , ▁" ISO : ▁File ▁Type ▁M ajor ▁B rand : ▁% .4 s \ n ", ( char ▁* ) & type ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q pc i _ pc _ config _ writ ew ( Q PC I Bus ▁* bus , ▁int ▁dev fn , ▁uint 8_ t ▁offset , ▁uint 16_ t ▁value ) ▁{ ▁out l (0 x cf 8, ▁(1 ▁<< ▁3 1) ▁| ▁( dev fn ▁<< ▁8) ▁| ▁offset ); ▁out w (0 x cf c , ▁value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ stream _ header ( N UT Context ▁* n ut ){ ▁AV Format Context ▁* s = ▁nut -> av f ; ▁Byte IO Context ▁* bc ▁= ▁& s -> pb ; ▁Stream Context ▁* st c ; ▁int ▁class , ▁stream _ id ; ▁uint 64_ t ▁tmp , ▁end ; ▁AV Stream ▁* st ; ▁end = ▁get _ pack eth eader ( n ut , ▁bc , ▁1); ▁end ▁+= ▁url _ ft ell ( bc ); ▁GET _ V ( stream _ id , ▁tmp ▁< ▁s -> nb _ streams ▁&& ▁! n ut -> stream [ tmp ]. time _ base ); ▁st c = ▁& n ut -> stream [ stream _ id ]; ▁st ▁= ▁s -> streams [ stream _ id ]; ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁lz _ unpack ( const ▁unsigned ▁char ▁* src , ▁unsigned ▁char ▁* dest , ▁int ▁dest _ len ) ▁{ ▁const ▁unsigned ▁char ▁* s ; ▁unsigned ▁char ▁* d ; ▁unsigned ▁char ▁* d _ end ; ▁unsigned ▁char ▁queue [ QUEUE _ SIZE ]; ▁unsigned ▁int ▁q pos ; ▁unsigned ▁int ▁dat al eft ; ▁unsigned ▁int ▁chain of s ; ▁unsigned ▁int ▁chain len ; ▁unsigned ▁int ▁spec len ; ▁unsigned ▁char ▁tag ; ▁unsigned ▁int ▁i , ▁j ; ▁s ▁= ▁src ; ▁d ▁= ▁dest ; ▁d _ end ▁= ▁d ▁+ ▁dest _ len ; ▁dat al eft ▁= ▁AV _ RL 32 ( s ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sc si _ req _ cancel ( SC SI Request ▁* req ) ▁{ ▁trace _ sc si _ req _ cancel ( req -> dev -> id , ▁req -> lun , ▁req -> tag ); ▁if ▁(! req -> en queued ) ▁{ ▁return ; ▁} ▁sc si _ req _ ref ( req ); ▁sc si _ req _ de queue ( req ); ▁req -> io _ cancel ed ▁= ▁true ; ▁if ▁( req -> ai oc b ) ▁{ ▁blk _ a io _ cancel ( req -> ai oc b ); ▁} ▁else ▁{ ▁sc si _ req _ cancel _ complete ( req ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ exception _ return ( Dis as Context ▁* s , ▁TC G v _ i 32 ▁pc ) ▁{ ▁TC G v _ i 32 ▁tmp ; ▁store _ reg ( s , ▁15, ▁pc ); ▁tmp ▁= ▁load _ cpu _ field ( sp sr ); ▁gen _ set _ c ps r ( tmp , ▁C PS R _ ER ET _ MASK ); ▁tc g _ temp _ free _ i 32 ( tmp ); ▁s -> is _ j mp ▁= ▁DIS AS _ UPDATE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q io _ channel _ web sock _ write _ close ( Q IO Channel Web sock ▁* i oc , ▁uint 16_ t ▁code , ▁const ▁char ▁* reason ) ▁{ ▁struct ▁i ove c ▁i ov ; ▁buffer _ re serve ( & i oc -> raw output , ▁2 ▁+ ▁( reason ▁? ▁str len ( reason ) ▁: ▁0 )); ▁* ( uint 16_ t ▁* )( i oc -> raw output . buffer ▁+ ▁i oc -> raw output . offset ) ▁= ▁cpu _ to _ be 16 ( code ); ▁i oc -> raw output . offset ▁+= ▁2; ▁if ▁( reason ) ▁{ ▁buffer _ append ( & i oc -> raw output , ▁reason , ▁str len ( reason )); ▁} ▁i ov

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁f ad t _ setup ( Ac pi F ad t Descriptor Rev 1 ▁* f ad t , ▁Ac pi Pm Info ▁* pm ) ▁{ ▁f ad t -> model ▁= ▁1; ▁f ad t -> reserved 1 ▁= ▁0; ▁f ad t -> sc i _ int ▁= ▁cpu _ to _ le 16 ( pm -> sc i _ int ); ▁f ad t -> sm i _ cmd ▁= ▁cpu _ to _ le 32 ( AC PI _ PORT _ S MI _ CMD ); ▁f ad t -> ac pi _ enable ▁= ▁pm -> ac pi _ enable _ cmd ; ▁f ad t -> ac pi _ disable ▁= ▁pm -> ac pi _ disable _ cmd ; ▁/* ▁EVT , ▁C NT , ▁T MR ▁offset ▁matches ▁hw / ac pi / core . c ▁*/ ▁f ad t -> pm 1 a _ evt _ blk

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ac pi _ pm 1_ cnt _ write ( AC PI REG S ▁* ar , ▁uint 16_ t ▁val ) ▁{ ▁ar -> pm 1. cnt . cnt ▁= ▁val ▁& ▁~ ( AC PI _ BIT MASK _ S LE EP _ ENABLE ); ▁if ▁( val ▁& ▁AC PI _ BIT MASK _ S LE EP _ ENABLE ) ▁{ ▁/* ▁change ▁suspend ▁type ▁*/ ▁uint 16_ t ▁sus _ typ ▁= ▁( val ▁>> ▁10) ▁& ▁7 ; ▁switch ( s us _ typ ) ▁{ ▁case ▁0: ▁/* ▁soft ▁power ▁off ▁*/ ▁qemu _ system _ shutdown _ request (); ▁break ; ▁case ▁1: ▁/* ▁AC PI _ BIT MASK _ WA KE _ STATUS ▁should ▁be ▁set ▁on ▁resume . ▁P ret end ▁that ▁resume ▁w

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁win 32_ re arm _ timer ( struct ▁qemu _ alarm _ timer ▁* t ) ▁{ ▁struct ▁qemu _ alarm _ win 32 ▁* data ▁= ▁t -> priv ; ▁uint 64_ t ▁nearest _ delta _ us ; ▁if ▁(! active _ tim ers [ Q EM U _ T IMER _ RE AL TIME ] ▁&& ▁! active _ tim ers [ Q EM U _ T IMER _ VI RTUAL ]) ▁return ; ▁nearest _ delta _ us ▁= ▁qemu _ next _ dead line _ dy nt ick (); ▁nearest _ delta _ us ▁/= ▁1000 ; ▁time Kill Event ( data -> timer Id ); ▁data -> timer Id ▁= ▁time Set Event (1, ▁data -> period , ▁host _ alarm _ ha

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q api _ de alloc _ end _ struct ( Visitor ▁* v , ▁Error ▁** err p ) ▁{ ▁Q api De alloc Visitor ▁* q ov ▁= ▁to _ q ov ( v ); ▁void ▁** obj ▁= ▁q api _ de alloc _ pop ( q ov ); ▁if ▁( obj ) ▁{ ▁g _ free (* obj ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁file _ completion ( const ▁char ▁* input ) ▁{ ▁DIR ▁* ff s ; ▁struct ▁dire nt ▁* d ; ▁char ▁path [10 24 ]; ▁char ▁file [10 24 ], ▁file _ prefix [10 24 ]; ▁int ▁input _ path _ len ; ▁const ▁char ▁* p ; ▁p ▁= ▁str r chr ( input , ▁'/ '); ▁if ▁(! p ) ▁{ ▁input _ path _ len ▁= ▁0; ▁p str c py ( file _ prefix , ▁sizeof ( file _ prefix ), ▁input ); ▁p str c py ( path , ▁sizeof ( path ), ▁". "); ▁} ▁else ▁{ ▁input _ path _ len ▁= ▁p ▁- ▁input ▁+ ▁1; ▁mem c py ( path , ▁input , ▁input _ path _ len 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁set _ int 8 ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Device State ▁* dev ▁= ▁DEVICE ( obj ); ▁Property ▁* prop ▁= ▁opaque ; ▁int 8_ t ▁* ptr ▁= ▁q dev _ get _ prop _ ptr ( dev , ▁prop ); ▁Error ▁* local _ err ▁= ▁NULL ; ▁int 64_ t ▁value ; ▁if ▁( dev -> state ▁!= ▁DEV _ STATE _ CREATED ) ▁{ ▁error _ set ( err p , ▁Q ERR _ PERMISSION _ DE NI ED ); ▁return ; ▁} ▁visit _ type _ int ( v , ▁& value , ▁name , ▁& local _ err ); ▁if ▁( local

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁enter _ migration _ cor outine ( void ▁* op aque ) ▁{ ▁Cor outine ▁* co ▁= ▁opaque ; ▁qemu _ cor outine _ enter ( co , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ channel _ resid ues ( W mall Decode Ctx ▁* s , ▁int ▁ch , ▁int ▁tile _ size ) ▁{ ▁int ▁i ▁= ▁0; ▁unsigned ▁int ▁a ve _ mean ; ▁s -> trans ient [ ch ] ▁= ▁get _ bits 1( & s -> gb ); ▁if ▁( s -> trans ient [ ch ]) ▁{ ▁s -> trans ient _ pos [ ch ] ▁= ▁get _ bits ( & s -> gb , ▁av _ log 2( tile _ size )); ▁if ▁( s -> trans ient _ pos [ ch ]) ▁s -> trans ient [ ch ] ▁= ▁0; ▁s -> channel [ ch ]. trans ient _ counter ▁= ▁FF MAX ( s -> channel [ ch ]. trans ient _ counter , ▁s -> samples _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁c ina udio _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁C in Audio Context ▁* c in ▁= ▁av ctx -> priv _ data ; ▁const ▁uint 8_ t ▁* src ▁= ▁buf ; ▁int 16_ t ▁* samples ▁= ▁data ; ▁int ▁delta ; ▁buf _ size ▁= ▁FF MIN ( buf _ size , ▁* data _ size /2 ); ▁delta ▁= ▁c in -> delta ; ▁if ▁( c in -> initial _ decode _ frame ) ▁{ ▁c in -> initial 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rv 34 _ pred _ mv _ rv 3( RV 34 Dec Context ▁* r , ▁int ▁block _ type , ▁int ▁dir ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& r -> s ; ▁int ▁mv _ pos ▁= ▁s -> mb _ x ▁* ▁2 ▁+ ▁s -> mb _ y ▁* ▁2 ▁* ▁s -> b 8_ stride ; ▁int ▁A [2] ▁= ▁{0 }, ▁B [2], ▁C [2 ]; ▁int ▁i , ▁j , ▁k ; ▁int ▁mx , ▁my ; ▁int ▁avail _ index ▁= ▁avail _ indexes [0]; ▁if ( r -> avail _ cache [ avail _ index ▁- ▁1] ){ ▁A [0] ▁= ▁s -> current _ picture _ ptr -> f . m otion _ val [0] [ mv _ pos ▁- ▁1] [0]; ▁A [1] ▁= ▁s -> current _ p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ pa io _ init ( struct ▁qemu _ pa io init ▁* a io init ) ▁{ ▁int ▁ret ; ▁ret ▁= ▁p thread _ attr _ init ( & attr ); ▁if ▁( ret ) ▁die 2( ret , ▁" pth read _ attr _ init "); ▁ret ▁= ▁p thread _ attr _ set detach state ( & attr , ▁P THREAD _ CREATE _ DE TA CHED ); ▁if ▁( ret ) ▁die 2( ret , ▁" pth read _ attr _ set detach state "); ▁TA IL Q _ INIT ( & request _ list ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁d print ( int ▁level , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁va _ list ▁args ; ▁if ▁( level ▁<= ▁debug ) ▁{ ▁va _ start ( args , ▁fmt ); ▁vf printf ( stderr , ▁fmt , ▁args ); ▁va _ end ( args ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁s 39 0_ pc i host _ hot _ plug ( Hot plug Handler ▁* hot plug _ dev , ▁Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁PC ID evice ▁* pc i _ dev ▁= ▁P CI _ DEVICE ( dev ); ▁S 390 PC I Bus Device ▁* pb dev ; ▁S 390 pc i State ▁* s ▁= ▁S 39 0_ PC I _ HOST _ BR ID GE ( pc i _ device _ root _ bus ( pc i _ dev ) ▁-> q bus . parent ); ▁pb dev ▁= ▁& s -> pb dev [ PC I _ SL OT ( pc i _ dev -> dev fn ) ]; ▁pb dev -> f id ▁= ▁s 39 0_ pc i _ get _ pf id ( pc i _ dev ); ▁pb dev -> pd ev ▁= ▁pci _ dev ; ▁p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁p xa 2 xx _ mm _ read ( void ▁* op aque , ▁hw addr ▁addr , ▁unsigned ▁size ) ▁{ ▁P XA 2 xx State ▁* s ▁= ▁( P XA 2 xx State ▁* ) ▁opaque ; ▁switch ▁( addr ) ▁{ ▁case ▁M DC NF G ▁... ▁SA 11 10 : ▁if ▁(( addr ▁& ▁3) ▁== ▁0) ▁return ▁s -> mm _ re gs [ addr ▁>> ▁2 ]; ▁default : ▁printf ("% s : ▁Bad ▁register ▁" ▁REG _ F MT ▁"\ n ", ▁__ FUNCTION __, ▁addr ); ▁break ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v host _ verify _ ring _ mappings ( struct ▁v host _ dev ▁* dev , ▁uint 64_ t ▁start _ addr , ▁uint 64_ t ▁size ) ▁{ ▁int ▁i , ▁j ; ▁int ▁r ▁= ▁0; ▁const ▁char ▁* part _ name [] ▁= ▁{ ▁" descriptor ▁table ", ▁" available ▁ring ", ▁" used ▁ring " ▁}; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁dev -> nv qs ; ▁++ i ) ▁{ ▁struct ▁v host _ virt queue ▁* v q ▁= ▁dev -> v qs ▁+ ▁i ; ▁j ▁= ▁0; ▁r ▁= ▁v host _ verify _ ring _ part _ mapping ( v q -> desc , ▁v q -> desc _ ph ys , ▁v q -> desc _ size , ▁start _ addr , ▁s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ ram _ re map ( ram _ addr _ t ▁addr , ▁ram _ addr _ t ▁length ) ▁{ ▁RAM Block ▁* block ; ▁ram _ addr _ t ▁offset ; ▁int ▁flags ; ▁void ▁* area , ▁* v addr ; ▁Q TAIL Q _ FORE A CH ( block , ▁& ram _ list . blocks , ▁next ) ▁{ ▁offset ▁= ▁addr ▁- ▁block -> offset ; ▁if ▁( offset ▁< ▁block -> length ) ▁{ ▁v addr ▁= ▁block -> host ▁+ ▁offset ; ▁if ▁( block -> flags ▁& ▁RAM _ PRE AL LOC _ MASK ) ▁{ ▁; ▁} ▁else ▁if ▁( x en _ enabled ()) ▁{ ▁abort (); ▁} ▁else ▁{ ▁flags ▁= ▁MAP _ FIX ED ; ▁m un map

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁const ▁char ▁* object _ get _ typ ename ( Object ▁* obj ) ▁{ ▁return ▁obj -> class -> type -> name ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁va api _ build _ decoder _ config ( VA AP ID ec oder Context ▁* ctx , ▁AV Codec Context ▁* av ctx , ▁int ▁fallback _ allowed ) ▁{ ▁AV VA AP ID evice Context ▁* hw ctx ▁= ▁ctx -> device -> hw ctx ; ▁AV VA API H W Config ▁* hw config ▁= ▁NULL ; ▁AV H W Frames Constraints ▁* constraints ▁= ▁NULL ; ▁V A Status ▁v as ; ▁int ▁err , ▁i , ▁j ; ▁int ▁log level ▁= ▁fallback _ allowed ▁? ▁AV _ LOG _ VER BOSE ▁: ▁AV _ LOG _ ERROR ; ▁const ▁AV Codec Descriptor ▁* codec _ desc ; ▁const ▁AV Pix F mt Descri

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse ( AV Codec Parser Context ▁* ctx , ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁** out _ data , ▁int ▁* out _ size , ▁const ▁uint 8_ t ▁* data , ▁int ▁size ) ▁{ ▁V P 9 Parse Context ▁* s ▁= ▁ctx -> priv _ data ; ▁int ▁marker ; ▁if ▁( size ▁<= ▁0) ▁{ ▁* out _ size ▁= ▁0; ▁* out _ data ▁= ▁data ; ▁return ▁0; ▁} ▁if ▁( s -> n _ frames ▁> ▁0) ▁{ ▁* out _ data ▁= ▁data ; ▁* out _ size ▁= ▁s -> size [ -- s -> n _ frames ]; ▁parse _ frame ( ctx , ▁* out _ data , ▁* out _ size ); ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ram _ init 1( Sys Bus Device ▁* dev ) ▁{ ▁Ram Device ▁* d ▁= ▁S UN 4 U _ RAM ( dev ); ▁memory _ region _ init _ ram ( & d -> ram , ▁OBJECT ( d ), ▁" sun 4 u . ram ", ▁d -> size , ▁& error _ abort ); ▁vm state _ register _ ram _ global ( & d -> ram ); ▁sys bus _ init _ mm io ( dev , ▁& d -> ram ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁stop _ t co ( const ▁TestData ▁* d ) ▁{ ▁uint 32_ t ▁val ; ▁val ▁= ▁q pc i _ io _ read w ( d -> dev , ▁d -> t co _ io _ base ▁+ ▁T CO 1_ C NT ); ▁val ▁|= ▁T CO _ T MR _ H LT ; ▁q pc i _ io _ writ ew ( d -> dev , ▁d -> t co _ io _ base ▁+ ▁T CO 1_ C NT , ▁val ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ put _ be 32 ( Q EM U File ▁* f , ▁unsigned ▁int ▁v ) ▁{ ▁qemu _ put _ byte ( f , ▁v ▁>> ▁24 ); ▁qemu _ put _ byte ( f , ▁v ▁>> ▁16 ); ▁qemu _ put _ byte ( f , ▁v ▁>> ▁8 ); ▁qemu _ put _ byte ( f , ▁v ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁unsigned ▁char ▁* seq _ unpack _ r le _ block ( const ▁unsigned ▁char ▁* src , ▁unsigned ▁char ▁* dst , ▁int ▁dst _ size ) ▁{ ▁int ▁i , ▁len , ▁sz ; ▁Get Bit Context ▁gb ; ▁int ▁code _ table [ 64 ]; ▁/* ▁get ▁the ▁r le ▁codes ▁( at ▁most ▁64 ▁bytes ) ▁*/ ▁init _ get _ bits ( & gb , ▁src , ▁64 ▁* ▁8 ); ▁for ▁( i ▁= ▁0, ▁sz ▁= ▁0; ▁i ▁< ▁64 ▁&& ▁sz ▁< ▁dst _ size ; ▁i ++) ▁{ ▁code _ table [ i ] ▁= ▁get _ sb its ( & gb , ▁4 ); ▁sz ▁+= ▁FF AB S ( code _ table [ i ]); ▁} ▁src ▁+= ▁( get _ bits 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁b dr v _ is _ first _ non _ filter ( Block Driver State ▁* candidate ) ▁{ ▁Block Driver State ▁* bs ; ▁B dr v Next Iterator ▁* it ▁= ▁NULL ; ▁/* ▁walk ▁down ▁the ▁bs ▁forest ▁recursively ▁*/ ▁while ▁(( it ▁= ▁b dr v _ next ( it , ▁& bs )) ▁!= ▁NULL ) ▁{ ▁bool ▁perm ; ▁/* ▁try ▁to ▁recurse ▁in ▁this ▁top ▁level ▁bs ▁*/ ▁perm ▁= ▁b dr v _ rec urse _ is _ first _ non _ filter ( bs , ▁candidate ); ▁/* ▁candidate ▁is ▁the ▁first ▁non ▁filter ▁*/ ▁if ▁( perm ) ▁{ ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v host _ user _ set _ mem _ table ( struct ▁v host _ dev ▁* dev , ▁struct ▁v host _ memory ▁* mem ) ▁{ ▁int ▁f ds [ V HOST _ MEMORY _ MAX _ N REGION S ]; ▁int ▁i , ▁fd ; ▁size _ t ▁fd _ num ▁= ▁0; ▁bool ▁reply _ supported ▁= ▁virt io _ has _ feature ( dev -> protocol _ features , ▁V HOST _ USER _ PROTOCOL _ F _ REP LY _ ACK ); ▁V host User Msg ▁msg ▁= ▁{ ▁. hdr . request ▁= ▁V HOST _ USER _ SET _ ME M _ TABLE , ▁. hdr . flags ▁= ▁V HOST _ USER _ VERSION , ▁}; ▁if ▁( reply _ supported ) ▁{ ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ parser _ parse 2( AV Codec Parser Context ▁* s , ▁AV Codec Context ▁* av ctx , ▁uint 8_ t ▁** p out buf , ▁int ▁* p out buf _ size , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁int 64_ t ▁pts , ▁int 64_ t ▁dt s , ▁int 64_ t ▁pos ) ▁{ ▁int ▁index , ▁i ; ▁uint 8_ t ▁dummy _ buf [ AV _ INPUT _ BUFFER _ P ADDING _ SIZE ]; ▁if ▁(! ( s -> flags ▁& ▁PARSER _ FLAG _ F ET CHED _ OFFSET )) ▁{ ▁s -> next _ frame _ offset ▁= ▁s -> cur _ offset ▁= ▁pos ; ▁s -> flags ▁|= ▁PARSER _ FLAG _ F ET CHED _ OFFSE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ co _ read v _1 ( N bd Client Session ▁* client , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁Q EM UI O Vector ▁* q io v , ▁int ▁offset ) ▁{ ▁struct ▁nb d _ request ▁request ; ▁struct ▁nb d _ reply ▁reply ; ▁s size _ t ▁ret ; ▁request . type ▁= ▁N BD _ CMD _ READ ; ▁request . from ▁= ▁sector _ num ▁* ▁512 ; ▁request . len ▁= ▁nb _ sect ors ▁* ▁512 ; ▁nb d _ cor outine _ start ( client , ▁& request ); ▁ret ▁= ▁nb d _ co _ send _ request ( client , ▁& request , ▁NULL , ▁0); ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁AV IO Context ▁* ▁w tv file _ open 2( AV Format Context ▁* s , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁const ▁uint 8_ t ▁* filename , ▁int ▁filename _ size ) ▁{ ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf ▁+ ▁buf _ size ; ▁while ( buf ▁+ ▁48 ▁<= ▁buf _ end ) ▁{ ▁int ▁dir _ length , ▁name _ size , ▁first _ sect or , ▁depth ; ▁uint 64_ t ▁file _ length ; ▁const ▁uint 8_ t ▁* name ; ▁if ▁( ff _ guid cmp ( buf , ▁dir _ entry _ guid )) ▁{ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" unknown ▁guid ▁" FF _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁st ere o _ processing ( PS Context ▁* ps , ▁INT FLOAT ▁(* l )[ 32 ][ 2], ▁INT FLOAT ▁(* r )[ 32 ][ 2], ▁int ▁is 34 ) ▁{ ▁int ▁e , ▁b , ▁k ; ▁INT FLOAT ▁(* H 11) [ PS _ MAX _ NUM _ ENV +1 ][ PS _ MAX _ N R _ I ID IC C ] ▁= ▁ps -> H 11 ; ▁INT FLOAT ▁(* H 12) [ PS _ MAX _ NUM _ ENV +1 ][ PS _ MAX _ N R _ I ID IC C ] ▁= ▁ps -> H 12 ; ▁INT FLOAT ▁(* H 2 1) [ PS _ MAX _ NUM _ ENV +1 ][ PS _ MAX _ N R _ I ID IC C ] ▁= ▁ps -> H 21 ; ▁INT FLOAT ▁(* H 22 )[ PS _ MAX _ NUM _ ENV +1 ][ PS _ MAX _ N R _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ q mp _ command ( JSON Message Parser ▁* parser , ▁Q List ▁* tokens ) ▁{ ▁int ▁err ; ▁Q Object ▁* obj ; ▁Q Dict ▁* input , ▁* args ; ▁const ▁mon _ cmd _ t ▁* cmd ; ▁Monitor ▁* mon ▁= ▁cur _ mon ; ▁const ▁char ▁* cmd _ name , ▁* info _ item ; ▁args ▁= ▁NULL ; ▁obj ▁= ▁json _ parser _ parse ( tokens , ▁NULL ); ▁if ▁(! obj ) ▁{ ▁// ▁FIX ME : ▁should ▁be ▁triggered ▁in ▁json _ parser _ parse () ▁q error _ report ( Q ERR _ JSON _ PAR SING ); ▁goto ▁err _ out ; ▁q error _ report ( Q ERR _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁id c in _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Id c in Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i , ▁j , ▁histogram _ index ▁= ▁0; ▁unsigned ▁char ▁* histogram s ; ▁s -> av ctx ▁= ▁av ctx ; ▁av ctx -> pix _ fmt ▁= ▁PI X _ F MT _ P AL 8 ; ▁ds put il _ init ( & s -> d sp , ▁av ctx ); ▁/* ▁make ▁sure ▁the ▁H uff man ▁tables ▁make ▁it ▁*/ ▁if ▁( s -> av ctx -> ex tr ad ata _ size ▁!= ▁H UFF MAN _ TABLE _ SIZE ) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" ▁Id ▁C IN ▁vide

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁find _ best _ solid _ area ( V nc State ▁* vs , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h , ▁uint 32_ t ▁color , ▁int ▁* w _ ptr , ▁int ▁* h _ ptr ) ▁{ ▁int ▁dx , ▁dy , ▁dw , ▁dh ; ▁int ▁w _ prev ; ▁int ▁w _ best ▁= ▁0, ▁h _ best ▁= ▁0; ▁w _ prev ▁= ▁w ; ▁for ▁( dy ▁= ▁y ; ▁dy ▁< ▁y ▁+ ▁h ; ▁dy ▁+= ▁V NC _ T IGHT _ MAX _ SP LIT _ TI LE _ SIZE ) ▁{ ▁dh ▁= ▁MIN ( V NC _ T IGHT _ MAX _ SP LIT _ TI LE _ SIZE , ▁y ▁+ ▁h ▁- ▁dy ); ▁dw ▁= ▁MIN ( V NC _ T IGHT _ MAX _ SP LIT _ TI LE _ SIZE , ▁w _ prev 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁RAM Block ▁* q emu _ get _ ram _ block ( ram _ addr _ t ▁addr ) ▁{ ▁RAM Block ▁* block ; ▁/* ▁The ▁list ▁is ▁protected ▁by ▁the ▁i oth read ▁lock ▁here . ▁*/ ▁block ▁= ▁ram _ list . m ru _ block ; ▁if ▁( block ▁&& ▁addr ▁- ▁block -> offset ▁< ▁block -> max _ length ) ▁{ ▁goto ▁found ; ▁} ▁Q TAIL Q _ FORE A CH ( block , ▁& ram _ list . blocks , ▁next ) ▁{ ▁if ▁( addr ▁- ▁block -> offset ▁< ▁block -> max _ length ) ▁{ ▁goto ▁found ; ▁} ▁} ▁f printf ( stderr , ▁" Bad ▁ram ▁offset ▁% " ▁PRI x 64 ▁"\ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb net _ can _ receive ( V LAN Client State ▁* nc ) ▁{ ▁USB Net State ▁* s ▁= ▁DO _ UP CAST ( N IC State , ▁nc , ▁nc ) -> op aque ; ▁if ▁( s -> r nd is ▁&& ▁! s -> r nd is _ state ▁== ▁R ND IS _ DATA _ INIT IALIZED ) ▁return ▁1; ▁return ▁! s -> in _ len ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ disk _ em ulate _ mode _ s ense ( SC SI Request ▁* req , ▁uint 8_ t ▁* out buf ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁req -> dev ); ▁uint 64_ t ▁nb _ sect ors ; ▁int ▁page , ▁db d , ▁buf len , ▁page _ control ; ▁uint 8_ t ▁* p ; ▁uint 8_ t ▁dev _ specific _ param ; ▁db d ▁= ▁req -> cmd . buf [1] ▁& ▁0 x 8 ; ▁page ▁= ▁req -> cmd . buf [2] ▁& ▁0 x 3 f ; ▁page _ control ▁= ▁( req -> cmd . buf [2] ▁& ▁0 xc 0) ▁>> ▁6 ; ▁D PRI NT F (" Mode ▁S ense ( %

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tc g _ add _ target _ add _ op _ defs ( const ▁TC G Target Op Def ▁* td efs ) ▁{ ▁TC G Op code ▁op ; ▁TC G Op Def ▁* def ; ▁const ▁char ▁* ct _ str ; ▁int ▁i , ▁nb _ args ; ▁for ( ; ;) ▁{ ▁if ▁( td efs -> op ▁== ▁( TC G Op code ) -1) ▁break ; ▁op ▁= ▁t defs -> op ; ▁assert (( un signed ) op ▁< ▁NB _ OP S ); ▁def ▁= ▁& tc g _ op _ defs [ op ]; ▁# if ▁defined ( CONFIG _ DEBUG _ TC G ) ▁/* ▁Duplicate ▁entry ▁in ▁op ▁definitions ? ▁*/ ▁assert (! def -> used ); ▁def -> used ▁= ▁1; ▁# end if ▁nb _ args ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁A UD _ v log ▁( const ▁char ▁* cap , ▁const ▁char ▁* fmt , ▁va _ list ▁ap ) ▁{ ▁if ▁( conf . log _ to _ monitor ) ▁{ ▁if ▁( cap ) ▁{ ▁monitor _ printf ( default _ mon , ▁"% s : ▁", ▁cap ); ▁} ▁monitor _ v printf ( default _ mon , ▁fmt , ▁ap ); ▁} ▁else ▁{ ▁if ▁( cap ) ▁{ ▁f printf ▁( stderr , ▁"% s : ▁", ▁cap ); ▁} ▁vf printf ▁( stderr , ▁fmt , ▁ap ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁o gg _ build _ fla c _ headers ( const ▁uint 8_ t ▁* ex tr ad ata , ▁int ▁extr ad ata _ size , ▁O GG Stream Context ▁* og g stream , ▁int ▁bit exact ) ▁{ ▁const ▁char ▁* vendor ▁= ▁bit exact ▁? ▁" ff mpeg " ▁: ▁LIB AV FORMAT _ IDENT ; ▁uint 8_ t ▁* p ; ▁if ▁( ex tr ad ata _ size ▁!= ▁3 4) ▁return ▁-1; ▁o gg stream -> header _ len [0] ▁= ▁5 1; ▁o gg stream -> header [0] ▁= ▁av _ m alloc z (5 1); ▁// ▁per ▁o gg ▁fla c ▁specs ▁p ▁= ▁o gg stream -> header [0]; ▁by test ream _ put _ byte ( & p , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁put _ sub frame ( D CA Enc Context ▁* c , ▁int ▁sub frame ) ▁{ ▁int ▁i , ▁band , ▁ss , ▁ch ; ▁/* ▁Sub sub frames ▁count ▁*/ ▁put _ bits ( & c -> pb , ▁2, ▁SUB SUB FRAME S ▁-1 ); ▁/* ▁Partial ▁sub sub frame ▁sample ▁count : ▁dummy ▁*/ ▁put _ bits ( & c -> pb , ▁3, ▁0); ▁/* ▁Pred iction ▁mode : ▁no ▁AD PC M , ▁in ▁each ▁channel ▁and ▁sub band ▁*/ ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁c -> full band _ channels ; ▁ch ++) ▁for ▁( band ▁= ▁0; ▁band ▁< ▁D CA EN C _ SUB B AN DS ; ▁band ++) ▁put _ bits ( & c ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ gray _ bit stream ( HY uv Context ▁* s , ▁int ▁count ) ▁{ ▁int ▁i ; ▁count / = 2; ▁if ▁( count ▁>= ▁( get _ bits _ left ( & s -> gb )) ▁/ ▁( 31 ▁* ▁2 )) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁count ▁&& ▁get _ bits _ left ( & s -> gb ) ▁> ▁0; ▁i ++) ▁{ ▁READ _2 PI X ( s -> temp [0] [2 ▁* ▁i ], ▁s -> temp [0] [2 ▁* ▁i ▁+ ▁1], ▁0); ▁} ▁} ▁else ▁{ ▁for ( i =0; ▁i < count ; ▁i ++){ ▁READ _2 PI X ( s -> temp [0] [2 ▁* ▁i ], ▁s -> temp [0] [2 ▁* ▁i ▁+ ▁1], ▁0); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁start _ auth _ v encrypt _ sub auth ( V nc State ▁* vs ) ▁{ ▁switch ▁( vs -> vd -> sub auth ) ▁{ ▁case ▁V NC _ AUTH _ VE NC RY PT _ TLS NONE : ▁case ▁V NC _ AUTH _ VE NC RY PT _ X 509 NONE : ▁V NC _ DEBUG (" Accept ▁TLS ▁auth ▁none \ n "); ▁v nc _ write _ u 32 ( vs , ▁0); ▁/* ▁Accept ▁auth ▁completion ▁*/ ▁v nc _ read _ when ( vs , ▁protocol _ client _ init , ▁1); ▁break ; ▁case ▁V NC _ AUTH _ VE NC RY PT _ TL SV NC : ▁case ▁V NC _ AUTH _ VE NC RY PT _ X 509 V NC : ▁V NC _ DEBUG (" Start ▁TL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁iscsi _ un map _ cb ( struct ▁iscsi _ context ▁* isc si , ▁int ▁status , ▁void ▁* command _ data , ▁void ▁* op aque ) ▁{ ▁I sc si A IO CB ▁* ac b ▁= ▁opaque ; ▁if ▁( ac b -> cancel ed ▁!= ▁0) ▁{ ▁return ; ▁} ▁ac b -> status ▁= ▁0; ▁if ▁( status ▁< ▁0) ▁{ ▁error _ report (" Failed ▁to ▁un map ▁data ▁on ▁i SC SI ▁lun . ▁% s ", ▁iscsi _ get _ error ( isc si )); ▁ac b -> status ▁= ▁- E IO ; ▁} ▁iscsi _ schedule _ b h ( ac b ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ notify ( struct ▁sub channel _ id ▁sch id ) ▁{ ▁k vm _ hyper call ( K VM _ S 39 0_ VI RT IO _ CC W _ NOT IFY , ▁* ( u 32 *) & sch id , ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ m ce _ in j _ s ra o _ mem scr ub 2( CPU State ▁* env , ▁target _ ph ys _ addr _ t ▁p addr ) ▁{ ▁struct ▁k vm _ x 86_ m ce ▁m ce ▁= ▁{ ▁. bank ▁= ▁9, ▁. status ▁= ▁M CI _ STATUS _ VAL ▁| ▁M CI _ STATUS _ UC ▁| ▁M CI _ STATUS _ EN ▁| ▁M CI _ STATUS _ MI SC V ▁| ▁M CI _ STATUS _ ADD RV ▁| ▁M CI _ STATUS _ S ▁| ▁0 xc 0, ▁. mc g _ status ▁= ▁M CG _ STATUS _ MC IP ▁| ▁M CG _ STATUS _ RI P V , ▁. addr ▁= ▁p addr , ▁. misc ▁= ▁( M CM _ ADDR _ PH Y S ▁<< ▁6) ▁| ▁0 xc , ▁}; ▁k vm _ inject _ x

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁lm 32_ ev r _ init ( Q EM UM achine Init Args ▁* args ) ▁{ ▁const ▁char ▁* cpu _ model ▁= ▁args -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁args -> kernel _ filename ; ▁L M 32 CPU ▁* cpu ; ▁CP UL M 32 State ▁* env ; ▁Drive Info ▁* d info ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* ph ys _ ram ▁= ▁g _ new ( Memory Region , ▁1); ▁qemu _ irq ▁* cpu _ irq , ▁irq [ 32 ]; ▁Reset Info ▁* reset _ info ; ▁int ▁i ; ▁/* ▁memory ▁map ▁*/ ▁target 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ms a _ branch ( CP UM IP S State ▁* env , ▁Dis as Context ▁* ctx , ▁uint 32_ t ▁op 1) ▁{ ▁uint 8_ t ▁df ▁= ▁( ctx -> op code ▁>> ▁2 1) ▁& ▁0 x 3; ▁uint 8_ t ▁wt ▁= ▁( ctx -> op code ▁>> ▁16 ) ▁& ▁0 x 1 f ; ▁int 64_ t ▁s 16 ▁= ▁( int 16_ t ) ctx -> op code ; ▁check _ ms a _ access ( ctx ); ▁if ▁( ctx -> ins n _ flags ▁& ▁I SA _ M IP S 32 R 6 ▁&& ▁ctx -> h flags ▁& ▁M IP S _ H FLAG _ B MASK ) ▁{ ▁generate _ exception _ end ( ctx , ▁EX CP _ RI ); ▁return ; ▁} ▁switch ▁( op 1) ▁{ ▁case ▁O

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Q Object ▁* parse _ keyword ( JSON Parser Context ▁* ctxt , ▁Q List ▁** tokens ) ▁{ ▁Q Object ▁* token , ▁* ret ; ▁Q List ▁* working ▁= ▁q list _ copy (* tokens ); ▁token ▁= ▁q list _ pop ( working ); ▁if ▁( token ▁== ▁NULL ) ▁{ ▁goto ▁out ; ▁} ▁if ▁( token _ get _ type ( token ) ▁!= ▁JSON _ KEYWORD ) ▁{ ▁goto ▁out ; ▁} ▁if ▁( token _ is _ keyword ( token , ▁" true ")) ▁{ ▁ret ▁= ▁Q OBJECT ( q bool _ from _ int ( true )); ▁} ▁else ▁if ▁( token _ is _ keyword ( token , ▁" false ")) ▁{ ▁ret ▁= ▁Q O

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁va api _ encode _ config _ attributes ( AV Codec Context ▁* av ctx ) ▁{ ▁V A API Encode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁V A Status ▁v as ; ▁int ▁i , ▁n , ▁err ; ▁V A Profile ▁* profiles ▁= ▁NULL ; ▁V A En tr yp oint ▁* entry points ▁= ▁NULL ; ▁V A Config Attrib ▁attr [] ▁= ▁{ ▁{ ▁V A Config Attrib RT Format ▁}, ▁{ ▁V A Config Attrib Rate Control ▁}, ▁{ ▁V A Config Attrib Enc Max Ref Frames ▁}, ▁}; ▁n ▁= ▁va Max Num Profiles ( ctx -> hw ctx -> display ); ▁profiles ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁targ a _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* p , ▁int ▁* got _ packet ) ▁{ ▁int ▁b pp , ▁pic size , ▁datas ize ▁= ▁-1, ▁ret ; ▁uint 8_ t ▁* out ; ▁if ( av ctx -> width ▁> ▁0 xffff ▁|| ▁av ctx -> height ▁> ▁0 xffff ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" image ▁dimensions ▁too ▁large \ n "); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁pic size ▁= ▁av _ image _ get _ buffer _ size ( av ctx -> pix _ fmt , ▁av ctx -> width , ▁av ctx -> height 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ req _ length ( SC SI Command ▁* cmd , ▁S CS ID evice ▁* dev , ▁uint 8_ t ▁* buf ) ▁{ ▁cmd -> x fer ▁= ▁sc si _ c db _ length ( buf ); ▁switch ▁( buf [0]) ▁{ ▁case ▁TEST _ UNIT _ READY : ▁case ▁RE W IND : ▁case ▁START _ STOP : ▁case ▁SET _ CAPACITY : ▁case ▁WRITE _ FILE MARK S : ▁case ▁WRITE _ FILE MARK S _16 : ▁case ▁SPACE : ▁case ▁RE SER VE : ▁case ▁RELEASE : ▁case ▁E RA SE : ▁case ▁ALLOW _ MEDI UM _ REMO VAL : ▁case ▁SE EK _10 : ▁case ▁SY N CH RON I ZE _ CACHE : ▁case ▁SY N CH RON 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q dm 2_ init ( Q DM 2 Context ▁* q ) ▁{ ▁static ▁int ▁init ed ▁= ▁0; ▁if ▁( init ed ▁!= ▁0) ▁return ; ▁init ed ▁= ▁1; ▁q dm 2_ init _ vlc (); ▁ff _ mp a _ sy nth _ init ( mp a _ window ); ▁soft clip _ table _ init (); ▁rnd _ table _ init (); ▁init _ noise _ samples (); ▁av _ log ( NULL , ▁AV _ LOG _ DEBUG , ▁" init ▁done \ n "); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ frame ( F la c Encode Context ▁* s ) ▁{ ▁int ▁ch , ▁count ; ▁count ▁= ▁count _ frame _ header ( s ); ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁s -> channels ; ▁ch ++) ▁count ▁+= ▁encode _ resid ual _ ch ( s , ▁ch ); ▁count ▁+= ▁(8 ▁- ▁( count ▁& ▁7 )) ▁& ▁7 ; ▁// ▁byte ▁alignment ▁count ▁+= ▁16 ; ▁// ▁CRC -16 ▁return ▁count ▁>> ▁3; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vf io _ add _ std _ cap ( V FI OP C ID evice ▁* v dev , ▁uint 8_ t ▁pos ) ▁{ ▁PC ID evice ▁* pd ev ▁= ▁& v dev -> pd ev ; ▁uint 8_ t ▁cap _ id , ▁next , ▁size ; ▁int ▁ret ; ▁cap _ id ▁= ▁pd ev -> config [ pos ]; ▁next ▁= ▁pd ev -> config [ pos ▁+ ▁P CI _ CAP _ LIST _ NEXT ]; ▁/* ▁* ▁If ▁it ▁becomes ▁important ▁to ▁configure ▁capabilities ▁to ▁their ▁actual ▁* ▁size , ▁use ▁this ▁as ▁the ▁default ▁when ▁it ' s ▁something ▁we ▁don ' t ▁recognize . ▁* ▁Since ▁Q EM U ▁doesn ' t ▁actually ▁handle

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ exec ( CPU State ▁* env 1) ▁{ ▁# define ▁DEC LA RE _ HOST _ REG S ▁1 ▁# include ▁" host re gs _ helper . h " ▁int ▁ret , ▁interrupt _ request ; ▁Translation Block ▁* tb ; ▁uint 8_ t ▁* tc _ ptr ; ▁unsigned ▁long ▁next _ tb ; ▁if ▁( cpu _ hal ted ( env 1) ▁== ▁EX CP _ H AL TED ) ▁return ▁EX CP _ H AL TED ; ▁cpu _ single _ env ▁= ▁env 1; ▁/* ▁first ▁we ▁save ▁global ▁registers ▁*/ ▁# define ▁SAVE _ HOST _ REG S ▁1 ▁# include ▁" host re gs _ helper . h " ▁env ▁= ▁env 1; ▁# if ▁defined ( TARGET _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( v 7 m _ ms r )( CPU ARM State ▁* env , ▁uint 32_ t ▁mask reg , ▁uint 32_ t ▁val ) ▁{ ▁/* ▁We ' re ▁passed ▁bits ▁[1 1. .0 ] ▁of ▁the ▁instruction ; ▁extract ▁* ▁SY Sm ▁and ▁the ▁mask ▁bits . ▁* ▁Invalid ▁combinations ▁of ▁SY Sm ▁and ▁mask ▁are ▁UN PRE DICT ABLE ; ▁* ▁we ▁choose ▁to ▁treat ▁them ▁as ▁if ▁the ▁mask ▁bits ▁were ▁valid . ▁* ▁NB ▁that ▁the ▁pseudocode ▁' mask ' ▁variable ▁is ▁bits ▁[ 11 .. 10 ], ▁* ▁whereas ▁ ours ▁is ▁[ 11 .. 8 ]. ▁*/ ▁uint 32_ t ▁mask ▁= ▁extract 32 ( mask r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁migrate _ caps _ check ( bool ▁* cap _ list , ▁Migration Capability Status List ▁* params , ▁Error ▁** err p ) ▁{ ▁Migration Capability Status List ▁* cap ; ▁bool ▁old _ post copy _ cap ; ▁old _ post copy _ cap ▁= ▁cap _ list [ M IG R ATION _ CAP ABILITY _ POST COPY _ RAM ]; ▁for ▁( cap ▁= ▁params ; ▁cap ; ▁cap ▁= ▁cap -> next ) ▁{ ▁cap _ list [ cap -> value -> cap ability ] ▁= ▁cap -> value -> state ; ▁} ▁# if nd ef ▁CONFIG _ LI VE _ BLOCK _ M IG R ATION ▁if ▁( cap _ list [ M IG R ATION _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ blk _ handle _ rw _ error ( V irt IO Block Req ▁* req , ▁int ▁error , ▁bool ▁is _ read ) ▁{ ▁Block Error Action ▁action ▁= ▁b dr v _ get _ error _ action ( req -> dev -> bs , ▁is _ read , ▁error ); ▁V irt IO Block ▁* s ▁= ▁req -> dev ; ▁if ▁( action ▁== ▁BLOCK _ ERROR _ ACTION _ STOP ) ▁{ ▁req -> next ▁= ▁s -> rq ; ▁s -> rq ▁= ▁req ; ▁} ▁else ▁if ▁( action ▁== ▁BLOCK _ ERROR _ ACTION _ REPORT ) ▁{ ▁virt io _ blk _ req _ complete ( req , ▁VI RT IO _ BL K _ S _ IO ERR ); ▁block _ ac 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁F UNC ( id ct Row Cond DC _ ex tr ash ift )( int 16_ t ▁* row , ▁int ▁extra _ shift ) ▁# else ▁static ▁inline ▁void ▁F UNC ( id ct Row Cond DC )( int 16_ t ▁* row , ▁int ▁extra _ shift ) ▁# end if ▁{ ▁int ▁a 0, ▁a 1, ▁a 2, ▁a 3, ▁b 0, ▁b 1, ▁b 2, ▁b 3; ▁# if ▁HAVE _ FA ST _64 BIT ▁# define ▁ROW 0_ MASK ▁(0 xffff LL ▁<< ▁48 ▁* ▁HAVE _ B IG ENDIAN ) ▁if ▁( (( AV _ R N 64 A ( row ) ▁& ▁~ ROW 0_ MASK ) ▁| ▁AV _ R N 64 A ( row + 4 )) ▁== ▁0) ▁{ ▁uint 64_ t ▁temp ; ▁if ▁( DC _ SHIFT ▁- ▁e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ mm c _ s ▁* om ap 2_ mm c _ init ( struct ▁o map _ target _ agent _ s ▁* ta , ▁Block Driver State ▁* bd , ▁qemu _ irq ▁irq , ▁qemu _ irq ▁d ma [], ▁o map _ cl k ▁f cl k , ▁o map _ cl k ▁i cl k ) ▁{ ▁struct ▁o map _ mm c _ s ▁* s ▁= ▁( struct ▁o map _ mm c _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ mm c _ s )); ▁s -> irq ▁= ▁irq ; ▁s -> d ma ▁= ▁d ma ; ▁s -> cl k ▁= ▁f cl k ; ▁s -> lines ▁= ▁4; ▁s -> rev ▁= ▁2; ▁o map _ mm c _ reset ( s ); ▁memory _ region _ init _ io ( & s -> iom 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cal x ed a _ init ( Machine State ▁* machine , ▁enum ▁cx m achines ▁machine _ id ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁machine -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁machine -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁Device State ▁* dev ▁= ▁NULL ; ▁Sys Bus Device ▁* bus dev ; ▁qemu _ irq ▁pic [ 128 ]; ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ ph ys _ addr _ v 5 ( CPU State ▁* env , ▁uint 32_ t ▁address , ▁int ▁access _ type , ▁int ▁is _ user , ▁uint 32_ t ▁* ph ys _ ptr , ▁int ▁* prot ) ▁{ ▁int ▁code ; ▁uint 32_ t ▁table ; ▁uint 32_ t ▁desc ; ▁int ▁type ; ▁int ▁ap ; ▁int ▁domain ; ▁uint 32_ t ▁phys _ addr ; ▁/* ▁Pag etable ▁walk . ▁*/ ▁/* ▁Lookup ▁l 1 ▁descriptor . ▁*/ ▁table ▁= ▁get _ level 1_ table _ address ( env , ▁address ); ▁desc ▁= ▁ld l _ ph ys ( table ); ▁type ▁= ▁( desc ▁& ▁3 ); ▁domain ▁= ▁( env -> cp 15. c 3 ▁>>

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm x net 3_ update _ m cast _ filters ( VM X NET 3 State ▁* s ) ▁{ ▁uint 16_ t ▁list _ bytes ▁= ▁VM X NET 3_ READ _ DR V _ SHA RED 16 ( s -> dr v _ sh mem , ▁dev Read . rx Filter Conf . mf Table Len ); ▁s -> m cast _ list _ len ▁= ▁list _ bytes ▁/ ▁sizeof ( s -> m cast _ list [0]); ▁s -> m cast _ list ▁= ▁g _ real loc ( s -> m cast _ list , ▁list _ bytes ); ▁if ▁(! s -> m cast _ list ) ▁{ ▁if ▁( s -> m cast _ list _ len ▁== ▁0) ▁{ ▁VM W _ CF PR N (" Current ▁multicast ▁list ▁is ▁empty "); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ nv dec _ decode _ init ( AV Codec Context ▁* av ctx , ▁unsigned ▁int ▁d pb _ size ) ▁{ ▁NV DEC Context ▁* ctx ▁= ▁av ctx -> internal -> hw accel _ priv _ data ; ▁NV DEC Frame Pool ▁* pool ; ▁AV H W Frames Context ▁* frames _ ctx ; ▁const ▁AV Pix F mt Descriptor ▁* sw _ desc ; ▁C UV ID DE CODE CREATE INFO ▁params ▁= ▁{ ▁0 ▁}; ▁int ▁cu vid _ codec _ type , ▁cu vid _ chrom a _ format ; ▁int ▁ret ▁= ▁0; ▁sw _ desc ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> sw _ pix _ fmt ); ▁if ▁(! sw _ desc ) ▁re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h mp _ info _ snapshots ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁Block Driver State ▁* bs , ▁* bs 1; ▁Q EM US napshot Info ▁* sn _ tab , ▁* sn , ▁s , ▁* sn _ info ▁= ▁& s ; ▁int ▁nb _ s ns , ▁i , ▁ret , ▁available ; ▁int ▁total ; ▁int ▁* available _ snapshots ; ▁bs ▁= ▁find _ vm state _ bs (); ▁if ▁(! bs ) ▁{ ▁monitor _ printf ( mon , ▁" No ▁available ▁block ▁device ▁supports ▁snapshots \ n "); ▁return ; ▁} ▁nb _ s ns ▁= ▁b dr v _ snapshot _ list ( bs , ▁& sn _ tab ); ▁if ▁( nb _ s ns ▁< ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁decode _ block _ coeff s ( VP 56 Range Coder ▁* c , ▁int 16_ t ▁block [ 16 ], ▁uint 8_ t ▁probs [ 16 ][ 3 ][ NUM _ D CT _ TOKEN S ▁- ▁1], ▁int ▁i , ▁int ▁zero _ n hood , ▁int 16_ t ▁q mul [2]) ▁{ ▁uint 8_ t ▁* token _ prob ▁= ▁probs [ i ][ zero _ n hood ]; ▁if ▁(! vp 56 _ rac _ get _ prob _ branch y ( c , ▁token _ prob [0] )) ▁// ▁D CT _ E OB ▁return ▁0; ▁return ▁decode _ block _ coeff s _ internal ( c , ▁block , ▁probs , ▁i , ▁token _ prob , ▁q mul ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cir r us _ bit bl t _ solid fill ( C ir r us V GA State ▁* s , ▁int ▁bl t _ rop ) ▁{ ▁cir r us _ fill _ t ▁ro p _ func ; ▁if ▁( blit _ is _ unsafe ( s )) ▁{ ▁return ▁0; ▁} ▁ro p _ func ▁= ▁cir r us _ fill [ rop _ to _ index [ bl t _ rop ] ][ s -> cir r us _ bl t _ pixel width ▁- ▁1 ]; ▁ro p _ func ( s , ▁s -> v ga . v ram _ ptr ▁+ ▁( s -> cir r us _ bl t _ dst addr ▁& ▁s -> cir r us _ addr _ mask ), ▁s -> cir r us _ bl t _ dst p itch , ▁s -> cir r us _ bl t _ width , ▁s -> cir r us _ bl t _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁load _ ip movie _ packet ( IP M VE Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁chunk _ type ; ▁if ▁( s -> audio _ chunk _ offset ) ▁{ ▁/* ▁adjust ▁for ▁PC M ▁audio ▁by ▁skipping ▁chunk ▁header ▁*/ ▁if ▁( s -> audio _ type ▁!= ▁CODE C _ ID _ INTER PLAY _ D PC M ) ▁{ ▁s -> audio _ chunk _ offset ▁+= ▁6 ; ▁s -> audio _ chunk _ size ▁-= ▁6 ; ▁av io _ seek ( pb , ▁s -> audio _ chunk _ offset , ▁SE EK _ SET ); ▁s -> audio _ chunk _ offset ▁= ▁0; ▁if ▁( s -> audio _ chunk _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ hq _ slice ( AV Codec Context ▁* av ctx , ▁void ▁* arg ) ▁{ ▁Slice Args ▁* slice _ dat ▁= ▁arg ; ▁VC 2 Enc Context ▁* s ▁= ▁slice _ dat -> ctx ; ▁Put Bit Context ▁* pb ▁= ▁& slice _ dat -> pb ; ▁const ▁int ▁slice _ x ▁= ▁slice _ dat -> x ; ▁const ▁int ▁slice _ y ▁= ▁slice _ dat -> y ; ▁const ▁int ▁quant _ idx ▁= ▁slice _ dat -> quant _ idx ; ▁const ▁int ▁slice _ bytes _ max ▁= ▁slice _ dat -> bytes ; ▁uint 8_ t ▁qu ants [ MAX _ D WT _ LE VE LS ][ 4 ]; ▁int ▁p , ▁level , ▁orientation

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ info _ commands ( Monitor ▁* mon , ▁Q Object ▁** ret _ data ) ▁{ ▁Q List ▁* cmd _ list ; ▁const ▁mon _ cmd _ t ▁* cmd ; ▁cmd _ list ▁= ▁q list _ new (); ▁for ▁( cmd ▁= ▁q mp _ cmds ; ▁cmd -> name ▁!= ▁NULL ; ▁cmd ++) ▁{ ▁if ▁( monitor _ handler _ port ed ( cmd ) ▁&& ▁! monitor _ cmd _ user _ only ( cmd ) ▁&& ▁! compare _ cmd ( cmd -> name , ▁" info ")) ▁{ ▁q list _ append _ obj ( cmd _ list , ▁get _ cmd _ dict ( cmd -> name )); ▁} ▁} ▁for ▁( cmd ▁= ▁q mp _ query _ cmds ; ▁cmd -> name ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ m si _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁data , ▁unsigned ▁size ) ▁{ ▁s P AP R PH B State ▁* ph b ▁= ▁opaque ; ▁int ▁n dev ▁= ▁addr ▁>> ▁16 ; ▁int ▁vec ▁= ▁(( addr ▁& ▁0 xFFFF ) ▁>> ▁2) ▁| ▁data ; ▁uint 32_ t ▁irq ▁= ▁ph b -> m si _ table [ nd ev ]. irq ▁+ ▁vec ; ▁trace _ sp ap r _ pc i _ m si _ write ( addr , ▁data , ▁irq ); ▁qemu _ irq _ p ulse ( x ics _ get _ q irq ( sp ap r -> ic p , ▁irq )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p xa 2 xx _ pm _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁value ) ▁{ ▁struct ▁p xa 2 xx _ state _ s ▁* s ▁= ▁( struct ▁p xa 2 xx _ state _ s ▁* ) ▁opaque ; ▁if ▁( addr ▁> ▁s -> pm _ base ▁+ ▁PC MD 3 1) ▁{ ▁/* ▁Special ▁case : ▁P W RI 2 C ▁registers ▁appear ▁in ▁the ▁same ▁range . ▁*/ ▁p xa 2 xx _ i 2 c _ write ( s -> i 2 c [1], ▁addr , ▁value ); ▁return ; ▁} ▁addr ▁-= ▁s -> pm _ base ; ▁switch ▁( addr ) ▁{ ▁case ▁PM CR : ▁s -> pm _ re gs [ addr ▁>> ▁2] ▁&= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁CPU X 86 State ▁* cpu _ x 86_ init ( void ) ▁{ ▁CPU X 86 State ▁* env ; ▁int ▁i ; ▁static ▁int ▁init ed ; ▁cpu _ x 86_ t blocks _ init (); ▁env ▁= ▁m alloc ( size of ( CPU X 86 State )); ▁if ▁(! env ) ▁return ▁NULL ; ▁mem set ( env , ▁0, ▁sizeof ( CPU X 86 State )); ▁/* ▁basic ▁F PU ▁init ▁*/ ▁for ( i ▁= ▁0; i ▁< ▁8 ; ▁i ++) ▁env -> f pt ags [ i ] ▁= ▁1; ▁env -> f pu c ▁= ▁0 x 37 f ; ▁/* ▁flags ▁setup ▁*/ ▁env -> ef lags ▁= ▁0; ▁/* ▁init ▁various ▁static ▁tables ▁*/ ▁if ▁(! init ed ) ▁{ ▁init ed ▁= ▁1; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁readline _ show _ prompt ( Read Line State ▁* rs ) ▁{ ▁monitor _ printf ( rs -> mon , ▁"% s ", ▁rs -> prompt ); ▁monitor _ flush ( rs -> mon ); ▁rs -> last _ cmd _ buf _ index ▁= ▁0; ▁rs -> last _ cmd _ buf _ size ▁= ▁0; ▁rs -> esc _ state ▁= ▁IS _ N ORM ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parallel _ parse ( const ▁char ▁* dev name ) ▁{ ▁static ▁int ▁index ▁= ▁0; ▁char ▁label [ 32 ]; ▁if ▁( str cmp ( dev name , ▁" none ") ▁== ▁0) ▁return ▁0; ▁if ▁( index ▁== ▁MAX _ PAR AL LE L _ PORT S ) ▁{ ▁f printf ( stderr , ▁" q emu : ▁too ▁many ▁parallel ▁ports \ n "); ▁exit (1); ▁} ▁sn printf ( label , ▁sizeof ( label ), ▁" parallel % d ", ▁index ); ▁parallel _ h ds [ index ] ▁= ▁qemu _ chr _ new ( label , ▁dev name , ▁NULL ); ▁if ▁(! parallel _ h ds [ index ]) ▁{ ▁f printf ( stderr , ▁"

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁START _ TEST ( q float _ destroy _ test ) ▁{ ▁Q Float ▁* q f ▁= ▁q float _ from _ double (0 .0 ); ▁Q DE CRE F ( q f ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ l stat ( Fs Context ▁* fs _ ctx , ▁V 9 fs Path ▁* fs _ path , ▁struct ▁stat ▁* st buf ) ▁{ ▁int ▁err ; ▁char ▁buffer [ PATH _ MAX ]; ▁char ▁* path ▁= ▁fs _ path -> data ; ▁err ▁= ▁lst at ( r path ( fs _ ctx , ▁path , ▁buffer ), ▁st buf ); ▁if ▁( err ) ▁{ ▁return ▁err ; ▁} ▁if ▁( fs _ ctx -> fs _ sm ▁== ▁SM _ MAP PED ) ▁{ ▁/* ▁Actual ▁credentials ▁are ▁part ▁of ▁extended ▁attrs ▁*/ ▁uid _ t ▁tmp _ uid ; ▁gid _ t ▁tmp _ gid ; ▁mode _ t ▁tmp _ mode ; ▁dev _ t ▁tmp _ dev ; ▁if ▁( get x a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁Q EM U _ NO RETURN ▁runtime _ exception ( CP US 390 X State ▁* env , ▁int ▁exc p , ▁uint ptr _ t ▁ret addr ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( s 39 0_ env _ get _ cpu ( env )); ▁int ▁t ; ▁cs -> exception _ index ▁= ▁EX CP _ PG M ; ▁env -> int _ pg m _ code ▁= ▁exc p ; ▁/* ▁Use ▁the ▁( ult imate ) ▁call ers ▁address ▁to ▁find ▁the ▁insn ▁that ▁tra pped . ▁*/ ▁cpu _ restore _ state ( cs , ▁ret addr ); ▁/* ▁Advance ▁past ▁the ▁insn . ▁*/ ▁t ▁= ▁cpu _ ld ub _ code ( env , ▁env -> p sw . addr ); ▁env -> int

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ host _ init ( void ) ▁{ ▁const ▁struct ▁lib usb _ poll fd ▁** poll ; ▁int ▁i , ▁rc ; ▁if ▁( ctx ) ▁{ ▁return ▁0; ▁} ▁rc ▁= ▁lib usb _ init ( & ctx ); ▁if ▁( rc ▁!= ▁0) ▁{ ▁return ▁-1; ▁} ▁lib usb _ set _ debug ( ctx , ▁log level ); ▁lib usb _ set _ poll fd _ not ifiers ( ctx , ▁usb _ host _ add _ fd , ▁usb _ host _ del _ fd , ▁ctx ); ▁poll ▁= ▁lib usb _ get _ poll fds ( ctx ); ▁if ▁( poll ) ▁{ ▁for ▁( i ▁= ▁0; ▁poll [ i ] ▁!= ▁NULL ; ▁i ++) ▁{ ▁usb _ host _ add _ fd ( poll [ i ] -> fd 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Snapshot Info ▁* q mp _ block dev _ snapshot _ delete _ internal _ sync ( const ▁char ▁* device , ▁bool ▁has _ id , ▁const ▁char ▁* id , ▁bool ▁has _ name , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁Block Backend ▁* blk ; ▁A io Context ▁* a io _ context ; ▁Q EM US napshot Info ▁sn ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁Snapshot Info ▁* info ▁= ▁NULL ; ▁int ▁ret ; ▁blk ▁= ▁blk _ by _ name ( device ); ▁if ▁(! blk ) ▁{ ▁error _ set ( err p , ▁ERROR _ CLASS _ DEVICE _ NOT _ FOUND

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ sc si _ complete _ req ( V irt IO SC SI Req ▁* req ) ▁{ ▁V irt IO SC SI ▁* s ▁= ▁req -> dev ; ▁V irt Queue ▁* v q ▁= ▁req -> v q ; ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( s ); ▁virt queue _ push ( v q , ▁& req -> elem , ▁req -> q sg l . size ▁+ ▁req -> elem . in _ sg [0]. io v _ len ); ▁if ▁( req -> s req ) ▁{ ▁req -> s req -> h ba _ private ▁= ▁NULL ; ▁sc si _ req _ un ref ( req -> s req ); ▁} ▁virt io _ sc si _ free _ req ( req ); ▁virt io _ notify ( v dev , ▁v q ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁timer _ pending ( Q EM UT imer ▁* ts ) ▁{ ▁Q EM UT imer ▁* t ; ▁for ▁( t ▁= ▁ts -> timer _ list -> active _ tim ers ; ▁t ▁!= ▁NULL ; ▁t ▁= ▁t -> next ) ▁{ ▁if ▁( t ▁== ▁ts ) ▁{ ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av _ col d ▁lib op us _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Lib op us Enc Context ▁* op us ▁= ▁av ctx -> priv _ data ; ▁const ▁uint 8_ t ▁* channel _ mapping ; ▁Op us MS Encoder ▁* enc ; ▁int ▁ret ▁= ▁OP US _ OK ; ▁int ▁couple d _ stream _ count , ▁header _ size , ▁frame _ size ; ▁couple d _ stream _ count ▁= ▁op us _ c ouple d _ streams [ av ctx -> channels ▁- ▁1 ]; ▁op us -> stream _ count ▁= ▁av ctx -> channels ▁- ▁couple d _ stream _ count ; ▁channel _ mapping ▁= ▁lib av _ l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁setup _ rt _ frame ( int ▁sig , ▁struct ▁em ulated _ sig action ▁* ka , ▁target _ sig info _ t ▁* info , ▁target _ sig set _ t ▁* set , ▁CPU X 86 State ▁* env ) ▁{ ▁struct ▁rt _ sig frame ▁* frame ; ▁int ▁err ▁= ▁0; ▁frame ▁= ▁get _ sig frame ( ka , ▁env , ▁sizeof (* frame )); ▁# if ▁0 ▁if ▁(! access _ ok ( VER IFY _ WRITE , ▁frame , ▁sizeof (* frame ))) ▁goto ▁give _ sig seg v ; ▁# end if ▁err ▁|= ▁__ put _ user (( /* current -> exec _ domain ▁&& ▁current -> exec _ domain -> signal _ inv m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tcp _ chr _ tel net _ init ( Q IO Channel ▁* i oc ) ▁{ ▁char ▁buf [3 ]; ▁/* ▁Send ▁the ▁telnet ▁neg otion ▁to ▁put ▁telnet ▁in ▁binary , ▁no ▁echo , ▁single ▁char ▁mode ▁*/ ▁I AC SET ( buf , ▁0 xff , ▁0 xf b , ▁0 x 01 ); ▁/* ▁I AC ▁W ILL ▁E CHO ▁*/ ▁q io _ channel _ write ( i oc , ▁buf , ▁3, ▁NULL ); ▁I AC SET ( buf , ▁0 xff , ▁0 xf b , ▁0 x 03 ); ▁/* ▁I AC ▁W ILL ▁Suppress ▁go ▁ahead ▁*/ ▁q io _ channel _ write ( i oc , ▁buf , ▁3, ▁NULL ); ▁I AC SET ( buf , ▁0 xff , ▁0 xf b , ▁0 x 00 ); ▁/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁blk _ delete ( Block Backend ▁* blk ) ▁{ ▁assert (! blk -> ref cnt ); ▁assert (! blk -> name ); ▁assert (! blk -> dev ); ▁if ▁( blk -> root ) ▁{ ▁blk _ remove _ bs ( blk ); ▁assert ( Q LIST _ EMPTY ( & blk -> remove _ bs _ not ifiers . not ifiers )); ▁assert ( Q LIST _ EMPTY ( & blk -> insert _ bs _ not ifiers . not ifiers )); ▁Q TAIL Q _ REMOVE ( & block _ backends , ▁blk , ▁link ); ▁drive _ info _ del ( blk -> legacy _ d info ); ▁block _ ac ct _ cleanup ( & blk -> stats ); ▁g _ free ( blk

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gdb server _ open ( int ▁port ) ▁{ ▁struct ▁sock addr _ in ▁sock addr ; ▁int ▁fd , ▁val , ▁ret ; ▁fd ▁= ▁socket ( PF _ INET , ▁SOCK _ STREAM , ▁0); ▁if ▁( fd ▁< ▁0) ▁{ ▁per ror (" socket "); ▁return ▁-1; ▁} ▁# if nd ef ▁_ W IN 32 ▁fcntl ( fd , ▁F _ SET FD , ▁F D _ CLO EXEC ); ▁# end if ▁/* ▁allow ▁fast ▁reuse ▁*/ ▁val ▁= ▁1; ▁sets ockopt ( fd , ▁SOL _ SOCKET , ▁SO _ RE USE ADDR , ▁( char ▁* ) & val , ▁sizeof ( val )); ▁sock addr . sin _ family ▁= ▁AF _ INET ; ▁sock addr . sin _ port ▁= ▁ht o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ nv ram _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁V IO s P AP R Device Class ▁* k ▁= ▁V IO _ SP AP R _ DEVICE _ CLASS ( k lass ); ▁k -> real ize ▁= ▁sp ap r _ nv ram _ real ize ; ▁k -> dev node ▁= ▁sp ap r _ nv ram _ dev node ; ▁k -> dt _ name ▁= ▁" nv ram "; ▁k -> dt _ type ▁= ▁" nv ram "; ▁k -> dt _ compatible ▁= ▁" q emu , sp ap r - nv ram "; ▁set _ bit ( DEVICE _ CATEGORY _ MI SC , ▁dc -> categories ); ▁dc -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ handle _ i ore q ( void ▁* op aque ) ▁{ ▁X en IO State ▁* state ▁= ▁opaque ; ▁i ore q _ t ▁* req ▁= ▁cpu _ get _ i ore q ( state ); ▁handle _ buffered _ i op age ( state ); ▁if ▁( req ) ▁{ ▁i ore q _ t ▁copy ▁= ▁* req ; ▁xen _ r mb (); ▁handle _ i ore q ( state , ▁& copy ); ▁req -> data ▁= ▁copy . data ; ▁if ▁( req -> state ▁!= ▁STATE _ IO REQ _ IN PROCESS ) ▁{ ▁f printf ( stderr , ▁" Bad ness ▁in ▁I / O ▁request ▁... ▁not ▁in ▁service ?! : ▁" ▁"% x , ▁ptr : ▁% x , ▁port : ▁% " PRI x 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁sc si _ target _ em ulate _ in quiry ( SC S IT arget Req ▁* r ) ▁{ ▁assert ( r -> req . dev -> lun ▁!= ▁r -> req . lun ); ▁if ▁( r -> req . cmd . buf [1] ▁& ▁0 x 2) ▁{ ▁/* ▁Command ▁support ▁data ▁- ▁optional , ▁not ▁implemented ▁*/ ▁return ▁false ; ▁} ▁if ▁( r -> req . cmd . buf [1] ▁& ▁0 x 1) ▁{ ▁/* ▁V ital ▁product ▁data ▁*/ ▁uint 8_ t ▁page _ code ▁= ▁r -> req . cmd . buf [2 ]; ▁r -> buf [ r -> len ++ ] ▁= ▁page _ code ▁; ▁/* ▁this ▁page ▁*/ ▁r -> buf [ r -> len ++ ] ▁= ▁0 x 00 ; ▁switc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qc ow 2_ expand _ zero _ clusters ( Block Driver State ▁* bs ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁* l 1_ table ▁= ▁NULL ; ▁uint 64_ t ▁nb _ clusters ; ▁uint 8_ t ▁* expanded _ clusters ; ▁int ▁ret ; ▁int ▁i , ▁j ; ▁nb _ clusters ▁= ▁size _ to _ clusters ( s , ▁bs -> file -> total _ sect ors ▁* ▁B DR V _ SE CTOR _ SIZE ); ▁expanded _ clusters ▁= ▁g _ m alloc 0 (( nb _ clusters ▁+ ▁7) ▁/ ▁8 ); ▁ret ▁= ▁expand _ zero _ clusters _ in _ l 1( bs , ▁s -> l 1_ table , ▁s -> l 1_ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ open 2( Fs Context ▁* fs _ ctx , ▁const ▁char ▁* path , ▁int ▁flags , ▁Fs Cred ▁* cre dp ) ▁{ ▁int ▁fd ▁= ▁-1; ▁int ▁err ▁= ▁-1; ▁int ▁ser r no ▁= ▁0; ▁/* ▁Determ ine ▁the ▁security ▁model ▁*/ ▁if ▁( fs _ ctx -> fs _ sm ▁== ▁SM _ MAP PED ) ▁{ ▁fd ▁= ▁open ( r path ( fs _ ctx , ▁path ), ▁flags , ▁SM _ LOCAL _ MODE _ BITS ); ▁if ▁( fd ▁== ▁-1) ▁{ ▁return ▁fd ; ▁} ▁cred p -> fc _ mode ▁= ▁cred p -> fc _ mode | S _ IF REG ; ▁/* ▁Set ▁cle int ▁credentials ▁in ▁x attr ▁*/ ▁err ▁= ▁local _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁y uv 2 packed X in C ( Sw s Context ▁* c , ▁int 16_ t ▁* l um Filter , ▁int 16_ t ▁** l um Src , ▁int ▁l um Filter Size , ▁int 16_ t ▁* chr Filter , ▁int 16_ t ▁** chr Src , ▁int ▁chr Filter Size , ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁y ) ▁{ ▁int ▁i ; ▁switch ( c -> dst Format ) ▁{ ▁case ▁PI X _ F MT _ B GR 32 : ▁case ▁PI X _ F MT _ RGB 32 : ▁Y SCALE _ Y UV _2_ RGB X _ C ( uint 32_ t ) ▁(( uint 32_ t *) dest )[ i 2 +0 ]= ▁r [ Y 1] ▁+ ▁g [ Y 1] ▁+ ▁b [ Y 1 ]; ▁(( uint 32_ t *) de

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret , ▁did _ split ; ▁if ▁( s -> output _ ts _ offset ) ▁{ ▁AV Stream ▁* st ▁= ▁s -> streams [ pk t -> stream _ index ]; ▁int 64_ t ▁offset ▁= ▁av _ res cale _ q ( s -> output _ ts _ offset , ▁AV _ TIME _ BASE _ Q , ▁st -> time _ base ); ▁if ▁( pk t -> d ts ▁!= ▁AV _ NO PT S _ VALUE ) ▁pkt -> d ts ▁+= ▁offset ; ▁if ▁( pk t -> pts ▁!= ▁AV _ NO PT S _ VALUE ) ▁pkt -> pts ▁+= ▁offset ; ▁} ▁if ▁( s -> av oid _ negative _ ts 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁read _ sgi _ header ( Byte IO Context ▁* f , ▁S GI Info ▁* info ) ▁{ ▁info -> magic ▁= ▁( un signed ▁short ) ▁get _ be 16 ( f ); ▁info -> r le ▁= ▁get _ byte ( f ); ▁info -> bytes _ per _ channel ▁= ▁get _ byte ( f ); ▁info -> dimension ▁= ▁( un signed ▁short ) get _ be 16 ( f ); ▁info -> x size ▁= ▁( un signed ▁short ) ▁get _ be 16 ( f ); ▁info -> y size ▁= ▁( un signed ▁short ) ▁get _ be 16 ( f ); ▁info -> z size ▁= ▁( un signed ▁short ) ▁get _ be 16 ( f ); ▁# if def ▁DEBUG ▁printf (" sgi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ init 1( ram _ addr _ t ▁ram _ size , ▁int ▁v ga _ ram _ size , ▁const ▁char ▁* boot _ device , ▁Display State ▁* ds , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁int ▁pci _ enabled , ▁const ▁char ▁* cpu _ model ) ▁{ ▁char ▁buf [10 24 ]; ▁int ▁ret , ▁linux _ boot , ▁i ; ▁ram _ addr _ t ▁ram _ addr , ▁v ga _ ram _ addr , ▁b ios _ offset , ▁v ga _ b ios _ offset ; ▁ram _ addr _ t ▁below _4 g _ mem _ size , ▁above _4 g _ mem 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sl ir p _ host f wd ( Sl ir p State ▁* s , ▁const ▁char ▁* re dir _ str , ▁int ▁legacy _ format ) ▁{ ▁struct ▁in _ addr ▁host _ addr ▁= ▁{ ▁. s _ addr ▁= ▁IN ADDR _ ANY ▁}; ▁struct ▁in _ addr ▁guest _ addr ▁= ▁{ ▁. s _ addr ▁= ▁0 ▁}; ▁int ▁host _ port , ▁guest _ port ; ▁const ▁char ▁* p ; ▁char ▁buf [ 256 ]; ▁int ▁is _ ud p ; ▁char ▁* end ; ▁p ▁= ▁re dir _ str ; ▁if ▁(! p ▁|| ▁get _ str _ sep ( buf , ▁sizeof ( buf ), ▁& p , ▁': ') ▁< ▁0) ▁{ ▁goto ▁fail _ syntax ; ▁} ▁if ▁(! str cmp ( buf , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ put _ regist ers ( CPU State ▁* cs , ▁int ▁level ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁S 39 0_ CPU ( cs ); ▁CP US 390 X State ▁* env ▁= ▁& cpu -> env ; ▁struct ▁k vm _ s re gs ▁s re gs ; ▁struct ▁k vm _ re gs ▁regs ; ▁struct ▁k vm _ f pu ▁f pu ; ▁int ▁r ; ▁int ▁i ; ▁/* ▁always ▁save ▁the ▁PS W ▁and ▁the ▁GP RS */ ▁cs -> k vm _ run -> p sw _ addr ▁= ▁env -> p sw . addr ; ▁cs -> k vm _ run -> p sw _ mask ▁= ▁env -> p sw . mask ; ▁if ▁( cap _ sync _ re gs ▁&& ▁cs -> k vm _ run -> k vm _ valid _ re g

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ hot plug _ req _ event ( uint 8_ t ▁hp _ id , ▁uint 8_ t ▁hp _ action , ▁s P AP R DR Connector Type ▁d rc _ type , ▁uint 32_ t ▁d rc ) ▁{ ▁s P AP R Machine State ▁* sp ap r ▁= ▁SP AP R _ MA CHINE ( q dev _ get _ machine ()); ▁struct ▁hp _ log _ full ▁* new _ hp ; ▁struct ▁rt as _ error _ log ▁* hdr ; ▁struct ▁rt as _ event _ log _ v 6 ▁* v 6 hdr ; ▁struct ▁rt as _ event _ log _ v 6_ main a ▁* main a ; ▁struct ▁rt as _ event _ log _ v 6_ main b ▁* main b ; ▁struct ▁rt as _ event _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ hub _ broadcast _ packet ( US B Hub State ▁* s , ▁USB Packet ▁* p ) ▁{ ▁USB Hub Port ▁* port ; ▁USB Device ▁* dev ; ▁int ▁i , ▁ret ; ▁for ( i ▁= ▁0; ▁i ▁< ▁NUM _ PORT S ; ▁i ++) ▁{ ▁port ▁= ▁& s -> ports [ i ]; ▁dev ▁= ▁port -> port . dev ; ▁if ▁( dev ▁&& ▁( port -> w Port Status ▁& ▁PORT _ STAT _ ENABLE )) ▁{ ▁ret ▁= ▁usb _ handle _ packet ( dev , ▁p ); ▁if ▁( ret ▁!= ▁USB _ RET _ NODE V ) ▁{ ▁return ▁ret ; ▁} ▁} ▁} ▁return ▁USB _ RET _ NODE V ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Driver A IO CB ▁* b dr v _ a io _ write v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁Block Driver A IO CB ▁* ret ; ▁if ▁(! dr v ) ▁return ▁NULL ; ▁if ▁( bs -> read _ only ) ▁return ▁NULL ; ▁if ▁( b dr v _ check _ request ( bs , ▁sector _ num , ▁nb _ sect ors )) ▁return ▁NULL ; ▁if ▁( bs -> dirty _ tracking ) ▁{ ▁set _ dirty _ bitmap ( b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ d ct _ init _ x 86 ( D CT Context ▁* s ) ▁{ ▁int ▁cpu _ flags ▁= ▁av _ get _ cpu _ flags (); ▁if ▁( EXTERNAL _ SS E ( cpu _ flags )) ▁s -> d ct 32 ▁= ▁ff _ d ct 32_ float _ s se ; ▁if ▁( EXTERNAL _ SS E 2( cpu _ flags )) ▁s -> d ct 32 ▁= ▁ff _ d ct 32_ float _ s se 2; ▁if ▁( EXTERNAL _ AV X ( cpu _ flags )) ▁s -> d ct 32 ▁= ▁ff _ d ct 32_ float _ av x ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ms r le _ decode _ pal 4 ( AV Codec Context ▁* av ctx , ▁AV Picture ▁* pic , ▁Get Byte Context ▁* gb ) ▁{ ▁unsigned ▁char ▁r le _ code ; ▁unsigned ▁char ▁extra _ byte , ▁odd _ pixel ; ▁unsigned ▁char ▁stream _ byte ; ▁unsigned ▁int ▁pixel _ ptr ▁= ▁0; ▁int ▁row _ dec ▁= ▁pic -> lines ize [0]; ▁int ▁row _ ptr ▁= ▁( av ctx -> height ▁- ▁1) ▁* ▁row _ dec ; ▁int ▁frame _ size ▁= ▁row _ dec ▁* ▁av ctx -> height ; ▁int ▁i ; ▁while ▁( row _ ptr ▁>= ▁0) ▁{ ▁if ▁( by test ream 2_ get _ bytes _ left (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( mvc )( CP US 390 X State ▁* env , ▁uint 32_ t ▁l , ▁uint 64_ t ▁dest , ▁uint 64_ t ▁src ) ▁{ ▁int ▁i ▁= ▁0; ▁int ▁x ▁= ▁0; ▁uint 32_ t ▁l _64 ▁= ▁( l ▁+ ▁1) ▁/ ▁8 ; ▁HEL PER _ LOG ("% s ▁l ▁% d ▁dest ▁% " ▁PRI x 64 ▁" ▁src ▁% " ▁PRI x 64 ▁"\ n ", ▁__ func __, ▁l , ▁dest , ▁src ); ▁# if nd ef ▁CONFIG _ USER _ ONLY ▁if ▁(( l ▁> ▁3 2) ▁&& ▁( src ▁& ▁TARGET _ PAGE _ MASK ) ▁== ▁(( src ▁+ ▁l ) ▁& ▁TARGET _ PAGE _ MASK ) ▁&& ▁( dest ▁& ▁TARGET _ PAGE _ MASK ) ▁== ▁(( dest ▁+ ▁l ) ▁& ▁TARGET _ P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ properties ( const ▁char ▁* path , ▁bool ▁recurse ) ▁{ ▁char ▁* child _ path ; ▁Q Dict ▁* response , ▁* tuple ; ▁Q List ▁* list ; ▁Q ListEntry ▁* entry ; ▁g _ test _ message (" Ob t aining ▁properties ▁of ▁% s ", ▁path ); ▁response ▁= ▁q mp ("{ ▁' execute ': ▁' q om - list ', " ▁" ▁' arguments ': ▁{ ▁' path ': ▁% s ▁} ▁} ", ▁path ); ▁g _ assert ( response ); ▁if ▁(! rec urse ) ▁{ ▁return ; ▁} ▁g _ assert ( q dict _ has key ( response , ▁" return ")); ▁list ▁= ▁q object _ to _ q list 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁th p _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁Th p Dem ux Context ▁* th p ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁i ; ▁/* ▁Read ▁the ▁file ▁header . ▁*/ ▁av io _ rb 32 ( pb ); ▁/* ▁Skip ▁Magic . ▁*/ ▁th p -> version ▁= ▁av io _ rb 32 ( pb ); ▁av io _ rb 32 ( pb ); ▁/* ▁Max ▁buf ▁size . ▁*/ ▁av io _ rb 32 ( pb ); ▁/* ▁Max ▁samples . ▁*/ ▁th p -> f ps ▁= ▁av _ d 2 q ( av _ int 2 float ( av io _ rb 32 ( pb )), ▁INT _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rd ma _ add _ block ( RD MA Context ▁* rd ma , ▁const ▁char ▁* block _ name , ▁void ▁* host _ addr , ▁ram _ addr _ t ▁block _ offset , ▁uint 64_ t ▁length ) ▁{ ▁R DM AL ocal Blocks ▁* local ▁= ▁& rd ma -> local _ ram _ blocks ; ▁R DM AL ocal Block ▁* block ; ▁R DM AL ocal Block ▁* old ▁= ▁local -> block ; ▁local -> block ▁= ▁g _ m alloc 0( size of ( RD M AL ocal Block ) ▁* ▁( local -> nb _ blocks ▁+ ▁1 )); ▁if ▁( local -> nb _ blocks ) ▁{ ▁int ▁x ; ▁if ▁( rd ma -> block map ) ▁{ ▁for ▁( x ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁process _ tx _ desc ( E 1000 State ▁* s , ▁struct ▁e 1000 _ tx _ desc ▁* dp ) ▁{ ▁uint 32_ t ▁tx d _ lower ▁= ▁le 32_ to _ cpu ( dp -> lower . data ); ▁uint 32_ t ▁dtype ▁= ▁tx d _ lower ▁& ▁( E 1000 _ TX D _ CMD _ DE XT ▁| ▁E 1000 _ TX D _ D TY P _ D ); ▁unsigned ▁int ▁split _ size ▁= ▁tx d _ lower ▁& ▁0 xffff , ▁bytes , ▁sz , ▁op ; ▁unsigned ▁int ▁m sh ▁= ▁0 xff fff , ▁hdr ▁= ▁0; ▁uint 64_ t ▁addr ; ▁struct ▁e 1000 _ context _ desc ▁* xp ▁= ▁( struct ▁e 1000 _ context _ desc ▁* ) dp ; ▁struct ▁e 1000 _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ input _ pc i _ real ize ( V irt IO PC I Proxy ▁* vpc i _ dev , ▁Error ▁** err p ) ▁{ ▁V irt IO Input PC I ▁* v input ▁= ▁VI RT IO _ INPUT _ PC I ( vpc i _ dev ); ▁Device State ▁* v dev ▁= ▁DEVICE ( & v input -> v dev ); ▁q dev _ set _ parent _ bus ( v dev , ▁B US ( & vpc i _ dev -> bus )); ▁/* ▁force ▁virt io -1 .0 ▁*/ ▁vpc i _ dev -> flags ▁&= ▁~ VI RT IO _ PC I _ FLAG _ DIS ABLE _ MO DER N ; ▁vpc i _ dev -> flags ▁|= ▁VI RT IO _ PC I _ FLAG _ DIS ABLE _ LEG ACY ; ▁object _ prope

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ visitor _ out _ string ( Test Output Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁char ▁* string ▁= ▁( char ▁* ) ▁" Q ▁E ▁M ▁U "; ▁Error ▁* err ▁= ▁NULL ; ▁Q Object ▁* obj ; ▁visit _ type _ str ( data -> ov , ▁& string , ▁NULL , ▁& err ); ▁g _ assert (! err ); ▁obj ▁= ▁q mp _ output _ get _ q object ( data -> q ov ); ▁g _ assert ( obj ▁!= ▁NULL ); ▁g _ assert ( q object _ type ( obj ) ▁== ▁Q TYPE _ Q STRING ); ▁g _ assert _ cmp str ( q string _ get _ str ( q object _ to _ q st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ machine _ set _ vm port ( Object ▁* obj , ▁bool ▁value , ▁Error ▁** err p ) ▁{ ▁PC Machine State ▁* pc ms ▁= ▁PC _ MA CHINE ( obj ); ▁pc ms -> vm port ▁= ▁value ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ tr ak ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁AV Stream ▁* st ; ▁MO V Stream Context ▁* sc ; ▁int ▁ret ; ▁st ▁= ▁av format _ new _ stream ( c -> fc , ▁NULL ); ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁st -> id ▁= ▁c -> fc -> nb _ streams ; ▁sc ▁= ▁av _ m alloc z ( size of ( MO V Stream Context )); ▁if ▁(! sc ) ▁return ▁A VER ROR ( EN O ME M ); ▁st -> priv _ data ▁= ▁sc ; ▁st -> codec -> codec _ type ▁= ▁AV MEDIA _ TYPE _ DATA ; ▁sc -> ff index ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁buffer _ empty ( Buffer ▁* buffer ) ▁{ ▁return ▁buffer -> offset ▁== ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁p ty _ chr _ timer ( g pointer ▁opaque ) ▁{ ▁struct ▁Char Driver State ▁* chr ▁= ▁opaque ; ▁P ty Char Driver ▁* s ▁= ▁chr -> op aque ; ▁if ▁( s -> connected ) ▁{ ▁goto ▁out ; ▁} ▁/* ▁Next ▁poll ▁... ▁*/ ▁p ty _ chr _ update _ read _ handler ( chr ); ▁out : ▁s -> timer _ tag ▁= ▁0; ▁return ▁FALSE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h 26 3_ encode _ init ( M peg Enc Context ▁* s ) ▁{ ▁static ▁int ▁done ▁= ▁0; ▁if ▁(! done ) ▁{ ▁done ▁= ▁1; ▁init _ uni _ dc _ tab (); ▁init _ rl ( & rl _ inter ); ▁init _ rl ( & rl _ in tra ); ▁init _ rl ( & rl _ in tra _ a ic ); ▁init _ uni _ mpeg 4_ rl _ tab ( & rl _ in tra , ▁uni _ mpeg 4_ in tra _ rl _ bits , ▁uni _ mpeg 4_ in tra _ rl _ len ); ▁init _ uni _ mpeg 4_ rl _ tab ( & rl _ inter , ▁uni _ mpeg 4_ inter _ rl _ bits , ▁uni _ mpeg 4_ inter _ rl _ len ); ▁init _ uni _ h 26 3_ rl _ tab (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ of lag _ cop ied ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁B dr v Check Mode ▁fix ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁* l 2_ table ▁= ▁qemu _ block align ( bs , ▁s -> cluster _ size ); ▁int ▁ret ; ▁uint 64_ t ▁ref count ; ▁int ▁i , ▁j ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> l 1_ size ; ▁i ++) ▁{ ▁uint 64_ t ▁l 1_ entry ▁= ▁s -> l 1_ table [ i ]; ▁uint 64_ t ▁l 2_ offset ▁= ▁l 1_ entry ▁& ▁L 1 E _ OFFSET _ MASK ; ▁bool ▁l 2_ dirty ▁= ▁false ; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁main stone _ common _ init ( Memory Region ▁* address _ space _ mem , ▁Machine State ▁* machine , ▁enum ▁main stone _ model _ e ▁model , ▁int ▁arm _ id ) ▁{ ▁uint 32_ t ▁sector _ len ▁= ▁256 ▁* ▁1024 ; ▁hw addr ▁main stone _ flash _ base [] ▁= ▁{ ▁M ST _ FL ASH _ 0, ▁M ST _ FL ASH _1 ▁}; ▁P XA 2 xx State ▁* mp u ; ▁Device State ▁* m st _ irq ; ▁Drive Info ▁* d info ; ▁int ▁i ; ▁int ▁be ; ▁Memory Region ▁* rom ▁= ▁g _ new ( Memory Region , ▁1); ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( v u 9_ to _ v u 12 )( const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁uint 8_ t ▁* dst 1, ▁uint 8_ t ▁* dst 2, ▁long ▁width , ▁long ▁height , ▁long ▁src Stride 1, ▁long ▁src Stride 2, ▁long ▁dst Stride 1, ▁long ▁dst Stride 2) ▁{ ▁long ▁y , x , w , h ; ▁w = width /2 ; ▁h = height /2 ; ▁# if def ▁HAVE _ MM X ▁asm ▁volatile ( ▁PREF ETCH " ▁% 0\ n \ t " ▁PREF ETCH " ▁% 1\ n \ t " ▁:: " m " (* ( src 1+ src Stride 1) ), " m " (* ( src 2 + src Stride 2) ): " memory "); ▁#

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p uv 3_ init ( Machine State ▁* machine ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁machine -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁CPU Un i Core 32 State ▁* env ; ▁Un i Core 32 CPU ▁* cpu ; ▁if ▁( init rd _ filename ) ▁{ ▁error _ report (" Please ▁use ▁kernel ▁built - in ▁init ram disk "); ▁exit (1); ▁} ▁if ▁(! cpu _ model ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁output _ data _ internal ( ML P Decode Context ▁* m , ▁unsigned ▁int ▁substr , ▁uint 8_ t ▁* data , ▁unsigned ▁int ▁* data _ size , ▁int ▁is 32) ▁{ ▁Sub Stream ▁* s ▁= ▁& m -> sub stream [ substr ]; ▁unsigned ▁int ▁i , ▁out _ ch ▁= ▁0; ▁int 32_ t ▁* data _32 ▁= ▁( int 32_ t *) ▁data ; ▁int 16_ t ▁* data _16 ▁= ▁( int 16_ t *) ▁data ; ▁if ▁(* data _ size ▁< ▁( s -> max _ channel ▁+ ▁1) ▁* ▁s -> block pos ▁* ▁( is 32 ▁? ▁4 ▁: ▁2 )) ▁return ▁-1; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> block pos ; ▁i ++) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ read _ extensions ( Block Driver State ▁* bs , ▁uint 64_ t ▁start _ offset , ▁uint 64_ t ▁end _ offset , ▁void ▁** p _ feature _ table , ▁Error ▁** err p ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁Q C ow Extension ▁ext ; ▁uint 64_ t ▁offset ; ▁int ▁ret ; ▁# if def ▁DEBUG _ EXT ▁printf (" q c ow 2_ read _ extensions : ▁start =% ld ▁end =% ld \ n ", ▁start _ offset , ▁end _ offset ); ▁# end if ▁offset ▁= ▁start _ offset ; ▁while ▁( offset ▁< ▁end _ offset ) ▁{ ▁# if def ▁DEBU

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁inline ▁static ▁void ▁RE NAME ( h cs cale )( Sw s Context ▁* c , ▁uint 16_ t ▁* dst , ▁int ▁dst Width , ▁const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁int ▁src W , ▁int ▁x Inc , ▁const ▁int 16_ t ▁* h Ch r Filter , ▁const ▁int 16_ t ▁* h Ch r Filter Pos , ▁int ▁h Ch r Filter Size , ▁uint 8_ t ▁* format Conv Buffer , ▁uint 32_ t ▁* pal ) ▁{ ▁src 1 ▁+= ▁c -> chr Src Offset ; ▁src 2 ▁+= ▁c -> chr Src Offset ; ▁if ▁( c -> chr To Y V 12) ▁{ ▁c -> chr To Y V 12 ( format Conv Buffer , ▁format Conv Buf

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pl 01 1_ init ( uint 32_ t ▁base , ▁qemu _ irq ▁irq , ▁Char Driver State ▁* chr ) ▁{ ▁int ▁i om em type ; ▁pl 01 1_ state ▁* s ; ▁s ▁= ▁( pl 01 1_ state ▁* ) q emu _ m alloc z ( size of ( pl 01 1_ state )); ▁i om em type ▁= ▁cpu _ register _ io _ memory (0, ▁pl 01 1_ read fn , ▁pl 01 1_ writ ef n , ▁s ); ▁cpu _ register _ ph ysical _ memory ( base , ▁0 x 00000 fff , ▁i om em type ); ▁s -> base ▁= ▁base ; ▁s -> irq ▁= ▁irq ; ▁s -> chr ▁= ▁chr ; ▁s -> read _ trigger ▁= ▁1; ▁s -> if l ▁= ▁0 x 12 ; ▁s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spr _ read _ x er ▁( Dis as Context ▁* ctx , ▁int ▁g pr n , ▁int ▁spr n ) ▁{ ▁gen _ read _ x er ( cpu _ g pr [ g pr n ]); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cpu _ load _ old ( Q EM U File ▁* f , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁Power PC CPU ▁* cpu ▁= ▁opaque ; ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁unsigned ▁int ▁i , ▁j ; ▁target _ ulong ▁s dr 1; ▁uint 32_ t ▁fps cr ; ▁target _ ulong ▁x er ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁32 ; ▁i ++) ▁qemu _ get _ b et ls ( f , ▁& env -> g pr [ i ]); ▁# if ▁! defined ( TARGET _ P PC 64) ▁for ▁( i ▁= ▁0; ▁i ▁< ▁32 ; ▁i ++) ▁qemu _ get _ b et ls ( f , ▁& env -> g pr h [ i ]); ▁# end if ▁qemu _ get _ b et l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str t oul _ invalid ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" ▁xxxx ▁\ t ▁abc "; ▁char ▁f ▁= ▁' X '; ▁const ▁char ▁* end ptr ▁= ▁& f ; ▁unsigned ▁long ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str t oul ( str , ▁& end ptr , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert ( end ptr ▁== ▁str ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ l um a _ mid v _ q rt _4 w _ ms a ( const ▁uint 8_ t ▁* src , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride , ▁int 32_ t ▁height , ▁uint 8_ t ▁ver _ offset ) ▁{ ▁uint 32_ t ▁loop _ cnt ; ▁v 16 i 8 ▁src 0, ▁src 1, ▁src 2, ▁src 3, ▁src 4; ▁v 16 i 8 ▁mask 0, ▁mask 1, ▁mask 2; ▁v 8 i 16 ▁h z _ out 0, ▁h z _ out 1, ▁h z _ out 2, ▁h z _ out 3; ▁v 8 i 16 ▁h z _ out 4, ▁h z _ out 5, ▁h z _ out 6, ▁h z _ out 7, ▁h z _ out 8 ; ▁v 8 i 16 ▁dst 0, ▁dst 1, ▁dst 2, ▁dst 3,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁a ml _ free ( g pointer ▁data , ▁g pointer ▁user _ data ) ▁{ ▁A ml ▁* var ▁= ▁data ; ▁build _ free _ array ( var -> buf ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ sc si _ handle _ cmd ( V irt IO Device ▁* v dev , ▁V irt Queue ▁* v q ) ▁{ ▁/* ▁use ▁non - Q OM ▁cast s ▁in ▁the ▁data ▁path ▁*/ ▁V irt IO SC SI ▁* s ▁= ▁( V irt IO SC SI ▁* ) v dev ; ▁V irt IO SC SI Common ▁* vs ▁= ▁& s -> parent _ obj ; ▁V irt IO SC SI Req ▁* req ; ▁int ▁n ; ▁while ▁(( req ▁= ▁virt io _ sc si _ pop _ req ( s , ▁v q ))) ▁{ ▁S CS ID evice ▁* d ; ▁int ▁out _ size , ▁in _ size ; ▁if ▁( req -> elem . out _ num ▁< ▁1 ▁|| ▁req -> elem . in _ num ▁< ▁1) ▁{ ▁virt io _ sc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Char Driver State ▁* text _ console _ init ( Q emu Opts ▁* opts ) ▁{ ▁Char Driver State ▁* chr ; ▁Q emu Console ▁* s ; ▁unsigned ▁width ; ▁unsigned ▁height ; ▁chr ▁= ▁g _ m alloc 0( size of ( Char Driver State )); ▁width ▁= ▁qemu _ opt _ get _ number ( opts , ▁" width ", ▁0); ▁if ▁( width ▁== ▁0) ▁width ▁= ▁qemu _ opt _ get _ number ( opts , ▁" cols ", ▁0) ▁* ▁FONT _ WIDTH ; ▁height ▁= ▁qemu _ opt _ get _ number ( opts , ▁" height ", ▁0); ▁if ▁( height ▁== ▁0) ▁height ▁= ▁qemu _ opt _ get _ number ( opts

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁e ep ro 100 _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁EE PRO 100 State ▁* s ▁= ▁opaque ; ▁switch ▁( size ) ▁{ ▁case ▁1: ▁return ▁e ep ro 100 _ read 1( s , ▁addr ); ▁case ▁2: ▁return ▁e ep ro 100 _ read 2( s , ▁addr ); ▁case ▁4: ▁return ▁e ep ro 100 _ read 4 ( s , ▁addr ); ▁default : ▁abort (); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁v ring _ should _ notify ( V irt IO Device ▁* v dev , ▁V ring ▁* v ring ) ▁{ ▁uint 16_ t ▁old , ▁new ; ▁bool ▁v ; ▁/* ▁Flush ▁out ▁used ▁index ▁updates . ▁This ▁is ▁paired ▁* ▁with ▁the ▁barrier ▁that ▁the ▁Gu est ▁executes ▁when ▁enabling ▁* ▁interrupt s . ▁*/ ▁s mp _ mb (); ▁if ▁(( v dev -> guest _ features ▁& ▁(1 ▁<< ▁VI RT IO _ F _ NOT IFY _ ON _ EMPTY )) ▁&& ▁unlikely (! v ring _ more _ avail ( v dev , ▁v ring ))) ▁{ ▁return ▁true ; ▁} ▁if ▁(! ( v dev -> guest _ features ▁& ▁(1 ▁<< ▁VI RT IO _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁am r _ nb _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* av pk t , ▁const ▁AV Frame ▁* frame , ▁int ▁* got _ packet _ ptr ) ▁{ ▁AM R Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁written , ▁ret ; ▁int 16_ t ▁* flush _ buf ▁= ▁NULL ; ▁const ▁int 16_ t ▁* samples ▁= ▁frame ▁? ▁( const ▁int 16_ t ▁* ) frame -> data [0] ▁: ▁NULL ; ▁if ▁( s -> enc _ bit rate ▁!= ▁av ctx -> bit _ rate ) ▁{ ▁s -> enc _ mode ▁= ▁get _ bit rate _ mode ( av ctx -> bit _ rate , ▁av ctx ); ▁s -> enc _ bi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ un assigned _ access ( target _ ph ys _ addr _ t ▁addr , ▁int ▁is _ write , ▁int ▁is _ exec , ▁int ▁is _ as i , ▁int ▁size ) ▁{ ▁CPU State ▁* saved _ env ; ▁/* ▁XXX : ▁hack ▁to ▁restore ▁env ▁in ▁all ▁cases , ▁even ▁if ▁not ▁called ▁from ▁generated ▁code ▁*/ ▁saved _ env ▁= ▁env ; ▁env ▁= ▁cpu _ single _ env ; ▁qemu _ log (" Un assigned ▁" ▁TARGET _ F MT _ pl x ▁" ▁wr =% d ▁exe =% d \ n ", ▁addr , ▁is _ write , ▁is _ exec ); ▁if ▁(! ( env -> s re gs [ SR _ MS R ] ▁& ▁MS R _ EE )) ▁{ ▁return ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁RE NAME ( sw Scale )( Sw s Context ▁* c , ▁uint 8_ t * ▁src [], ▁int ▁src Stride [], ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁uint 8_ t * ▁dst [], ▁int ▁dst Stride [] ){ ▁/* ▁load ▁a ▁few ▁things ▁into ▁local ▁vars ▁to ▁make ▁the ▁code ▁more ▁readable ? ▁and ▁faster ▁*/ ▁const ▁int ▁src W = ▁c -> src W ; ▁const ▁int ▁dst W = ▁c -> dst W ; ▁const ▁int ▁dst H = ▁c -> dst H ; ▁const ▁int ▁chr Dst W = ▁c -> chr Dst W ; ▁const ▁int ▁chr Src W = ▁c -> chr Src W ; ▁const ▁int ▁l um X Inc = ▁c -> l 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( b gr 24 To Y )( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁int ▁width , ▁uint 32_ t ▁* unused ) ▁{ ▁# if ▁COM PI LE _ TEMPLATE _ MM X ▁RE NAME ( b gr 24 To Y _ mm x )( dst , ▁src , ▁width , ▁PI X _ F MT _ B GR 24 ); ▁# else ▁int ▁i ; ▁for ▁( i =0; ▁i < width ; ▁i ++) ▁{ ▁int ▁b = ▁src [ i * 3 +0 ]; ▁int ▁g = ▁src [ i * 3 +1 ]; ▁int ▁r = ▁src [ i * 3 +2 ]; ▁dst [ i ]= ▁(( RY * r ▁+ ▁G Y * g ▁+ ▁BY * b ▁+ ▁( 33 << ( RGB 2 Y UV _ SHIFT -1 ))) >> RGB 2 Y UV _ SHIFT ); ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁F UNC ( ff _ simple _ id ct )( D CT E LE M ▁* block ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁F UNC ( id ct Row Cond DC )( block ▁+ ▁i * 8 ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁F UNC ( id ct Sparse Col )( block ▁+ ▁i ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁oh ci _ async _ cancel _ device ( O H CI State ▁* oh ci , ▁USB Device ▁* dev ) ▁{ ▁if ▁( oh ci -> async _ td ▁&& ▁oh ci -> usb _ packet . owner ▁!= ▁NULL ▁&& ▁oh ci -> usb _ packet . owner -> dev ▁== ▁dev ) ▁{ ▁usb _ cancel _ packet ( & oh ci -> usb _ packet ); ▁oh ci -> async _ td ▁= ▁0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av _ encode ( AV Format Context ▁** output _ files , ▁int ▁nb _ output _ files , ▁AV Format Context ▁** input _ files , ▁int ▁nb _ input _ files , ▁AV Stream Map ▁* stream _ maps , ▁int ▁nb _ stream _ maps ) ▁{ ▁int ▁ret , ▁i , ▁j , ▁k , ▁n , ▁nb _ ist ream s ▁= ▁0, ▁nb _ ost ream s ▁= ▁0; ▁AV Format Context ▁* is , ▁* os ; ▁AV Codec Context ▁* codec , ▁* icode c ; ▁AV OutputStream ▁* ost , ▁** ost _ table ▁= ▁NULL ; ▁AV InputStream ▁* ist , ▁** ist _ table ▁= ▁NULL ; ▁AV Input File ▁* file 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av priv _ mpeg 4 audio _ get _ config ( M PEG 4 Audio Config ▁* c , ▁const ▁uint 8_ t ▁* buf , ▁int ▁bit _ size , ▁int ▁sync _ extension ) ▁{ ▁Get Bit Context ▁gb ; ▁int ▁specific _ config _ bit index ; ▁init _ get _ bits ( & gb , ▁buf , ▁bit _ size ); ▁c -> object _ type ▁= ▁get _ object _ type ( & gb ); ▁c -> sample _ rate ▁= ▁get _ sample _ rate ( & gb , ▁& c -> sampling _ index ); ▁c -> chan _ config ▁= ▁get _ bits ( & gb , ▁4 ); ▁if ▁( c -> chan _ config ▁< ▁FF _ ARRAY _ E LE MS ( ff _ mpeg 4 a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁vc 1_ apply _ p _ h _ loop _ filter ( VC 1 Context ▁* v , ▁int ▁block _ num ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& v -> s ; ▁int ▁mb _ cb p ▁= ▁v -> cb p [ s -> mb _ x ▁- ▁1 ▁- ▁s -> mb _ stride ], ▁block _ cb p ▁= ▁mb _ cb p ▁>> ▁( block _ num ▁* ▁4), ▁right _ cb p , ▁mb _ is _ in tra ▁= ▁v -> is _ in tra [ s -> mb _ x ▁- ▁1 ▁- ▁s -> mb _ stride ], ▁block _ is _ in tra ▁= ▁mb _ is _ in tra ▁>> ▁( block _ num ▁* ▁4), ▁right _ is _ in tra ; ▁int ▁idx , ▁lines ize ▁= ▁block 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ packet ( AV Format Context ▁* s , ▁uint 8_ t ▁* buf , ▁int ▁raw _ packet _ size , ▁uint 8_ t ▁** data ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁len ; ▁for ( ; ;) ▁{ ▁len ▁= ▁ff io _ read _ ind irect ( pb , ▁buf , ▁TS _ PA CKET _ SIZE , ▁data ); ▁if ▁( len ▁!= ▁TS _ PA CKET _ SIZE ) ▁return ▁len ▁< ▁0 ▁? ▁len ▁: ▁A VER ROR _ EOF ; ▁/* ▁check ▁packet ▁sync ▁byte ▁*/ ▁if ▁(( * data )[0] ▁!= ▁0 x 47 ) ▁{ ▁/* ▁find ▁a ▁new ▁packet ▁start ▁*/ ▁av io _ seek ( pb , ▁- TS _ PA CKET _ SIZE 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ parse _ sample _ rate ( un signed ▁* ret , ▁const ▁char ▁* arg , ▁void ▁* log _ ctx ) ▁{ ▁char ▁* tail ; ▁double ▁s rate ▁= ▁av _ str tod ( arg , ▁& tail ); ▁if ▁(* tail ▁|| ▁s rate ▁< ▁1 ▁|| ▁( int ) s rate ▁!= ▁s rate ) ▁{ ▁av _ log ( log _ ctx , ▁AV _ LOG _ ERROR , ▁" Invalid ▁sample ▁rate ▁'% s '\ n ", ▁arg ); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁* ret ▁= ▁s rate ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ abs _ store ( CP UT ri Core State ▁* env , ▁Dis as Context ▁* ctx ) ▁{ ▁int 32_ t ▁op 2; ▁int 32_ t ▁r 1; ▁uint 32_ t ▁address ; ▁TC G v ▁temp ; ▁r 1 ▁= ▁MASK _ OP _ AB S _ S 1 D ( ctx -> op code ); ▁address ▁= ▁MASK _ OP _ AB S _ OFF 18 ( ctx -> op code ); ▁op 2 ▁= ▁MASK _ OP _ AB S _ OP 2( ctx -> op code ); ▁temp ▁= ▁tc g _ const _ i 32 ( EA _ AB S _ FORMAT ( address )); ▁switch ▁( op 2) ▁{ ▁case ▁O PC 2_ 32_ AB S _ ST _ A : ▁tc g _ gen _ q emu _ st _ tl ( cpu _ g pr _ a [ r 1], 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v 9 fs _ read dir ( void ▁* op aque ) ▁{ ▁int 32_ t ▁fid ; ▁V 9 fs F id State ▁* f id p ; ▁s size _ t ▁retval ▁= ▁0; ▁size _ t ▁offset ▁= ▁7 ; ▁uint 64_ t ▁initial _ offset ; ▁int 32_ t ▁count ; ▁uint 32_ t ▁max _ count ; ▁V 9 fs P DU ▁* pd u ▁= ▁opaque ; ▁V 9 fs State ▁* s ▁= ▁pdu -> s ; ▁pdu _ un marshal ( pd u , ▁offset , ▁" d q d ", ▁& f id , ▁& initial _ offset , ▁& max _ count ); ▁trace _ v 9 fs _ read dir ( pd u -> tag , ▁pdu -> id , ▁fid , ▁initial _ offset , ▁max _ count ); ▁fid p 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁HEL PER ( l ra )( CP US 390 X State ▁* env , ▁uint 64_ t ▁addr ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( s 39 0_ env _ get _ cpu ( env )); ▁uint 32_ t ▁cc ▁= ▁0; ▁int ▁old _ exc ▁= ▁cs -> exception _ index ; ▁uint 64_ t ▁asc ▁= ▁env -> p sw . mask ▁& ▁PS W _ MASK _ ASC ; ▁uint 64_ t ▁ret ; ▁int ▁flags ; ▁/* ▁XXX ▁incomplete ▁- ▁has ▁more ▁corner ▁cases ▁*/ ▁if ▁(! ( env -> p sw . mask ▁& ▁PS W _ MASK _64 ) ▁&& ▁( addr ▁>> ▁32 )) ▁{ ▁program _ interrupt ( env , ▁PG M _ SPE CIAL _ OP , ▁2); ▁} ▁cs -> exc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b dr v _ check _ update _ perm ( Block Driver State ▁* bs , ▁uint 64_ t ▁new _ used _ perm , ▁uint 64_ t ▁new _ shared _ perm , ▁B dr v Child ▁* ignore _ child , ▁Error ▁** err p ) ▁{ ▁B dr v Child ▁* c ; ▁uint 64_ t ▁cumulative _ perms ▁= ▁new _ used _ perm ; ▁uint 64_ t ▁cumulative _ shared _ perms ▁= ▁new _ shared _ perm ; ▁/* ▁There ▁is ▁no ▁reason ▁why ▁anyone ▁couldn ' t ▁tol erate ▁write _ unch anged ▁*/ ▁assert ( new _ shared _ perm ▁& ▁BL K _ PER M _ WRITE _ UN CHANGED ); ▁Q LIST _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁monitor _ protocol _ em itter ( Monitor ▁* mon , ▁Q Object ▁* data ) ▁{ ▁Q Dict ▁* q mp ; ▁q mp ▁= ▁q dict _ new (); ▁if ▁(! monitor _ has _ error ( mon )) ▁{ ▁/* ▁success ▁response ▁*/ ▁if ▁( data ) ▁{ ▁assert ( q object _ type ( data ) ▁== ▁Q TYPE _ Q DICT ); ▁q object _ in cre f ( data ); ▁q dict _ put _ obj ( q mp , ▁" return ", ▁data ); ▁} ▁else ▁{ ▁/* ▁return ▁an ▁empty ▁Q Dict ▁by ▁default ▁*/ ▁q dict _ put ( q mp , ▁" return ", ▁q dict _ new ()); ▁} ▁} ▁else ▁{ ▁/* ▁error ▁response 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁decode _ v ui _ parameters ( H 264 Context ▁* h , ▁S PS ▁* sp s ) ▁{ ▁int ▁aspect _ ratio _ info _ present _ flag ; ▁unsigned ▁int ▁aspect _ ratio _ id c ; ▁aspect _ ratio _ info _ present _ flag ▁= ▁get _ bits 1( & h -> gb ); ▁if ▁( aspect _ ratio _ info _ present _ flag ) ▁{ ▁aspect _ ratio _ id c ▁= ▁get _ bits ( & h -> gb , ▁8 ); ▁if ▁( aspect _ ratio _ id c ▁== ▁EX TEN DED _ S AR ) ▁{ ▁sp s -> sar . num ▁= ▁get _ bits ( & h -> gb , ▁16 ); ▁sp s -> sar . den ▁= ▁get _ bits ( & h 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ write _ compressed ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁const ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁int ▁ret ; ▁if ▁(! dr v ) ▁{ ▁return ▁- EN O MEDI UM ; ▁} ▁if ▁(! dr v -> b dr v _ write _ compressed ) ▁{ ▁return ▁- EN OT SUP ; ▁} ▁ret ▁= ▁b dr v _ check _ request ( bs , ▁sector _ num , ▁nb _ sect ors ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁assert ( Q LIST _ EMPTY ( & bs -> dirty _ bit maps )); ▁return ▁drv -> b dr v _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ host _ handle _ control ( US B Device ▁* dev , ▁USB Packet ▁* p , ▁int ▁request , ▁int ▁value , ▁int ▁index , ▁int ▁length , ▁uint 8_ t ▁* data ) ▁{ ▁USB Host Device ▁* s ▁= ▁DO _ UP CAST ( US B Host Device , ▁dev , ▁dev ); ▁struct ▁usb dev fs _ urb ▁* urb ; ▁Async UR B ▁* aur b ; ▁int ▁ret ; ▁/* ▁* ▁Process ▁certain ▁standard ▁device ▁requests . ▁* ▁These ▁are ▁inf requ ent ▁and ▁are ▁processed ▁synchronously . ▁*/ ▁/* ▁Note ▁request ▁is ▁( b Request Type ▁<< ▁8) ▁| ▁b Request ▁*/ ▁tr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁d show _ read _ header ( AV Format Context ▁* av ctx ) ▁{ ▁struct ▁d show _ ctx ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁I Graph Builder ▁* graph ▁= ▁NULL ; ▁I Create Dev Enum ▁* dev enum ▁= ▁NULL ; ▁I Media Control ▁* control ▁= ▁NULL ; ▁I Media Event ▁* media _ event ▁= ▁NULL ; ▁HAND LE ▁media _ event _ handle ; ▁HAND LE ▁proc ; ▁int ▁ret ▁= ▁A VER ROR ( E IO ); ▁int ▁r ; ▁Co Initialize (0); ▁if ▁(! ctx -> list _ devices ▁&& ▁! parse _ device _ name ( av ctx )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁s 39 0_ machine _ init fn ( Object ▁* obj ) ▁{ ▁object _ property _ add _ bool ( obj , ▁" a es - key - wrap ", ▁machine _ get _ a es _ key _ wrap , ▁machine _ set _ a es _ key _ wrap , ▁NULL ); ▁object _ property _ set _ description ( obj , ▁" a es - key - wrap ", ▁" enable / disable ▁AES ▁key ▁wrapping ▁using ▁the ▁C PA CF ▁wrapping ▁key ", ▁object _ property _ set _ bool ( obj , ▁true , ▁" a es - key - wrap ", ▁NULL ); ▁object _ property _ add _ bool ( obj , ▁" de a - key - wrap "

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁l jpeg _ decode _ rgb _ scan ( M J peg Decode Context ▁* s , ▁int ▁nb _ components , ▁int ▁predict or , ▁int ▁point _ transform ) ▁{ ▁int ▁i , ▁mb _ x , ▁mb _ y ; ▁uint 16_ t ▁(* buffer ) [4 ]; ▁int ▁left [4 ], ▁top [4 ], ▁to pleft [4 ]; ▁const ▁int ▁lines ize ▁= ▁s -> lines ize [0]; ▁const ▁int ▁mask ▁= ▁( (1 ▁<< ▁s -> bits ) ▁- ▁1) ▁<< ▁point _ transform ; ▁int ▁res ync _ mb _ y ▁= ▁0; ▁int ▁res ync _ mb _ x ▁= ▁0; ▁if ▁( s -> nb _ components ▁!= ▁3 ▁&& ▁s -> nb _ components ▁!= ▁4) ▁retur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ sp ice _ display _ init _ one ( Q emu Console ▁* con ) ▁{ ▁Simple Sp ice Display ▁* ss d ▁= ▁g _ new 0( Simple Sp ice Display , ▁1); ▁qemu _ sp ice _ display _ init _ common ( ss d ); ▁s sd -> q xl . base . s if ▁= ▁& d py _ interface . base ; ▁qemu _ sp ice _ add _ display _ interface ( & ss d -> q xl , ▁con ); ▁assert ( ss d -> worker ); ▁qemu _ sp ice _ create _ host _ mem slot ( ss d ); ▁s sd -> d cl . ops ▁= ▁& display _ listener _ ops ; ▁s sd -> d cl . con ▁= ▁con ; ▁register _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ index _ search _ timestamp ( const ▁AV Index Entry ▁* entries , ▁int ▁nb _ entries , ▁int 64_ t ▁wanted _ timestamp , ▁int ▁flags ) ▁{ ▁int ▁a , ▁b , ▁m ; ▁int 64_ t ▁timestamp ; ▁a ▁= ▁-1; ▁b ▁= ▁nb _ entries ; ▁// ▁Opt imize ▁appending ▁index ▁entries ▁at ▁the ▁end . ▁if ▁( b ▁&& ▁entries [ b ▁- ▁1 ]. timestamp ▁< ▁wanted _ timestamp ) ▁a ▁= ▁b ▁- ▁1; ▁while ▁( b ▁- ▁a ▁> ▁1) ▁{ ▁m ▁= ▁( a ▁+ ▁b ) ▁>> ▁1; ▁// ▁Search ▁for ▁the ▁next ▁non - dis card ed ▁packet . ▁while ▁(( entries [ m ]. flags

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁codec _ get _ buffer ( AV Codec Context ▁* s , ▁AV Frame ▁* frame ) ▁{ ▁InputStream ▁* ist ▁= ▁s -> op aque ; ▁Frame Buffer ▁* buf ; ▁int ▁ret , ▁i ; ▁if ▁(! ist -> buffer _ pool ▁&& ▁( ret ▁= ▁alloc _ buffer ( s , ▁ist , ▁& ist -> buffer _ pool )) ▁< ▁0) ▁return ▁ret ; ▁buf ▁= ▁ist -> buffer _ pool ; ▁ist -> buffer _ pool ▁= ▁buf -> next ; ▁buf -> next ▁= ▁NULL ; ▁if ▁( buf -> w ▁!= ▁s -> width ▁|| ▁buf -> h ▁!= ▁s -> height ▁|| ▁buf -> pix _ fmt ▁!= ▁s -> pix _ fmt ) ▁{ ▁av _ fre ep ( & bu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁filter _ frame ( AV Filter Link ▁* in link , ▁AV Frame ▁* in pic ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁in link -> dst ; ▁H ist eq Context ▁* hist eq ▁= ▁ctx -> priv ; ▁AV Filter Link ▁* out link ▁= ▁ctx -> outputs [0]; ▁int ▁strength ▁= ▁hist eq -> strength ▁* ▁1000 ; ▁int ▁intensity ▁= ▁hist eq -> int ensity ▁* ▁1000 ; ▁int ▁x , ▁y , ▁i , ▁l uth i , ▁l ut lo , ▁l ut , ▁l um a , ▁ol um a , ▁m ; ▁AV Frame ▁* out pic ; ▁unsigned ▁int ▁r , ▁g , ▁b , ▁j ran ; ▁uint 8_ t ▁* src , ▁* dst ; ▁out pic ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ visitor _ in _ native _ list _ int 32 ( Test Input Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁test _ native _ list _ integer _ helper ( data , ▁unused , ▁USER _ DEF _ N ATIVE _ LIST _ UN ION _ K IND _ S 32 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nb d _ trip ( void ▁* op aque ) ▁{ ▁N BD Client ▁* client ▁= ▁opaque ; ▁NB DE x port ▁* exp ▁= ▁client -> exp ; ▁N BD Request ▁* req ; ▁struct ▁nb d _ request ▁request ; ▁struct ▁nb d _ reply ▁reply ; ▁s size _ t ▁ret ; ▁uint 32_ t ▁command ; ▁TRACE (" Reading ▁request ."); ▁if ▁( client -> closing ) ▁{ ▁return ; ▁} ▁req ▁= ▁nb d _ request _ get ( client ); ▁ret ▁= ▁nb d _ co _ receive _ request ( req , ▁& request ); ▁if ▁( ret ▁== ▁- E AG AIN ) ▁{ ▁goto ▁done ; ▁} ▁if ▁( ret ▁== ▁- E IO ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ register _ reset ( Q EM U Reset Handler ▁* func , ▁void ▁* op aque ) ▁{ ▁Q EM U Reset Entry ▁* re ▁= ▁qemu _ m alloc z ( size of ( Q EM U Reset Entry )); ▁re -> func ▁= ▁func ; ▁re -> op aque ▁= ▁opaque ; ▁TA IL Q _ INSERT _ TAIL ( & reset _ handlers , ▁re , ▁entry ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st l _ ph ys _ not dirty ( hw addr ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁uint 8_ t ▁* ptr ; ▁Memory Region Section ▁* section ; ▁section ▁= ▁phys _ page _ find ( address _ space _ memory . dispatch , ▁addr ▁>> ▁TARGET _ PAGE _ BITS ); ▁if ▁(! memory _ region _ is _ ram ( section -> mr ) ▁|| ▁section -> readonly ) ▁{ ▁addr ▁= ▁memory _ region _ section _ addr ( section , ▁addr ); ▁if ▁( memory _ region _ is _ ram ( section -> mr )) ▁{ ▁section ▁= ▁& ph ys _ sections [ ph ys _ section _ rom ]; ▁} ▁io _ mem 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ ant ialias _ float ( MP AD ecode Context ▁* s , ▁Gr an ule Def ▁* g ) ▁{ ▁float ▁* ptr ; ▁int ▁n , ▁i ; ▁/* ▁we ▁ant ialias ▁only ▁" long " ▁bands ▁*/ ▁if ▁( g -> block _ type ▁== ▁2) ▁{ ▁if ▁(! g -> switch _ point ) ▁return ; ▁/* ▁XXX : ▁check ▁this ▁for ▁8000 Hz ▁case ▁*/ ▁n ▁= ▁1; ▁} ▁else ▁{ ▁n ▁= ▁SB LIMIT ▁- ▁1; ▁} ▁ptr ▁= ▁g -> sb _ hy brid ▁+ ▁18 ; ▁for ( i ▁= ▁n ; i ▁> ▁0; i --) ▁{ ▁float ▁tmp 0, ▁tmp 1; ▁float ▁* cs a ▁= ▁& cs a _ table _ float [0] [0]; ▁# define ▁FLOAT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P CI Bus ▁* i 4 40 fx _ init ( PC II 4 40 FX State ▁** pi 4 40 fx _ state , ▁int ▁* pi ix 3_ dev fn , ▁qemu _ irq ▁* pic , ▁int ▁ram _ size ) ▁{ ▁Device State ▁* dev ; ▁P CI Bus ▁* b ; ▁PC ID evice ▁* d ; ▁I 4 40 FX State ▁* s ; ▁PI IX 3 State ▁* pi ix 3; ▁dev ▁= ▁q dev _ create ( NULL , ▁" i 4 40 FX - pc i host "); ▁s ▁= ▁FROM _ SY SB US ( I 4 40 FX State , ▁sys bus _ from _ q dev ( dev )); ▁b ▁= ▁pci _ bus _ new ( & s -> bus dev . q dev , ▁NULL , ▁0); ▁s -> bus ▁= ▁b ; ▁q dev _ init _ n of ail ( dev );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ cv tt q _ c ( CPU Alpha State ▁* env , ▁uint 64_ t ▁a ) ▁{ ▁return ▁inline _ cv tt q ( env , ▁a , ▁float _ round _ to _ zero , ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ d ca _ core _ parse ( DC AC ore Decoder ▁* s , ▁uint 8_ t ▁* data , ▁int ▁size ) ▁{ ▁int ▁ret ; ▁s -> ext _ audio _ mask ▁= ▁0; ▁s -> x ch _ pos ▁= ▁s -> xx ch _ pos ▁= ▁s -> x 96 _ pos ▁= ▁0; ▁if ▁(( ret ▁= ▁init _ get _ bits 8 ( & s -> gb , ▁data , ▁size )) ▁< ▁0) ▁return ▁ret ; ▁s -> gb _ in ▁= ▁s -> gb ; ▁if ▁(( ret ▁= ▁parse _ frame _ header ( s )) ▁< ▁0) ▁return ▁ret ; ▁if ▁(( ret ▁= ▁alloc _ sample _ buffer ( s )) ▁< ▁0) ▁return ▁ret ; ▁if ▁(( ret ▁= ▁parse _ frame _ data ( s , ▁HEADER _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ mul u ( Dis as Context ▁* dc , ▁TC G v ▁dest , ▁TC G v ▁src a , ▁TC G v ▁src b ) ▁{ ▁TC G v ▁sr _ cy ▁= ▁tc g _ temp _ new (); ▁tc g _ gen _ mul s 2_ tl ( dest , ▁sr _ cy , ▁src a , ▁src b ); ▁tc g _ gen _ set con di _ tl ( TC G _ COND _ NE , ▁sr _ cy , ▁sr _ cy , ▁0); ▁tc g _ gen _ dep osit _ tl ( cpu _ sr , ▁cpu _ sr , ▁sr _ cy , ▁ct z 32 ( SR _ CY ), ▁1); ▁gen _ ove _ cy ( dc , ▁sr _ cy ); ▁tc g _ temp _ free ( sr _ cy ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ init _ mp 3 on 4 ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁MP 3 On 4 Decode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁if ▁(( av ctx -> ex tr ad ata _ size ▁< ▁2) ▁|| ▁( av ctx -> ex tr ad ata ▁== ▁NULL )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Codec ▁extr ad ata ▁missing ▁or ▁too ▁short .\ n "); ▁return ▁-1; ▁} ▁s -> chan _ cfg ▁= ▁( (( un signed ▁char ▁* ) av ctx -> ex tr ad ata ) [1] ▁>> ▁3) ▁& ▁0 x 0 f ; ▁s -> frames ▁= ▁mp 3 Frames [ s -> chan _ cfg ]; ▁if (! s -> fr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁_ sy scall 4 ( int , sys _ ut im ens at , int , dir fd , const ▁char ▁* , pathname , ▁const ▁struct ▁times pec ▁* , t sp , int , flags ) ▁# end if ▁# end if ▁/* ▁CONFIG _ UT IME NS AT ▁*/ ▁# if def ▁CONFIG _ IN OT IFY ▁# include ▁< sys / in otify . h > ▁# if ▁defined ( TARGET _ N R _ in otify _ init ) ▁&& ▁defined (__ N R _ in otify _ init ) ▁static ▁int ▁sys _ in otify _ init ( void ) ▁{ ▁return ▁( in otify _ init ()); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁curl _ read v _ b h _ cb ( void ▁* p ) ▁{ ▁C URL State ▁* state ; ▁int ▁running ; ▁C URL A IO CB ▁* ac b ▁= ▁p ; ▁B DR VC URL State ▁* s ▁= ▁ac b -> common . bs -> op aque ; ▁qemu _ b h _ delete ( ac b -> b h ); ▁ac b -> b h ▁= ▁NULL ; ▁size _ t ▁start ▁= ▁ac b -> sect or _ num ▁* ▁SE CTOR _ SIZE ; ▁size _ t ▁end ; ▁// ▁In ▁case ▁we ▁have ▁the ▁requested ▁data ▁already ▁( e . g . ▁read - ahead ), ▁// ▁we ▁can ▁just ▁call ▁the ▁callback ▁and ▁be ▁done . ▁switch ▁( curl _ find _ buf ( s , ▁st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dn x hd _ encode _ r do ( AV Codec Context ▁* av ctx , ▁DN X H DE nc Context ▁* ctx ) ▁{ ▁int ▁lambda , ▁up _ step , ▁down _ step ; ▁int ▁last _ lower ▁= ▁INT _ MAX , ▁last _ high er ▁= ▁0; ▁int ▁x , ▁y , ▁q ; ▁for ▁( q ▁= ▁1; ▁q ▁< ▁av ctx -> q max ; ▁q ++) ▁{ ▁ctx -> q scale ▁= ▁q ; ▁av ctx -> execute 2( av ctx , ▁dn x hd _ calc _ bits _ thread , ▁NULL , ▁NULL , ▁ctx -> m . mb _ height ); ▁} ▁up _ step ▁= ▁down _ step ▁= ▁2 << LA MB DA _ F RA C _ BITS ; ▁lambda ▁= ▁ctx -> lambda ; ▁for ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁find _ and _ decode _ index ( N UT Context ▁* n ut ) ▁{ ▁AV Format Context ▁* s ▁= ▁nut -> av f ; ▁AV IO Context ▁* bc ▁= ▁s -> pb ; ▁uint 64_ t ▁tmp , ▁end ; ▁int ▁i , ▁j , ▁sync point _ count ; ▁int 64_ t ▁filesize ▁= ▁av io _ size ( bc ); ▁int 64_ t ▁* sync points ; ▁int 8_ t ▁* has _ key frame ; ▁int ▁ret ▁= ▁A VER ROR _ IN V ALI DD ATA ; ▁av io _ seek ( bc , ▁filesize ▁- ▁12, ▁SE EK _ SET ); ▁av io _ seek ( bc , ▁filesize ▁- ▁av io _ rb 64 ( bc ), ▁SE EK _ SET ); ▁if ▁( av io _ rb 64 ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁men el a us _ rt c _ stop ( struct ▁men el a us _ s ▁* s ) ▁{ ▁qemu _ del _ timer ( s -> rt c . hz ); ▁s -> rt c . next ▁= - ▁qemu _ get _ clock ( rt _ clock ); ▁if ▁( s -> rt c . next ▁< ▁1) ▁s -> rt c . next ▁= ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁drive _ init ( struct ▁drive _ opt ▁* arg , ▁int ▁snapshot , ▁void ▁* op aque ) ▁{ ▁char ▁buf [ 128 ]; ▁char ▁file [10 24 ]; ▁char ▁dev name [ 128 ]; ▁char ▁serial [ 21 ]; ▁const ▁char ▁* media str ▁= ▁""; ▁Block Interface Type ▁type ; ▁enum ▁{ ▁MEDIA _ DIS K , ▁MEDIA _ CD ROM ▁} ▁media ; ▁int ▁bus _ id , ▁unit _ id ; ▁int ▁cy ls , ▁heads , ▁secs , ▁translation ; ▁Block Driver State ▁* b dr v ; ▁Block Driver ▁* dr v ▁= ▁NULL ; ▁Q EM UM achine ▁* machine ▁= ▁opaque ; ▁int ▁max _ dev s ; ▁int ▁index ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁g ic _ complete _ irq ( g ic _ state ▁* ▁s , ▁int ▁cpu , ▁int ▁irq ) ▁{ ▁int ▁update ▁= ▁0; ▁int ▁cm ▁= ▁1 ▁<< ▁cpu ; ▁D PRI NT F (" E O I ▁% d \ n ", ▁irq ); ▁if ▁( s -> running _ irq [ cpu ] ▁== ▁10 23 ) ▁return ; ▁/* ▁No ▁active ▁IR Q . ▁*/ ▁if ▁( irq ▁!= ▁10 23 ) ▁{ ▁/* ▁Mark ▁level ▁triggered ▁interrupt s ▁as ▁pending ▁if ▁they ▁are ▁still ▁raised . ▁*/ ▁if ▁(! G IC _ TEST _ TRI GGER ( irq ) ▁&& ▁G IC _ TEST _ ENABLED ( irq , ▁cm ) ▁&& ▁G IC _ TEST _ LEVEL ( irq , ▁cm ) ▁&& ▁( G IC _ T

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁init _ de quant 8_ coeff _ table ( H 264 Context ▁* h ){ ▁int ▁i , q , x ; ▁const ▁int ▁transpose ▁= ▁( h -> h 264 d sp . h 2 64_ id ct 8_ add ▁!= ▁ff _ h 2 64_ id ct 8_ add _ c ); ▁// FIX ME ▁ugly ▁h -> de quant 8_ coeff [0] ▁= ▁h -> de quant 8_ buffer [0]; ▁h -> de quant 8_ coeff [1] ▁= ▁h -> de quant 8_ buffer [1]; ▁for ( i =0; ▁i < 2; ▁i ++ ▁){ ▁if ( i ▁&& ▁! mem cmp ( h -> pp s . scaling _ matrix 8 [0], ▁h -> pp s . scaling _ matrix 8 [1], ▁64 * size of ( uint 8_ t )) ){ ▁h -> de quant

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁char ▁* vn c _ display _ local _ addr ( const ▁char ▁* id ) ▁{ ▁V nc Display ▁* vs ▁= ▁v nc _ display _ find ( id ); ▁return ▁v nc _ socket _ local _ addr ("% s :% s ", ▁vs -> ls ock ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( set _ T 0) ▁{ ▁T 0 ▁= ▁PARAM (1); ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ validate _ fail _ struct _ nested ( Test Input Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁User Def Two ▁* ud p ▁= ▁NULL ; ▁Error ▁* err ▁= ▁NULL ; ▁Visitor ▁* v ; ▁v ▁= ▁validate _ test _ init ( data , ▁"{ ▁' string 0 ': ▁' string 0', ▁' dict 1': ▁{ ▁' string 1': ▁' string 1', ▁' dict 2': ▁{ ▁' user def 1': ▁{ ▁' integer ': ▁4 2, ▁' string ': ▁' string ', ▁' extra ': ▁[4 2, ▁23, ▁{' foo ':' bar '}] ▁}, ▁' string 2': ▁' string 2' }} } "); ▁visit _ type _ User Def Two ( v , ▁N

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁socket _ get _ buffer ( void ▁* op aque , ▁uint 8_ t ▁* buf , ▁int 64_ t ▁pos , ▁int ▁size ) ▁{ ▁Q EM U File Socket ▁* s ▁= ▁opaque ; ▁s size _ t ▁len ; ▁do ▁{ ▁len ▁= ▁qemu _ recv ( s -> fd , ▁buf , ▁size , ▁0); ▁} ▁while ▁( len ▁== ▁-1 ▁&& ▁socket _ error () ▁== ▁E INT R ); ▁if ▁( len ▁== ▁-1) ▁len ▁= ▁- socket _ error (); ▁return ▁len ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁G IO Status ▁ga _ channel _ write ( GA Channel ▁* c , ▁const ▁char ▁* buf , ▁size _ t ▁size , ▁size _ t ▁* count ) ▁{ ▁G IO Status ▁status ; ▁OVER L AP PED ▁o v ▁= ▁{0 }; ▁BOOL ▁ret ; ▁DWORD ▁written ; ▁o v . h Event ▁= ▁Create Event ( NULL , ▁FALSE , ▁FALSE , ▁NULL ); ▁ret ▁= ▁Write File ( c -> handle , ▁buf , ▁size , ▁& written , ▁& ov ); ▁if ▁(! ret ) ▁{ ▁if ▁( Get Last Error () ▁== ▁ERROR _ IO _ PENDING ) ▁{ ▁/* ▁write ▁is ▁pending ▁*/ ▁ret ▁= ▁Get Over la pped Result ( c -> handle , ▁& ov , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ jni _ exception _ get _ summary ( JNI Env ▁* env , ▁j th rowable ▁exception , ▁char ▁** error , ▁void ▁* log _ ctx ) ▁{ ▁int ▁ret ▁= ▁0; ▁AV B Print ▁bp ; ▁char ▁* name ▁= ▁NULL ; ▁char ▁* message ▁= ▁NULL ; ▁j class ▁class _ class ▁= ▁NULL ; ▁j method ID ▁get _ name _ id ▁= ▁NULL ; ▁j class ▁exception _ class ▁= ▁NULL ; ▁j method ID ▁get _ message _ id ▁= ▁NULL ; ▁j string ▁string ; ▁av _ b print _ init ( & bp , ▁0, ▁AV _ B PRI NT _ SIZE _ A UT OM ATIC ); ▁exception _ class ▁= ▁(* env ) -> Get

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v sc si _ command _ complete ( SC SI Bus ▁* bus , ▁int ▁reason , ▁uint 32_ t ▁tag , ▁uint 32_ t ▁arg ) ▁{ ▁V SC SI State ▁* s ▁= ▁DO _ UP CAST ( V SC SI State , ▁v dev . q dev , ▁bus -> q bus . parent ); ▁v sc si _ req ▁* req ▁= ▁v sc si _ find _ req ( s , ▁tag ); ▁S CS ID evice ▁* s dev ; ▁uint 8_ t ▁* buf ; ▁int 32_ t ▁res _ in ▁= ▁0, ▁res _ out ▁= ▁0; ▁int ▁len , ▁rc ▁= ▁0; ▁d printf (" V SC SI : ▁SC SI ▁cmd ▁complete , ▁r =0 x % x ▁tag =0 x % x ▁arg =0 x % x , ▁req =% p \ n ", ▁reason ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ store _ sd r 1( CP UP PC State ▁* env , ▁target _ ulong ▁val ) ▁{ ▁Power PC CPU ▁* cpu ▁= ▁p pc _ env _ get _ cpu ( env ); ▁if ▁(! env -> external _ ht ab ) ▁{ ▁if ▁( env -> spr [ SP R _ SD R 1] ▁!= ▁val ) ▁{ ▁p pc _ store _ sd r 1( env , ▁val ); ▁tl b _ flush ( CPU ( cpu )); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁fw _ cfg _ comb _ valid ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size , ▁bool ▁is _ write ) ▁{ ▁return ▁( size ▁== ▁1) ▁|| ▁( is _ write ▁&& ▁size ▁== ▁2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁s P AP RT CE Table ▁* sp ap r _ t ce _ new _ table ( Device State ▁* owner , ▁uint 32_ t ▁li ob n , ▁uint 64_ t ▁bus _ offset , ▁uint 32_ t ▁page _ shift , ▁uint 32_ t ▁nb _ table , ▁bool ▁vf io _ accel ) ▁{ ▁s P AP RT CE Table ▁* tc et ; ▁char ▁tmp [ 64 ]; ▁if ▁( sp ap r _ t ce _ find _ by _ li ob n ( li ob n )) ▁{ ▁f printf ( stderr , ▁" Attempt ed ▁to ▁create ▁T CE ▁table ▁with ▁duplicate " ▁" ▁LI OB N ▁0 x % x \ n ", ▁li ob n ); ▁return ▁NULL ; ▁} ▁if ▁(! nb _ table ) ▁{ ▁return ▁NULL ; ▁} ▁tc et ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁debug _ print _ f is ( uint 8_ t ▁* f is , ▁int ▁cmd _ len ) ▁{ ▁# if def ▁DEBUG _ A H CI ▁int ▁i ; ▁f printf ( stderr , ▁" f is :"); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁cmd _ len ; ▁i ++) ▁{ ▁if ▁(( i ▁& ▁0 xf ) ▁== ▁0) ▁{ ▁f printf ( stderr , ▁"\ n % 02 x :", i ); ▁} ▁f printf ( stderr , ▁"% 02 x ▁", f is [ i ]); ▁} ▁f printf ( stderr , ▁"\ n "); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁svc _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁SV C Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁S Enc Param Ext ▁param ▁= ▁{ ▁0 ▁}; ▁int ▁err ▁= ▁A VER ROR _ UNKNOWN ; ▁int ▁log _ level ; ▁W els Trace Callback ▁callback _ function ; ▁AV CP B Properties ▁* props ; ▁// ▁M ing w ▁G CC ▁< ▁4. 7 ▁on ▁x 86 _32 ▁uses ▁an ▁incorrect / b ugg y ▁AB I ▁for ▁the ▁W els Get Codec Version ▁// ▁function ▁( for ▁functions ▁returning ▁larger ▁struct s ), ▁thus ▁skip ▁the ▁check ▁in ▁those ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sm 5 01_ dis p _ ctrl _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁value , ▁unsigned ▁size ) ▁{ ▁SM 5 01 State ▁* s ▁= ▁( SM 5 01 State ▁* ) op aque ; ▁SM 5 01_ DP RI NT F (" sm 5 01 ▁disp ▁ctrl ▁regs ▁: ▁write ▁addr =% x , ▁val =% x \ n ", ▁( un signed ) addr , ▁( un signed ) value ); ▁switch ▁( addr ) ▁{ ▁case ▁SM 5 01_ DC _ PA NEL _ CONTROL : ▁s -> dc _ panel _ control ▁= ▁value ▁& ▁0 x 0 FFF 73 FF ; ▁break ; ▁case ▁SM 5 01_ DC _ PA NEL _ P AN NING _ CONTROL : ▁s -> dc _ pan

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁rgb 15 to 16 ( const ▁uint 8_ t ▁* src , uint 8_ t ▁* dst , uint 32_ t ▁src _ size ) ▁{ ▁# if def ▁HAVE _ MM X ▁register ▁const ▁char * ▁s = src + src _ size ; ▁register ▁char * ▁d = dst + src _ size ; ▁register ▁int ▁offs =- src _ size ; ▁__ asm ▁__ vol atile ( PRE FETCH " ▁% 0 ": :" m " (* ( s + off s )): " memory "); ▁__ asm ▁__ vol atile ( ▁" mov q ▁% 0, ▁%% mm 4\ n \ t " ▁" mov q ▁% 1, ▁%% mm 5" ▁:: " m " ( mask 15 b ), ▁" m " ( mask 15 rg ): " memory "); ▁while ( off s < 0) ▁{ ▁__ asm ▁__ vol

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁r le _ unpack ( const ▁unsigned ▁char ▁* src , ▁unsigned ▁char ▁* dest , ▁int ▁src _ len , ▁int ▁dest _ len ) ▁{ ▁const ▁unsigned ▁char ▁* ps ; ▁unsigned ▁char ▁* pd ; ▁int ▁i , ▁l ; ▁unsigned ▁char ▁* dest _ end ▁= ▁dest ▁+ ▁dest _ len ; ▁ps ▁= ▁src ; ▁pd ▁= ▁dest ; ▁if ▁( src _ len ▁& ▁1) ▁* pd ++ ▁= ▁* ps ++; ▁src _ len ▁>>= ▁1; ▁i ▁= ▁0; ▁do ▁{ ▁l ▁= ▁* ps ++; ▁if ▁( l ▁& ▁0 x 80) ▁{ ▁l ▁= ▁( l ▁& ▁0 x 7 F ) ▁* ▁2; ▁if ▁( pd ▁+ ▁l ▁> ▁dest _ end ) ▁return ▁ps ▁- ▁src ; ▁mem c py ( pd , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ avg _ h 2 64_ qp el 16_ mc 33 _ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ h v _ q rt _ and _ aver _ dst _16 x 16_ ms a ( src ▁+ ▁stride ▁- ▁2, ▁src ▁- ▁( stride ▁* ▁2) ▁+ ▁sizeof ( uint 8_ t ), ▁stride , ▁dst , ▁stride ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v orb is _ parse ( AV Codec Parser Context ▁* s 1, ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁** p out buf , ▁int ▁* p out buf _ size , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁V orb is Parse Context ▁* s ▁= ▁s 1 -> priv _ data ; ▁int ▁duration ; ▁if ▁(! s -> vp ▁&& ▁av ctx -> ex tr ad ata ▁&& ▁av ctx -> ex tr ad ata _ size ) ▁{ ▁s -> vp ▁= ▁av _ vor b is _ parse _ init ( av ctx -> ex tr ad ata , ▁av ctx -> ex tr ad ata _ size ); ▁if ▁(! s -> vp ) ▁goto ▁end ; ▁} ▁if ▁(( durat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁xen _ ram _ init ( PC Machine State ▁* pc ms , ▁ram _ addr _ t ▁ram _ size , ▁Memory Region ▁** ram _ memory _ p ) ▁{ ▁Memory Region ▁* sys mem ▁= ▁get _ system _ memory (); ▁ram _ addr _ t ▁block _ len ; ▁uint 64_ t ▁user _ low mem ▁= ▁object _ property _ get _ int ( q dev _ get _ machine (), ▁PC _ MA CHINE _ MAX _ RAM _ BE LOW _4 G , ▁& error _ abort ); ▁/* ▁Handle ▁the ▁machine ▁opt ▁max - ram - below -4 g . ▁It ▁is ▁basically ▁doing ▁* ▁min ( x en ▁limit , ▁user ▁limit ). ▁*/ ▁if ▁( H V

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ sp ap r _ set _ irq ( void ▁* op aque , ▁int ▁irq _ num , ▁int ▁level ) ▁{ ▁/* ▁* ▁Here ▁we ▁use ▁the ▁number ▁returned ▁by ▁pci _ sp ap r _ map _ irq ▁to ▁find ▁a ▁* ▁corresponding ▁qemu _ irq . ▁*/ ▁s P AP R PH B State ▁* ph b ▁= ▁opaque ; ▁trace _ sp ap r _ pc i _ l si _ set ( ph b -> bus name , ▁irq _ num , ▁ph b -> l si _ table [ irq _ num ]. irq ); ▁qemu _ set _ irq ( sp ap r _ ph b _ l si _ q irq ( ph b , ▁irq _ num ), ▁level ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁alloc _ sequence _ buffers ( D ira c Context ▁* s ) ▁{ ▁int ▁sb width ▁= ▁DIV R ND UP ( s -> source . width , ▁4 ); ▁int ▁sb height ▁= ▁DIV R ND UP ( s -> source . height , ▁4 ); ▁int ▁i , ▁w , ▁h , ▁top _ padding ; ▁/* ▁todo : ▁think ▁more ▁about ▁this ▁/ ▁use ▁or ▁set ▁Pl ane ▁here ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁3; ▁i ++) ▁{ ▁int ▁max _ xb len ▁= ▁MAX _ BLOCK SIZE ▁>> ▁( i ▁? ▁s -> chrom a _ x _ shift ▁: ▁0); ▁int ▁max _ y b len ▁= ▁MAX _ BLOCK SIZE ▁>> ▁( i ▁? ▁s -> chrom a _ y _ shift ▁: ▁0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ev c _ handle _ packet ( AV Format Context ▁* ctx , ▁Payload Context ▁* r tp _ h ev c _ ctx , ▁AV Stream ▁* st , ▁AV Packet ▁* pk t , ▁uint 32_ t ▁* timestamp , ▁const ▁uint 8_ t ▁* buf , ▁int ▁len , ▁uint 16_ t ▁seq , ▁int ▁flags ) ▁{ ▁const ▁uint 8_ t ▁* r tp _ pl ▁= ▁buf ; ▁int ▁tid , ▁l id , ▁n al _ type ; ▁int ▁first _ fragment , ▁last _ fragment , ▁fu _ type ; ▁uint 8_ t ▁new _ nal _ header [2 ]; ▁int ▁res ▁= ▁0; ▁/* ▁sanity ▁check ▁for ▁size ▁of ▁input ▁packet : ▁1 ▁byte ▁payload ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av priv _ lock _ av format ( void ) ▁{ ▁if ▁( lock mgr _ cb ) ▁{ ▁if ▁(( * lock mgr _ cb )( & av format _ mut ex , ▁AV _ LOCK _ OB T AIN )) ▁return ▁-1; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁libs ch ro ed inger _ encode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁S ch ro Encoder Params ▁* p _ sch ro _ params ▁= ▁av ctx -> priv _ data ; ▁/* ▁Close ▁the ▁encoder . ▁*/ ▁sch ro _ encoder _ free ( p _ sch ro _ params -> encoder ); ▁/* ▁Free ▁data ▁in ▁the ▁output ▁frame ▁queue . ▁*/ ▁ff _ sch ro _ queue _ free ( & p _ sch ro _ params -> enc _ frame _ queue , ▁libs ch ro ed inger _ free _ frame ); ▁/* ▁Free ▁the ▁encoder ▁buffer . ▁*/ ▁if ▁( p _ sch ro _ params -> enc _ buf _ size ) ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁c ine p ak _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁ret ▁= ▁0, ▁buf _ size ▁= ▁av pk t -> size ; ▁C ine p ak Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> data ▁= ▁buf ; ▁s -> size ▁= ▁buf _ size ; ▁if ▁(( ret ▁= ▁ff _ re get _ buffer ( av ctx , ▁s -> frame )) ▁< ▁0) ▁return ▁ret ; ▁if ▁( s -> palette _ video ) ▁{ ▁const ▁uint 8_ t ▁* pal ▁= ▁av _ packet _ get _ side 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁t ai hu _40 5 ep _ init ( Machine State ▁* machine ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁machine -> ram _ size ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁char ▁* filename ; ▁qemu _ irq ▁* pic ; ▁Memory Region ▁* sys mem ▁= ▁get _ system _ memory (); ▁Memory Region ▁* b ios ; ▁Memory Region ▁* ram _ mem ories ▁= ▁g _ m alloc (2 ▁* ▁sizeof (* ram _ mem ories )); ▁Memory Region ▁* ram ▁= ▁g _ m a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* ff _ av io _ child _ next ( void ▁* obj , ▁void ▁* prev ) ▁{ ▁AV IO Context ▁* s ▁= ▁obj ; ▁AV IO Internal ▁* internal ▁= ▁s -> op aque ; ▁return ▁prev ▁? ▁NULL ▁: ▁internal -> h ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pm _ i op ort _ read ( I OR ange ▁* i op ort , ▁uint 64_ t ▁addr , ▁unsigned ▁width , ▁uint 64_ t ▁* data ) ▁{ ▁PI IX 4 PM State ▁* s ▁= ▁container _ of ( i op ort , ▁PI IX 4 PM State , ▁i op ort ); ▁uint 32_ t ▁val ; ▁switch ( addr ) ▁{ ▁case ▁0 x 00 : ▁val ▁= ▁ac pi _ pm 1_ evt _ get _ st s ( & s -> ar , ▁s -> ar . tm r . overflow _ time ); ▁break ; ▁case ▁0 x 0 2: ▁val ▁= ▁s -> ar . pm 1. evt . en ; ▁break ; ▁case ▁0 x 04 : ▁val ▁= ▁s -> ar . pm 1. cnt . cnt ; ▁break ; ▁case ▁0 x 08 : ▁v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁update _ dimensions ( VP 8 Context ▁* s , ▁int ▁width , ▁int ▁height ) ▁{ ▁if ▁( width ▁!= ▁s -> av ctx -> width ▁|| ▁height ▁!= ▁s -> av ctx -> height ) ▁{ ▁if ▁( av _ image _ check _ size ( width , ▁height , ▁0, ▁s -> av ctx )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁vp 8_ decode _ flush _ impl ( s -> av ctx , ▁1, ▁0, ▁1); ▁av codec _ set _ dimensions ( s -> av ctx , ▁width , ▁height ); ▁} ▁s -> mb _ width ▁= ▁( s -> av ctx -> coded _ width ▁+ 15) ▁/ ▁16 ; ▁s -> mb _ height ▁= ▁( s -> av c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁nb d _ receive _ reply ( Q IO Channel ▁* i oc , ▁N BD Reply ▁* reply , ▁Error ▁** err p ) ▁{ ▁int ▁ret ; ▁const ▁char ▁* type ; ▁ret ▁= ▁nb d _ read _ eof ( i oc , ▁& reply -> magic , ▁sizeof ( reply -> magic ), ▁err p ); ▁if ▁( ret ▁<= ▁0) ▁{ ▁return ▁ret ; ▁} ▁be 32_ to _ cpus ( & reply -> magic ); ▁switch ▁( reply -> magic ) ▁{ ▁case ▁N BD _ SI MPLE _ REP LY _ M AGIC : ▁ret ▁= ▁nb d _ receive _ simple _ reply ( i oc , ▁& reply -> simple , ▁err p ); ▁if ▁( ret ▁< ▁0) ▁{ ▁break ; ▁} ▁trace _ nb d _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ne 2000 _ receive ( void ▁* op aque , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size ) ▁{ ▁NE 2000 State ▁* s ▁= ▁opaque ; ▁uint 8_ t ▁* p ; ▁int ▁total _ len , ▁next , ▁avail , ▁len , ▁index , ▁m cast _ idx ; ▁uint 8_ t ▁buf 1[ 60 ]; ▁static ▁const ▁uint 8_ t ▁broadcast _ mac addr [ 6] ▁= ▁{ ▁0 xff , ▁0 xff , ▁0 xff , ▁0 xff , ▁0 xff , ▁0 xff ▁}; ▁# if ▁defined ( DEBUG _ NE 2 000) ▁printf (" NE 2000 : ▁received ▁len =% d \ n ", ▁size ); ▁# end if ▁if ▁(! ne 2000 _ can _ receive ( s )) ▁return ; ▁/*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tr ues peech _ apply _ tw op oint _ filter ( TS Context ▁* dec , ▁int ▁qu art ) ▁{ ▁int 16_ t ▁tmp [ 146 ▁+ ▁60 ], ▁* ptr 0, ▁* ptr 1; ▁const ▁int 16_ t ▁* filter ; ▁int ▁i , ▁t , ▁off ; ▁t ▁= ▁dec -> offset 2[ qu art ]; ▁if ( t ▁== ▁127 ){ ▁mem set ( dec -> new vec , ▁0, ▁60 ▁* ▁sizeof (* dec -> new vec )); ▁return ; ▁} ▁for ( i ▁= ▁0; ▁i ▁< ▁14 6 ; ▁i ++) ▁tmp [ i ] ▁= ▁dec -> fil t buf [ i ]; ▁off ▁= ▁( t ▁/ ▁25 ) ▁+ ▁dec -> offset 1[ qu art ▁>> ▁1] ▁+ ▁18 ; ▁ptr 0 ▁= ▁tmp ▁+ ▁145 ▁- ▁of

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ disk _ pur ge _ requests ( SC S ID isk State ▁* s ) ▁{ ▁S CS ID isk Req ▁* r ; ▁while ▁(! Q TAIL Q _ EMPTY ( & s -> q dev . requests )) ▁{ ▁r ▁= ▁DO _ UP CAST ( SC S ID isk Req , ▁req , ▁Q TAIL Q _ FIRST ( & s -> q dev . requests )); ▁if ▁( r -> req . ai oc b ) ▁{ ▁b dr v _ a io _ cancel ( r -> req . ai oc b ); ▁} ▁sc si _ remove _ request ( r ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ sl ir p _ init ( V LAN State ▁* vlan ) ▁{ ▁if ▁(! sl ir p _ init ed ) ▁{ ▁sl ir p _ init ed ▁= ▁1; ▁sl ir p _ init (); ▁} ▁sl ir p _ vc ▁= ▁qemu _ new _ vlan _ client ( vlan , ▁sl ir p _ receive , ▁NULL ); ▁sn printf ( sl ir p _ vc -> info _ str , ▁sizeof ( sl ir p _ vc -> info _ str ), ▁" user ▁redirect or "); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pn m _ decode _ header ( AV Codec Context ▁* av ctx , ▁P NM Context ▁* ▁const ▁s ){ ▁char ▁buf 1[ 32 ], ▁tuple _ type [ 32 ]; ▁int ▁h , ▁w , ▁depth , ▁maxval ; ; ▁pn m _ get ( s , ▁buf 1, ▁sizeof ( buf 1) ); ▁if ▁(! str cmp ( buf 1, ▁" P 4 ")) ▁{ ▁av ctx -> pix _ fmt ▁= ▁PI X _ F MT _ MON OW H ITE ; ▁} ▁else ▁if ▁(! str cmp ( buf 1, ▁" P 5 ")) ▁{ ▁if ▁( av ctx -> codec _ id ▁== ▁CODE C _ ID _ PG MY UV ) ▁av ctx -> pix _ fmt ▁= ▁PI X _ F MT _ Y UV 4 20 P ; ▁else ▁av ctx -> pix _ fmt ▁= ▁PI X 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ ph ysical _ memory _ rw ( target _ ph ys _ addr _ t ▁addr , ▁uint 8_ t ▁* buf , ▁int ▁len , ▁int ▁is _ write ) ▁{ ▁return ▁address _ space _ rw ( & address _ space _ memory , ▁addr , ▁buf , ▁len , ▁is _ write ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v 9 fs _ link ( void ▁* op aque ) ▁{ ▁V 9 fs P DU ▁* pd u ▁= ▁opaque ; ▁V 9 fs State ▁* s ▁= ▁pdu -> s ; ▁int 32_ t ▁df id , ▁old f id ; ▁V 9 fs F id State ▁* df id p , ▁* ol df id p ; ▁V 9 fs String ▁name ; ▁size _ t ▁offset ▁= ▁7 ; ▁int ▁err ▁= ▁0; ▁pdu _ un marshal ( pd u , ▁offset , ▁" dd s ", ▁& df id , ▁& ol df id , ▁& name ); ▁trace _ v 9 fs _ link ( pd u -> tag , ▁pdu -> id , ▁df id , ▁old f id , ▁name . data ); ▁df id p ▁= ▁get _ f id ( pd u , ▁df id ); ▁if ▁( df id p ▁== ▁NULL ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁dx va 2_ init ( AV Codec Context ▁* s ) ▁{ ▁InputStream ▁* ist ▁= ▁s -> op aque ; ▁int ▁log level ▁= ▁( ist -> hw accel _ id ▁== ▁H W AC CEL _ AUTO ) ▁? ▁AV _ LOG _ VER BOSE ▁: ▁AV _ LOG _ ERROR ; ▁D X VA 2 Context ▁* ctx ; ▁int ▁ret ; ▁if ▁(! ist -> hw accel _ ctx ) ▁{ ▁ret ▁= ▁dx va 2_ alloc ( s ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁} ▁ctx ▁= ▁ist -> hw accel _ ctx ; ▁if ▁( s -> codec _ id ▁== ▁AV _ CODE C _ ID _ H 264 ▁&& ▁( s -> profile ▁& ▁~ FF _ PROFILE _ H 2 64_ CONST RA I NED ) ▁> ▁FF _ PROFI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁X en PT Bar Flag ▁xen _ pt _ bar _ reg _ parse ( X en PC IP as sthrough State ▁* s , ▁X en PT Reg Info ▁* reg ) ▁{ ▁PC ID evice ▁* d ▁= ▁& s -> dev ; ▁X en PT Region ▁* region ▁= ▁NULL ; ▁P CI I OR eg ion ▁* r ; ▁int ▁index ▁= ▁0; ▁/* ▁check ▁64 bit ▁BAR ▁*/ ▁index ▁= ▁xen _ pt _ bar _ offset _ to _ index ( reg -> offset ); ▁if ▁( (0 ▁< ▁index ) ▁&& ▁( index ▁< ▁P CI _ ROM _ SL OT )) ▁{ ▁int ▁type ▁= ▁s -> real _ device . io _ regions [ index ▁- ▁1 ]. type ; ▁if ▁(( type ▁& ▁X EN _ HOST _ PC I _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁g 7 26 _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁G 7 26 Context * ▁c ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> strict _ std _ compl iance ▁> ▁FF _ COMP LI ANCE _ U NO F FI CIAL ▁&& ▁av ctx -> sample _ rate ▁!= ▁8 000) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Sample ▁rates ▁other ▁than ▁8 k Hz ▁are ▁not ▁" ▁" allowed ▁when ▁the ▁compl iance ▁level ▁is ▁higher ▁than ▁un off icial . ▁" ▁" Res ample ▁or ▁reduce ▁the ▁compl iance ▁level .\ n "); ▁return ▁A VER ROR ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dv _ read _ seek ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁timestamp , ▁int ▁flags ) ▁{ ▁Raw D V Context ▁* r ▁= ▁s -> priv _ data ; ▁D VD em ux Context ▁* c ▁= ▁r -> dv _ dem ux ; ▁int 64_ t ▁offset ▁= ▁dv _ frame _ offset ( s , ▁c , ▁timestamp , ▁flags ); ▁dv _ offset _ reset ( c , ▁offset ▁/ ▁c -> sys -> frame _ size ); ▁offset ▁= ▁av io _ seek ( s -> pb , ▁offset , ▁SE EK _ SET ); ▁return ▁( offset ▁< ▁0) ▁? ▁offset ▁: ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ ph b _ hot _ plug _ child ( Hot plug Handler ▁* plug _ handler , ▁Device State ▁* plug ged _ dev , ▁Error ▁** err p ) ▁{ ▁s P AP R PH B State ▁* ph b ▁= ▁SP AP R _ PC I _ HOST _ BR ID GE ( DEVICE ( plug _ handler )); ▁PC ID evice ▁* pd ev ▁= ▁P CI _ DEVICE ( plug ged _ dev ); ▁s P AP R DR Connector ▁* d rc ▁= ▁sp ap r _ ph b _ get _ pc i _ d rc ( ph b , ▁pd ev ); ▁Error ▁* local _ err ▁= ▁NULL ; ▁/* ▁if ▁DR ▁is ▁disabled ▁we ▁don ' t ▁need ▁to ▁do ▁anything ▁in ▁the ▁case ▁of ▁* ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff _ dv video _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁D V Video Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁D SP Context ▁d sp ; ▁static ▁int ▁done ▁= ▁0; ▁int ▁i , ▁j ; ▁if ▁(! done ) ▁{ ▁V LC ▁dv _ vlc ; ▁uint 16_ t ▁new _ dv _ vlc _ bits [ NB _ D V _ V LC * 2 ]; ▁uint 8_ t ▁new _ dv _ vlc _ len [ NB _ D V _ V LC * 2 ]; ▁uint 8_ t ▁new _ dv _ vlc _ run [ NB _ D V _ V LC * 2 ]; ▁int 16_ t ▁new _ dv _ vlc _ level [ NB _ D V _ V LC * 2 ]; ▁done ▁= ▁1; ▁/* ▁it ' s ▁faster ▁to ▁include ▁sig

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lib qu vi _ read _ header ( AV Format Context ▁* s ) ▁{ ▁int ▁i , ▁ret ; ▁qu vi _ t ▁q ; ▁qu vi _ media _ t ▁m ; ▁QU VI code ▁rc ; ▁Lib Qu vi Context ▁* q c ▁= ▁s -> priv _ data ; ▁char ▁* media _ url , ▁* pag et itle ; ▁rc ▁= ▁qu vi _ init ( & q ); ▁if ▁( rc ▁!= ▁QU VI _ OK ) ▁goto ▁qu vi _ fail ; ▁qu vi _ set opt ( q , ▁QU V IO PT _ FORMAT , ▁qc -> format ); ▁rc ▁= ▁qu vi _ parse ( q , ▁s -> filename , ▁& m ); ▁if ▁( rc ▁!= ▁QU VI _ OK ) ▁goto ▁qu vi _ fail ; ▁rc ▁= ▁qu vi _ get prop ( m ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁add _ old _ style _ options ( const ▁char ▁* fmt , ▁Q emu Opts ▁* opts , ▁const ▁char ▁* base _ filename , ▁const ▁char ▁* base _ fmt ) ▁{ ▁if ▁( base _ filename ) ▁{ ▁if ▁( q emu _ opt _ set ( opts , ▁BLOCK _ OPT _ BACK ING _ FILE , ▁base _ filename )) ▁{ ▁error _ report (" Back ing ▁file ▁not ▁supported ▁for ▁file ▁format ▁'% s ' ", ▁fmt ); ▁return ▁-1; ▁} ▁} ▁if ▁( base _ fmt ) ▁{ ▁if ▁( q emu _ opt _ set ( opts , ▁BLOCK _ OPT _ BACK ING _ F MT , ▁base _ fmt )) ▁{ ▁error _ report (" Back 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ flush _ queued _ pack ets ( V LAN Client State ▁* vc ) ▁{ ▁while ▁(! TAIL Q _ EMPTY ( & vc -> vlan -> send _ queue )) ▁{ ▁V LAN Packet ▁* packet ; ▁int ▁ret ; ▁packet ▁= ▁TA IL Q _ FIRST ( & vc -> vlan -> send _ queue ); ▁TA IL Q _ REMOVE ( & vc -> vlan -> send _ queue , ▁packet , ▁entry ); ▁ret ▁= ▁qemu _ del iver _ packet ( packet -> sender , ▁packet -> data , ▁packet -> size ); ▁if ▁( ret ▁== ▁0 ▁&& ▁packet -> sent _ cb ▁!= ▁NULL ) ▁{ ▁TA IL Q _ INSERT _ HEAD ( & vc -> vlan -> send _ queu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁LF _ F UNC ▁( h , ▁l um a , ▁s se 2) ▁LF _ IF UNC ( h , ▁l um a _ in tra , ▁s se 2) ▁LF _ F UNC ▁( v , ▁l um a , ▁s se 2) ▁LF _ IF UNC ( v , ▁l um a _ in tra , ▁s se 2) ▁/ **************** **************** ** */ ▁/* ▁weighted ▁prediction ▁*/ ▁# define ▁H 2 64_ WEIGHT ( W , ▁H , ▁OPT ) ▁\ ▁void ▁ff _ h 2 64_ weight _ ▁## ▁W ▁## ▁x ▁## ▁H ▁## ▁_ ▁## ▁OPT ( uint 8_ t ▁* dst , ▁\ ▁int ▁stride , ▁int ▁log 2_ denom , ▁int ▁weight , ▁int ▁offset ); ▁# define ▁H 2 64_ BI WEIGHT ( W , ▁H , ▁OPT ) ▁\ ▁void ▁ff _ h

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ band _ hdr ( I VI 45 Dec Context ▁* ctx , ▁I VI Band Desc ▁* band , ▁AV Codec Context ▁* av ctx ) ▁{ ▁int ▁plane , ▁band _ num , ▁indx , ▁transform _ id , ▁scan _ ind x ; ▁int ▁i ; ▁plane ▁= ▁get _ bits ( & ctx -> gb , ▁2); ▁band _ num ▁= ▁get _ bits ( & ctx -> gb , ▁4 ); ▁if ▁( band -> plane ▁!= ▁plane ▁|| ▁band -> band _ num ▁!= ▁band _ num ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Invalid ▁band ▁header ▁sequence ! \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁band -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁long ▁do _ sy scall ( void ▁* cpu _ env , ▁int ▁num , ▁long ▁arg 1, ▁long ▁arg 2, ▁long ▁arg 3, ▁long ▁arg 4, ▁long ▁arg 5, ▁long ▁arg 6) ▁{ ▁long ▁ret ; ▁struct ▁stat ▁st ; ▁struct ▁kernel _ stat fs ▁* st fs ; ▁# if def ▁DEBUG ▁gem u _ log (" sy scall ▁% d \ n ", ▁num ); ▁# end if ▁switch ( num ) ▁{ ▁case ▁TARGET _ N R _ exit : ▁# if def ▁HAVE _ G PRO F ▁_ m cleanup (); ▁# end if ▁_ exit ( arg 1); ▁ret ▁= ▁0; ▁/* ▁avoid ▁warning ▁*/ ▁break ; ▁case ▁TARGET _ N R _ read : ▁ret ▁= ▁get _ err no ( read ( ar

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rebuild _ refcount _ structure ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁void ▁** refcount _ table , ▁int 64_ t ▁* nb _ clusters ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁first _ free _ cluster ▁= ▁0, ▁re ft able _ offset ▁= ▁-1, ▁cluster ▁= ▁0; ▁int 64_ t ▁ref block _ offset , ▁ref block _ start , ▁ref block _ index ; ▁uint 32_ t ▁re ft able _ size ▁= ▁0; ▁uint 64_ t ▁* on _ disk _ re ft able ▁= ▁NULL ; ▁void ▁* on _ disk _ ref block ; ▁int ▁ret ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁synchronize _ audio ( Video State ▁* is , ▁short ▁* samples , ▁int ▁samples _ size 1, ▁double ▁pts ) ▁{ ▁int ▁n , ▁samples _ size ; ▁double ▁ref _ clock ; ▁n ▁= ▁2 ▁* ▁is -> audio _ st -> codec -> channels ; ▁samples _ size ▁= ▁samples _ size 1; ▁/* ▁if ▁not ▁master , ▁then ▁we ▁try ▁to ▁remove ▁or ▁add ▁samples ▁to ▁correct ▁the ▁clock ▁*/ ▁if ▁( (( is -> av _ sync _ type ▁== ▁AV _ SYNC _ VI DEO _ MA STER ▁&& ▁is -> video _ st ) ▁|| ▁is -> av _ sync _ type ▁== ▁AV _ SYNC _ EXTERNAL _ C LOCK

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff _ iv i _ init _ plan es ( I VI Plane Desc ▁* plan es , ▁const ▁I VI Pic Config ▁* cfg , ▁int ▁is _ ind eo 4) ▁{ ▁int ▁p , ▁b ; ▁uint 32_ t ▁b _ width , ▁b _ height , ▁align _ fac , ▁width _ aligned , ▁height _ aligned , ▁buf _ size ; ▁I VI Band Desc ▁* band ; ▁iv i _ free _ buffers ( plan es ); ▁if ▁( av _ image _ check _ size ( cfg -> pic _ width , ▁cfg -> pic _ height , ▁0, ▁NULL ) ▁< ▁0 ▁|| ▁cfg -> l um a _ b ands ▁< ▁1 ▁|| ▁cfg -> chrom a _ b ands ▁< ▁1) ▁return ▁A VER ROR _ IN V 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁seq video _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Seq Video Context ▁* seq ▁= ▁av ctx -> priv _ data ; ▁seq -> av ctx ▁= ▁av ctx ; ▁av ctx -> pix _ fmt ▁= ▁AV _ PI X _ F MT _ P AL 8 ; ▁seq -> frame ▁= ▁av _ frame _ alloc (); ▁if ▁(! seq -> frame ) ▁return ▁A VER ROR ( EN O ME M ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block A IO CB ▁* b dr v _ co _ a io _ rw _ vector ( B dr v Child ▁* child , ▁int 64_ t ▁sector _ num , ▁Q EM UI O Vector ▁* q io v , ▁int ▁nb _ sect ors , ▁B dr v Request Flags ▁flags , ▁Block Completion Func ▁* cb , ▁void ▁* op aque , ▁bool ▁is _ write ) ▁{ ▁Cor outine ▁* co ; ▁Block A IO CB Cor outine ▁* ac b ; ▁ac b ▁= ▁qemu _ a io _ get ( & b dr v _ em _ co _ ai oc b _ info , ▁child -> bs , ▁cb , ▁opaque ); ▁ac b -> child ▁= ▁child ; ▁ac b -> need _ b h ▁= ▁true ; ▁ac b -> req . error ▁= ▁- E

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁standard _ decode _ picture _ secondary _ header ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁int ▁status ▁= ▁0, ▁index ; ▁switch ▁( v -> s . p ict _ type ) ▁{ ▁case ▁P _ TYPE : ▁status ▁= ▁decode _ p _ picture _ secondary _ header ( v ); ▁break ; ▁case ▁B _ TYPE : ▁status ▁= ▁decode _ b _ picture _ secondary _ header ( v ); ▁break ; ▁case ▁BI _ TYPE : ▁case ▁I _ TYPE : ▁break ; ▁// Nothing ▁needed ▁as ▁it ' s ▁done ▁in ▁the ▁ep ilog ▁} ▁if ▁( status ▁< ▁0) ▁return ▁F

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cc w _ machine _ class _ init ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁Machine Class ▁* mc ▁= ▁MA CHINE _ CLASS ( oc ); ▁N MI Class ▁* nc ▁= ▁N MI _ CLASS ( oc ); ▁Hot plug Handler Class ▁* hc ▁= ▁H OT PL UG _ HANDLER _ CLASS ( oc ); ▁S 390 C cw Machine Class ▁* s 390 mc ▁= ▁S 39 0_ MA CHINE _ CLASS ( mc ); ▁s 390 mc -> ri _ allowed ▁= ▁true ; ▁s 390 mc -> cpu _ model _ allowed ▁= ▁true ; ▁s 390 mc -> css _ migration _ enabled ▁= ▁true ; ▁s 390 mc -> gs _ allowed ▁= ▁true ; ▁mc -> init ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ cv id _ header ( C ine p ak Enc Context ▁* s , ▁unsigned ▁char ▁* buf , ▁int ▁num _ stri ps , ▁int ▁data _ size ) ▁{ ▁buf [0] ▁= ▁0; ▁AV _ W B 24 ( & buf [1], ▁data _ size ▁+ ▁CV ID _ HEADER _ SIZE ); ▁AV _ W B 16 ( & buf [4 ], ▁s -> w ); ▁AV _ W B 16 ( & buf [6 ], ▁s -> h ); ▁AV _ W B 16 ( & buf [ 8 ], ▁num _ stri ps ); ▁return ▁CV ID _ HEADER _ SIZE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁m peg 4 video _ parse _ init ( AV Codec Parser Context ▁* s ) ▁{ ▁Parse Context 1 ▁* pc ▁= ▁s -> priv _ data ; ▁pc -> enc ▁= ▁av _ m alloc z ( size of ( M peg Enc Context )); ▁if ▁(! pc -> enc ) ▁return ▁-1; ▁pc -> first _ picture ▁= ▁1; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁const ▁AV Option ▁* av _ opt _ next ( void ▁* obj , ▁const ▁AV Option ▁* last ) ▁{ ▁AV Class ▁* class ▁= ▁* ( AV Class ** ) obj ; ▁if ▁(! last ▁&& ▁class -> option [0]. name ) ▁return ▁class -> option ; ▁if ▁( last ▁&& ▁last [1]. name ) ▁return ▁++ last ; ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ audio _ out ( AV Format Context ▁* s , ▁OutputStream ▁* ost , ▁InputStream ▁* ist , ▁AV Frame ▁* decoded _ frame ) ▁{ ▁uint 8_ t ▁* buf tmp ; ▁int ▁size _ out , ▁frame _ bytes , ▁resample _ changed , ▁ret ; ▁AV Codec Context ▁* enc ▁= ▁o st -> st -> codec ; ▁AV Codec Context ▁* dec ▁= ▁ist -> st -> codec ; ▁int ▁os ize ▁= ▁av _ get _ bytes _ per _ sample ( enc -> sample _ fmt ); ▁int ▁is ize ▁= ▁av _ get _ bytes _ per _ sample ( dec -> sample _ fmt ); ▁uint 8_ t ▁* buf ▁= ▁decoded _ fr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ arm _ shift _ im ( TC G v ▁var , ▁int ▁shif top , ▁int ▁shift , ▁int ▁flags ) ▁{ ▁switch ▁( sh if top ) ▁{ ▁case ▁0: ▁/* ▁L SL ▁*/ ▁if ▁( shift ▁!= ▁0) ▁{ ▁if ▁( flags ) ▁shif ter _ out _ im ( var , ▁32 ▁- ▁shift ); ▁tc g _ gen _ sh li _ i 32 ( var , ▁var , ▁shift ); ▁} ▁break ; ▁case ▁1: ▁/* ▁L SR ▁*/ ▁if ▁( shift ▁== ▁0) ▁{ ▁if ▁( flags ) ▁{ ▁tc g _ gen _ sh ri _ i 32 ( var , ▁var , ▁31 ); ▁gen _ set _ CF ( var ); ▁} ▁tc g _ gen _ mov i _ i 32 ( var , ▁0); ▁} ▁else ▁{ ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm x net 3_ update _ vlan _ filters ( VM X NET 3 State ▁* s ) ▁{ ▁int ▁i ; ▁/* ▁Copy ▁configuration ▁from ▁shared ▁memory ▁*/ ▁VM X NET 3_ READ _ DR V _ SHA RED ( s -> dr v _ sh mem , ▁dev Read . rx Filter Conf . vf Table , ▁s -> vlan _ table , ▁sizeof ( s -> vlan _ table )); ▁/* ▁In vert ▁byte ▁order ▁when ▁needed ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( s -> vlan _ table ); ▁i ++) ▁{ ▁s -> vlan _ table [ i ] ▁= ▁le 32_ to _ cpu ( s -> vlan _ table [ i ]); ▁} ▁/* ▁Dump ▁configuration ▁fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁arm _ timer _ re cal ibrate ( arm _ timer _ state ▁* s , ▁int ▁reload ) ▁{ ▁uint 32_ t ▁limit ; ▁if ▁(( s -> control ▁& ▁T IMER _ CT RL _ PER IO DI C ) ▁== ▁0) ▁{ ▁/* ▁Free ▁running . ▁*/ ▁if ▁( s -> control ▁& ▁T IMER _ CT RL _32 BIT ) ▁limit ▁= ▁0 xffffffff ; ▁else ▁limit ▁= ▁0 xffff ; ▁} ▁else ▁{ ▁/* ▁Period ic . ▁*/ ▁limit ▁= ▁s -> limit ; ▁} ▁p timer _ set _ limit ( s -> timer , ▁limit , ▁reload ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁term _ down _ char ( void ) ▁{ ▁if ▁( term _ hist _ entry ▁== ▁TER M _ MAX _ CM DS ▁- ▁1 ▁|| ▁term _ hist _ entry ▁== ▁-1) ▁return ; ▁if ▁( term _ history [ ++ term _ hist _ entry ] ▁!= ▁NULL ) ▁{ ▁p str c py ( term _ cmd _ buf , ▁sizeof ( term _ cmd _ buf ), ▁term _ history [ term _ hist _ entry ]); ▁} ▁else ▁{ ▁term _ hist _ entry ▁= ▁-1; ▁} ▁term _ cmd _ buf _ index ▁= ▁term _ cmd _ buf _ size ▁= ▁str len ( term _ cmd _ buf ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ log _ start ( target _ ph ys _ addr _ t ▁phys _ addr , ▁ram _ addr _ t ▁size ) ▁{ ▁return ▁k vm _ dirty _ pages _ log _ change ( ph ys _ addr , ▁size , ▁K VM _ ME M _ LOG _ DIR TY _ PAGE S , ▁K VM _ ME M _ LOG _ DIR TY _ PAGE S ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ log ( int ▁arg c , ▁const ▁char ▁** argv ) ▁{ ▁int ▁mask ; ▁if ▁( arg c ▁!= ▁2) ▁goto ▁help ; ▁if ▁(! str cmp ( argv [1], ▁" none ")) ▁{ ▁mask ▁= ▁0; ▁} ▁else ▁{ ▁mask ▁= ▁cpu _ str _ to _ log _ mask ( argv [1]); ▁if ▁(! mask ) ▁{ ▁help : ▁help _ cmd ( argv [0]); ▁return ; ▁} ▁} ▁cpu _ set _ log ( mask ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ls _ decode _ entry ( AV Codec Context ▁* av ctxt , ▁void ▁* is Filter Thread ) ▁{ ▁HE VC Context ▁* s ▁= ▁av ctxt -> priv _ data ; ▁int ▁ct b _ size ▁= ▁1 ▁<< ▁s -> sp s -> log 2_ ct b _ size ; ▁int ▁more _ data ▁= ▁1; ▁int ▁x _ ct b ▁= ▁0; ▁int ▁y _ ct b ▁= ▁0; ▁int ▁ct b _ addr _ ts ▁= ▁s -> pp s -> ct b _ addr _ rs _ to _ ts [ s -> sh . slice _ ct b _ addr _ rs ]; ▁if ▁(! ct b _ addr _ ts ▁&& ▁s -> sh . dependent _ slice _ segment _ flag ) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ header ( MP AD ecode Context ▁* s , ▁U INT 32 ▁header ) ▁{ ▁int ▁sample _ rate , ▁frame _ size , ▁m peg 25, ▁padding ; ▁int ▁sample _ rate _ index , ▁bitrate _ index ; ▁if ▁( header ▁& ▁(1 << 20 )) ▁{ ▁s -> ls f ▁= ▁( header ▁& ▁(1 << 19 )) ▁? ▁0 ▁: ▁1; ▁m peg 25 ▁= ▁0; ▁} ▁else ▁{ ▁s -> ls f ▁= ▁1; ▁m peg 25 ▁= ▁1; ▁} ▁s -> layer ▁= ▁4 ▁- ▁(( header ▁>> ▁17 ) ▁& ▁3 ); ▁/* ▁extract ▁frequency ▁*/ ▁sample _ rate _ index ▁= ▁( header ▁>> ▁10) ▁& ▁3; ▁sample _ rate ▁= ▁m pa _ freq _ ta

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁init ( AV Filter Context ▁* ctx , ▁const ▁char ▁* args ) ▁{ ▁Grad Fun Context ▁* g f ▁= ▁ctx -> priv ; ▁float ▁thresh ▁= ▁1. 2; ▁int ▁radius ▁= ▁16 ; ▁if ▁( args ) ▁s scan f ( args , ▁"% f :% d ", ▁& th resh , ▁& radius ); ▁thresh ▁= ▁av _ clip f ( th resh , ▁0.5 1, ▁255 ); ▁gf -> th resh ▁= ▁(1 ▁<< ▁15 ) ▁/ ▁thresh ; ▁gf -> radius ▁= ▁av _ clip (( radius ▁+ ▁1) ▁& ▁~ 1, ▁4, ▁32 ); ▁gf -> blur _ line ▁= ▁ff _ grad fun _ blur _ line _ c ; ▁gf -> filter _ line ▁= ▁ff _ grad fun _ f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ client _ migration _ log ( struct ▁CP UP h ys Memory Client ▁* client , ▁int ▁enable ) ▁{ ▁return ▁k vm _ set _ migration _ log ( enable ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁rt mp _ read _ seek ( URL Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁timestamp , ▁int ▁flags ) ▁{ ▁RT MP ▁* r ▁= ▁s -> priv _ data ; ▁if ▁( flags ▁& ▁AV SE EK _ FLAG _ BYTE ) ▁return ▁A VER ROR ( EN OS Y S ); ▁/* ▁seek s ▁are ▁in ▁milliseconds ▁*/ ▁timestamp ▁= ▁av _ res cale ( timestamp , ▁AV _ TIME _ BASE , ▁1000); ▁if ▁(! RT MP _ Send Seek ( r , ▁timestamp )) ▁return ▁-1; ▁return ▁timestamp ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ma ce _ decode _ init ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁MA CE Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> channels ▁> ▁2) ▁return ▁-1; ▁av ctx -> sample _ fmt ▁= ▁AV _ SA MPLE _ F MT _ S 16 ; ▁av codec _ get _ frame _ defaults ( & ctx -> frame ); ▁av ctx -> coded _ frame ▁= ▁& ctx -> frame ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁float 16 ▁float 32_ to _ float 16 ( float 32 ▁a , ▁flag ▁i eee ▁STATUS _ PARAM ) ▁{ ▁flag ▁a Sign ; ▁int _ fast 16_ t ▁a Exp ; ▁uint 32_ t ▁a Sig ; ▁uint 32_ t ▁mask ; ▁uint 32_ t ▁increment ; ▁int 8 ▁rounding Mode ; ▁a ▁= ▁float 32_ s qu ash _ input _ den ormal ( a ▁STATUS _ VAR ); ▁a Sig ▁= ▁extract Float 32 F rac ( ▁a ▁); ▁a Exp ▁= ▁extract Float 32 Exp ( ▁a ▁); ▁a Sign ▁= ▁extract Float 32 Sign ( ▁a ▁); ▁if ▁( ▁a Exp ▁== ▁0 xFF ▁) ▁{ ▁if ▁( a Sig ) ▁{ ▁/* ▁Input ▁is ▁a ▁NaN ▁*/ ▁float 16 ▁r ▁= ▁commo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁virt queue _ avail _ bytes ( V irt Queue ▁* v q , ▁int ▁in _ bytes , ▁int ▁out _ bytes ) ▁{ ▁unsigned ▁int ▁idx ; ▁unsigned ▁int ▁total _ buf s , ▁in _ total , ▁out _ total ; ▁idx ▁= ▁v q -> last _ avail _ idx ; ▁total _ buf s ▁= ▁in _ total ▁= ▁out _ total ▁= ▁0; ▁while ▁( virt queue _ num _ head s ( v q , ▁idx )) ▁{ ▁unsigned ▁int ▁max , ▁num _ buf s , ▁indirect ▁= ▁0; ▁target _ ph ys _ addr _ t ▁desc _ pa ; ▁int ▁i ; ▁max ▁= ▁v q -> v ring . num ; ▁num _ buf s ▁= ▁total _ buf s ; ▁i ▁= ▁virt queu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ fd ( int ▁fd _ in , ▁int ▁fd _ out ) ▁{ ▁Char Driver State ▁* chr ; ▁F D Char Driver ▁* s ; ▁chr ▁= ▁g _ m alloc 0( size of ( Char Driver State )); ▁s ▁= ▁g _ m alloc 0( size of ( FD Char Driver )); ▁s -> fd _ in ▁= ▁io _ channel _ from _ fd ( fd _ in ); ▁s -> fd _ out ▁= ▁io _ channel _ from _ fd ( fd _ out ); ▁fcntl ( fd _ out , ▁F _ SET FL , ▁O _ NON BLOCK ); ▁s -> chr ▁= ▁chr ; ▁chr -> op aque ▁= ▁s ; ▁chr -> chr _ add _ watch ▁= ▁fd _ chr _ add _ wat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁g 7 22 _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* av pk t , ▁const ▁AV Frame ▁* frame , ▁int ▁* got _ packet _ ptr ) ▁{ ▁G 7 22 Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁const ▁int 16_ t ▁* samples ▁= ▁( const ▁int 16_ t ▁* ) frame -> data [0]; ▁int ▁nb _ samples , ▁out _ size , ▁ret ; ▁out _ size ▁= ▁( frame -> nb _ samples ▁+ ▁1) ▁/ ▁2; ▁if ▁(( ret ▁= ▁ff _ alloc _ packet 2( av ctx , ▁av pk t , ▁out _ size ))) ▁return ▁ret ; ▁nb _ samples ▁= ▁frame -> nb _ samples ▁- ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gif _ image _ write _ image ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁** by test ream , ▁uint 8_ t ▁* end , ▁const ▁uint 32_ t ▁* palette , ▁const ▁uint 8_ t ▁* buf , ▁const ▁int ▁lines ize , ▁AV Packet ▁* pk t ) ▁{ ▁GIF Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁len ▁= ▁0, ▁height ▁= ▁av ctx -> height , ▁width ▁= ▁av ctx -> width , ▁x , ▁y ; ▁int ▁x _ start ▁= ▁0, ▁y _ start ▁= ▁0, ▁trans ▁= ▁s -> transparent _ index ; ▁int ▁honor _ trans p arency ▁= ▁( s -> flags ▁& ▁G F _ TRANS DIFF 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁open file ( char ▁* name , ▁int ▁flags ) ▁{ ▁if ▁( bs ) ▁{ ▁f printf ( stderr , ▁" file ▁open ▁already , ▁try ▁' help ▁close '\ n "); ▁return ▁1; ▁} ▁bs ▁= ▁b dr v _ new (" h da "); ▁if ▁(! bs ) ▁return ▁1; ▁if ▁( b dr v _ open ( bs , ▁name , ▁flags ) ▁== ▁-1) ▁{ ▁f printf ( stderr , ▁"% s : ▁can ' t ▁open ▁device ▁% s \ n ", ▁prog name , ▁name ); ▁bs ▁= ▁NULL ; ▁return ▁1; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁e 500 _ pc i host _ bridge _ real ize ( PC ID evice ▁* d , ▁Error ▁** err p ) ▁{ ▁P P CE 500 PC I Bridge State ▁* b ▁= ▁P PC _ E 500 _ PC I _ BR ID GE ( d ); ▁P P CE 500 C CS R State ▁* cc sr ▁= ▁C CS R ( container _ get ( q dev _ get _ machine (), ▁"/ e 500 - cc sr ")); ▁pci _ config _ set _ class ( d -> config , ▁P CI _ CLASS _ BR ID GE _ PC I ); ▁d -> config [ PC I _ HEADER _ TYPE ] ▁= ▁( d -> config [ PC I _ HEADER _ TYPE ] ▁& ▁P CI _ HEADER _ TYPE _ MULTI _ FUNCTION ) ▁| ▁P CI _ HEADER

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ clear _ fixed _ vector ( float ▁* out , ▁const ▁AM R Fixed ▁* in , ▁int ▁size ) ▁{ ▁int ▁i ; ▁for ▁( i =0; ▁i ▁< ▁in -> n ; ▁i ++) ▁{ ▁int ▁x ▁= ▁in -> x [ i ], ▁repeats ▁= ▁! (( in -> no _ repeat _ mask ▁>> ▁i ) ▁& ▁1); ▁do ▁{ ▁out [ x ] ▁= ▁0.0 ; ▁x ▁+= ▁in -> p itch _ lag ; ▁} ▁while ▁( x ▁< ▁size ▁&& ▁repeats ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fil m _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁Fil m Dem ux Context ▁* fil m ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ; ▁unsigned ▁char ▁scratch [ 256 ]; ▁int ▁i ; ▁unsigned ▁int ▁data _ offset ; ▁unsigned ▁int ▁audio _ frame _ counter ; ▁fil m -> sample _ table ▁= ▁NULL ; ▁fil m -> st ere o _ buffer ▁= ▁NULL ; ▁fil m -> st ere o _ buffer _ size ▁= ▁0; ▁/* ▁load ▁the ▁main ▁FIL M ▁header ▁*/ ▁if ▁( av io _ read ( pb , ▁scr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vl c _ decode _ block ( M im ic Context ▁* ctx , ▁int ▁num _ coeff s , ▁int ▁q scale ) ▁{ ▁int 16_ t ▁* block ▁= ▁ctx -> d ct _ block ; ▁unsigned ▁int ▁pos ; ▁ctx -> bd sp . clear _ block ( block ); ▁block [0] ▁= ▁get _ bits ( & ctx -> gb , ▁8) ▁<< ▁3; ▁for ▁( pos ▁= ▁1; ▁pos ▁< ▁num _ coeff s ; ▁pos ++) ▁{ ▁uint 32_ t ▁vl c , ▁num _ bits ; ▁int ▁value ; ▁int ▁coeff ; ▁vl c ▁= ▁get _ vlc 2( & ctx -> gb , ▁ctx -> vlc . table , ▁ctx -> vlc . bits , ▁3 ); ▁if ▁(! vlc ) ▁/* ▁end - of - block ▁co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sv q 3_ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁M peg Enc Context ▁* const ▁s ▁= ▁av ctx -> priv _ data ; ▁H 264 Context ▁* const ▁h ▁= ▁av ctx -> priv _ data ; ▁int ▁m , ▁mb _ type ; ▁/* ▁special ▁case ▁for ▁last ▁picture ▁*/ ▁if ▁( buf _ size ▁== ▁0) ▁{ ▁if ▁( s -> next _ picture _ ptr ▁&& ▁! s -> low _ delay ) ▁{ ▁* ( AV Frame ▁* ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁rl 2_ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁R l 2 Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁back _ size ; ▁int ▁i ; ▁s -> av ctx ▁= ▁av ctx ; ▁av ctx -> pix _ fmt ▁= ▁AV _ PI X _ F MT _ P AL 8 ; ▁av codec _ get _ frame _ defaults ( & s -> frame ); ▁/** ▁parse ▁extra ▁data ▁*/ ▁if (! av ctx -> ex tr ad ata ▁|| ▁av ctx -> ex tr ad ata _ size ▁< ▁EX TR ADATA 1_ SIZE ){ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" invalid ▁extr ad ata ▁size \ n "); ▁return ▁-1; ▁} ▁/**

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pic mem set ( Pic Context ▁* s , ▁AV Frame ▁* frame , ▁int ▁value , ▁int ▁run , ▁int ▁* x , ▁int ▁* y , ▁int ▁* plane , ▁int ▁bits _ per _ plane ) ▁{ ▁uint 8_ t ▁* d ; ▁int ▁shift ▁= ▁* plane ▁* ▁bits _ per _ plane ; ▁int ▁mask ▁= ▁( (1 ▁<< ▁bits _ per _ plane ) ▁- ▁1) ▁<< ▁shift ; ▁value ▁<<= ▁shift ; ▁while ▁( run ▁> ▁0) ▁{ ▁int ▁j ; ▁for ▁( j ▁= ▁8 - bits _ per _ plane ; ▁j ▁>= ▁0; ▁j ▁-= ▁bits _ per _ plane ) ▁{ ▁d ▁= ▁frame -> data [0] ▁+ ▁* y ▁* ▁frame -> lines ize [0]; ▁d [ * x ] ▁|=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁sil k _ st abil ize _ ls f ( int 16_ t ▁n ls f [ 16 ], ▁int ▁order , ▁const ▁uint 16_ t ▁min _ delta [ 17 ]) ▁{ ▁int ▁pass , ▁i ; ▁for ▁( pass ▁= ▁0; ▁pass ▁< ▁20 ; ▁pass ++) ▁{ ▁int ▁k , ▁min _ diff ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁order +1 ; ▁i ++) ▁{ ▁int ▁low ▁= ▁i ▁!= ▁0 ▁? ▁n ls f [ i -1] ▁: ▁0; ▁int ▁high ▁= ▁i ▁!= ▁order ▁? ▁n ls f [ i ] ▁: ▁327 68 ; ▁int ▁diff ▁= ▁( high ▁- ▁low ) ▁- ▁( min _ delta [ i ]); ▁if ▁( diff ▁< ▁min _ diff ) ▁{ ▁min _ diff ▁= ▁diff ; ▁k ▁= ▁i ; ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ un in _ main _ config _ writ el ▁( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁UN IN State ▁* s ▁= ▁opaque ; ▁UN IN _ DP RI NT F (" config _ writ el ▁addr ▁" ▁TARGET _ F MT _ pl x ▁" ▁val ▁% x \ n ", ▁addr , ▁val ); ▁# if def ▁TARGET _ WORDS _ B IG ENDIAN ▁val ▁= ▁b swap 32 ( val ); ▁# end if ▁s -> config _ reg ▁= ▁val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁v ub r _ set _ v ring _ addr _ exec ( V ub r Dev ▁* dev , ▁V host User Msg ▁* v msg ) ▁{ ▁struct ▁v host _ v ring _ addr ▁* v ra ▁= ▁& v msg -> payload . addr ; ▁unsigned ▁int ▁index ▁= ▁v ra -> index ; ▁V ub r V irt q ▁* v q ▁= ▁& dev -> v q [ index ]; ▁D PRI NT (" v host _ v ring _ addr :\ n "); ▁D PRI NT (" ▁index : ▁% d \ n ", ▁v ra -> index ); ▁D PRI NT (" ▁flags : ▁% d \ n ", ▁v ra -> flags ); ▁D PRI NT (" ▁desc _ user _ addr : ▁0 x % 016 ll x \ n ", ▁v ra -> desc _ user _ addr ); ▁D PRI NT (" ▁use

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ get _ un scaled _ sw scale ( Sw s Context ▁* c ) ▁{ ▁const ▁enum ▁Pixel Format ▁src Format ▁= ▁c -> src Format ; ▁const ▁enum ▁Pixel Format ▁dst Format ▁= ▁c -> dst Format ; ▁const ▁int ▁flags ▁= ▁c -> flags ; ▁const ▁int ▁dst H ▁= ▁c -> dst H ; ▁int ▁needs D ither ; ▁needs D ither ▁= ▁is Any RGB ( dst Format ) ▁&& ▁c -> dst Format B pp ▁< ▁24 ▁&& ▁( c -> dst Format B pp ▁< ▁c -> src Format B pp ▁|| ▁(! is Any RGB ( src Format ))); ▁/* ▁y v 12 _ to _ nv 12 ▁*/ ▁if ▁(( src Format ▁== ▁PI X _ F 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁P CI Bridge Windows ▁* pc i _ bridge _ region _ init ( PC I Bridge ▁* br ) ▁{ ▁PC ID evice ▁* pd ▁= ▁P CI _ DEVICE ( br ); ▁P CI Bus ▁* parent ▁= ▁pd -> bus ; ▁P CI Bridge Windows ▁* w ▁= ▁g _ new ( PC I Bridge Windows , ▁1); ▁uint 16_ t ▁cmd ▁= ▁pci _ get _ word ( pd -> config ▁+ ▁P CI _ COMMAND ); ▁pci _ bridge _ init _ alias ( br , ▁& w -> alias _ pref _ mem , ▁P CI _ BASE _ ADDRESS _ ME M _ PRE FETCH , ▁" pc i _ bridge _ pref _ mem ", ▁& br -> address _ space _ mem , ▁parent -> address _ spac

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h ls _ transform _ tree ( HE VC Context ▁* s , ▁int ▁x 0, ▁int ▁y 0, ▁int ▁x Base , ▁int ▁y Base , ▁int ▁cb _ x Base , ▁int ▁cb _ y Base , ▁int ▁log 2_ cb _ size , ▁int ▁log 2_ tra fo _ size , ▁int ▁tra fo _ depth , ▁int ▁blk _ idx ) ▁{ ▁HE VC Local Context ▁* lc ▁= ▁& s -> HE V Cl c ; ▁uint 8_ t ▁split _ transform _ flag ; ▁if ▁( tra fo _ depth ▁> ▁0 ▁&& ▁log 2_ tra fo _ size ▁== ▁2) ▁{ ▁SAMPLE _ CB F ( lc -> tt . cb f _ cb [ tra fo _ depth ], ▁x 0, ▁y 0) ▁= ▁SAMPLE _ CB F ( lc -> tt . cb 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁aw _ p ulse _ set 2( W MA Voice Context ▁* s , ▁Get Bit Context ▁* gb , ▁int ▁block _ idx , ▁AM R Fixed ▁* f cb ) ▁{ ▁uint 16_ t ▁use _ mask _ mem [ 9 ]; ▁// ▁only ▁5 ▁are ▁used , ▁rest ▁is ▁padding ▁uint 16_ t ▁* use _ mask ▁= ▁use _ mask _ mem ▁+ ▁2; ▁/* ▁in ▁this ▁function , ▁idx ▁is ▁the ▁index ▁in ▁the ▁80 - bit ▁( + ▁padding ) ▁use _ mask ▁* ▁bit - array . ▁Since ▁use _ mask ▁consists ▁of ▁16 - bit ▁values , ▁the ▁lower ▁4 ▁bits ▁* ▁of ▁idx ▁are ▁the ▁position ▁of ▁the ▁bit ▁within ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁as f _ build _ simple _ index ( AV Format Context ▁* s , ▁int ▁stream _ index ) ▁{ ▁ff _ as f _ guid ▁g ; ▁AS F Context ▁* as f ▁= ▁s -> priv _ data ; ▁int 64_ t ▁current _ pos ▁= ▁av io _ t ell ( s -> pb ); ▁int ▁i ; ▁av io _ seek ( s -> pb , ▁as f -> data _ object _ offset ▁+ ▁as f -> data _ object _ size , ▁SE EK _ SET ); ▁ff _ get _ guid ( s -> pb , ▁& g ); ▁/* ▁the ▁data ▁object ▁can ▁be ▁followed ▁by ▁other ▁top - level ▁objects , ▁* ▁skip ▁them ▁until ▁the ▁simple ▁index ▁object ▁is 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ q ed _ d rain ( Block Driver State ▁* bs ) ▁{ ▁B DR V Q ED State ▁* s ▁= ▁bs -> op aque ; ▁/* ▁Cancel ▁timer ▁and ▁start ▁doing ▁I / O ▁that ▁were ▁meant ▁to ▁happen ▁as ▁if ▁it ▁* ▁fired , ▁that ▁way ▁we ▁get ▁b dr v _ d rain () ▁taking ▁care ▁of ▁the ▁on going ▁requests ▁* ▁correctly . ▁*/ ▁q ed _ cancel _ need _ check _ timer ( s ); ▁q ed _ plug _ alloc ating _ write _ reqs ( s ); ▁b dr v _ a io _ flush ( s -> bs , ▁q ed _ clear _ need _ check , ▁s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str tol _ invalid ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁" ▁xxxx ▁\ t ▁abc "; ▁char ▁f ▁= ▁' X '; ▁const ▁char ▁* end ptr ▁= ▁& f ; ▁long ▁res ▁= ▁999 ; ▁int ▁err ; ▁err ▁= ▁qemu _ str tol ( str , ▁& end ptr , ▁0, ▁& res ); ▁g _ assert _ cmp int ( err , ▁== , ▁0); ▁g _ assert _ cmp int ( res , ▁== , ▁0); ▁g _ assert ( end ptr ▁== ▁str ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ bind ( const ▁char ▁* hostname , ▁bool ▁* has _ proto ) ▁{ ▁int ▁fd ▁= ▁-1; ▁struct ▁addr info ▁ai , ▁* res ▁= ▁NULL ; ▁int ▁rc ; ▁int ▁ret ▁= ▁-1; ▁mem set ( & ai , ▁0, ▁sizeof ( ai )); ▁ai . ai _ flags ▁= ▁AI _ CAN ON NAME ▁| ▁AI _ V 4 MAP PED ▁| ▁AI _ ADDR CONFIG ; ▁ai . ai _ family ▁= ▁AF _ UN SPEC ; ▁ai . ai _ sock type ▁= ▁SOCK _ STREAM ; ▁/* ▁lookup ▁*/ ▁rc ▁= ▁get addrinfo ( hostname , ▁NULL , ▁& ai , ▁& res ); ▁if ▁( rc ▁!= ▁0) ▁{ ▁if ▁( rc ▁== ▁E AI _ ADDR FAMILY ▁|| ▁rc ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁run _ poll _ handlers ( A io Context ▁* ctx , ▁int 64_ t ▁max _ ns ) ▁{ ▁bool ▁progress ▁= ▁false ; ▁int 64_ t ▁end _ time ; ▁assert ( ctx -> notify _ me ); ▁assert ( ctx -> walk ing _ handlers ▁> ▁0); ▁assert ( ctx -> poll _ disable _ cnt ▁== ▁0); ▁trace _ run _ poll _ handlers _ begin ( ctx , ▁max _ ns ); ▁end _ time ▁= ▁qemu _ clock _ get _ ns ( Q EM U _ C LOCK _ RE AL TIME ) ▁+ ▁max _ ns ; ▁do ▁{ ▁A io Handler ▁* node ; ▁Q LIST _ FORE A CH ( node , ▁& ctx -> a io _ handlers , ▁node ) ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁screen press o _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁Screen press o Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* frame ▁= ▁data ; ▁int ▁key frame ; ▁int ▁ret ; ▁/* ▁Size ▁check ▁*/ ▁if ▁( av pk t -> size ▁< ▁3) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Packet ▁too ▁small ▁( % d )\ n ", ▁av pk t -> size ); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁/* ▁Basic ▁sanity ▁check , ▁but ▁not ▁really ▁h arm fu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁TC G v ▁iw mm xt _ load _ cre g ( int ▁reg ) ▁{ ▁TC G v ▁var ▁= ▁new _ tmp (); ▁tc g _ gen _ ld _ i 32 ( var , ▁cpu _ env , ▁offset of ( CPU State , ▁iw mm xt . cre gs [ reg ])); ▁return ▁var ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( set _ cp _ reg 64 )( CPU ARM State ▁* env , ▁void ▁* rip , ▁uint 64_ t ▁value ) ▁{ ▁const ▁ARM CP Reg Info ▁* ri ▁= ▁ri p ; ▁ri -> writ ef n ( env , ▁ri , ▁value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v host _ sc si _ stop ( V Host SC SI ▁* s ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( s ); ▁Bus State ▁* q bus ▁= ▁B US ( q dev _ get _ parent _ bus ( DEVICE ( v dev ))); ▁V irt io Bus Class ▁* k ▁= ▁VI RT IO _ B US _ GET _ CLASS ( q bus ); ▁int ▁ret ▁= ▁0; ▁if ▁(! k -> set _ guest _ not ifiers ) ▁{ ▁ret ▁= ▁k -> set _ guest _ not ifiers ( q bus -> parent , ▁s -> dev . nv qs , ▁false ); ▁if ▁( ret ▁< ▁0) ▁{ ▁error _ report (" v host ▁guest ▁notifier ▁cleanup ▁failed : ▁% d \ n ",

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁start _ t co ( const ▁TestData ▁* d ) ▁{ ▁uint 32_ t ▁val ; ▁val ▁= ▁q pc i _ io _ read w ( d -> dev , ▁d -> t co _ io _ base ▁+ ▁T CO 1_ C NT ); ▁val ▁&= ▁~ T CO _ T MR _ H LT ; ▁q pc i _ io _ writ ew ( d -> dev , ▁d -> t co _ io _ base ▁+ ▁T CO 1_ C NT , ▁val ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁memory _ global _ dirty _ log _ stop ( void ) ▁{ ▁global _ dirty _ log ▁= ▁false ; ▁/* ▁Refresh ▁DIR TY _ LOG _ M IG R ATION ▁bit . ▁*/ ▁memory _ region _ transaction _ begin (); ▁memory _ region _ update _ pending ▁= ▁true ; ▁memory _ region _ transaction _ commit (); ▁ME MORY _ LIST ENER _ CALL _ GLOBAL ( log _ global _ stop , ▁Reverse ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁open _ by _ handle ( int ▁mount fd , ▁const ▁char ▁* fh , ▁int ▁flags ) ▁{ ▁errno ▁= ▁ENO SY S ; ▁return ▁-1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cmd _ get _ event _ status _ notification ( IDE State ▁* s , ▁uint 8_ t ▁* buf ) ▁{ ▁const ▁uint 8_ t ▁* packet ▁= ▁buf ; ▁struct ▁{ ▁uint 8_ t ▁opcode ; ▁uint 8_ t ▁pol led ; ▁/* ▁lsb ▁bit ▁is ▁pol led ; ▁others ▁are ▁reserved ▁*/ ▁uint 8_ t ▁reserved 2 [2 ]; ▁uint 8_ t ▁class ; ▁uint 8_ t ▁reserved 3 [2 ]; ▁uint 16_ t ▁len ; ▁uint 8_ t ▁control ; ▁} ▁__ attribute __ (( packed )) ▁* ges n _ c db ; ▁struct ▁{ ▁uint 16_ t ▁len ; ▁uint 8_ t ▁notification _ class ; ▁uint 8_ t ▁supported _ even

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ plane ( U t video Context ▁* c , ▁int ▁plane _ no , ▁uint 8_ t ▁* dst , ▁int ▁step , ▁ptr diff _ t ▁stride , ▁int ▁width , ▁int ▁height , ▁const ▁uint 8_ t ▁* src , ▁int ▁use _ pred ) ▁{ ▁int ▁i , ▁j , ▁slice , ▁pix ; ▁int ▁s start , ▁send ; ▁V LC ▁vl c ; ▁Get Bit Context ▁gb ; ▁int ▁prev , ▁fs ym ; ▁const ▁int ▁c mask ▁= ▁c -> inter laced ▁? ▁~ (1 ▁+ ▁2 ▁* ▁(! plane _ no ▁&& ▁c -> av ctx -> pix _ fmt ▁== ▁AV _ PI X _ F MT _ Y UV 4 20 P )) ▁: ▁~ (! plane _ no ▁&& ▁c -> av ctx -> pix

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁o gg _ buffer _ data ( AV Format Context ▁* s , ▁AV Stream ▁* st , ▁uint 8_ t ▁* data , ▁unsigned ▁size , ▁int 64_ t ▁gr an ule , ▁int ▁header ) ▁{ ▁O GG Stream Context ▁* og g stream ▁= ▁st -> priv _ data ; ▁O GG Context ▁* og g ▁= ▁s -> priv _ data ; ▁int ▁total _ segments ▁= ▁size ▁/ ▁255 ▁+ ▁1; ▁uint 8_ t ▁* p ▁= ▁data ; ▁int ▁i , ▁segments , ▁len , ▁flush ▁= ▁0; ▁// ▁H andles ▁V FR ▁by ▁flush ing ▁page ▁because ▁this ▁frame ▁needs ▁to ▁have ▁a ▁timestamp ▁// ▁For ▁the ora , ▁key frames 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁m peg 4_ encode _ picture _ header ( M peg Enc Context ▁* ▁s , ▁int ▁picture _ number ) ▁{ ▁int ▁time _ inc r ; ▁int ▁time _ div , ▁time _ mod ; ▁if ( s -> p ict _ type == AV _ PI CT URE _ TYPE _ I ){ ▁if (! ( s -> flags & CODE C _ FLAG _ GLOBAL _ HEADER )){ ▁if ( s -> strict _ std _ compl iance ▁< ▁FF _ COMP LI ANCE _ VERY _ STRI CT ) ▁// H ACK , ▁the ▁reference ▁sw ▁is ▁buggy ▁m peg 4_ encode _ visual _ object _ header ( s ); ▁if ( s -> strict _ std _ compl iance ▁< ▁FF _ COMP LI ANCE _ VERY _ ST

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁build _ vlc ( V LC ▁* vlc , ▁const ▁uint 8_ t ▁* bits _ table , ▁const ▁uint 8_ t ▁* val _ table , ▁int ▁nb _ codes ) ▁{ ▁uint 8_ t ▁h uff _ size [ 256 ]; ▁uint 16_ t ▁h uff _ code [ 256 ]; ▁mem set ( h uff _ size , ▁0, ▁sizeof ( h uff _ size )); ▁build _ h uff man _ codes ( h uff _ size , ▁h uff _ code , ▁bits _ table , ▁val _ table ); ▁init _ vlc ( vlc , ▁9, ▁nb _ codes , ▁h uff _ size , ▁1, ▁1, ▁h uff _ code , ▁2, ▁2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ cor outine _ adjust _ pool _ size ( int ▁n ) ▁{ ▁qemu _ mut ex _ lock ( & pool _ lock ); ▁pool _ max _ size ▁+= ▁n ; ▁/* ▁Call ers ▁should ▁never ▁take ▁away ▁more ▁than ▁they ▁added ▁*/ ▁assert ( pool _ max _ size ▁>= ▁PO OL _ DEFAULT _ SIZE ); ▁/* ▁Tr im ▁overs ized ▁pool ▁down ▁to ▁new ▁max ▁*/ ▁while ▁( pool _ size ▁> ▁pool _ max _ size ) ▁{ ▁Cor outine ▁* co ▁= ▁Q S LIST _ FIRST ( & pool ); ▁Q S LIST _ REMOVE _ HEAD ( & pool , ▁pool _ next ); ▁pool _ size --; ▁qemu _ cor outine _ delete

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rnd is _ clear _ response queue ( US B Net State ▁* s ) ▁{ ▁struct ▁rnd is _ response ▁* r ; ▁while ▁(( r ▁= ▁s -> r nd is _ resp . t q h _ first )) ▁{ ▁TA IL Q _ REMOVE ( & s -> r nd is _ resp , ▁r , ▁entries ); ▁qemu _ free ( r ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ vp 56 d sp _ init _ x 86 ( VP 56 DS P Context * ▁c , ▁enum ▁AV Codec ID ▁codec ) ▁{ ▁# if ▁HAVE _ Y AS M ▁int ▁mm _ flags ▁= ▁av _ get _ cpu _ flags (); ▁if ▁( CONFIG _ VP 6_ DE CO DER ▁&& ▁codec ▁== ▁AV _ CODE C _ ID _ VP 6) ▁{ ▁# if ▁ARCH _ X 86 _32 ▁if ▁( mm _ flags ▁& ▁AV _ CPU _ FLAG _ MM X ) ▁{ ▁c -> vp 6_ filter _ diag 4 ▁= ▁ff _ vp 6_ filter _ diag 4_ mm x ; ▁} ▁# end if ▁if ▁( mm _ flags ▁& ▁AV _ CPU _ FLAG _ SS E 2) ▁{ ▁c -> vp 6_ filter _ diag 4 ▁= ▁ff _ vp 6_ filter _ d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ pp c _ handle _ mm u _ fault ▁( CPU State ▁* env , ▁uint 32_ t ▁address , ▁int ▁rw , ▁int ▁is _ user , ▁int ▁is _ soft mm u ) ▁{ ▁uint 32_ t ▁physical ; ▁int ▁prot ; ▁int ▁exception ▁= ▁0, ▁error _ code ▁= ▁0; ▁int ▁access _ type ; ▁int ▁ret ▁= ▁0; ▁// ▁printf ("% s ▁0 \ n ", ▁__ func __ ); ▁access _ type ▁= ▁env -> access _ type ; ▁if ▁( env -> user _ mode _ only ) ▁{ ▁/* ▁user ▁mode ▁only ▁em ulation ▁*/ ▁ret ▁= ▁- 2; ▁goto ▁do _ fault ; ▁} ▁/* ▁N AST Y ▁BU G ▁workaround ▁*/ ▁if ▁( access _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spatial _ dec om pose 53 i ( D W TE LE M ▁* buffer , ▁int ▁width , ▁int ▁height , ▁int ▁stride ){ ▁int ▁y ; ▁D W TE LE M ▁* b 0 = ▁buffer ▁+ ▁mirror ( -2 -1, ▁height -1) * stride ; ▁D W TE LE M ▁* b 1= ▁buffer ▁+ ▁mirror ( -2 ▁, ▁height -1) * stride ; ▁for ( y = -2 ; ▁y < height ; ▁y + =2 ){ ▁D W TE LE M ▁* b 2= ▁buffer ▁+ ▁mirror ( y +1, ▁height -1) * stride ; ▁D W TE LE M ▁* b 3= ▁buffer ▁+ ▁mirror ( y + 2, ▁height -1) * stride ; ▁{ START _ T IMER ▁if ( b 1 ▁<= ▁b 3) ▁horizontal _ dec om 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sd _ truncate ( Block Driver State ▁* bs , ▁int 64_ t ▁offset ) ▁{ ▁B DR V Sh eep dog State ▁* s ▁= ▁bs -> op aque ; ▁int ▁ret , ▁fd ; ▁unsigned ▁int ▁dat al en ; ▁if ▁( offset ▁< ▁s -> in ode . v di _ size ) ▁{ ▁error _ report (" sh rink ing ▁is ▁not ▁supported "); ▁return ▁- E IN VAL ; ▁} ▁else ▁if ▁( offset ▁> ▁SD _ MAX _ V DI _ SIZE ) ▁{ ▁error _ report (" too ▁big ▁image ▁size "); ▁return ▁- E IN VAL ; ▁} ▁fd ▁= ▁connect _ to _ sd og ( s -> addr , ▁s -> port ); ▁if ▁( fd ▁< ▁0) ▁{ ▁retu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rnd is _ parse ( US B Net State ▁* s , ▁uint 8_ t ▁* data , ▁int ▁length ) ▁{ ▁uint 32_ t ▁msg _ type ; ▁le 32 ▁* tmp ▁= ▁( le 32 ▁* ) ▁data ; ▁msg _ type ▁= ▁le 32_ to _ cp up ( tmp ); ▁switch ▁( msg _ type ) ▁{ ▁case ▁R ND IS _ INIT IALI ZE _ MSG : ▁s -> r nd is _ state ▁= ▁R ND IS _ INIT IALIZED ; ▁return ▁rnd is _ init _ response ( s , ▁( r nd is _ init _ msg _ type ▁* ) ▁data ); ▁case ▁R ND IS _ H ALT _ MSG : ▁s -> r nd is _ state ▁= ▁R ND IS _ UN INIT IALIZED ; ▁return ▁0; ▁case ▁R ND 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sap _ write _ header ( AV Format Context ▁* s ) ▁{ ▁struct ▁SAP State ▁* s ap ▁= ▁s -> priv _ data ; ▁char ▁host [10 24 ], ▁path [10 24 ], ▁url [10 24 ], ▁announce _ addr [ 50 ] ▁= ▁""; ▁char ▁* option _ list ; ▁int ▁port ▁= ▁9 87 5, ▁base _ port ▁= ▁500 4, ▁i , ▁pos ▁= ▁0, ▁same _ port ▁= ▁0, ▁ttl ▁= ▁255 ; ▁AV Format Context ▁** contexts ▁= ▁NULL ; ▁int ▁ret ▁= ▁0; ▁struct ▁sock addr _ storage ▁local addr ; ▁sock len _ t ▁add rl en ▁= ▁sizeof ( local addr ); ▁int ▁udp _ fd ; ▁AV Dictionary

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h ls _ prediction _ unit ( HE VC Context ▁* s , ▁int ▁x 0, ▁int ▁y 0, ▁int ▁n P b W , ▁int ▁n P b H , ▁int ▁log 2_ cb _ size , ▁int ▁part Idx , ▁int ▁idx ) ▁{ ▁# define ▁POS ( c _ idx , ▁x , ▁y ) ▁\ ▁& s -> frame -> data [ c _ idx ][ (( y ) ▁>> ▁s -> sp s -> v shift [ c _ idx ]) ▁* ▁s -> frame -> lines ize [ c _ idx ] ▁+ ▁\ ▁( (( x ) ▁>> ▁s -> sp s -> h shift [ c _ idx ]) ▁<< ▁s -> sp s -> pixel _ shift )] ▁HE VC Local Context ▁* lc ▁= ▁s -> HE V Cl c ; ▁int ▁merge _ idx ▁= ▁0; ▁struct ▁M v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ blk _ handle _ output ( V irt IO Device ▁* v dev , ▁V irt Queue ▁* v q ) ▁{ ▁V irt IO Block ▁* s ▁= ▁VI RT IO _ BL K ( v dev ); ▁V irt IO Block Req ▁* req ; ▁Multi Req Buffer ▁m rb ▁= ▁{}; ▁/* ▁Some ▁guest s ▁kick ▁before ▁setting ▁VI RT IO _ CONFIG _ S _ D RIVER _ OK ▁so ▁start ▁* ▁data plane ▁here ▁instead ▁of ▁waiting ▁for ▁. set _ status (). ▁*/ ▁if ▁( s -> data plane ) ▁{ ▁virt io _ blk _ data _ plane _ start ( s -> data plane ); ▁return ; ▁} ▁blk _ io _ plug ( s -> blk ); ▁w

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av _ n oin line ▁filter _ mb _ edge h ( ▁uint 8_ t ▁* pix , ▁int ▁stride , ▁int 16_ t ▁b S [4 ], ▁unsigned ▁int ▁qp , ▁H 264 Context ▁* h ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁52 ▁+ ▁qp ▁+ ▁h -> slice _ alpha _ c 0_ offset ; ▁const ▁int ▁alpha ▁= ▁alpha _ table [ index _ a ]; ▁const ▁int ▁beta ▁= ▁( beta _ table + 5 2) [ qp ▁+ ▁h -> slice _ beta _ offset ]; ▁if ▁( alpha ▁== 0 ▁|| ▁beta ▁== ▁0) ▁return ; ▁if ( ▁b S [0] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc [4 ]; ▁tc [0] ▁= ▁tc 0_ table [ index _ a 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁realize ( Device State ▁* d , ▁Error ▁** err p ) ▁{ ▁s P AP R DR Connector ▁* d rc ▁= ▁SP AP R _ DR _ CONNECT OR ( d ); ▁Object ▁* root _ container ; ▁char ▁link _ name [ 256 ]; ▁g char ▁* child _ name ; ▁Error ▁* err ▁= ▁NULL ; ▁trace _ sp ap r _ d rc _ real ize ( sp ap r _ d rc _ index ( d rc )); ▁/* ▁NOTE : ▁we ▁do ▁this ▁as ▁part ▁of ▁realize / un real ize ▁due ▁to ▁the ▁fact ▁* ▁that ▁the ▁guest ▁will ▁communicate ▁with ▁the ▁D RC ▁via ▁RT AS ▁calls ▁* ▁referencing ▁the ▁global ▁D RC ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ld _ as i ( Dis as Context ▁* dc , ▁TC G v ▁dst , ▁TC G v ▁addr , ▁int ▁insn , ▁int ▁size , ▁int ▁sign ) ▁{ ▁TC G v _ i 32 ▁r _ as i , ▁r _ size , ▁r _ sign ; ▁r _ as i ▁= ▁gen _ get _ as i ( dc , ▁insn ); ▁r _ size ▁= ▁tc g _ const _ i 32 ( size ); ▁r _ sign ▁= ▁tc g _ const _ i 32 ( sign ); ▁# if def ▁TARGET _ SP AR C 64 ▁gen _ helper _ ld _ as i ( dst , ▁cpu _ env , ▁addr , ▁r _ as i , ▁r _ size , ▁r _ sign ); ▁# else ▁{ ▁TC G v _ i 64 ▁t 64 ▁= ▁tc g _ temp _ new _ i 64 (); ▁gen _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁float 64 ▁u cf 64_ it od ( uint 64_ t ▁i ) ▁{ ▁union ▁{ ▁uint 64_ t ▁i ; ▁float 64 ▁d ; ▁} ▁v ; ▁v . i ▁= ▁i ; ▁return ▁v . d ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁tc g _ gen _ code ( TC G Context ▁* s , ▁tc g _ ins n _ unit ▁* gen _ code _ buf ) ▁{ ▁int ▁i , ▁o i , ▁o i _ next , ▁num _ ins ns ; ▁# if def ▁CONFIG _ PRO FIL ER ▁{ ▁int ▁n ; ▁n ▁= ▁s -> gen _ last _ op _ idx ▁+ ▁1; ▁s -> op _ count ▁+= ▁n ; ▁if ▁( n ▁> ▁s -> op _ count _ max ) ▁{ ▁s -> op _ count _ max ▁= ▁n ; ▁} ▁n ▁= ▁s -> nb _ tem ps ; ▁s -> temp _ count ▁+= ▁n ; ▁if ▁( n ▁> ▁s -> temp _ count _ max ) ▁{ ▁s -> temp _ count _ max ▁= ▁n ; ▁} ▁} ▁# end if ▁# if def ▁DEBUG _ DIS AS ▁if ▁( un likel

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁eh ci _ process _ it d ( E H CI State ▁* eh ci , ▁E H CI it d ▁* it d ) ▁{ ▁USB Port ▁* port ; ▁USB Device ▁* dev ; ▁int ▁ret ; ▁uint 32_ t ▁i , ▁j , ▁len , ▁pid , ▁dir , ▁dev addr , ▁end p ; ▁uint 32_ t ▁pg , ▁off , ▁ptr 1, ▁ptr 2, ▁max , ▁mult ; ▁dir ▁= ( it d -> buf ptr [1] ▁& ▁IT D _ BU F PT R _ DI RECTION ); ▁dev addr ▁= ▁get _ field ( it d -> buf ptr [0], ▁IT D _ BU F PT R _ DEV ADDR ); ▁end p ▁= ▁get _ field ( it d -> buf ptr [0], ▁IT D _ BU F PT R _ EP ); ▁max ▁= ▁get _ field ( it d 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q mp _ input _ pop ( Visitor ▁* v , ▁void ▁** obj ) ▁{ ▁Q mp Input Visitor ▁* q iv ▁= ▁to _ q iv ( v ); ▁Stack Object ▁* tos ▁= ▁Q S LIST _ FIRST ( & q iv -> stack ); ▁assert ( tos ▁&& ▁to s -> q api ▁== ▁obj ); ▁Q S LIST _ REMOVE _ HEAD ( & q iv -> stack , ▁node ); ▁q mp _ input _ stack _ object _ free ( tos ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v md _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁V md Dem ux Context ▁* v md ▁= ▁( V md Dem ux Context ▁* ) s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁& s -> pb ; ▁AV Stream ▁* st ; ▁unsigned ▁int ▁toc _ offset ; ▁unsigned ▁char ▁* raw _ frame _ table ; ▁int ▁raw _ frame _ table _ size ; ▁offset _ t ▁current _ offset ; ▁int ▁i , ▁j ; ▁unsigned ▁int ▁total _ frames ; ▁int 64_ t ▁video _ pts _ inc ▁= ▁0; ▁int 64_ t ▁current _ video _ pts ▁= ▁0; ▁unsigned ▁ch

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ds put il _ init _ arm ( DS P Context * ▁c , ▁AV Codec Context ▁* av ctx ) ▁{ ▁int ▁id ct _ al go = ▁av ctx -> id ct _ al go ; ▁ff _ put _ pixels _ cl amp ed ▁= ▁c -> put _ pixels _ cl amp ed ; ▁ff _ add _ pixels _ cl amp ed ▁= ▁c -> add _ pixels _ cl amp ed ; ▁if ▁( av ctx -> low res ▁== ▁0) ▁{ ▁if ( id ct _ al go ▁== ▁FF _ ID CT _ AUTO ){ ▁# if ▁HAVE _ IP P ▁id ct _ al go ▁= ▁FF _ ID CT _ IP P ; ▁# el if ▁HAVE _ NE ON ▁id ct _ al go ▁= ▁FF _ ID CT _ SI MPLE NE ON ; ▁# el if ▁HAVE _ ARM V 6 ▁id ct

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ h 2 64_ free _ context ( H 264 Context ▁* h ) ▁{ ▁int ▁i ; ▁ff _ h 2 64_ free _ tables ( h ); ▁if ▁( h -> DP B ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁H 2 64_ MAX _ PI CT URE _ COUNT ; ▁i ++) ▁ff _ h 2 64_ un ref _ picture ( h , ▁& h -> DP B [ i ]); ▁av _ fre ep ( & h -> DP B ); ▁} ▁h -> cur _ pic _ ptr ▁= ▁NULL ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁h -> nb _ slice _ ctx ; ▁i ++) ▁av _ fre ep ( & h -> slice _ ctx [ i ]. rb sp _ buffer ); ▁av _ fre ep ( & h -> slice _ ctx ); ▁h -> nb _ slice _ ctx ▁= ▁0; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁aio _ poll ( A io Context ▁* ctx , ▁bool ▁blocking ) ▁{ ▁A io Handler ▁* node ; ▁int ▁i , ▁ret ; ▁bool ▁progress ; ▁int 64_ t ▁timeout ; ▁aio _ context _ acquire ( ctx ); ▁progress ▁= ▁false ; ▁/* ▁aio _ notify ▁can ▁avoid ▁the ▁expensive ▁event _ notifier _ set ▁if ▁* ▁everything ▁( file ▁descriptors , ▁bottom ▁hal ves , ▁timers ) ▁will ▁* ▁be ▁re - eval uated ▁before ▁the ▁next ▁blocking ▁poll (). ▁This ▁is ▁* ▁already ▁true ▁when ▁aio _ poll ▁is ▁called ▁with ▁blocking ▁== ▁false ; ▁* ▁if ▁block

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av codec _ default _ re get _ buffer ( AV Codec Context ▁* s , ▁AV Frame ▁* pic ) ▁{ ▁av _ assert 0 (0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lat m _ write _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁Put Bit Context ▁bs ; ▁int ▁i , ▁len ; ▁uint 8_ t ▁lo as _ header [] ▁= ▁"\ x 56 \ xe 0\ x 00 "; ▁uint 8_ t ▁* buf ▁= ▁NULL ; ▁if ▁( s -> streams [0] -> codec -> codec _ id ▁== ▁CODE C _ ID _ A AC _ L AT M ) ▁return ▁ff _ raw _ write _ packet ( s , ▁pkt ); ▁if ▁( pk t -> size ▁> ▁2 ▁&& ▁pkt -> data [0] ▁== ▁0 xff ▁&& ▁( pk t -> data [1] ▁>> ▁4) ▁== ▁0 xf ) ▁{ ▁av _ log ( s , ▁AV _ LO

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁aio _ read _ done ( void ▁* op aque , ▁int ▁ret ) ▁{ ▁struct ▁aio _ ctx ▁* ctx ▁= ▁opaque ; ▁struct ▁time val ▁t 2; ▁get time of day ( & t 2, ▁NULL ); ▁if ▁( ret ▁< ▁0) ▁{ ▁printf (" read v ▁failed : ▁% s \ n ", ▁strerror (- ret )); ▁goto ▁out ; ▁} ▁if ▁( ctx -> P flag ) ▁{ ▁void ▁* cmp _ buf ▁= ▁g _ m alloc ( ctx -> q io v . size ); ▁mem set ( cmp _ buf , ▁ctx -> pattern , ▁ctx -> q io v . size ); ▁if ▁( mem cmp ( ctx -> buf , ▁cmp _ buf , ▁ctx -> q io v . size )) ▁{ ▁printf (" Pattern ▁ve

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁char ▁* read _ ts ( const ▁char ▁* buf , ▁int ▁* ts _ start , ▁int ▁* ts _ end , ▁int ▁* x 1, ▁int ▁* y 1, ▁int ▁* x 2, ▁int ▁* y 2) ▁{ ▁int ▁i , ▁hs , ▁ms , ▁ss , ▁he , ▁me , ▁se ; ▁for ▁( i =0; ▁i < 2; ▁i ++) ▁{ ▁/* ▁try ▁to ▁read ▁timestamps ▁in ▁either ▁the ▁first ▁or ▁second ▁line ▁*/ ▁int ▁c ▁= ▁s scan f ( buf , ▁"% d : %2 d : %2 d % * 1[ , . ] %3 d ▁--> ▁% d : %2 d : %2 d % * 1[ , . ] %3 d " ▁"% * [ ▁] X 1: % u ▁X 2: % u ▁Y 1: % u ▁Y 2: % u ", ▁& hs , ▁& ms , ▁& ss , ▁ts _ start , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ph ys _ addr _ t ▁cpu _ get _ ph ys _ page _ debug ( CPU State ▁* env , ▁target _ ulong ▁addr ) ▁{ ▁target _ ulong ▁p de _ addr , ▁p te _ addr ; ▁uint 64_ t ▁p te ; ▁target _ ph ys _ addr _ t ▁p addr ; ▁uint 32_ t ▁page _ offset ; ▁int ▁page _ size ; ▁if ▁( env -> cr [4] ▁& ▁CR 4_ PA E _ MASK ) ▁{ ▁target _ ulong ▁pd pe _ addr ; ▁uint 64_ t ▁p de , ▁pd pe ; ▁# if def ▁TARGET _ X 86_64 ▁if ▁( env -> h flags ▁& ▁H F _ L MA _ MASK ) ▁{ ▁uint 64_ t ▁p ml 4 e _ addr , ▁p ml 4 e ; ▁int 32_ t ▁s ext ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sp ap r _ pc i _ rt as _ init ( void ) ▁{ ▁sp ap r _ rt as _ register (" read - pc i - config ", ▁rt as _ read _ pc i _ config ); ▁sp ap r _ rt as _ register (" write - pc i - config ", ▁rt as _ write _ pc i _ config ); ▁sp ap r _ rt as _ register (" ibm , read - pc i - config ", ▁rt as _ ibm _ read _ pc i _ config ); ▁sp ap r _ rt as _ register (" ibm , write - pc i - config ", ▁rt as _ ibm _ write _ pc i _ config ); ▁if ▁( m si _ supported ) ▁{ ▁sp ap r _ rt as _ register (" ibm , query - interru

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compare _ sec _ rs _ final ize ( Socket Read State ▁* sec _ rs ) ▁{ ▁Compare State ▁* s ▁= ▁container _ of ( sec _ rs , ▁Compare State , ▁sec _ rs ); ▁if ▁( packet _ enqueue ( s , ▁SECOND ARY _ IN )) ▁{ ▁trace _ col o _ compare _ main (" secondary : ▁unsupported ▁packet ▁in "); ▁} ▁else ▁{ ▁/* ▁compare ▁connection ▁*/ ▁g _ queue _ foreach ( & s -> conn _ list , ▁col o _ compare _ connection , ▁s ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁F D Ctrl ▁* fd ctrl _ init _ isa ( Drive Info ▁** fds ) ▁{ ▁IS AD evice ▁* dev ; ▁dev ▁= ▁isa _ create (" isa - fd c "); ▁if ▁( fds [0]) ▁{ ▁q dev _ prop _ set _ drive _ n of ail ( & dev -> q dev , ▁" drive A ", ▁f ds [0] -> b dr v ); ▁} ▁if ▁( fds [1]) ▁{ ▁q dev _ prop _ set _ drive _ n of ail ( & dev -> q dev , ▁" drive B ", ▁f ds [1] -> b dr v ); ▁} ▁if ▁( q dev _ init ( & dev -> q dev ) ▁< ▁0) ▁return ▁NULL ; ▁return ▁& ( DO _ UP CAST ( FD Ctrl IS AB us , ▁bus dev , ▁dev ) -> state ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁as f _ read _ picture ( AV Format Context ▁* s , ▁int ▁len ) ▁{ ▁AS F Context ▁* as f ▁= ▁s -> priv _ data ; ▁AV Packet ▁pkt ▁= ▁{ ▁0 ▁}; ▁const ▁Codec Mime ▁* mime ▁= ▁ff _ id 3 v 2_ mime _ tags ; ▁enum ▁AV Codec ID ▁id ▁= ▁AV _ CODE C _ ID _ NONE ; ▁char ▁mimetype [ 64 ]; ▁uint 8_ t ▁* desc ▁= ▁NULL ; ▁AV Stream ▁* st ▁= ▁NULL ; ▁int ▁ret , ▁type , ▁pic size , ▁desc _ len ; ▁AS F Stream ▁* as f _ st ; ▁/* ▁type ▁+ ▁pic size ▁+ ▁mime ▁+ ▁desc ▁*/ ▁if ▁( len ▁< ▁1 ▁+ ▁4 ▁+ ▁2 ▁+ ▁2) ▁{ ▁av _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( access _ check _ cp _ reg )( CPU ARM State ▁* env , ▁void ▁* rip , ▁uint 32_ t ▁sy nd rome ) ▁{ ▁const ▁ARM CP Reg Info ▁* ri ▁= ▁ri p ; ▁switch ▁( ri -> access fn ( env , ▁ri )) ▁{ ▁case ▁CP _ ACCESS _ OK : ▁case ▁CP _ ACCESS _ TR AP : ▁break ; ▁case ▁CP _ ACCESS _ TR AP _ UNC ATEG ORIZ ED : ▁env -> exception . sy nd rome ▁= ▁syn _ unc ategor ized (); ▁break ; ▁default : ▁g _ assert _ not _ re ached ();

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* sc s ibus _ get _ dev _ path ( Device State ▁* dev ) ▁{ ▁S CS ID evice ▁* d ▁= ▁DO _ UP CAST ( SC S ID evice , ▁q dev , ▁dev ); ▁Device State ▁* h ba ▁= ▁dev -> parent _ bus -> parent ; ▁char ▁* id ▁= ▁NULL ; ▁if ▁( h ba ▁&& ▁h ba -> parent _ bus ▁&& ▁h ba -> parent _ bus -> info -> get _ dev _ path ) ▁{ ▁id ▁= ▁h ba -> parent _ bus -> info -> get _ dev _ path ( h ba ); ▁} ▁if ▁( id ) ▁{ ▁return ▁g _ str dup _ printf ("% s /% d :% d :% d ", ▁id , ▁d -> channel , ▁d -> id , ▁d -> lun ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁eval _ l pc _ coeff s ( const ▁float ▁* in , ▁float ▁* t gt , ▁int ▁n ) ▁{ ▁int ▁x , ▁y ; ▁double ▁f 0, ▁f 1, ▁f 2; ▁if ▁( in [ n ] ▁== ▁0) ▁return ▁0; ▁if ▁(( f 0 ▁= ▁* in ) ▁<= ▁0) ▁return ▁0; ▁in --; ▁// ▁To ▁avoid ▁a ▁-1 ▁subtraction ▁in ▁the ▁inner ▁loop ▁for ▁( x =1; ▁x ▁<= ▁n ; ▁x ++) ▁{ ▁f 1 ▁= ▁in [ x +1 ]; ▁for ▁( y =0; ▁y ▁< ▁x ▁- ▁1; ▁y ++) ▁f 1 ▁+= ▁in [ x - y ]* t gt [ y ]; ▁tgt [ x -1] ▁= ▁f 2 ▁= ▁- f 1/ f 0; ▁for ▁( y =0; ▁y ▁< ▁x ▁>> ▁1; ▁y ++) ▁{ ▁float ▁temp ▁= ▁tgt [ y ] 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sw r _ init ( struct ▁Sw r Context ▁* s ){ ▁s -> in _ buffer _ index = ▁0; ▁s -> in _ buffer _ count = ▁0; ▁s -> res ample _ in _ constraint = ▁0; ▁free _ temp ( & s -> post in ); ▁free _ temp ( & s -> mid buf ); ▁free _ temp ( & s -> pre out ); ▁free _ temp ( & s -> in _ buffer ); ▁free _ temp ( & s -> d ither ); ▁sw ri _ audio _ convert _ free ( & s -> ▁in _ convert ); ▁sw ri _ audio _ convert _ free ( & s -> out _ convert ); ▁sw ri _ audio _ convert _ free ( & s -> full _ convert ); ▁sw ri _ rem 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pc _ hot _ add _ cpu ( const ▁int 64_ t ▁id , ▁Error ▁** err p ) ▁{ ▁Device State ▁* ic c _ bridge ; ▁int 64_ t ▁ap ic _ id ▁= ▁x 86_ cpu _ ap ic _ id _ from _ index ( id ); ▁if ▁( cpu _ exists ( ap ic _ id )) ▁{ ▁error _ set g ( err p , ▁" Unable ▁to ▁add ▁CPU : ▁% " ▁PRI i 64 ▁", ▁it ▁already ▁exists ", ▁id ); ▁if ▁( id ▁>= ▁max _ cpus ) ▁{ ▁error _ set g ( err p , ▁" Unable ▁to ▁add ▁CPU : ▁% " ▁PRI i 64 ▁", ▁max ▁allowed : ▁% d ", ▁id , ▁max _ cpus ▁- ▁1); ▁i cc _ bridge ▁= ▁DEVICE ( object _ r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x ln x _ ep 10 8_ init ( Machine State ▁* machine ) ▁{ ▁X ln x EP 108 ▁* s ▁= ▁g _ new 0( X ln x EP 10 8, ▁1); ▁Error ▁* err ▁= ▁NULL ; ▁object _ initialize ( & s -> s oc , ▁sizeof ( s -> s oc ), ▁TYPE _ X L NX _ ZY N Q MP ); ▁object _ property _ add _ child ( OBJECT ( machine ), ▁" s oc ", ▁OBJECT ( & s -> s oc ), ▁& error _ abort ); ▁object _ property _ set _ bool ( OBJECT ( & s -> s oc ), ▁true , ▁" real ized ", ▁& err ); ▁if ▁( err ) ▁{ ▁error _ report ("% s ", ▁error _ get _ pretty ( e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ inputs ( const ▁char ▁** buf , ▁AV Filter In Out ▁** curr _ inputs , ▁AV Filter In Out ▁** open _ outputs , ▁AV Class ▁* log _ ctx ) ▁{ ▁int ▁pad ▁= ▁0; ▁while ▁( ** buf ▁== ▁'[ ') ▁{ ▁char ▁* name ▁= ▁parse _ link _ name ( buf , ▁log _ ctx ); ▁AV Filter In Out ▁* match ; ▁if ▁(! name ) ▁return ▁A VER ROR ( E IN VAL ); ▁/* ▁First ▁check ▁if ▁the ▁label ▁is ▁not ▁in ▁the ▁open _ outputs ▁list ▁*/ ▁match ▁= ▁extract _ in out ( name , ▁open _ outputs ); ▁if ▁( match ) ▁{ ▁av _ free ( na

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁vp 8_ mc _ chrom a ( VP 8 Context ▁* s , ▁V P 8 Thread Data ▁* td , ▁uint 8_ t ▁* dst 1, ▁uint 8_ t ▁* dst 2, ▁Thread Frame ▁* ref , ▁const ▁V P 56 mv ▁* mv , ▁int ▁x _ off , ▁int ▁y _ off , ▁int ▁block _ w , ▁int ▁block _ h , ▁int ▁width , ▁int ▁height , ▁int ▁lines ize , ▁vp 8_ mc _ func ▁mc _ func [3 ][ 3 ]) ▁{ ▁uint 8_ t ▁* src 1 ▁= ▁ref -> f -> data [1], ▁* src 2 ▁= ▁ref -> f -> data [2 ]; ▁if ▁( AV _ R N 32 A ( mv )) ▁{ ▁int ▁mx ▁= ▁mv -> x & 7, ▁mx _ idx ▁= ▁sub p el _ idx [0] [ mx ]; ▁int ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rgb 24 _ to _ y uv 444 p ( AV Picture ▁* dst , ▁AV Picture ▁* src , ▁int ▁width , ▁int ▁height ) ▁{ ▁int ▁src _ wrap , ▁x , ▁y ; ▁int ▁r , ▁g , ▁b ; ▁uint 8_ t ▁* l um , ▁* cb , ▁* cr ; ▁const ▁uint 8_ t ▁* p ; ▁l um ▁= ▁dst -> data [0]; ▁cb ▁= ▁dst -> data [1]; ▁cr ▁= ▁dst -> data [2 ]; ▁src _ wrap ▁= ▁src -> lines ize [0] ▁- ▁width ▁* ▁B PP ; ▁p ▁= ▁src -> data [0]; ▁for ( y =0; y < height ; y ++) ▁{ ▁for ( x =0; x < width ; x ++) ▁{ ▁RGB _ IN ( r , ▁g , ▁b , ▁p ); ▁l um [0] ▁= ▁RGB _ TO 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* pc ibus _ get _ fw _ dev _ path ( Device State ▁* dev ) ▁{ ▁PC ID evice ▁* d ▁= ▁( PC ID evice ▁* ) dev ; ▁char ▁path [ 50 ], ▁name [ 33 ]; ▁int ▁off ; ▁off ▁= ▁sn printf ( path , ▁sizeof ( path ), ▁"% s @ % x ", ▁pci _ dev _ fw _ name ( dev , ▁name , ▁sizeof ▁name ), ▁P CI _ SL OT ( d -> dev fn )); ▁if ▁( PC I _ F UNC ( d -> dev fn )) ▁sn printf ( path ▁+ ▁off , ▁sizeof ( path ) ▁+ ▁off , ▁", % x ", ▁P CI _ F UNC ( d -> dev fn )); ▁return ▁str dup ( path ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q io _ channel _ web sock _ handshake _ send _ response ( Q IO Channel Web sock ▁* i oc , ▁const ▁char ▁* key , ▁Error ▁** err p ) ▁{ ▁char ▁combined _ key [ Q IO _ CHANNEL _ WEB SO CK _ CLIENT _ KEY _ LEN ▁+ ▁Q IO _ CHANNEL _ WEB SO CK _ G UID _ LEN ▁+ ▁1 ]; ▁char ▁* accept ▁= ▁NULL , ▁* response ▁= ▁NULL ; ▁size _ t ▁res pon sel en ; ▁g _ str lc py ( combined _ key , ▁key , ▁Q IO _ CHANNEL _ WEB SO CK _ CLIENT _ KEY _ LEN ▁+ ▁1); ▁g _ str l cat ( combined _ key , ▁Q IO _ CHANNEL _ WEB SO C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁d py _ g fx _ copy ( Q emu Console ▁* con , ▁int ▁src _ x , ▁int ▁src _ y , ▁int ▁dst _ x , ▁int ▁dst _ y , ▁int ▁w , ▁int ▁h ) ▁{ ▁Display State ▁* s ▁= ▁con -> ds ; ▁Display ChangeListener ▁* d cl ; ▁if ▁(! q emu _ console _ is _ visible ( con )) ▁{ ▁return ; ▁} ▁Q LIST _ FORE A CH ( d cl , ▁& s -> listeners , ▁next ) ▁{ ▁if ▁( con ▁!= ▁( d cl -> con ▁? ▁d cl -> con ▁: ▁active _ console )) ▁{ ▁continue ; ▁} ▁if ▁( d cl -> ops -> d py _ g fx _ copy ) ▁{ ▁d cl -> ops -> d py _ g fx _ copy ( d cl , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁TC G Arg ▁* tc g _ constant _ fold ing ( TC G Context ▁* s , ▁uint 16_ t ▁* tc g _ op c _ ptr , ▁TC G Arg ▁* args , ▁TC G Op Def ▁* tc g _ op _ defs ) ▁{ ▁int ▁i , ▁nb _ ops , ▁op _ index , ▁nb _ tem ps , ▁nb _ globals , ▁nb _ call _ args ; ▁TC G Op code ▁op ; ▁const ▁TC G Op Def ▁* def ; ▁TC G Arg ▁* gen _ args ; ▁TC G Arg ▁tmp ; ▁TC G Cond ▁cond ; ▁/* ▁Array ▁VAL S ▁has ▁an ▁element ▁for ▁each ▁temp . ▁If ▁this ▁temp ▁holds ▁a ▁constant ▁then ▁its ▁value ▁is ▁kept ▁in ▁VAL S ' ▁element . ▁If ▁t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ connect ( V nc Display ▁* vd , ▁int ▁cs ock , ▁bool ▁skip auth , ▁bool ▁websocket ) ▁{ ▁V nc State ▁* vs ▁= ▁g _ m alloc 0( size of ( V nc State )); ▁int ▁i ; ▁vs -> cs ock ▁= ▁cs ock ; ▁vs -> vd ▁= ▁v d ; ▁if ▁( skip auth ) ▁{ ▁vs -> auth ▁= ▁V NC _ AUTH _ NONE ; ▁vs -> sub auth ▁= ▁V NC _ AUTH _ INVALID ; ▁} ▁else ▁{ ▁if ▁( websocket ) ▁{ ▁vs -> auth ▁= ▁v d -> ws _ auth ; ▁vs -> sub auth ▁= ▁V NC _ AUTH _ INVALID ; ▁} ▁else ▁{ ▁vs -> auth ▁= ▁v d -> auth ; ▁vs -> sub auth ▁= ▁v d 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ current _ dir ( FTP Context ▁* s ) ▁{ ▁char ▁* res ▁= ▁NULL , ▁* start ▁= ▁NULL , ▁* end ▁= ▁NULL ; ▁int ▁i ; ▁const ▁char ▁* command ▁= ▁" P WD \ r \ n "; ▁const ▁int ▁pwd _ codes [] ▁= ▁{ 25 7, ▁0 }; ▁if ▁(! ftp _ send _ command ( s , ▁command , ▁pwd _ codes , ▁& res )) ▁goto ▁fail ; ▁for ▁( i ▁= ▁0; ▁res [ i ]; ▁++ i ) ▁{ ▁if ▁( res [ i ] ▁== ▁'" ') ▁{ ▁if ▁(! start ) ▁{ ▁start ▁= ▁res ▁+ ▁i ▁+ ▁1; ▁continue ; ▁} ▁end ▁= ▁res ▁+ ▁i ; ▁break ; ▁} ▁} ▁if ▁(! end ) ▁goto ▁fail ; ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ opts _ print ( Q emu Opts ▁* opts , ▁void ▁* dummy ) ▁{ ▁Q emu Opt ▁* opt ; ▁f printf ( stderr , ▁"% s : ▁% s :", ▁opts -> list -> name , ▁opts -> id ▁? ▁opts -> id ▁: ▁"< n oid >"); ▁TA IL Q _ FORE A CH ( opt , ▁& opts -> head , ▁next ) ▁{ ▁f printf ( stderr , ▁" ▁% s =\" % s \" ", ▁opt -> name , ▁opt -> str ); ▁} ▁f printf ( stderr , ▁"\ n "); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁jpeg 2000 _ decode _ tile ( J peg 2000 Decoder Context ▁* s , ▁J peg 2000 Tile ▁* tile , ▁AV Frame ▁* picture ) ▁{ ▁int ▁comp no , ▁res level no , ▁band no ; ▁int ▁x , ▁y ; ▁uint 8_ t ▁* line ; ▁J peg 2000 T 1 Context ▁t 1; ▁/* ▁Loop ▁on ▁tile ▁components ▁*/ ▁for ▁( comp no ▁= ▁0; ▁comp no ▁< ▁s -> n components ; ▁comp no ++) ▁{ ▁J peg 2000 Component ▁* comp ▁= ▁tile -> comp ▁+ ▁comp no ; ▁J peg 2000 Coding Style ▁* cod st y ▁= ▁tile -> cod st y ▁+ ▁comp no ; ▁/* ▁Loop ▁on ▁resolution ▁leve

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ run _ all _ tim ers ( void ) ▁{ ▁alarm _ timer -> pending ▁= ▁0; ▁/* ▁re arm ▁timer , ▁if ▁not ▁periodic ▁*/ ▁if ▁( alarm _ timer -> expired ) ▁{ ▁alarm _ timer -> expired ▁= ▁0; ▁qemu _ re arm _ alarm _ timer ( alarm _ timer ); ▁} ▁/* ▁vm ▁time ▁timers ▁*/ ▁qemu _ run _ tim ers ( vm _ clock ); ▁qemu _ run _ tim ers ( rt _ clock ); ▁qemu _ run _ tim ers ( host _ clock ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁struct ▁X en Device ▁* x en _ be _ get _ x end ev ( const ▁char ▁* type , ▁int ▁dom , ▁int ▁dev , ▁struct ▁X en Dev Ops ▁* ops ) ▁{ ▁struct ▁X en Device ▁* x end ev ; ▁x end ev ▁= ▁xen _ be _ find _ x end ev ( type , ▁dom , ▁dev ); ▁if ▁( x end ev ) ▁{ ▁return ▁x end ev ; ▁} ▁/* ▁init ▁new ▁x end ev ▁*/ ▁x end ev ▁= ▁g _ m alloc 0( ops -> size ); ▁x end ev -> type ▁= ▁type ; ▁x end ev -> dom ▁= ▁dom ; ▁x end ev -> dev ▁= ▁dev ; ▁x end ev -> ops ▁= ▁ops ; ▁sn printf ( x end ev -> be , ▁sizeof ( x 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁json _ message _ process _ token ( JSON Lexer ▁* lexer , ▁Q String ▁* token , ▁JS ONT oken Type ▁type , ▁int ▁x , ▁int ▁y ) ▁{ ▁JSON Message Parser ▁* parser ▁= ▁container _ of ( lexer , ▁JSON Message Parser , ▁lexer ); ▁Q Dict ▁* dict ; ▁if ▁( type ▁== ▁JSON _ O PERATOR ) ▁{ ▁switch ▁( q string _ get _ str ( token ) [0]) ▁{ ▁case ▁'{ ': ▁parser -> b race _ count ++; ▁break ; ▁case ▁' } ': ▁parser -> b race _ count --; ▁break ; ▁case ▁'[ ': ▁parser -> b racket _ count ++; ▁break ; ▁case ▁' 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁set _ memory _ options ( uint 64_ t ▁* ram _ slots , ▁ram _ addr _ t ▁* max ram _ size ) ▁{ ▁uint 64_ t ▁sz ; ▁const ▁char ▁* mem _ str ; ▁const ▁char ▁* max mem _ str , ▁* slots _ str ; ▁const ▁ram _ addr _ t ▁default _ ram _ size ▁= ▁( ram _ addr _ t ) DEFAULT _ RAM _ SIZE ▁* ▁1024 ▁* ▁1024 ; ▁Q emu Opts ▁* opts ▁= ▁qemu _ find _ opts _ singleton (" memory "); ▁sz ▁= ▁0; ▁mem _ str ▁= ▁qemu _ opt _ get ( opts , ▁" size "); ▁if ▁( mem _ str ) ▁{ ▁if ▁(! * mem _ str ) ▁{ ▁error _ report (" 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁iscsi _ refresh _ limits ( Block Driver State ▁* bs , ▁Error ▁** err p ) ▁{ ▁/* ▁We ▁don ' t ▁actually ▁refresh ▁here , ▁but ▁just ▁return ▁data ▁quer ied ▁in ▁* ▁iscsi _ open (): ▁iscsi ▁targets ▁don ' t ▁change ▁their ▁limits . ▁*/ ▁I sc si L un ▁* is cs il un ▁= ▁bs -> op aque ; ▁uint 64_ t ▁max _ x fer _ len ▁= ▁is cs il un -> use _1 6_ for _ rw ▁? ▁0 xffffffff ▁: ▁0 xffff ; ▁bs -> request _ alignment ▁= ▁is cs il un -> block _ size ; ▁if ▁( is cs il un -> bl . max _ x fer _ len ) ▁{ ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ set _ m ce ( CPU State ▁* env , ▁struct ▁k vm _ x 86_ m ce ▁* m ) ▁{ ▁return ▁k vm _ vc pu _ io ctl ( env , ▁K VM _ X 86_ SET _ MCE , ▁m ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ide _ ata pi _ cmd ( IDE State ▁* s ) ▁{ ▁uint 8_ t ▁* buf ; ▁buf ▁= ▁s -> io _ buffer ; ▁# if def ▁DEBUG _ IDE _ ATA PI ▁{ ▁int ▁i ; ▁printf (" ATA PI ▁limit =0 x % x ▁packet :", ▁s -> l cy l ▁| ▁( s -> h cy l ▁<< ▁8 )); ▁for ( i ▁= ▁0; ▁i ▁< ▁AT API _ PA CKET _ SIZE ; ▁i ++) ▁{ ▁printf (" ▁%02 x ", ▁buf [ i ]); ▁} ▁printf ("\ n "); ▁} ▁# end if ▁/* ▁* ▁If ▁there ' s ▁a ▁UNIT _ AT TE NT ION ▁condition ▁pending , ▁only ▁command ▁flagged ▁with ▁* ▁ALLOW _ UA ▁are ▁allowed ▁to ▁complete . ▁with ▁othe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h ev c _ l um a _ mv _ merge _ mode ( HE VC Context ▁* s , ▁int ▁x 0, ▁int ▁y 0, ▁int ▁n P b W , ▁int ▁n P b H , ▁int ▁log 2_ cb _ size , ▁int ▁part _ idx , ▁int ▁merge _ idx , ▁M v Field ▁* mv ) ▁{ ▁int ▁single M CL Flag ▁= ▁0; ▁int ▁n CS ▁= ▁1 ▁<< ▁log 2_ cb _ size ; ▁LOCAL _ ALI G NED (4, ▁M v Field , ▁mer g ec and _ list , ▁[ MR G _ MAX _ NUM _ CAN DS ]); ▁int ▁n P b W 2 ▁= ▁n P b W ; ▁int ▁n P b H 2 ▁= ▁n P b H ; ▁HE VC Local Context ▁* lc ▁= ▁& s -> HE V Cl c ; ▁mem set ( mer g ec and _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁s 39 0_ cpu _ write _ elf 64_ note ( Write Core Dump Function ▁f , ▁CPU State ▁* cs , ▁int ▁cp uid , ▁void ▁* op aque ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁S 39 0_ CPU ( cs ); ▁return ▁s 390 x _ write _ all _ elf 64_ notes (" CORE ", ▁f , ▁cpu , ▁cp uid , ▁opaque ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁encode _ cl np ass ( J peg 2000 T 1 Context ▁* t 1, ▁int ▁width , ▁int ▁height , ▁int ▁band no , ▁int ▁* nm sed ec , ▁int ▁bp no ) ▁{ ▁int ▁y 0, ▁x , ▁y , ▁mask ▁= ▁1 ▁<< ▁( bp no ▁+ ▁NM SE DEC _ F RA CB ITS ); ▁for ▁( y 0 ▁= ▁0; ▁y 0 ▁< ▁height ; ▁y 0 ▁+= ▁4) ▁for ▁( x ▁= ▁0; ▁x ▁< ▁width ; ▁x ++){ ▁if ▁( y 0 ▁+ ▁3 ▁< ▁height ▁&& ▁! ( ▁( t 1 -> flags [ y 0 +1 ][ x +1] ▁& ▁( J PEG 2000 _ T 1_ SIG _ NB ▁| ▁JPEG 2000 _ T 1_ VI S ▁| ▁JPEG 2000 _ T 1_ SIG )) ▁|| ▁( t 1 -> flags [ y 0 +2 ][ x +1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁p pc _ hash 64_ pt e _ update _ flags ( struct ▁mm u _ ctx _ hash 64 ▁* ctx , ▁target _ ulong ▁* pt e 1 p , ▁int ▁ret , ▁int ▁rw ) ▁{ ▁int ▁store ▁= ▁0; ▁/* ▁Update ▁page ▁flags ▁*/ ▁if ▁(! (* pt e 1 p ▁& ▁H P TE 64_ R _ R )) ▁{ ▁/* ▁Update ▁accessed ▁flag ▁*/ ▁* pt e 1 p ▁|= ▁H P TE 64_ R _ R ; ▁store ▁= ▁1; ▁} ▁if ▁(! (* pt e 1 p ▁& ▁H P TE 64_ R _ C )) ▁{ ▁if ▁( rw ▁== ▁1 ▁&& ▁ret ▁== ▁0) ▁{ ▁/* ▁Update ▁changed ▁flag ▁*/ ▁* pt e 1 p ▁|= ▁H P TE 64_ R _ C ; ▁store ▁= ▁1; ▁} ▁else ▁{ ▁/* ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block A IO CB ▁* d ma _ b dr v _ write ( Block Driver State ▁* bs , ▁Q EM US G List ▁* sg , ▁uint 64_ t ▁sector , ▁void ▁(* cb )( void ▁* op aque , ▁int ▁ret ), ▁void ▁* op aque ) ▁{ ▁return ▁d ma _ b dr v _ io ( bs , ▁sg , ▁sector , ▁b dr v _ a io _ write v , ▁cb , ▁opaque , ▁D MA _ DI RECTION _ TO _ DEVICE ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁discard _ single _ l 2( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁unsigned ▁int ▁nb _ clusters , ▁enum ▁qc ow 2_ dis card _ type ▁type , ▁bool ▁full _ dis card ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁* l 2_ table ; ▁int ▁l 2_ index ; ▁int ▁ret ; ▁int ▁i ; ▁ret ▁= ▁get _ cluster _ table ( bs , ▁offset , ▁& l 2_ table , ▁& l 2_ index ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁/* ▁Limit ▁nb _ clusters ▁to ▁one ▁L 2 ▁table ▁*/ ▁nb _ clusters ▁= ▁MIN ( nb _ clust

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁qemu _ arch ip el ago _ get length ( Block Driver State ▁* bs ) ▁{ ▁int 64_ t ▁ret ; ▁B DR V Arch ip el ago State ▁* s ▁= ▁bs -> op aque ; ▁ret ▁= ▁arch ip el ago _ volume _ info ( s ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt as _ ibm _ set _ ee h _ option ( Power PC CPU ▁* cpu , ▁s P AP R Machine State ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁s P AP R PH B State ▁* s ph b ; ▁s P AP R PH B Class ▁* sp c ; ▁PC ID evice ▁* pd ev ; ▁uint 32_ t ▁addr , ▁option ; ▁uint 64_ t ▁b uid ; ▁int ▁ret ; ▁if ▁(( n args ▁!= ▁4) ▁|| ▁( n ret ▁!= ▁1)) ▁{ ▁goto ▁param _ error _ exit ; ▁} ▁b uid ▁= ▁rt as _ ld q ( args , ▁1); ▁addr ▁= ▁rt as

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ acl _ remove ( q emu _ acl ▁* acl , ▁const ▁char ▁* match ) ▁{ ▁qemu _ acl _ entry ▁* entry ; ▁int ▁i ▁= ▁0; ▁TA IL Q _ FORE A CH ( entry , ▁& acl -> entries , ▁next ) ▁{ ▁i ++; ▁if ▁( str cmp ( entry -> match , ▁match ) ▁== ▁0) ▁{ ▁TA IL Q _ REMOVE ( & acl -> entries , ▁entry , ▁next ); ▁return ▁i ; ▁} ▁} ▁return ▁-1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ac 97 _ init fn ▁( PC ID evice ▁* dev ) ▁{ ▁P CI AC 97 Link State ▁* d ▁= ▁DO _ UP CAST ▁( PC I AC 97 Link State , ▁dev , ▁dev ); ▁AC 97 Link State ▁* s ▁= ▁& d -> ac 97 ; ▁uint 8_ t ▁* c ▁= ▁d -> dev . config ; ▁s -> pc i _ dev ▁= ▁& d -> dev ; ▁pci _ config _ set _ vendor _ id ▁( c , ▁P CI _ VE ND OR _ ID _ INT EL ); ▁/* ▁ro ▁*/ ▁pci _ config _ set _ device _ id ▁( c , ▁P CI _ DEVICE _ ID _ INT EL _8 28 01 AA _5 ); ▁/* ▁ro ▁*/ ▁c [0 x 04 ] ▁= ▁0 x 00 ; ▁/* ▁pc ic md ▁pci ▁command ▁rw , ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cook _ parse ( AV Codec Parser Context ▁* s 1, ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁** p out buf , ▁int ▁* p out buf _ size , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁C ook Parse Context ▁* s ▁= ▁s 1 -> priv _ data ; ▁if ▁( s -> duration ) ▁s 1 -> duration ▁= ▁s -> duration ; ▁else ▁if ▁( av ctx -> ex tr ad ata ▁&& ▁av ctx -> ex tr ad ata _ size ▁>= ▁8 ▁&& ▁av ctx -> channels ) ▁s -> duration ▁= ▁AV _ RB 16 ( av ctx -> ex tr ad ata ▁+ ▁4) ▁/ ▁av ctx -> channels ; ▁/* ▁al

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁add _ codec ( FF Server Stream ▁* stream , ▁AV Codec Context ▁* av , ▁FF Server Config ▁* config ) ▁{ ▁AV Stream ▁* st ; ▁AV Dictionary ▁** opts , ▁* recomm ended ▁= ▁NULL ; ▁char ▁* enc _ config ; ▁if ( stream -> nb _ streams ▁>= ▁FF _ ARRAY _ E LE MS ( stream -> streams )) ▁return ; ▁opts ▁= ▁av -> codec _ type ▁== ▁AV MEDIA _ TYPE _ AU DIO ▁? ▁& config -> audio _ opts ▁: ▁& config -> video _ opts ; ▁av _ dict _ copy ( & recomm ended , ▁* opts , ▁0); ▁av _ opt _ set _ dict 2( av -> priv _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q mp _ output _ end _ struct ( Visitor ▁* v , ▁Error ▁** err p ) ▁{ ▁Q mp Output Visitor ▁* q ov ▁= ▁to _ q ov ( v ); ▁Q Object ▁* value ▁= ▁q mp _ output _ pop ( q ov ); ▁assert ( q object _ type ( value ) ▁== ▁Q TYPE _ Q DICT ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁compute _ images _ m se _16 bit ( PS N R Context ▁* s , ▁const ▁uint 8_ t ▁* main _ data [4 ], ▁const ▁int ▁main _ lines izes [4 ], ▁const ▁uint 8_ t ▁* ref _ data [4 ], ▁const ▁int ▁ref _ lines izes [4 ], ▁int ▁w , ▁int ▁h , ▁double ▁mse [4 ]) ▁{ ▁int ▁i , ▁c , ▁j ; ▁for ▁( c ▁= ▁0; ▁c ▁< ▁s -> nb _ components ; ▁c ++) ▁{ ▁const ▁int ▁out w ▁= ▁s -> plan ewidth [ c ]; ▁const ▁int ▁ outh ▁= ▁s -> plane height [ c ]; ▁const ▁uint 16_ t ▁* main _ line ▁= ▁( uint 16_ t ▁* ) main _ data [ c ]; ▁const ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁put sum ( uint 8_ t ▁* data , ▁uint 32_ t ▁n , ▁uint 32_ t ▁s loc , ▁uint 32_ t ▁css , ▁uint 32_ t ▁c se ) ▁{ ▁uint 32_ t ▁sum ; ▁if ▁( c se ▁&& ▁c se ▁< ▁n ) ▁n ▁= ▁c se ▁+ ▁1; ▁if ▁( s loc ▁< ▁n -1) ▁{ ▁sum ▁= ▁net _ checksum _ add ( n - css , ▁data + css ); ▁st w _ be _ p ( data ▁+ ▁s loc , ▁net _ checksum _ finish ( sum )); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁HEL PER ( cl cle )( CP US 390 X State ▁* env , ▁uint 32_ t ▁r 1, ▁uint 64_ t ▁a 2, ▁uint 32_ t ▁r 3) ▁{ ▁uint ptr _ t ▁ra ▁= ▁GET PC (); ▁uint 64_ t ▁dest len ▁= ▁get _ length ( env , ▁r 1 ▁+ ▁1); ▁uint 64_ t ▁dest ▁= ▁get _ address ( env , ▁r 1); ▁uint 64_ t ▁sr cl en ▁= ▁get _ length ( env , ▁r 3 ▁+ ▁1); ▁uint 64_ t ▁src ▁= ▁get _ address ( env , ▁r 3); ▁uint 8_ t ▁pad ▁= ▁a 2 ▁& ▁0 xff ; ▁uint 32_ t ▁cc ▁= ▁0; ▁if ▁(! ( dest len ▁|| ▁sr cl en )) ▁{ ▁return ▁cc ; ▁} ▁if ▁( sr cl en ▁> ▁dest

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* b ios _ link er _ loader _ cleanup ( G Array ▁* link er ) ▁{ ▁return ▁g _ array _ free ( link er , ▁false ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁const ▁p pc _ hash _ pt e 64_ t ▁* pp c _ hash 64_ map _ h pt es ( Power PC CPU ▁* cpu , ▁hw addr ▁pt ex , ▁int ▁n ) ▁{ ▁p pc _ hash _ pt e 64_ t ▁* h pt es ▁= ▁NULL ; ▁hw addr ▁p te _ offset ▁= ▁pt ex ▁* ▁HASH _ P TE _ SIZE _64 ; ▁if ▁( cpu -> env . external _ ht ab ▁== ▁MM U _ HASH 64_ K VM _ MAN AG ED _ H PT ) ▁{ ▁/* ▁* ▁HT AB ▁is ▁controlled ▁by ▁K VM . ▁Fetch ▁into ▁temporary ▁buffer ▁*/ ▁h pt es ▁= ▁g _ m alloc ( HASH _ P TE G _ SIZE _64 ); ▁k vm pp c _ read _ h pt es ( h pt es , ▁pt ex , ▁n ); ▁} 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁bool ▁reg ime _ translation _ disabled ( CPU ARM State ▁* env , ▁AR MM MU Idx ▁mm u _ idx ) ▁{ ▁if ▁( arm _ feature ( env , ▁ARM _ FEATURE _ M )) ▁{ ▁switch ▁( env -> v 7 m . mp u _ ctrl ▁& ▁( R _ V 7 M _ MP U _ CT RL _ ENABLE _ MASK ▁| ▁R _ V 7 M _ MP U _ CT RL _ H FN MI EN A _ MASK )) ▁{ ▁case ▁R _ V 7 M _ MP U _ CT RL _ ENABLE _ MASK : ▁/* ▁Enabled , ▁but ▁not ▁for ▁Hard Fault ▁and ▁N MI ▁*/ ▁return ▁mm u _ idx ▁== ▁AR MM MU Idx _ M Neg P ri ▁|| ▁mm u _ idx ▁== ▁AR MM MU Idx _ MS Neg P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁build _ processor _ devices ( A ml ▁* sb _ scope , ▁unsigned ▁ac pi _ cpus , ▁Ac pi Cpu Info ▁* cpu , ▁Ac pi Pm Info ▁* pm ) ▁{ ▁int ▁i ; ▁A ml ▁* dev ; ▁A ml ▁* cr s ; ▁A ml ▁* pkg ; ▁A ml ▁* field ; ▁A ml ▁* if ctx ; ▁A ml ▁* method ; ▁/* ▁The ▁current ▁A ML ▁generator ▁can ▁cover ▁the ▁API C ▁ID ▁range ▁[0 .. 255 ], ▁* ▁inclusive , ▁for ▁V CPU ▁hot plug . ▁*/ ▁Q EM U _ BUILD _ BUG _ ON ( AC PI _ CPU _ H OT PL UG _ ID _ LIMIT ▁> ▁256 ); ▁g _ assert ( ac pi _ cpus ▁<= ▁AC PI _ CPU _ H OT P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁e 1000 _ mm io _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁E 1000 State ▁* s ▁= ▁opaque ; ▁unsigned ▁int ▁index ▁= ▁( addr ▁& ▁0 x 1 ffff ) ▁>> ▁2; ▁if ▁( index ▁< ▁N READ OP S ▁&& ▁ma cre g _ read ops [ index ]) ▁{ ▁return ▁ma cre g _ read ops [ index ]( s , ▁index ); ▁} ▁DBG OUT ( UNKNOWN , ▁" MM IO ▁unknown ▁read ▁addr =0 x % 08 x \ n ", ▁index << 2); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cc id _ on _ ap du _ from _ guest ( US B CC ID State ▁* s , ▁CC ID _ X fer Block ▁* recv ) ▁{ ▁uint 32_ t ▁len ; ▁if ▁( cc id _ card _ status ( s ) ▁!= ▁I CC _ STATUS _ PRE SENT _ ACTIVE ) ▁{ ▁D PRI NT F ( s , ▁1, ▁" usb - cc id : ▁not ▁sending ▁a pd u ▁to ▁client , ▁no ▁card ▁connected \ n "); ▁cc id _ write _ data _ block _ error ( s , ▁recv -> hdr . b Slot , ▁recv -> hdr . b Seq ); ▁return ; ▁} ▁len ▁= ▁le 32_ to _ cpu ( recv -> hdr . dw Length ); ▁D PRI NT F ( s , ▁1, ▁"% s : ▁seq ▁% d 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ pred _ init _ x 86 ( H 264 Pred Context ▁* h , ▁int ▁codec _ id ) ▁{ ▁mm _ flags ▁= ▁mm _ support (); ▁# if ▁HAVE _ Y AS M ▁if ▁( mm _ flags ▁& ▁FF _ MM _ MM X ) ▁{ ▁h -> pred 16 x 16 [ VER T _ PRE D 8 x 8] ▁= ▁ff _ pred 16 x 16_ vertical _ mm x ; ▁h -> pred 16 x 16 [ H OR _ PRE D 8 x 8 ▁] ▁= ▁ff _ pred 16 x 16_ horizontal _ mm x ; ▁h -> pred 8 x 8 ▁[ VER T _ PRE D 8 x 8] ▁= ▁ff _ pred 8 x 8_ vertical _ mm x ; ▁h -> pred 8 x 8 ▁[ H OR _ PRE D 8 x 8 ▁] ▁= ▁ff _ pred 8 x 8_ horizontal _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁abi _ long ▁target _ to _ host _ times pec ( struct ▁times pec ▁* host _ ts , ▁abi _ ulong ▁target _ addr ) ▁{ ▁struct ▁target _ times pec ▁* target _ ts ; ▁if ▁(! lock _ user _ struct ( VER IFY _ READ , ▁target _ ts , ▁target _ addr , ▁1)) ▁return ▁- TARGET _ E FAULT ; ▁host _ ts -> tv _ sec ▁= ▁t swap al ( target _ ts -> tv _ sec ); ▁host _ ts -> tv _ n sec ▁= ▁t swap al ( target _ ts -> tv _ n sec ); ▁unlock _ user _ struct ( target _ ts , ▁target _ addr , ▁0); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁D MA _ init ( int ▁high _ page _ enable , ▁qemu _ irq ▁* cpu _ request _ exit ) ▁{ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ delta _ l ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* buf , ▁const ▁uint 8_ t ▁* buf _ end , ▁int ▁w , ▁int ▁flag , ▁int ▁b pp , ▁int ▁dst _ size ) ▁{ ▁Get Byte Context ▁off 0, ▁off 1, ▁d gb , ▁o gb ; ▁Put Byte Context ▁pb ; ▁unsigned ▁p off 0, ▁p off 1; ▁int ▁i , ▁k , ▁dst p itch ; ▁int ▁plan ep itch _ byte ▁= ▁( w ▁+ ▁7) ▁/ ▁8 ; ▁int ▁plan ep itch ▁= ▁(( w ▁+ ▁15 ) ▁/ ▁16 ) ▁* ▁2; ▁int ▁pitch ▁= ▁plan ep itch ▁* ▁b pp ; ▁if ▁( buf _ end ▁- ▁buf ▁<= ▁64 ) ▁return ; ▁by test ream 2_ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁intel _ h da _ mm io _ write b ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁Intel H DA State ▁* d ▁= ▁opaque ; ▁const ▁Intel HD AR eg ▁* reg ▁= ▁intel _ h da _ reg _ find ( d , ▁addr ); ▁intel _ h da _ reg _ write ( d , ▁reg , ▁val , ▁0 xff ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁serial _ real ize _ core ( Serial State ▁* s , ▁Error ▁** err p ) ▁{ ▁if ▁(! q emu _ chr _ fe _ backend _ connected ( & s -> chr )) ▁{ ▁error _ set g ( err p , ▁" Can ' t ▁create ▁serial ▁device , ▁empty ▁char ▁device "); ▁return ; ▁} ▁s -> mod em _ status _ poll ▁= ▁timer _ new _ ns ( Q EM U _ C LOCK _ VI RTUAL , ▁( Q EM UT imer CB ▁* ) ▁serial _ update _ ms l , ▁s ); ▁s -> f ifo _ timeout _ timer ▁= ▁timer _ new _ ns ( Q EM U _ C LOCK _ VI RTUAL , ▁( Q EM UT imer CB ▁* ) ▁fif o _ timeout _ int , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ ph ysical _ address ( CP UP PC State ▁* env , ▁mm u _ ctx _ t ▁* ctx , ▁target _ ulong ▁e addr , ▁int ▁rw , ▁int ▁access _ type ) ▁{ ▁int ▁ret ; ▁# if ▁0 ▁qemu _ log ("% s \ n ", ▁__ func __ ); ▁# end if ▁if ▁(( access _ type ▁== ▁ACCESS _ CODE ▁&& ▁ms r _ ir ▁== ▁0) ▁|| ▁( access _ type ▁!= ▁ACCESS _ CODE ▁&& ▁ms r _ dr ▁== ▁0 )) ▁{ ▁if ▁( env -> mm u _ model ▁== ▁PO WER PC _ MM U _ BOOK E ) ▁{ ▁/* ▁The ▁Book E ▁MM U ▁always ▁performs ▁address ▁translation . ▁The ▁IS ▁and ▁DS ▁bits ▁o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 8_ t ▁e ep rom 24 c 0 x _ read ( void ) ▁{ ▁logout ("% u : ▁scl ▁= ▁% u , ▁sda ▁= ▁% u , ▁data ▁= ▁0 x % 02 x \ n ", ▁e ep rom . tick , ▁e ep rom . s cl , ▁e ep rom . s da , ▁e ep rom . data ); ▁return ▁e ep rom . s da ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁block dev _ do _ action ( int ▁kind , ▁void ▁* data , ▁Error ▁** err p ) ▁{ ▁Transaction Action ▁action ; ▁Transaction Action List ▁list ; ▁action . kind ▁= ▁kind ; ▁action . data ▁= ▁data ; ▁list . value ▁= ▁& action ; ▁list . next ▁= ▁NULL ; ▁q mp _ transaction ( & list , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h 26 3_ h _ loop _ filter _ mm x ( uint 8_ t ▁* src , ▁int ▁stride , ▁int ▁q scale ) ▁{ ▁if ▁( CONFIG _ H 26 3_ DE CO DER ▁|| ▁CONFIG _ H 26 3_ EN CO DER ) ▁{ ▁const ▁int ▁strength ▁= ▁ff _ h 26 3_ loop _ filter _ strength [ q scale ]; ▁DEC LA RE _ ALI G NED ( 8, ▁uint 64_ t , ▁temp ) [4 ]; ▁uint 8_ t ▁* b temp ▁= ▁( uint 8_ t *) temp ; ▁src ▁-= ▁2; ▁transpose 4 x 4 ( b temp , ▁src , ▁8, ▁stride ); ▁transpose 4 x 4 ( b temp ▁+ ▁4, ▁src ▁+ ▁4 ▁* ▁stride , ▁8, ▁stride ); ▁__ asm __ ▁volatile 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁boot p _ reply ( struct ▁boot p _ t ▁* bp ) ▁{ ▁BO OT P Client ▁* bc ; ▁struct ▁m buf ▁* m ; ▁struct ▁boot p _ t ▁* rb p ; ▁struct ▁sock addr _ in ▁s addr , ▁d addr ; ▁struct ▁in _ addr ▁dns _ addr ; ▁int ▁dhcp _ msg _ type , ▁val ; ▁uint 8_ t ▁* q ; ▁/* ▁extract ▁exact ▁D HCP ▁msg ▁type ▁*/ ▁dhcp _ decode ( bp -> bp _ v end , ▁D HCP _ OPT _ LEN , ▁& dhcp _ msg _ type ); ▁d printf (" boot p ▁packet ▁op =% d ▁msg type =% d \ n ", ▁bp -> bp _ op , ▁dhcp _ msg _ type ); ▁if ▁( dhcp _ msg _ typ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁d rc _ isol ate _ ph ysical ( s P AP R DR Connector ▁* d rc ) ▁{ ▁switch ▁( d rc -> state ) ▁{ ▁case ▁SP AP R _ D RC _ STATE _ PH YSI CAL _ PO WER ON : ▁return ▁RT AS _ OUT _ SUCCESS ; ▁/* ▁Nothing ▁to ▁do ▁*/ ▁case ▁SP AP R _ D RC _ STATE _ PH YSI CAL _ CONFIG URE D : ▁break ; ▁/* ▁see ▁below ▁*/ ▁case ▁SP AP R _ D RC _ STATE _ PH YSI CAL _ UN IS OL ATE : ▁return ▁RT AS _ OUT _ PARAM _ ERROR ; ▁/* ▁not ▁allowed ▁*/ ▁default : ▁g _ assert _ not _ re ached (); ▁} ▁/* ▁if ▁the ▁guest ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁input _ linux _ event _ mouse ( void ▁* op aque ) ▁{ ▁Input Linux ▁* il ▁= ▁opaque ; ▁struct ▁input _ event ▁event ; ▁int ▁rc ; ▁for ▁( ; ;) ▁{ ▁rc ▁= ▁read ( il -> fd , ▁& event , ▁sizeof ( event )); ▁if ▁( rc ▁!= ▁sizeof ( event )) ▁{ ▁if ▁( rc ▁< ▁0 ▁&& ▁errno ▁!= ▁E AG AIN ) ▁{ ▁f printf ( stderr , ▁"% s : ▁read : ▁% s \ n ", ▁__ func __, ▁strerror ( err no )); ▁qemu _ set _ fd _ handler ( il -> fd , ▁NULL , ▁NULL , ▁NULL ); ▁close ( il -> fd ); ▁} ▁break ; ▁} ▁input _ linux _ handle _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁float 64_ eq ( ▁float 64 ▁a , ▁float 64 ▁b ▁STATUS _ PARAM ▁) ▁{ ▁if ▁( ▁( ▁( ▁extract Float 64 Exp ( ▁a ▁) ▁== ▁0 x 7 FF ▁) ▁&& ▁extract Float 64 F rac ( ▁a ▁) ▁) ▁|| ▁( ▁( ▁extract Float 64 Exp ( ▁b ▁) ▁== ▁0 x 7 FF ▁) ▁&& ▁extract Float 64 F rac ( ▁b ▁) ▁) ▁) ▁{ ▁if ▁( ▁float 64_ is _ signal ing _ nan ( ▁a ▁) ▁|| ▁float 64_ is _ signal ing _ nan ( ▁b ▁) ▁) ▁{ ▁float _ raise ( ▁float _ flag _ invalid ▁STATUS _ VAR ); ▁} ▁return ▁0; ▁} ▁return ▁( ▁a ▁== ▁b ▁) ▁|| ▁( ▁( bits 64) ▁( ▁( ▁a ▁| ▁b ▁) <<

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁always _ inline ▁void ▁gen _ cmp ( TC G Cond ▁cond , ▁int ▁ra , ▁int ▁rb , ▁int ▁rc , ▁int ▁is lit , ▁uint 8_ t ▁lit ) ▁{ ▁int ▁l 1, ▁l 2; ▁TC G v ▁tmp ; ▁if ▁( un likely ( rc ▁== ▁31 )) ▁return ; ▁l 1 ▁= ▁gen _ new _ label (); ▁l 2 ▁= ▁gen _ new _ label (); ▁if ▁( ra ▁!= ▁3 1) ▁{ ▁tmp ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ I 64 ); ▁tc g _ gen _ mov _ i 64 ( tmp , ▁cpu _ ir [ ra ]); ▁} ▁else ▁tmp ▁= ▁tc g _ const _ i 64 (0); ▁if ▁( is lit ) ▁tc g _ gen _ br con di _ i 64 ( cond , ▁tmp , ▁lit , ▁l 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ sc si _ device _ exit ( Device State ▁* q dev ) ▁{ ▁V irt IO SC SI ▁* s ▁= ▁VI RT IO _ SC SI ( q dev ); ▁V irt IO SC SI Common ▁* vs ▁= ▁VI RT IO _ SC SI _ COM MON ( q dev ); ▁unregister _ save vm ( q dev , ▁" virt io - sc si ", ▁s ); ▁return ▁virt io _ sc si _ common _ exit ( vs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pci _ v pb _ init ( Sys Bus Device ▁* dev ) ▁{ ▁P CI V PB State ▁* s ▁= ▁FROM _ SY SB US ( PC IV PB State , ▁dev ); ▁P CI Bus ▁* bus ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++) ▁{ ▁sys bus _ init _ irq ( dev , ▁& s -> irq [ i ]); ▁} ▁bus ▁= ▁pci _ register _ bus ( & dev -> q dev , ▁" pc i ", ▁pci _ v pb _ set _ irq , ▁pci _ v pb _ map _ irq , ▁s -> irq , ▁get _ system _ memory (), ▁get _ system _ io (), ▁P CI _ DEV FN (1 1, ▁0), ▁4 ); ▁/* ▁??? ▁Register ▁memory ▁space . ▁*/ ▁memory _ regio

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rng _ random _ set _ filename ( Object ▁* obj , ▁const ▁char ▁* filename , ▁Error ▁** err p ) ▁{ ▁R ng Backend ▁* b ▁= ▁R NG _ BACK END ( obj ); ▁R nd Random ▁* s ▁= ▁R NG _ R ANDOM ( obj ); ▁if ▁( b -> opened ) ▁{ ▁error _ set ( err p , ▁Q ERR _ PERMISSION _ DE NI ED ); ▁return ; ▁} ▁if ▁( s -> filename ) ▁{ ▁g _ free ( s -> filename ); ▁} ▁s -> filename ▁= ▁g _ str dup ( filename ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt as _ ibm _ get _ config _ addr _ info 2( Power PC CPU ▁* cpu , ▁s P AP R Machine State ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁s P AP R PH B State ▁* s ph b ; ▁PC ID evice ▁* pd ev ; ▁uint 32_ t ▁addr , ▁option ; ▁uint 64_ t ▁b uid ; ▁if ▁(( n args ▁!= ▁4) ▁|| ▁( n ret ▁!= ▁2 )) ▁{ ▁goto ▁param _ error _ exit ; ▁} ▁b uid ▁= ▁rt as _ ld q ( args , ▁1); ▁s ph b ▁= ▁sp ap r _ pc i _ find _ ph b ( sp ap 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁migrate _ fd _ completed ( Migration State ▁* s ) ▁{ ▁D PRI NT F (" setting ▁completed ▁state \ n "); ▁migrate _ fd _ cleanup ( s ); ▁if ▁( s -> state ▁== ▁M IG _ STATE _ ACTIVE ) ▁{ ▁s -> state ▁= ▁M IG _ STATE _ COMPLETE D ; ▁run state _ set ( RUN _ STATE _ POST M IG RATE ); ▁} ▁notifier _ list _ notify ( & migration _ state _ not ifiers , ▁s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁dec _ add s _ r ( Dis as Context ▁* dc ) ▁{ ▁TC G v ▁t 0; ▁int ▁size ▁= ▁mem size _ z ( dc ); ▁DIS ( f printf ▁( log file , ▁" add s . % c ▁$ r % u , ▁$ r % u \ n ", ▁mem size _ char ( size ), ▁dc -> op 1, ▁dc -> op 2 )); ▁cr is _ cc _ mask ( dc , ▁CC _ MASK _ N Z VC ); ▁t 0 ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ TL ); ▁/* ▁Size ▁can ▁only ▁be ▁q i ▁or ▁hi . ▁*/ ▁t _ gen _ se xt ( t 0, ▁cpu _ R [ dc -> op 1], ▁size ); ▁cr is _ al u ( dc , ▁CC _ OP _ ADD , ▁cpu _ R [ dc -> op 2], ▁cp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁create _ map ( vor b is _ context ▁* vc , ▁unsigned ▁floor _ number ) ▁{ ▁v orb is _ floor ▁* f lo ors ▁= ▁vc -> f lo ors ; ▁v orb is _ floor 0 ▁* vf ; ▁int ▁idx ; ▁int ▁block flag , ▁n ; ▁int 32_ t ▁* map ; ▁for ▁( block flag ▁= ▁0; ▁block flag ▁< ▁2; ▁++ block flag ) ▁{ ▁n ▁= ▁vc -> block size [ block flag ] ▁/ ▁2; ▁flo ors [ floor _ number ]. data . t 0. map [ block flag ] ▁= ▁av _ m alloc (( n ▁+ ▁1) ▁* ▁sizeof ( int 32_ t )); ▁// ▁n ▁+ ▁sentinel ▁map ▁= ▁flo ors [ floor _ number ]. dat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ sc si _ parse _ req ( V irt IO SC SI ▁* s , ▁V irt Queue ▁* v q , ▁V irt IO SC SI Req ▁* req ) ▁{ ▁assert ( req -> elem . out _ num ▁&& ▁req -> elem . in _ num ); ▁req -> v q ▁= ▁v q ; ▁req -> dev ▁= ▁s ; ▁req -> s req ▁= ▁NULL ; ▁req -> req . buf ▁= ▁req -> elem . out _ sg [0]. io v _ base ; ▁req -> resp . buf ▁= ▁req -> elem . in _ sg [0]. io v _ base ; ▁if ▁( req -> elem . out _ num ▁> ▁1) ▁{ ▁qemu _ sg l _ init _ external ( & req -> q sg l , ▁& req -> elem . out _ sg [1], ▁& r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb _ u as _ task ( U AS Device ▁* u as , ▁u as _ ui ▁* ui ) ▁{ ▁uint 16_ t ▁tag ▁= ▁be 16_ to _ cpu ( ui -> hdr . tag ); ▁uint 64_ t ▁lun 64 ▁= ▁be 64_ to _ cpu ( ui -> task . lun ); ▁S CS ID evice ▁* dev ▁= ▁usb _ u as _ get _ dev ( u as , ▁lun 64 ); ▁int ▁lun ▁= ▁usb _ u as _ get _ lun ( lun 64 ); ▁U AS Request ▁* req ; ▁uint 16_ t ▁task _ tag ; ▁req ▁= ▁usb _ u as _ find _ request ( u as , ▁be 16_ to _ cpu ( ui -> hdr . tag )); ▁if ▁( req ) ▁{ ▁goto ▁over la pped _ tag ; ▁} ▁switch ▁( u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ide _ q dev _ init ( Device State ▁* q dev , ▁Device Info ▁* base ) ▁{ ▁IDE Device ▁* dev ▁= ▁DO _ UP CAST ( IDE Device , ▁q dev , ▁q dev ); ▁IDE Device Info ▁* info ▁= ▁DO _ UP CAST ( IDE Device Info , ▁q dev , ▁base ); ▁IDE Bus ▁* bus ▁= ▁DO _ UP CAST ( IDE Bus , ▁q bus , ▁q dev -> parent _ bus ); ▁if ▁(! dev -> conf . d info ) ▁{ ▁f printf ( stderr , ▁"% s : ▁no ▁drive ▁specified \ n ", ▁q dev -> info -> name ); ▁goto ▁err ; ▁} ▁if ▁( dev -> unit ▁== ▁-1) ▁{ ▁dev -> unit ▁= ▁bus -> master

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁tc g _ match _ or i ( TC G Type ▁type , ▁tc g _ target _ long ▁val ) ▁{ ▁if ▁( fac ilities ▁& ▁F AC I LITY _ EXT _ IM M ) ▁{ ▁if ▁( type ▁== ▁TC G _ TYPE _ I 32) ▁{ ▁/* ▁All ▁32- bit ▁OR s ▁can ▁be ▁performed ▁with ▁1 ▁48 - bit ▁insn . ▁*/ ▁return ▁1; ▁} ▁} ▁/* ▁Look ▁for ▁negative ▁values . ▁These ▁are ▁best ▁to ▁load ▁with ▁L G HI . ▁*/ ▁if ▁( val ▁< ▁0) ▁{ ▁if ▁( val ▁== ▁( int 16_ t ) val ) ▁{ ▁return ▁0; ▁} ▁if ▁( fac ilities ▁& ▁F AC I LITY _ EXT _ IM M ) ▁{ ▁if ▁( val ▁== ▁( int 32_ t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁OP PRO TO ▁op _ add q _ ED I _ T 0( void ) ▁{ ▁E DI ▁= ▁( ED I ▁+ ▁T 0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁hyper call _ register _ types ( void ) ▁{ ▁/* ▁h call - p ft ▁*/ ▁sp ap r _ register _ hyper call ( H _ ENTER , ▁h _ enter ); ▁sp ap r _ register _ hyper call ( H _ REMOVE , ▁h _ remove ); ▁sp ap r _ register _ hyper call ( H _ PRO TE CT , ▁h _ prot ect ); ▁sp ap r _ register _ hyper call ( H _ READ , ▁h _ read ); ▁/* ▁h call - bulk ▁*/ ▁sp ap r _ register _ hyper call ( H _ B UL K _ REMOVE , ▁h _ bulk _ remove ); ▁/* ▁h call - d ab r ▁*/ ▁sp ap r _ register _ hyper call ( H _ SET _ D AB R 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ blk _ update _ config ( V irt IO Device ▁* v dev , ▁uint 8_ t ▁* config ) ▁{ ▁V irt IO Block ▁* s ▁= ▁VI RT IO _ BL K ( v dev ); ▁Block Conf ▁* conf ▁= ▁& s -> conf . conf ; ▁struct ▁virt io _ blk _ config ▁blk cfg ; ▁uint 64_ t ▁capacity ; ▁int ▁blk _ size ▁= ▁conf -> logical _ block _ size ; ▁b dr v _ get _ geometry ( s -> bs , ▁& capacity ); ▁mem set ( & blk cfg , ▁0, ▁sizeof ( blk cfg )); ▁virt io _ st q _ p ( v dev , ▁& blk cfg . capacity , ▁capacity ); ▁virt io _ stl _ p ( v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ op c ▁( CP UM IP S State ▁* env , ▁Dis as Context ▁* ctx ) ▁{ ▁int 32_ t ▁offset ; ▁int ▁rs , ▁rt , ▁rd , ▁sa ; ▁uint 32_ t ▁op , ▁op 1; ▁int 16_ t ▁imm ; ▁/* ▁make ▁sure ▁instructions ▁are ▁on ▁a ▁word ▁boundary ▁*/ ▁if ▁( ctx -> pc ▁& ▁0 x 3) ▁{ ▁env -> CP 0_ Bad V Addr ▁= ▁ctx -> pc ; ▁generate _ exception ( ctx , ▁EX CP _ Ad EL ); ▁return ; ▁} ▁/* ▁Handle ▁b likely ▁not ▁taken ▁case ▁*/ ▁if ▁(( ctx -> h flags ▁& ▁M IP S _ H FLAG _ B MASK _ BASE ) ▁== ▁M IP S _ H FLAG _ BL ) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁blk _ dev _ is _ tr ay _ open ( Block Backend ▁* blk ) ▁{ ▁if ▁( blk -> dev _ ops ▁&& ▁blk -> dev _ ops -> is _ tr ay _ open ) ▁{ ▁return ▁blk -> dev _ ops -> is _ tr ay _ open ( blk -> dev _ op aque ); ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁td sc _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁TD SC Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁const ▁AV Codec ▁* codec ; ▁int ▁ret ; ▁av ctx -> pix _ fmt ▁= ▁AV _ PI X _ F MT _ B GR 24 ; ▁/* ▁These ▁needs ▁to ▁be ▁set ▁to ▁estimate ▁buffer ▁and ▁frame ▁size ▁*/ ▁if ▁(! ( av ctx -> width ▁&& ▁av ctx -> height )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Video ▁size ▁not ▁set .\ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁/* ▁This ▁value ▁should ▁be ▁large ▁enough ▁fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁hv f _ vc pu _ exec ( CPU State ▁* cpu ) ▁{ ▁X 86 CPU ▁* x 86_ cpu ▁= ▁X 86_ CPU ( cpu ); ▁CPU X 86 State ▁* env ▁= ▁& x 86_ cpu -> env ; ▁int ▁ret ▁= ▁0; ▁uint 64_ t ▁ri p ▁= ▁0; ▁cpu -> hal ted ▁= ▁0; ▁if ▁( h vf _ process _ events ( cpu )) ▁{ ▁return ▁EX CP _ H LT ; ▁} ▁do ▁{ ▁if ▁( cpu -> vc pu _ dirty ) ▁{ ▁hv f _ put _ regist ers ( cpu ); ▁cpu -> vc pu _ dirty ▁= ▁false ; ▁} ▁if ▁( h vf _ inject _ interrupt s ( cpu )) ▁{ ▁return ▁EX CP _ INTER R UP T ; ▁} ▁vm x _ update _ tp r ( cpu ); ▁qemu _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁intel _ h 26 3_ decode _ picture _ header ( M peg Enc Context ▁* s ) ▁{ ▁int ▁format ; ▁/* ▁picture ▁header ▁*/ ▁if ▁( get _ bits _ long ( & s -> gb , ▁2 2) ▁!= ▁0 x 20) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" Bad ▁picture ▁start ▁code \ n "); ▁return ▁-1; ▁} ▁s -> picture _ number ▁= ▁get _ bits ( & s -> gb , ▁8 ); ▁/* ▁picture ▁timestamp ▁*/ ▁if ▁( get _ bits 1( & s -> gb ) ▁!= ▁1) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" Bad ▁marker \ n "); ▁return ▁-1; ▁/* ▁marker ▁*/ ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ p write ( Block Driver State ▁* bs , ▁int 64_ t ▁offset , ▁const ▁void ▁* buf 1, ▁int ▁count 1) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁if ▁(! dr v ) ▁return ▁- EN O MEDI UM ; ▁if ▁(! dr v -> b dr v _ p write ) ▁return ▁b dr v _ p write _ em ( bs , ▁offset , ▁buf 1, ▁count 1); ▁if ▁( b dr v _ wr _ bad req _ bytes ( bs , ▁offset , ▁count 1)) ▁return ▁- ED OM ; ▁return ▁drv -> b dr v _ p write ( bs , ▁offset , ▁buf 1, ▁count 1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ truncate ( Fs Context ▁* ctx , ▁V 9 fs Path ▁* fs _ path , ▁off _ t ▁size ) ▁{ ▁char ▁* buffer ; ▁int ▁ret ; ▁char ▁* path ▁= ▁fs _ path -> data ; ▁buffer ▁= ▁r path ( ctx , ▁path ); ▁ret ▁= ▁truncate ( buffer , ▁size ); ▁g _ free ( buffer ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁uuid _ un parse ( const ▁uuid _ t ▁u u , ▁char ▁* out ) ▁{ ▁sn printf ( out , ▁3 7, ▁UUID _ F MT , ▁u u [0], ▁u u [1], ▁u u [2], ▁u u [3 ], ▁u u [4 ], ▁u u [5 ], ▁u u [6 ], ▁u u [ 7 ], ▁u u [ 8 ], ▁u u [ 9 ], ▁u u [10 ], ▁u u [ 11 ], ▁u u [ 12 ], ▁u u [1 3], ▁u u [ 14 ], ▁u u [ 15 ]); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁st ell aris _ enet _ can _ receive ( void ▁* op aque ) ▁{ ▁st ell aris _ enet _ state ▁* s ▁= ▁( st ell aris _ enet _ state ▁* ) op aque ; ▁if ▁(( s -> r ctl ▁& ▁SE _ R CT L _ R X EN ) ▁== ▁0) ▁return ▁1; ▁return ▁( s -> np ▁< ▁31 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ac pi _ memory _ un plug _ cb ( Mem Hot plug State ▁* mem _ st , ▁Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁Mem Status ▁* md ev ; ▁m dev ▁= ▁ac pi _ memory _ slot _ status ( mem _ st , ▁dev , ▁err p ); ▁if ▁(! md ev ) ▁{ ▁return ; ▁} ▁/* ▁nv dim m ▁device ▁hot ▁un plug ▁is ▁not ▁supported ▁yet . ▁*/ ▁assert (! object _ dynamic _ cast ( OBJECT ( dev ), ▁TYPE _ NV DI MM )); ▁m dev -> is _ enabled ▁= ▁false ; ▁m dev -> dim m ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁alloc _ f ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁int 64_ t ▁offset ; ▁int ▁nb _ sect ors ; ▁char ▁s 1[ 64 ]; ▁int ▁num ; ▁int ▁ret ; ▁const ▁char ▁* ret str ; ▁offset ▁= ▁cv t num ( argv [1]); ▁if ▁( offset ▁& ▁0 x 1 ff ) ▁{ ▁printf (" offset ▁% l ld ▁is ▁not ▁sector ▁aligned \ n ", ▁( long ▁long ) offset ); ▁return ▁0; ▁} ▁if ▁( arg c ▁== ▁3) ▁nb _ sect ors ▁= ▁cv t num ( argv [2] ); ▁else ▁nb _ sect ors ▁= ▁1; ▁ret ▁= ▁b dr v _ is _ allocated ( bs , ▁offset ▁>> ▁9, ▁nb _ sect ors , ▁& num ); ▁cv t str ( o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁h mp _ cont _ cb ( void ▁* op aque , ▁int ▁err ) ▁{ ▁if ▁(! err ) ▁{ ▁q mp _ cont ( NULL ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁meg as as _ ctrl _ get _ info ( M eg as as State ▁* s , ▁M eg as as Cmd ▁* cmd ) ▁{ ▁PC ID evice ▁* pc i _ dev ▁= ▁P CI _ DEVICE ( s ); ▁PC ID evice Class ▁* pc i _ class ▁= ▁P CI _ DEVICE _ GET _ CLASS ( pc i _ dev ); ▁M eg as as Base Class ▁* base _ class ▁= ▁ME G AS AS _ DEVICE _ GET _ CLASS ( s ); ▁struct ▁mf i _ ctrl _ info ▁info ; ▁size _ t ▁d cmd _ size ▁= ▁sizeof ( info ); ▁Bus Child ▁* k id ; ▁int ▁num _ pd _ dis ks ▁= ▁0; ▁mem set ( & info , ▁0 x 0, ▁cmd -> io v _ size ); ▁if ▁( cm

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ thread _ video _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* frame , ▁int ▁* got _ packet _ ptr ){ ▁Thread Context ▁* c ▁= ▁av ctx -> internal -> frame _ thread _ encoder ; ▁Task ▁task ; ▁int ▁ret ; ▁av _ assert 1 (! * got _ packet _ ptr ); ▁if ( frame ){ ▁if (! ( av ctx -> flags ▁& ▁CODE C _ FLAG _ INPUT _ PRE SER VED )){ ▁AV Frame ▁* new ▁= ▁av codec _ alloc _ frame (); ▁if (! new ) ▁return ▁A VER ROR ( EN O ME M ); ▁p thread _ mut ex _ lock ( & c ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁vm state _ load _ state ( Q EM U File ▁* f , ▁const ▁VM State Description ▁* v ms d , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁VM State Field ▁* field ▁= ▁vms d -> fields ; ▁if ▁( version _ id ▁> ▁vms d -> version _ id ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁if ▁( version _ id ▁< ▁vms d -> minimum _ version _ id _ old ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁if ▁( version _ id ▁< ▁vms d -> minimum _ version _ id ) ▁{ ▁return ▁vms d -> load _ state _ old ( f , ▁opaque , ▁version _ id ); ▁} ▁while ( field -> name ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ set cond 2( TC G Context ▁* s , ▁TC G Cond ▁cond , ▁TC G Reg ▁ret , ▁TC G Reg ▁al , ▁TC G Reg ▁ah , ▁TC G Reg ▁bl , ▁TC G Reg ▁bh ) ▁{ ▁TC G Reg ▁tmp 0 ▁= ▁TC G _ T MP 0; ▁TC G Reg ▁tmp 1 ▁= ▁ret ; ▁assert ( ret ▁!= ▁TC G _ T MP 0); ▁if ▁( ret ▁== ▁ah ▁|| ▁ret ▁== ▁bh ) ▁{ ▁assert ( ret ▁!= ▁TC G _ T MP 1); ▁tmp 1 ▁= ▁TC G _ T MP 1; ▁} ▁switch ▁( cond ) ▁{ ▁case ▁TC G _ COND _ EQ : ▁case ▁TC G _ COND _ NE : ▁tmp 1 ▁= ▁tc g _ out _ reduce _ eq 2( s , ▁tmp 0, ▁tmp 1, ▁al , ▁ah , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁display _ mouse _ define ( Display ChangeListener ▁* d cl , ▁Q EM U Cursor ▁* c ) ▁{ ▁Simple Sp ice Display ▁* ss d ▁= ▁container _ of ( d cl , ▁Simple Sp ice Display , ▁d cl ); ▁qemu _ mut ex _ lock ( & ss d -> lock ); ▁if ▁( c ) ▁{ ▁cursor _ get ( c ); ▁} ▁cursor _ put ( ss d -> cursor ); ▁s sd -> cursor ▁= ▁c ; ▁s sd -> hot _ x ▁= ▁c -> hot _ x ; ▁s sd -> hot _ y ▁= ▁c -> hot _ y ; ▁g _ free ( ss d -> ptr _ move ); ▁s sd -> ptr _ move ▁= ▁NULL ; ▁g _ free ( ss d -> ptr _ define ); ▁s sd 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁st w _ ph ys _ internal ( hw addr ▁addr , ▁uint 32_ t ▁val , ▁enum ▁device _ endian ▁endian ) ▁{ ▁uint 8_ t ▁* ptr ; ▁Memory Region Section ▁* section ; ▁section ▁= ▁phys _ page _ find ( address _ space _ memory . dispatch , ▁addr ▁>> ▁TARGET _ PAGE _ BITS ); ▁if ▁(! memory _ region _ is _ ram ( section -> mr ) ▁|| ▁section -> readonly ) ▁{ ▁addr ▁= ▁memory _ region _ section _ addr ( section , ▁addr ); ▁if ▁( memory _ region _ is _ ram ( section -> mr )) ▁{ ▁section ▁= ▁& ph ys _ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ scale _ factors ( un signed ▁char ▁scale _ code [ SB LIMIT ], ▁unsigned ▁char ▁scale _ factors [ SB LIMIT ][ 3], ▁int ▁sb _ samples [3 ][ 12 ][ SB LIMIT ], ▁int ▁sb limit ) ▁{ ▁int ▁* p , ▁vmax , ▁v , ▁n , ▁i , ▁j , ▁k , ▁code ; ▁int ▁index , ▁d 1, ▁d 2; ▁unsigned ▁char ▁* sf ▁= ▁& scale _ factors [0] [0]; ▁for ( j =0; j < s bl imit ; j ++) ▁{ ▁for ( i =0; i < 3; i ++) ▁{ ▁/* ▁find ▁the ▁max ▁absolute ▁value ▁*/ ▁p ▁= ▁& sb _ samples [ i ][0] [ j ]; ▁vmax ▁= ▁abs (* p ); ▁for ( k 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁opt _ new _ stream ( const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁AV Format Context ▁* oc ; ▁if ▁( nb _ output _ files ▁<= ▁0) ▁{ ▁f printf ( stderr , ▁" At ▁least ▁one ▁output ▁file ▁must ▁be ▁specified \ n "); ▁ffmpeg _ exit (1); ▁} ▁oc ▁= ▁output _ files [ nb _ output _ files ▁- ▁1 ]; ▁if ▁(! str cmp ( opt , ▁" new video " ▁)) ▁new _ video _ stream ▁( oc ); ▁else ▁if ▁(! str cmp ( opt , ▁" new audio " ▁)) ▁new _ audio _ stream ▁( oc ); ▁else ▁if ▁(! str cmp ( opt , ▁" new sub title "))

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uy 2 to y v 12 )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* y dst , ▁uint 8_ t ▁* ud st , ▁uint 8_ t ▁* v dst , ▁unsigned ▁int ▁width , ▁unsigned ▁int ▁height , ▁int ▁l um Stride , ▁int ▁chrom Stride , ▁int ▁src Stride ) ▁{ ▁unsigned ▁y ; ▁const ▁unsigned ▁chrom Width = ▁width >> 1; ▁for ( y =0; ▁y < height ; ▁y += 2) ▁{ ▁# if def ▁HAVE _ MM X ▁asm ▁volatile ( ▁" xor ▁% %" REG _ a ", ▁% %" REG _ a " ▁\ n \ t " ▁" pc m pe q w ▁%% mm 7, ▁%% mm 7 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h uf _ un compress ( Get Byte Context ▁* gb , ▁uint 16_ t ▁* dst , ▁int ▁dst _ size ) ▁{ ▁int 32_ t ▁src _ size , ▁im , ▁i M ; ▁uint 32_ t ▁n Bits ; ▁uint 64_ t ▁* freq ; ▁H uf Dec ▁* h dec ; ▁int ▁ret , ▁i ; ▁src _ size ▁= ▁by test ream 2_ get _ le 32 ( gb ); ▁im ▁= ▁by test ream 2_ get _ le 32 ( gb ); ▁i M ▁= ▁by test ream 2_ get _ le 32 ( gb ); ▁by test ream 2_ skip ( gb , ▁4 ); ▁n Bits ▁= ▁by test ream 2_ get _ le 32 ( gb ); ▁if ▁( im ▁< ▁0 ▁|| ▁im ▁>= ▁H U F _ EN C SIZE ▁|| ▁i M ▁< ▁0 ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ev c _ frame _ start ( HE VC Context ▁* s ) ▁{ ▁HE VC Local Context ▁* lc ▁= ▁& s -> HE V Cl c ; ▁int ▁ret ; ▁mem set ( s -> horizontal _ bs , ▁0, ▁2 ▁* ▁s -> bs _ width ▁* ▁( s -> bs _ height ▁+ ▁1 )); ▁mem set ( s -> vertical _ bs , ▁0, ▁2 ▁* ▁s -> bs _ width ▁* ▁( s -> bs _ height ▁+ ▁1 )); ▁mem set ( s -> cb f _ l um a , ▁0, ▁s -> sp s -> min _ tb _ width ▁* ▁s -> sp s -> min _ tb _ height ); ▁mem set ( s -> is _ pc m , ▁0, ▁s -> sp s -> min _ pu _ width ▁* ▁s -> sp s -> min _ pu _ hei

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ open 2( Fs Context ▁* fs _ ctx , ▁V 9 fs Path ▁* dir _ path , ▁const ▁char ▁* name , ▁int ▁flags , ▁Fs Cred ▁* cre dp , ▁V 9 fs F id Open State ▁* fs ) ▁{ ▁char ▁* path ; ▁int ▁fd ▁= ▁-1; ▁int ▁err ▁= ▁-1; ▁int ▁ser r no ▁= ▁0; ▁V 9 fs String ▁fullname ; ▁char ▁* buffer ; ▁/* ▁* ▁Mark ▁all ▁the ▁open ▁to ▁not ▁follow ▁symlink s ▁*/ ▁flags ▁|= ▁O _ NO F OLLOW ; ▁v 9 fs _ string _ init ( & fullname ); ▁v 9 fs _ string _ sp rint f ( & fullname , ▁"% s /% s ", ▁dir _ path -> data , ▁name

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fix _ coding _ method _ array ▁( int ▁sb , ▁int ▁channels , ▁sb _ int 8_ array ▁coding _ method ) ▁{ ▁int ▁j , k ; ▁int ▁ch ; ▁int ▁run , ▁case _ val ; ▁int ▁switch table [ 23 ] ▁= ▁{ 0, 5, 1, 5, 5, 5, 5, 5, 2, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 4 }; ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁channels ; ▁ch ++) ▁{ ▁for ▁( j ▁= ▁0; ▁j ▁< ▁64 ; ▁) ▁{ ▁if (( coding _ method [ ch ][ sb ][ j ] ▁- ▁8) ▁> ▁2 2) ▁{ ▁run ▁= ▁1; ▁case _ val ▁= ▁8 ; ▁} ▁else ▁{ ▁switch ▁( switch table [ coding _ method [ ch ][ sb 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ m td cr x ( Dis as Context ▁* ctx ) ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ REG ); ▁# else ▁if ▁( un likely ( ctx -> pr )) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ REG ); ▁return ; ▁} ▁/* ▁N IP ▁cannot ▁be ▁restored ▁if ▁the ▁memory ▁exception ▁comes ▁from ▁an ▁helper ▁*/ ▁gen _ update _ n ip ( ctx , ▁ctx -> n ip ▁- ▁4 ); ▁gen _ helper _ store _ d cr ( cpu _ env , ▁cpu _ g pr [ r A ( ctx -> op c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁usb _ packet _ map ( US B Packet ▁* p , ▁Q EM US G List ▁* sg l ) ▁{ ▁int ▁is _ write ▁= ▁( p -> pid ▁== ▁USB _ TOKEN _ IN ); ▁target _ ph ys _ addr _ t ▁len ; ▁void ▁* mem ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s gl -> n sg ; ▁i ++) ▁{ ▁len ▁= ▁s gl -> sg [ i ]. len ; ▁mem ▁= ▁cpu _ ph ysical _ memory _ map ( sg l -> sg [ i ]. base , ▁& len , ▁is _ write ); ▁if ▁(! mem ) ▁{ ▁goto ▁err ; ▁} ▁qemu _ i ove c _ add ( & p -> io v , ▁mem , ▁len ); ▁if ▁( len ▁!= ▁s gl -> sg [ i ]. len ) ▁{ ▁goto ▁err ; ▁} ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁get _ sensor _ evt _ status ( IP MI B mc Sim ▁* ib s , ▁uint 8_ t ▁* cmd , ▁unsigned ▁int ▁cmd _ len , ▁uint 8_ t ▁* r sp , ▁unsigned ▁int ▁* r sp _ len , ▁unsigned ▁int ▁max _ r sp _ len ) ▁{ ▁IP M IS ensor ▁* s ens ; ▁IP MI _ CHECK _ CMD _ LEN (3); ▁if ▁(( cmd [2] ▁> ▁MAX _ SENS ORS ) ▁|| ▁! IP MI _ SENSOR _ GET _ PRE SENT ( ib s -> s ensors ▁+ ▁cmd [2] )) ▁{ ▁rsp [2] ▁= ▁IP MI _ CC _ REQ _ ENTRY _ NOT _ PRE SENT ; ▁return ; ▁} ▁sens ▁= ▁i bs -> s ensors ▁+ ▁cmd [2 ]; ▁IP MI _ ADD _ R SP 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ m jpeg _ encode _ mb ( M peg Enc Context ▁* s , ▁int 16_ t ▁block [ 12 ][ 64 ]) ▁{ ▁int ▁i ; ▁if ▁( s -> chrom a _ format ▁== ▁CH ROM A _ 44 4) ▁{ ▁encode _ block ( s , ▁block [0], ▁0); ▁encode _ block ( s , ▁block [2], ▁2); ▁encode _ block ( s , ▁block [4 ], ▁4 ); ▁encode _ block ( s , ▁block [ 8 ], ▁8 ); ▁encode _ block ( s , ▁block [5 ], ▁5 ); ▁encode _ block ( s , ▁block [ 9 ], ▁9 ); ▁if ▁( 16 * s -> mb _ x + 8 ▁< ▁s -> width ) ▁{ ▁encode _ block ( s , ▁block [1], ▁1); ▁encode _ block ( s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁p te _ update _ flags ( mm u _ ctx _ t ▁* ctx , ▁target _ ulong ▁* pt e 1 p , ▁int ▁ret , ▁int ▁rw ) ▁{ ▁int ▁store ▁= ▁0; ▁/* ▁Update ▁page ▁flags ▁*/ ▁if ▁(! (* pt e 1 p ▁& ▁0 x 000001 00 )) ▁{ ▁/* ▁Update ▁accessed ▁flag ▁*/ ▁* pt e 1 p ▁|= ▁0 x 000001 00 ; ▁store ▁= ▁1; ▁} ▁if ▁(! (* pt e 1 p ▁& ▁0 x 000000 80 )) ▁{ ▁if ▁( rw ▁== ▁1 ▁&& ▁ret ▁== ▁0) ▁{ ▁/* ▁Update ▁changed ▁flag ▁*/ ▁* pt e 1 p ▁|= ▁0 x 000000 80 ; ▁store ▁= ▁1; ▁} ▁else ▁{ ▁/* ▁Force ▁page ▁fault ▁for ▁first ▁write ▁access ▁*/ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁enable _ device ( Ac pi P ci H p State ▁* s , ▁unsigned ▁b sel , ▁int ▁slot ) ▁{ ▁s -> ac pi _ pc ih p _ pc i _ status [ b sel ]. device _ present ▁|= ▁(1 U ▁<< ▁slot ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ avg _ h 2 64_ qp el 16_ mc 12 _ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ mid h _ q rt _ and _ aver _ dst _16 w _ ms a ( src ▁- ▁(2 ▁* ▁stride ) ▁- ▁2, ▁stride , ▁dst , ▁stride , ▁16, ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ parse _ color ( uint 8_ t ▁* rgba _ color , ▁const ▁char ▁* color _ string , ▁int ▁sl en , ▁void ▁* log _ ctx ) ▁{ ▁char ▁* tail , ▁color _ string 2[ 128 ]; ▁const ▁Color Entry ▁* entry ; ▁int ▁len , ▁hex _ offset ▁= ▁0; ▁if ▁( color _ string [0] ▁== ▁'# ') ▁{ ▁hex _ offset ▁= ▁1; ▁} ▁else ▁if ▁(! str n cmp ( color _ string , ▁"0 x ", ▁2 )) ▁hex _ offset ▁= ▁2; ▁if ▁( sl en ▁< ▁0) ▁sl en ▁= ▁str len ( color _ string ); ▁av _ str lc py ( color _ string 2, ▁color _ string ▁+ ▁hex _ offset , ▁FF M

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁raw _ in activate ( Block Driver State ▁* bs ) ▁{ ▁int ▁ret ; ▁uint 64_ t ▁perm ▁= ▁0; ▁uint 64_ t ▁shared ▁= ▁BL K _ PER M _ ALL ; ▁ret ▁= ▁raw _ handle _ perm _ lock ( bs , ▁RAW _ PL _ PRE PA RE , ▁perm , ▁shared , ▁NULL ); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁raw _ handle _ perm _ lock ( bs , ▁RAW _ PL _ COMMIT , ▁perm , ▁shared , ▁NULL ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q mp _ output _ type _ any ( Visitor ▁* v , ▁const ▁char ▁* name , ▁Q Object ▁** obj , ▁Error ▁** err p ) ▁{ ▁Q mp Output Visitor ▁* q ov ▁= ▁to _ q ov ( v ); ▁q object _ in cre f (* obj ); ▁q mp _ output _ add _ obj ( q ov , ▁name , ▁* obj ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁setup _ sig context ( struct ▁target _ sig context ▁* sc , ▁CPU SH 4 State ▁* re gs , ▁unsigned ▁long ▁mask ) ▁{ ▁int ▁err ▁= ▁0; ▁int ▁i ; ▁# define ▁COPY ( x ) ▁__ put _ user ( re gs -> x , ▁& sc -> sc _ ## x ) ▁COPY ( gre gs [0]); ▁COPY ( gre gs [1]); ▁COPY ( gre gs [2] ); ▁COPY ( gre gs [3 ]); ▁COPY ( gre gs [4 ]); ▁COPY ( gre gs [5 ]); ▁COPY ( gre gs [6 ]); ▁COPY ( gre gs [ 7 ]); ▁COPY ( gre gs [ 8 ]); ▁COPY ( gre gs [ 9 ]); ▁COPY ( gre gs [10 ]); ▁COPY ( gre gs [ 11 ]); ▁COPY ( gre gs 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ un map _ bar ( V FI O Device ▁* v dev , ▁int ▁nr ) ▁{ ▁V FI OB AR ▁* bar ▁= ▁& v dev -> bars [ nr ]; ▁if ▁(! bar -> size ) ▁{ ▁return ; ▁} ▁vf io _ bar _ quir k _ teardown ( v dev , ▁nr ); ▁memory _ region _ del _ sub region ( & bar -> mem , ▁& bar -> m map _ mem ); ▁m un map ( bar -> m map , ▁memory _ region _ size ( & bar -> m map _ mem )); ▁if ▁( v dev -> ms ix ▁&& ▁v dev -> ms ix -> table _ bar ▁== ▁nr ) ▁{ ▁memory _ region _ del _ sub region ( & bar -> mem , ▁& v dev -> ms ix -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁e pt _ em ulation _ fault ( uint 64_ t ▁e pt _ qual ) ▁{ ▁int ▁read , ▁write ; ▁/* ▁E PT ▁fault ▁on ▁an ▁instruction ▁fetch ▁doesn ' t ▁make ▁sense ▁here ▁*/ ▁if ▁( e pt _ qual ▁& ▁E PT _ VI OL ATION _ INST _ FETCH ) ▁{ ▁return ▁false ; ▁} ▁/* ▁E PT ▁fault ▁must ▁be ▁a ▁read ▁fault ▁or ▁a ▁write ▁fault ▁*/ ▁read ▁= ▁e pt _ qual ▁& ▁E PT _ VI OL ATION _ DATA _ READ ▁? ▁1 ▁: ▁0; ▁write ▁= ▁e pt _ qual ▁& ▁E PT _ VI OL ATION _ DATA _ WRITE ▁? ▁1 ▁: ▁0; ▁if ▁(( read ▁| ▁write ) ▁== ▁0) ▁{ ▁retu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 rgba 64_ full _ X _ c _ template ( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* l um Filter , ▁const ▁int 32_ t ▁** l um Src , ▁int ▁l um Filter Size , ▁const ▁int 16_ t ▁* chr Filter , ▁const ▁int 32_ t ▁** chr US rc , ▁const ▁int 32_ t ▁** chr V Src , ▁int ▁chr Filter Size , ▁const ▁int 32_ t ▁** al p Src , ▁uint 16_ t ▁* dest , ▁int ▁dst W , ▁int ▁y , ▁enum ▁AV Pixel Format ▁target , ▁int ▁has Alpha , ▁int ▁eight bytes ) ▁{ ▁int ▁i ; ▁int ▁A ▁= ▁0 xffff << 14 ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁dst W ; ▁i ++

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ q emu _ ld ( TC G Context ▁* s , ▁const ▁TC G Arg ▁* args , ▁int ▁op c ) ▁{ ▁int ▁addr _ reg l , ▁addr _ reg 1, ▁addr _ mem l ; ▁int ▁data _ reg l , ▁data _ re gh , ▁data _ reg 1, ▁data _ reg 2; ▁int ▁mem _ index , ▁s _ bits ; ▁# if ▁defined ( CONFIG _ SO FT MM U ) ▁void ▁* label 1_ ptr , ▁* label 2_ ptr ; ▁int ▁sp _ args ; ▁# end if ▁# if ▁TARGET _ LONG _ BITS ▁== ▁64 ▁# ▁if ▁defined ( CONFIG _ SO FT MM U ) ▁uint 8_ t ▁* label 3_ ptr ; ▁# ▁endif ▁int ▁addr _ re gh , ▁addr _ re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dec _ calc ( Dis as Context ▁* dc , ▁uint 32_ t ▁insn ) ▁{ ▁uint 32_ t ▁op 0, ▁op 1, ▁op 2; ▁uint 32_ t ▁ra , ▁rb , ▁rd ; ▁op 0 ▁= ▁extract 32 ( ins n , ▁0, ▁4 ); ▁op 1 ▁= ▁extract 32 ( ins n , ▁8, ▁2); ▁op 2 ▁= ▁extract 32 ( ins n , ▁6, ▁2); ▁ra ▁= ▁extract 32 ( ins n , ▁16, ▁5 ); ▁rb ▁= ▁extract 32 ( ins n , ▁11, ▁5 ); ▁rd ▁= ▁extract 32 ( ins n , ▁21, ▁5 ); ▁switch ▁( op 0) ▁{ ▁case ▁0 x 0000 : ▁switch ▁( op 1) ▁{ ▁case ▁0 x 00 : ▁/* ▁l . add ▁*/ ▁LOG _ DIS (" l . add ▁r % d , ▁r % d , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ calculate _ timeout ( void ) ▁{ ▁# if nd ef ▁CONFIG _ I OTH READ ▁int ▁timeout ; ▁if ▁(! vm _ running ) ▁timeout ▁= ▁5000 ; ▁else ▁{ ▁/* ▁XXX : ▁use ▁timeout ▁computed ▁from ▁timers ▁*/ ▁int 64_ t ▁add ; ▁int 64_ t ▁delta ; ▁/* ▁Advance ▁virtual ▁time ▁to ▁the ▁next ▁event . ▁*/ ▁delta ▁= ▁qemu _ ic ount _ delta (); ▁if ▁( delta ▁> ▁0) ▁{ ▁/* ▁If ▁virtual ▁time ▁is ▁ahead ▁of ▁real ▁time ▁then ▁just ▁wait ▁for ▁IO . ▁*/ ▁timeout ▁= ▁( delta ▁+ ▁9 9999 9) ▁/ ▁1000000 ; ▁} ▁else ▁{ ▁/* ▁Wait ▁f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ abort ( URL Context ▁* h ) ▁{ ▁static ▁const ▁char ▁* command ▁= ▁" AB OR \ r \ n "; ▁int ▁err ; ▁static ▁const ▁int ▁ab or _ codes [] ▁= ▁{2 25, ▁2 26, ▁0 }; ▁FTP Context ▁* s ▁= ▁h -> priv _ data ; ▁/* ▁According ▁to ▁R CF ▁9 59 : ▁" AB OR ▁command ▁tells ▁the ▁server ▁to ▁abort ▁the ▁previous ▁FTP ▁service ▁command ▁and ▁any ▁associated ▁transfer ▁of ▁data ." ▁There ▁are ▁FTP ▁server ▁implementations ▁that ▁don ' t ▁response ▁to ▁any ▁commands ▁during ▁data ▁transfer ▁in ▁passive ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rt mp _ packet _ read _ one _ chunk ( URL Context ▁* h , ▁RT MP Packet ▁* p , ▁int ▁chunk _ size , ▁RT MP Packet ▁** prev _ pk t _ ptr , ▁int ▁* nb _ prev _ pk t , ▁uint 8_ t ▁hdr ) ▁{ ▁uint 8_ t ▁buf [ 16 ]; ▁int ▁channel _ id , ▁timestamp , ▁size ; ▁uint 32_ t ▁ts _ field ; ▁// ▁non - extended ▁timestamp ▁or ▁delta ▁field ▁uint 32_ t ▁extra ▁= ▁0; ▁enum ▁RT MP Packet Type ▁type ; ▁int ▁written ▁= ▁0; ▁int ▁ret , ▁to read ; ▁RT MP Packet ▁* prev _ pk t ; ▁written ++; ▁channel _ id ▁= ▁hdr ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁e ep rom 93 xx _ write ( eep rom _ t ▁* eep rom , ▁int ▁e ec s , ▁int ▁e es k , ▁int ▁e edi ) ▁{ ▁uint 8_ t ▁tick ▁= ▁e ep rom -> tick ; ▁uint 8_ t ▁e ed o ▁= ▁e ep rom -> eed o ; ▁uint 16_ t ▁address ▁= ▁e ep rom -> address ; ▁uint 8_ t ▁command ▁= ▁e ep rom -> command ; ▁logout (" CS =% u ▁SK =% u ▁DI =% u ▁DO =% u , ▁tick ▁= ▁% u \ n ", ▁e ec s , ▁e es k , ▁e edi , ▁e ed o , ▁tick ); ▁if ▁(! ▁e ep rom -> e ec s ▁&& ▁e ec s ) ▁{ ▁/* ▁Start ▁chip ▁select ▁cycle . ▁*/ ▁logout (" Cycle ▁start , ▁wai

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* i oth read _ run ( void ▁* op aque ) ▁{ ▁IO Thread ▁* i oth read ▁= ▁opaque ; ▁qemu _ mut ex _ lock ( & i oth read -> init _ done _ lock ); ▁i oth read -> thread _ id ▁= ▁qemu _ get _ thread _ id (); ▁qemu _ cond _ signal ( & i oth read -> init _ done _ cond ); ▁qemu _ mut ex _ un lock ( & i oth read -> init _ done _ lock ); ▁while ▁(! i oth read -> st opping ) ▁{ ▁aio _ context _ acquire ( i oth read -> ctx ); ▁while ▁(! i oth read -> st opping ▁&& ▁aio _ poll ( i oth read -> ctx , ▁true

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁encode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁av _ frame _ free ( & av ctx -> coded _ frame ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ dim m _ get _ size ( Object ▁* obj , ▁Visitor ▁* v , ▁const ▁char ▁* name , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁int 64_ t ▁value ; ▁Memory Region ▁* mr ; ▁PC DI MM Device ▁* dim m ▁= ▁PC _ DI MM ( obj ); ▁mr ▁= ▁host _ memory _ backend _ get _ memory ( dim m -> host mem , ▁err p ); ▁value ▁= ▁memory _ region _ size ( mr ); ▁visit _ type _ int ( v , ▁name , ▁& value , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁pf lash _ t ▁* pf lash _ cf i 0 2_ register ( target _ ph ys _ addr _ t ▁base , ▁ram _ addr _ t ▁off , ▁Block Driver State ▁* bs , ▁uint 32_ t ▁sector _ len , ▁int ▁nb _ b locs , ▁int ▁nb _ mappings , ▁int ▁width , ▁uint 16_ t ▁id 0, ▁uint 16_ t ▁id 1, ▁uint 16_ t ▁id 2, ▁uint 16_ t ▁id 3, ▁uint 16_ t ▁unlock _ addr 0, ▁uint 16_ t ▁unlock _ addr 1) ▁{ ▁pf lash _ t ▁* p fl ; ▁int 32_ t ▁chip _ len ; ▁chip _ len ▁= ▁sector _ len ▁* ▁nb _ b locs ; ▁/* ▁XXX : ▁to ▁be ▁fixed ▁*/ ▁# if ▁0 ▁if ▁( total _ len ▁!

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 9 fs _ do _ ch mod ( V 9 fs State ▁* s , ▁V 9 fs String ▁* path , ▁mode _ t ▁mode ) ▁{ ▁return ▁s -> ops -> ch mod ( & s -> ctx , ▁path -> data , ▁mode ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ ph ysical ▁( CPU State ▁* env , ▁mm u _ ctx _ t ▁* ctx , ▁target _ ulong ▁e addr , ▁int ▁rw ) ▁{ ▁int ▁in _ pl b , ▁ret ; ▁ctx -> r addr ▁= ▁e addr ; ▁ctx -> prot ▁= ▁PAGE _ READ ; ▁ret ▁= ▁0; ▁switch ▁( env -> mm u _ model ) ▁{ ▁case ▁PO WER PC _ MM U _32 B : ▁case ▁PO WER PC _ MM U _ SO FT _6 xx : ▁case ▁PO WER PC _ MM U _ SO FT _ 74 xx : ▁case ▁PO WER PC _ MM U _6 01 : ▁case ▁PO WER PC _ MM U _ SO FT _4 xx : ▁case ▁PO WER PC _ MM U _ RE AL _4 xx : ▁case ▁PO WER PC _ MM U _ BOOK E 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ x vm c _ field _ end ( M peg Enc Context ▁* s ) ▁{ ▁struct ▁x vm c _ pix _ fmt ▁* render ▁= ▁( struct ▁x vm c _ pix _ fmt *) s -> current _ picture . f . data [2 ]; ▁assert ( render ); ▁if ▁( render -> filled _ mv _ blocks _ num ▁> ▁0) ▁ff _ mpeg _ draw _ h oriz _ band ( s , ▁0, ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁set _ system _ memory _ map ( Memory Region ▁* mr ) ▁{ ▁memory _ region _ transaction _ begin (); ▁address _ space _ memory . root ▁= ▁mr ; ▁memory _ region _ transaction _ commit (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁pp _ mode ▁* pp _ get _ mode _ by _ name _ and _ quality ( const ▁char ▁* name , ▁int ▁quality ) ▁{ ▁char ▁temp [ GET _ MODE _ BUFFER _ SIZE ]; ▁char ▁* p = ▁temp ; ▁static ▁const ▁char ▁filter Del imiters [] ▁= ▁", / "; ▁static ▁const ▁char ▁option Del imiters [] ▁= ▁": "; ▁struct ▁P P Mode ▁* pp Mode ; ▁char ▁* filter Token ; ▁pp Mode = ▁av _ m alloc ( size of ( PP Mode )); ▁pp Mode -> l um Mode = ▁0; ▁pp Mode -> chrom Mode = ▁0; ▁pp Mode -> max Tmp Noise [0] = ▁700 ; ▁pp Mode -> max Tmp Noise [1] = ▁1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qc ow 2_ write _ l 1_ entry ( Block Driver State ▁* bs , ▁int ▁l 1_ index ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁buf [ L 1_ ENT RIES _ PER _ SE CTOR ]; ▁int ▁l 1_ start _ index ; ▁int ▁i , ▁ret ; ▁l 1_ start _ index ▁= ▁l 1_ index ▁& ▁~ ( L 1_ ENT RIES _ PER _ SE CTOR ▁- ▁1); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁L 1_ ENT RIES _ PER _ SE CTOR ; ▁i ++) ▁{ ▁buf [ i ] ▁= ▁cpu _ to _ be 64 ( s -> l 1_ table [ l 1_ start _ index ▁+ ▁i ]); ▁} ▁ret ▁= ▁qc ow 2_ pre _ write _ overlap _ check ( bs

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁zero _ b ss ( abi _ ulong ▁el f _ b ss , ▁abi _ ulong ▁last _ b ss , ▁int ▁prot ) ▁{ ▁uint ptr _ t ▁host _ start , ▁host _ map _ start , ▁host _ end ; ▁last _ b ss ▁= ▁TARGET _ PAGE _ ALIGN ( last _ b ss ); ▁/* ▁??? ▁There ▁is ▁confusion ▁between ▁qemu _ real _ host _ page _ size ▁and ▁qemu _ host _ page _ size ▁here ▁and ▁elsewhere ▁in ▁target _ m map , ▁which ▁may ▁lead ▁to ▁the ▁end ▁of ▁the ▁data ▁section ▁mapping ▁from ▁the ▁file ▁not ▁being ▁mapped . ▁At ▁least ▁there ▁was ▁an ▁explic

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ bi w gt _4 x 4 multiple _ ms a ( uint 8_ t ▁* src , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride , ▁int 32_ t ▁height , ▁int 32_ t ▁log 2_ denom , ▁int 32_ t ▁src _ weight , ▁int 32_ t ▁dst _ weight , ▁int 32_ t ▁offset _ in ) ▁{ ▁uint 8_ t ▁cnt ; ▁uint 32_ t ▁load 0, ▁load 1, ▁load 2, ▁load 3; ▁v 16 i 8 ▁src _ w gt , ▁dst _ w gt , ▁w gt ; ▁v 16 i 8 ▁src 0, ▁src 1, ▁src 2, ▁src 3; ▁v 16 i 8 ▁dst 0, ▁dst 1, ▁dst 2, ▁dst 3; ▁v 8 i 16 ▁temp 0, ▁temp 1, ▁temp 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁tc g _ out _ ld ( TC G Context ▁* s , ▁TC G Type ▁type , ▁TC G Reg ▁ret , ▁TC G Reg ▁arg 1, ▁int ptr _ t ▁arg 2) ▁{ ▁int ▁op i , ▁op x ; ▁assert ( TC G _ TARGET _ REG _ BITS ▁== ▁64 ▁|| ▁type ▁== ▁TC G _ TYPE _ I 32 ); ▁if ▁( type ▁== ▁TC G _ TYPE _ I 32) ▁{ ▁op i ▁= ▁LW Z , ▁op x ▁= ▁LW ZX ; ▁} ▁else ▁{ ▁op i ▁= ▁LD , ▁op x ▁= ▁LD X ; ▁} ▁tc g _ out _ mem _ long ( s , ▁op i , ▁op x , ▁ret , ▁arg 1, ▁arg 2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ del vm ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁Block Driver State ▁* bs , ▁* bs 1; ▁Error ▁* err ▁= ▁NULL ; ▁const ▁char ▁* name ▁= ▁q dict _ get _ str ( q dict , ▁" name "); ▁bs ▁= ▁find _ vm state _ bs (); ▁if ▁(! bs ) ▁{ ▁monitor _ printf ( mon , ▁" No ▁block ▁device ▁supports ▁snapshots \ n "); ▁return ; ▁} ▁bs 1 ▁= ▁NULL ; ▁while ▁(( bs 1 ▁= ▁b dr v _ next ( bs 1 ))) ▁{ ▁if ▁( b dr v _ can _ snapshot ( bs 1)) ▁{ ▁b dr v _ snapshot _ delete _ by _ id _ or _ name ( bs , ▁name , ▁&

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁object _ property _ add ( Object ▁* obj , ▁const ▁char ▁* name , ▁const ▁char ▁* type , ▁Object Property Accessor ▁* get , ▁Object Property Accessor ▁* set , ▁Object Property Release ▁* release , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁Object Property ▁* prop ; ▁Q TAIL Q _ FORE A CH ( prop , ▁& obj -> properties , ▁node ) ▁{ ▁if ▁( str cmp ( prop -> name , ▁name ) ▁== ▁0) ▁{ ▁error _ set g ( err p , ▁" attempt ▁to ▁add ▁duplicate ▁property ▁'% s '" ▁" ▁to ▁object ▁( type ▁'% s ') ", ▁name , ▁obje

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁col lie _ init ( Machine State ▁* machine ) ▁{ ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁machine -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁Str ong ARM State ▁* s ; ▁Drive Info ▁* d info ; ▁Memory Region ▁* sys mem ▁= ▁get _ system _ memory (); ▁if ▁(! cpu _ model ) ▁{ ▁cpu _ model ▁= ▁" sa 11 10 "; ▁} ▁s ▁= ▁sa 11 10_ in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁avg _ pixels 16_ alt ive c ( uint 8_ t ▁* block , ▁const ▁uint 8_ t ▁* pixels , ▁int ▁line _ size , ▁int ▁h ) ▁{ ▁PO WER PC _ T BL _ DEC LA RE ( alt ive c _ avg _ pixels 16_ num , ▁1); ▁# if def ▁AL T IVE C _ USE _ REFERENCE _ C _ CODE ▁int ▁i ; ▁PO WER PC _ T BL _ START _ COUNT ( alt ive c _ avg _ pixels 16_ num , ▁1); ▁for ( i =0; ▁i < h ; ▁i ++) ▁{ ▁op _ avg (* (( uint 32_ t * )( block )), (( ( const ▁struct ▁un aligned _32 ▁* )( pixels )) -> l )); ▁op _ avg (* (( uint 32_ t * )( block + 4) ), (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁blk _ send _ response _ all ( struct ▁X en Bl k Dev ▁* blk dev ) ▁{ ▁struct ▁i ore q ▁* i ore q ; ▁int ▁send _ notify ▁= ▁0; ▁while ▁(! LIST _ EMPTY ( & blk dev -> finished )) ▁{ ▁i ore q ▁= ▁LIST _ FIRST ( & blk dev -> finished ); ▁send _ notify ▁+= ▁blk _ send _ response _ one ( i ore q ); ▁i ore q _ release ( i ore q ); ▁} ▁if ▁( send _ notify ) ▁xen _ be _ send _ notify ( & blk dev -> x end ev ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁interface _ client _ monitor s _ config ( Q X LIn stance ▁* sin , ▁V DA gent Monitor s Config ▁* monitor s _ config ) ▁{ ▁P CI Q X L Device ▁* q xl ▁= ▁container _ of ( sin , ▁P CI Q X L Device , ▁s sd . q xl ); ▁Q X LR om ▁* rom ▁= ▁memory _ region _ get _ ram _ ptr ( & q xl -> rom _ bar ); ▁int ▁i ; ▁unsigned ▁max _ outputs ▁= ▁ARRAY _ SIZE ( rom -> client _ monitor s _ config . head s ); ▁if ▁( q xl -> revision ▁< ▁4) ▁{ ▁trace _ q xl _ client _ monitor s _ config _ unsupported _ by _ dev

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ pc i _ real ize ( PC ID evice ▁* pc i _ dev , ▁Error ▁** err p ) ▁{ ▁V irt IO PC I Proxy ▁* proxy ▁= ▁VI RT IO _ PC I ( pc i _ dev ); ▁V irt io PC I Class ▁* k ▁= ▁VI RT IO _ PC I _ GET _ CLASS ( pc i _ dev ); ▁/* ▁* ▁virt io ▁pci ▁bar ▁layout ▁used ▁by ▁default . ▁* ▁subclasses ▁can ▁re - arrange ▁things ▁if ▁needed . ▁* ▁* ▁region ▁0 ▁-- ▁virt io ▁legacy ▁io ▁bar ▁* ▁region ▁1 ▁-- ▁m si - x ▁bar ▁* ▁region ▁4 + 5 ▁-- ▁virt io ▁modern ▁memory ▁( 64 bit ) ▁bar ▁* ▁*/ ▁proxy -> leg

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cd xl _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* pk t ) ▁{ ▁CD X L Video Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* ▁const ▁p ▁= ▁& c -> frame ; ▁int ▁ret , ▁w , ▁h , ▁encoding , ▁format , ▁buf _ size ▁= ▁pkt -> size ; ▁const ▁uint 8_ t ▁* buf ▁= ▁pkt -> data ; ▁if ▁( buf _ size ▁< ▁3 2) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁encoding ▁= ▁buf [1] ▁& ▁7 ; ▁format ▁= ▁buf [1] ▁& ▁0 xE 0; ▁w ▁= ▁AV _ RB 16 ( & buf [ 14 ]); ▁h 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _0 ( PA F Video Dec Context ▁* c , ▁uint 8_ t ▁* pk t , ▁uint 8_ t ▁code ) ▁{ ▁uint 32_ t ▁opcode _ size , ▁offset ; ▁uint 8_ t ▁* dst , ▁* d end , ▁mask ▁= ▁0, ▁color ▁= ▁0; ▁const ▁uint 8_ t ▁* src , ▁* send , ▁* op codes ; ▁int ▁i , ▁j , ▁op ▁= ▁0; ▁i ▁= ▁by test ream 2_ get _ byte ( & c -> gb ); ▁if ▁( i ) ▁{ ▁if ▁( code ▁& ▁0 x 10) ▁{ ▁int ▁align ; ▁align ▁= ▁by test ream 2_ t ell ( & c -> gb ) ▁& ▁3; ▁if ▁( align ) ▁by test ream 2_ skip ( & c -> gb , ▁4 ▁- ▁align ); ▁} ▁do ▁{ ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁save _ native _ fp _ fs ave ( CPU State ▁* env ) ▁{ ▁int ▁f pt ag , ▁i , ▁j ; ▁uint 16_ t ▁f pu c ; ▁struct ▁fp state ▁fp 1, ▁* fp ▁= ▁& fp 1; ▁asm ▁volatile ▁(" fs ave ▁% 0" ▁: ▁: ▁" m " ▁(* fp )); ▁env -> f pu c ▁= ▁fp -> f pu c ; ▁env -> fp st t ▁= ▁( fp -> fp us ▁>> ▁11 ) ▁& ▁7 ; ▁env -> fp us ▁= ▁fp -> fp us ▁& ▁~ 0 x 38 00 ; ▁f pt ag ▁= ▁fp -> f pt ag ; ▁for ( i ▁= ▁0; i ▁< ▁8 ; ▁i ++) ▁{ ▁env -> f pt ags [ i ] ▁= ▁(( f pt ag ▁& ▁3) ▁== ▁3 ); ▁f pt ag ▁>>= ▁2; ▁} ▁j ▁= ▁env -> fp st t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ thread ( void ▁* arg ) ▁{ ▁Video State ▁* is ▁= ▁arg ; ▁AV Format Context ▁* ic ; ▁int ▁err , ▁i , ▁ret , ▁video _ index , ▁audio _ index , ▁subtitle _ index ; ▁AV Packet ▁pkt 1, ▁* pk t ▁= ▁& pk t 1; ▁AV Format Parameters ▁params , ▁* ap ▁= ▁& params ; ▁video _ index ▁= ▁-1; ▁audio _ index ▁= ▁-1; ▁subtitle _ index ▁= ▁-1; ▁is -> video _ stream ▁= ▁-1; ▁is -> audio _ stream ▁= ▁-1; ▁is -> sub title _ stream ▁= ▁-1; ▁global _ video _ state ▁= ▁is ; ▁url _ set _ interrupt _ cb ( deco

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ad pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁AD PC M Decode Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁AD PC M Channel Status ▁* cs ; ▁int ▁n , ▁m , ▁channel , ▁i ; ▁short ▁* samples ; ▁const ▁uint 8_ t ▁* src ; ▁int ▁st ; ▁/* ▁st ere o ▁*/ ▁int ▁count 1, ▁count 2; ▁int ▁nb _ samples , ▁coded _ samples , ▁ret ; ▁nb _ samples ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ i ore q _ p io ( i ore q _ t ▁* req ) ▁{ ▁int ▁i , ▁sign ; ▁sign ▁= ▁req -> df ▁? ▁-1 ▁: ▁1; ▁if ▁( req -> dir ▁== ▁IO REQ _ READ ) ▁{ ▁if ▁(! req -> data _ is _ ptr ) ▁{ ▁req -> data ▁= ▁do _ inp ( req -> addr , ▁req -> size ); ▁} ▁else ▁{ ▁uint 32_ t ▁tmp ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁req -> count ; ▁i ++) ▁{ ▁tmp ▁= ▁do _ inp ( req -> addr , ▁req -> size ); ▁cpu _ ph ysical _ memory _ write ( ▁req -> data ▁+ ▁( sign ▁* ▁i ▁* ▁( int 64_ t ) req -> size ), ▁( uint 8_ t ▁* ) ▁& tmp , ▁req

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* choose _ pixel _ fmt s ( OutputStream ▁* ost ) ▁{ ▁if ▁( ost -> keep _ pix _ fmt ) ▁{ ▁if ▁( ost -> filter ) ▁av filter _ graph _ set _ auto _ convert ( ost -> filter -> graph -> graph , ▁AV FILTER _ AUTO _ CON VER T _ NONE ); ▁if ▁( ost -> st -> codec -> pix _ fmt ▁== ▁PI X _ F MT _ NONE ) ▁return ▁NULL ; ▁o st -> pix _ fmt s [0] ▁= ▁o st -> st -> codec -> pix _ fmt ; ▁return ▁o st -> pix _ fmt s ; ▁} ▁if ▁( ost -> st -> codec -> pix _ fmt ▁!= ▁PI X _ F MT _ NONE ) ▁{ ▁return ▁av _ str d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mov _ metadata _ creation _ time ( AV Metadata ▁** metadata , ▁time _ t ▁time ) ▁{ ▁char ▁buffer [ 32 ]; ▁if ▁( time ) ▁{ ▁time ▁-= ▁20 8 284 48 00 ; ▁/* ▁seconds ▁between ▁19 04 -01-01 ▁and ▁Epoch ▁*/ ▁strftime ( buffer , ▁sizeof ( buffer ), ▁"% Y -% m -% d ▁% H :% M :% S ", ▁gmtime ( & time )); ▁av _ metadata _ set 2( metadata , ▁" creation _ time ", ▁buffer , ▁0); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁hp et _ ram _ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁H PE T State ▁* s ▁= ▁( H PE T State ▁* ) op aque ; ▁uint 64_ t ▁cur _ tick , ▁index ; ▁D PRI NT F (" q emu : ▁Enter ▁hp et _ ram _ read l ▁at ▁% " ▁PRI x 64 ▁"\ n ", ▁addr ); ▁index ▁= ▁addr ; ▁/* address ▁range ▁of ▁all ▁T N ▁regs */ ▁if ▁( index ▁>= ▁0 x 100 ▁&& ▁index ▁<= ▁0 x 3 ff ) ▁{ ▁uint 8_ t ▁timer _ id ▁= ▁( addr ▁- ▁0 x 100 ) ▁/ ▁0 x 20 ; ▁if ▁( timer _ id ▁> ▁H PE T _ NUM _ T IM ERS ▁- ▁1) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁usb _ claim _ port ( US B Device ▁* dev , ▁Error ▁** err p ) ▁{ ▁USB Bus ▁* bus ▁= ▁usb _ bus _ from _ device ( dev ); ▁USB Port ▁* port ; ▁assert ( dev -> port ▁== ▁NULL ); ▁if ▁( dev -> port _ path ) ▁{ ▁Q TAIL Q _ FORE A CH ( port , ▁& bus -> free , ▁next ) ▁{ ▁if ▁( str cmp ( port -> path , ▁dev -> port _ path ) ▁== ▁0) ▁{ ▁break ; ▁} ▁} ▁if ▁( port ▁== ▁NULL ) ▁{ ▁error _ set g ( err p , ▁" usb ▁port ▁% s ▁( bus ▁% s ) ▁not ▁found ▁( in ▁use ?) ", ▁dev -> port _ path , ▁bus -> q bus . name ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vm x net 3_ update _ features ( VM X NET 3 State ▁* s ) ▁{ ▁uint 32_ t ▁guest _ features ; ▁int ▁r xc so _ supported ; ▁guest _ features ▁= ▁VM X NET 3_ READ _ DR V _ SHA RED 32 ( s -> dr v _ sh mem , ▁dev Read . misc . upt Features ); ▁r xc so _ supported ▁= ▁VM X NET _ FLAG _ IS _ SET ( guest _ features , ▁U PT 1_ F _ R X CS UM ); ▁s -> rx _ vlan _ stri pping ▁= ▁VM X NET _ FLAG _ IS _ SET ( guest _ features , ▁U PT 1_ F _ R X V LAN ); ▁s -> l ro _ supported ▁= ▁VM X NET _ FLAG _ IS _ SET

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ blk _ exit _ pc i ( PC ID evice ▁* pc i _ dev ) ▁{ ▁V irt IO PC I Proxy ▁* proxy ▁= ▁DO _ UP CAST ( V irt IO PC I Proxy , ▁pci _ dev , ▁pci _ dev ); ▁block dev _ mark _ auto _ del ( proxy -> block . d info -> b dr v ); ▁return ▁virt io _ exit _ pc i ( pc i _ dev ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 rgba 64_ full _1_ c _ template ( Sw s Context ▁* c , ▁const ▁int 32_ t ▁* buf 0, ▁const ▁int 32_ t ▁* ub uf [2], ▁const ▁int 32_ t ▁* v buf [2], ▁const ▁int 32_ t ▁* ab uf 0, ▁uint 16_ t ▁* dest , ▁int ▁dst W , ▁int ▁u val pha , ▁int ▁y , ▁enum ▁AV Pixel Format ▁target , ▁int ▁has Alpha , ▁int ▁eight bytes ) ▁{ ▁const ▁int 32_ t ▁* ub uf 0 ▁= ▁u buf [0], ▁* v buf 0 ▁= ▁v buf [0]; ▁int ▁i ; ▁int ▁A ▁= ▁0 xffff << 14 ; ▁if ▁( u val pha ▁< ▁2048 ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁dst W ; ▁i ++) ▁{ ▁int ▁Y 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁u h ci _ async _ complete ( US B Packet ▁* packet , ▁void ▁* op aque ) ▁{ ▁U H CI State ▁* s ▁= ▁opaque ; ▁U H CI Async ▁* async ▁= ▁( U H CI Async ▁* ) ▁packet ; ▁D PRI NT F (" u h ci : ▁async ▁complete . ▁td ▁0 x % x ▁token ▁0 x % x \ n ", ▁async -> td , ▁async -> token ); ▁async -> done ▁= ▁1; ▁u h ci _ process _ frame ( s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ne on _ un zip ( int ▁reg , ▁int ▁q , ▁int ▁tmp , ▁int ▁size ) ▁{ ▁int ▁n ; ▁TC G v ▁t 0, ▁t 1; ▁for ▁( n ▁= ▁0; ▁n ▁< ▁q ▁+ ▁1; ▁n ▁+= ▁2) ▁{ ▁t 0 ▁= ▁ne on _ load _ reg ( reg , ▁n ); ▁t 1 ▁= ▁ne on _ load _ reg ( reg , ▁n ▁+ ▁1); ▁switch ▁( size ) ▁{ ▁case ▁0: ▁gen _ ne on _ un zip _ u 8 ( t 0, ▁t 1); ▁break ; ▁case ▁1: ▁gen _ ne on _ zip _ u 16 ( t 0, ▁t 1); ▁break ; ▁/* ▁zip ▁and ▁unzip ▁are ▁the ▁same . ▁*/ ▁case ▁2: ▁/* ▁no - op ▁*/ ; ▁break ; ▁default : ▁abort (); ▁} ▁ne on _ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁parse _ num a _ distance ( Num a Dist Options ▁* dist , ▁Error ▁** err p ) ▁{ ▁uint 16_ t ▁src ▁= ▁dist -> src ; ▁uint 16_ t ▁dst ▁= ▁dist -> dst ; ▁uint 8_ t ▁val ▁= ▁dist -> val ; ▁if ▁( src ▁>= ▁MAX _ NODE S ▁|| ▁dst ▁>= ▁MAX _ NODE S ) ▁{ ▁error _ set g ( err p , ▁" Invalid ▁node ▁% " ▁PRI u 16 ▁", ▁max ▁possible ▁could ▁be ▁% " ▁PRI u 16, ▁MAX ( src , ▁dst ), ▁MAX _ NODE S ); ▁return ; ▁} ▁if ▁(! num a _ info [ src ]. present ▁|| ▁! num a _ info [ dst ]. present ) ▁{ ▁error _ set g ( e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ palette ( AV Codec Context ▁* av ctx , ▁Get Byte Context ▁* gb c , ▁uint 32_ t ▁* pal , ▁int ▁colors ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁<= ▁colors ; ▁i ++) ▁{ ▁uint 8_ t ▁r , ▁g , ▁b ; ▁unsigned ▁int ▁idx ▁= ▁by test ream 2_ get _ be 16 ( gb c ); ▁/* ▁color ▁index ▁*/ ▁if ▁( idx ▁> ▁255 ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ WARNING , ▁" Palette ▁index ▁out ▁of ▁range : ▁% u \ n ", ▁idx ); ▁by test ream 2_ skip ( gb c , ▁6 ); ▁continue ; ▁} ▁r ▁= ▁by test ream 2_ get _ byte ( gb c );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁compare _ int 64 ( const ▁void ▁* a , ▁const ▁void ▁* b ) ▁{ ▁int 64_ t ▁va ▁= ▁* ( int 64_ t ▁* ) a , ▁vb ▁= ▁* ( int 64_ t ▁* ) b ; ▁return ▁va ▁< ▁vb ▁? ▁-1 ▁: ▁va ▁> ▁vb ▁? ▁+1 ▁: ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁k vm _ arch _ get _ supported _ cp uid ( CPU State ▁* env , ▁uint 32_ t ▁function , ▁uint 32_ t ▁index , ▁int ▁reg ) ▁{ ▁struct ▁k vm _ cp uid 2 ▁* cp uid ; ▁int ▁i , ▁max ; ▁uint 32_ t ▁ret ▁= ▁0; ▁uint 32_ t ▁cp uid _1_ ed x ; ▁if ▁(! k vm _ check _ extension ( env -> k vm _ state , ▁K VM _ CAP _ EXT _ CP UID )) ▁{ ▁return ▁-1 U ; ▁} ▁max ▁= ▁1; ▁while ▁(( cp uid ▁= ▁try _ get _ cp uid ( env -> k vm _ state , ▁max )) ▁== ▁NULL ) ▁{ ▁max ▁*= ▁2; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁cp uid -> n ent ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁get _ next _ page ( Guest Ph ys Block ▁** block ptr , ▁uint 64_ t ▁* p fn ptr , ▁uint 8_ t ▁** buf ptr , ▁Dump State ▁* s ) ▁{ ▁Gu est Ph ys Block ▁* block ▁= ▁* block ptr ; ▁hw addr ▁addr ; ▁uint 8_ t ▁* buf ; ▁/* ▁block ▁== ▁NULL ▁means ▁the ▁start ▁of ▁the ▁iteration ▁*/ ▁if ▁(! block ) ▁{ ▁block ▁= ▁Q TAIL Q _ FIRST ( & s -> guest _ ph ys _ blocks . head ); ▁* block ptr ▁= ▁block ; ▁assert ( block -> target _ start ▁% ▁s -> page _ size ▁== ▁0); ▁assert ( block -> target _ end ▁% ▁s -> p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁coroutine _ fn ▁int ▁qc ow 2_ co _ write v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁remaining _ sect ors , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁index _ in _ cluster ; ▁int ▁n _ end ; ▁int ▁ret ; ▁int ▁cur _ nr _ sect ors ; ▁/* ▁number ▁of ▁sector s ▁in ▁current ▁iteration ▁*/ ▁uint 64_ t ▁cluster _ offset ; ▁Q EM UI O Vector ▁hd _ q io v ; ▁uint 64_ t ▁bytes _ done ▁= ▁0; ▁uint 8_ t ▁* cluster _ data ▁= ▁NULL ; ▁Q C ow L 2 Meta 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁usb _ desc _ get _ descriptor ( US B Device ▁* dev , ▁int ▁value , ▁uint 8_ t ▁* dest , ▁size _ t ▁len ) ▁{ ▁const ▁USB Desc ▁* desc ▁= ▁dev -> info -> usb _ desc ; ▁uint 8_ t ▁buf [ 256 ]; ▁uint 8_ t ▁type ▁= ▁value ▁>> ▁8 ; ▁uint 8_ t ▁index ▁= ▁value ▁& ▁0 xff ; ▁int ▁ret ▁= ▁-1; ▁switch ( type ) ▁{ ▁case ▁USB _ DT _ DEVICE : ▁ret ▁= ▁usb _ desc _ device ( & desc -> id , ▁desc -> full , ▁buf , ▁sizeof ( buf )); ▁trace _ usb _ desc _ device ( dev -> addr , ▁len , ▁ret ); ▁break ; ▁case ▁USB _ DT _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁conn ex _ init ( Machine State ▁* machine ) ▁{ ▁P XA 2 xx State ▁* cpu ; ▁Drive Info ▁* d info ; ▁int ▁be ; ▁Memory Region ▁* address _ space _ mem ▁= ▁get _ system _ memory (); ▁uint 32_ t ▁conn ex _ rom ▁= ▁0 x 01 000000 ; ▁uint 32_ t ▁conn ex _ ram ▁= ▁0 x 04 000000 ; ▁cpu ▁= ▁p xa 25 5_ init ( address _ space _ mem , ▁conn ex _ ram ); ▁d info ▁= ▁drive _ get ( IF _ P FL ASH , ▁0, ▁0); ▁if ▁(! d info ▁&& ▁! q test _ enabled ()) ▁{ ▁f printf ( stderr , ▁" A ▁flash ▁image ▁must ▁be ▁given 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁aio _ set _ event _ notifier ( A io Context ▁* ctx , ▁Event Notifier ▁* notifier , ▁bool ▁is _ external , ▁Event Notifier Handler ▁* io _ read , ▁A io Poll Fn ▁* io _ poll ) ▁{ ▁aio _ set _ fd _ handler ( ctx , ▁event _ notifier _ get _ fd ( notifier ), ▁is _ external , ▁( IO Handler ▁* ) io _ read , ▁NULL , ▁io _ poll , ▁notifier ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁av _ x te a _ crypt ( AV X TE A ▁* ctx , ▁uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁int ▁count , ▁uint 8_ t ▁* iv , ▁int ▁decrypt ) ▁{ ▁int ▁i ; ▁while ▁( count ▁> ▁0) ▁{ ▁if ▁( decrypt ) ▁{ ▁x te a _ crypt _ ec b ( ctx , ▁dst , ▁src , ▁decrypt ); ▁if ▁( iv ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁dst [ i ] ▁= ▁dst [ i ] ▁^ ▁iv [ i ]; ▁mem c py ( iv , ▁src , ▁8 ); ▁} ▁} ▁else ▁{ ▁if ▁( iv ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++) ▁dst [ i ] ▁= ▁src [ i ] ▁^ ▁iv [ i ]; ▁x te a _ crypt _ ec b ( ct

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁read _ chapter ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁int ▁len , ▁char ▁* t tag , ▁ID 3 v 2 Extra Meta ▁** extra _ meta ) ▁{ ▁AV R ational ▁time _ base ▁= ▁{1, ▁1000 }; ▁uint 32_ t ▁start , ▁end ; ▁AV Ch apter ▁* chapter ; ▁uint 8_ t ▁* dst ▁= ▁NULL ; ▁int ▁tag len ; ▁char ▁tag [5 ]; ▁decode _ str ( s , ▁pb , ▁0, ▁& dst , ▁& len ); ▁if ▁( len ▁< ▁16 ) ▁return ; ▁start ▁= ▁av io _ rb 32 ( pb ); ▁end ▁= ▁av io _ rb 32 ( pb ); ▁av io _ skip ( pb , ▁8 ); ▁chapter ▁= ▁av priv _ new _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁k q emu _ modify _ page ( CPU State ▁* env , ▁ram _ addr _ t ▁ram _ addr ) ▁{ ▁unsigned ▁long ▁page _ index ; ▁int ▁ret ; ▁# if def ▁_ W IN 32 ▁DWORD ▁temp ; ▁# end if ▁page _ index ▁= ▁ram _ addr ▁>> ▁TARGET _ PAGE _ BITS ; ▁if ▁(! modified _ ram _ pages _ table [ page _ index ]) ▁{ ▁# if ▁0 ▁printf ("% d : ▁modify _ page =% 08 l x \ n ", ▁nb _ modified _ ram _ pages , ▁ram _ addr ); ▁# end if ▁modified _ ram _ pages _ table [ page _ index ] ▁= ▁1; ▁modified _ ram _ pages [ nb _ modified _ ram _ p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁aio _ ep oll _ check _ poll ( A io Context ▁* ctx , ▁G Poll FD ▁* pf ds , ▁unsigned ▁np fd , ▁int 64_ t ▁timeout ) ▁{ ▁if ▁(! ctx -> ep oll _ available ) ▁{ ▁return ▁false ; ▁} ▁if ▁( a io _ ep oll _ enabled ( ctx )) ▁{ ▁return ▁true ; ▁} ▁if ▁( np fd ▁>= ▁EP OLL _ ENABLE _ THRESHOLD ) ▁{ ▁if ▁( a io _ ep oll _ try _ enable ( ctx )) ▁{ ▁return ▁true ; ▁} ▁else ▁{ ▁aio _ ep oll _ disable ( ctx ); ▁} ▁} ▁return ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁a arch 64_ cpu _ register _ types ( void ) ▁{ ▁int ▁i ; ▁type _ register _ static ( & a arch 64_ cpu _ type _ info ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( a arch 64_ cpus ); ▁i ++) ▁{ ▁a arch 64_ cpu _ register ( & a arch 64_ cpus [ i ]); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁music pal _ l cd _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁uint 64_ t ▁value , ▁unsigned ▁size ) ▁{ ▁music pal _ l cd _ state ▁* s ▁= ▁opaque ; ▁switch ▁( offset ) ▁{ ▁case ▁MP _ L CD _ IR Q CT RL : ▁s -> irq ctrl ▁= ▁value ; ▁break ; ▁case ▁MP _ L CD _ S PI CT RL : ▁if ▁( value ▁== ▁MP _ L CD _ S PI _ DATA ▁|| ▁value ▁== ▁MP _ L CD _ S PI _ CMD ) ▁{ ▁s -> mode ▁= ▁value ; ▁} ▁else ▁{ ▁s -> mode ▁= ▁MP _ L CD _ S PI _ INVALID ; ▁} ▁break ; ▁case ▁MP _ L CD _ INST : ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁uint 32_ t ▁nv ic _ gp rio _ mask ( N VI C State ▁* s ) ▁{ ▁return ▁~ 0 U ▁<< ▁( s -> pr ig roup ▁+ ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ event fd ( int ▁f ds [2]) ▁{ ▁# if def ▁CONFIG _ EVENT FD ▁int ▁ret ; ▁ret ▁= ▁event fd (0, ▁0); ▁if ▁( ret ▁>= ▁0) ▁{ ▁f ds [0] ▁= ▁ret ; ▁qemu _ set _ clo exec ( ret ); ▁if ▁(( fds [1] ▁= ▁dup ( ret )) ▁== ▁-1) ▁{ ▁close ( ret ); ▁return ▁-1; ▁} ▁qemu _ set _ clo exec ( fds [1]); ▁return ▁0; ▁} ▁if ▁( err no ▁!= ▁ENO SY S ) ▁{ ▁return ▁-1; ▁} ▁# end if ▁return ▁qemu _ pipe ( fds ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b dr v _ q ed _ truncate ( Block Driver State ▁* bs , ▁int 64_ t ▁offset ) ▁{ ▁return ▁- EN OT SUP ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( ws r _ ib reak enable )( uint 32_ t ▁v ) ▁{ ▁uint 32_ t ▁change ▁= ▁v ▁^ ▁env -> s re gs [ IB REA KEN ABLE ]; ▁unsigned ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁env -> config -> n ib reak ; ▁++ i ) ▁{ ▁if ▁( change ▁& ▁(1 ▁<< ▁i )) ▁{ ▁tb _ in validate _ ph ys _ page _ range ( ▁env -> s re gs [ IB REAK A ▁+ ▁i ], ▁env -> s re gs [ IB REAK A ▁+ ▁i ] ▁+ ▁1, ▁0); ▁} ▁} ▁env -> s re gs [ IB REA KEN ABLE ] ▁= ▁v ▁& ▁( (1 ▁<< ▁env -> config -> n ib reak ) ▁- ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁open r isc _ cpu _ class _ init ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁Open RI SC CPU Class ▁* occ ▁= ▁OPEN RI SC _ CPU _ CLASS ( oc ); ▁CPU Class ▁* cc ▁= ▁CPU _ CLASS ( occ ); ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( oc ); ▁occ -> parent _ real ize ▁= ▁dc -> real ize ; ▁dc -> real ize ▁= ▁open r isc _ cpu _ real iz ef n ; ▁occ -> parent _ reset ▁= ▁cc -> reset ; ▁cc -> reset ▁= ▁open r isc _ cpu _ reset ; ▁cc -> class _ by _ name ▁= ▁open r isc _ cpu _ class _ by _ name ; ▁cc -> has _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tcp _ accept _ incoming _ migration ( void ▁* op aque ) ▁{ ▁struct ▁sock addr _ in ▁addr ; ▁sock len _ t ▁add rl en ▁= ▁sizeof ( addr ); ▁int ▁s ▁= ▁( int ptr _ t ) op aque ; ▁Q EM U File ▁* f ; ▁int ▁c ; ▁do ▁{ ▁c ▁= ▁qemu _ accept ( s , ▁( struct ▁sock addr ▁* ) & addr , ▁& add rl en ); ▁} ▁while ▁( c ▁== ▁-1 ▁&& ▁socket _ error () ▁== ▁E INT R ); ▁qemu _ set _ fd _ handler 2( s , ▁NULL , ▁NULL , ▁NULL , ▁NULL ); ▁closes ocket ( s ); ▁D PRI NT F (" accept ed ▁migration \ n "); ▁if ▁( c ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qu orum _ copy _ q io v ( Q EM UI O Vector ▁* dest , ▁Q EM UI O Vector ▁* source ) ▁{ ▁int ▁i ; ▁assert ( dest -> nio v ▁== ▁source -> nio v ); ▁assert ( dest -> size ▁== ▁source -> size ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁source -> nio v ; ▁i ++) ▁{ ▁assert ( dest -> io v [ i ]. io v _ len ▁== ▁source -> io v [ i ]. io v _ len ); ▁mem c py ( dest -> io v [ i ]. io v _ base , ▁source -> io v [ i ]. io v _ base , ▁source -> io v [ i ]. io v _ len ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ sg ir le 8 ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁int ▁src _ size , ▁int ▁width , ▁int ▁height , ▁int ▁lines ize ) ▁{ ▁const ▁uint 8_ t ▁* src _ end ▁= ▁src ▁+ ▁src _ size ; ▁int ▁x ▁= ▁0, ▁y ▁= ▁0; ▁# define ▁IN C _ XY ( n ) ▁\ ▁x ▁+= ▁n ; ▁\ ▁if ▁( x ▁>= ▁width ) ▁{ ▁\ ▁y ++; ▁\ ▁if ▁( y ▁>= ▁height ) ▁\ ▁return ▁0; ▁\ ▁x ▁= ▁0; ▁\ ▁} ▁while ▁( src _ end ▁- ▁src ▁>= ▁2) ▁{ ▁uint 8_ t ▁v ▁= ▁* src ++; ▁if ▁( v ▁> ▁0 ▁&& ▁v ▁< ▁0 xC 0) ▁{ ▁do 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ls _ read _ seek ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁timestamp , ▁int ▁flags ) ▁{ ▁H LS Context ▁* c ▁= ▁s -> priv _ data ; ▁int ▁i ; ▁int 64_ t ▁seek _ timestamp ; ▁int ▁valid _ for ▁= ▁-1; ▁if ▁(( flags ▁& ▁AV SE EK _ FLAG _ BYTE ) ▁|| ▁! c -> v ariants [0] -> play lists [0] -> finished ) ▁return ▁A VER ROR ( EN OS Y S ); ▁seek _ timestamp ▁= ▁stream _ index ▁< ▁0 ▁? ▁timestamp ▁: ▁av _ res cale _ r nd ( timestamp , ▁AV _ TIME _ BASE , ▁s -> streams [ stream _ i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁assigned _ init fn ( struct ▁PC ID evice ▁* pc i _ dev ) ▁{ ▁Assign ed Device ▁* dev ▁= ▁DO _ UP CAST ( Assigned Device , ▁dev , ▁pci _ dev ); ▁uint 8_ t ▁e _ int x ; ▁int ▁r ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁if ▁(! k vm _ enabled ()) ▁{ ▁error _ report (" pc i - assign : ▁error : ▁requires ▁K VM ▁support "); ▁return ▁-1; ▁} ▁if ▁(! dev -> host . domain ▁&& ▁! dev -> host . bus ▁&& ▁! dev -> host . slot ▁&& ▁! dev -> host . function ) ▁{ ▁error _ report (" pc i - assign : ▁error : ▁no ▁hos

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁xen _ be _ send _ notify ( struct ▁X en Device ▁* x end ev ) ▁{ ▁return ▁xc _ evt chn _ notify ( x end ev -> evt ch nd ev , ▁x end ev -> local _ port ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁wrap _ timestamp ( AV Stream ▁* st , ▁int 64_ t ▁timestamp ) ▁{ ▁if ▁( st -> pts _ wrap _ behavior ▁!= ▁AV _ PT S _ WRAP _ IGNO RE ▁&& ▁st -> pts _ wrap _ bits ▁< ▁64 ▁&& ▁st -> pts _ wrap _ reference ▁!= ▁AV _ NO PT S _ VALUE ▁&& ▁timestamp ▁!= ▁AV _ NO PT S _ VALUE ) ▁{ ▁if ▁( st -> pts _ wrap _ behavior ▁== ▁AV _ PT S _ WRAP _ ADD _ OFFSET ▁&& ▁timestamp ▁< ▁st -> pts _ wrap _ reference ) ▁return ▁timestamp ▁+ ▁(1 ULL << st -> pts _ wrap _ bits ); ▁else ▁if ▁( st -> pts _ wrap _ beh

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ide _ ata pi _ cmd _ reply _ end ( IDE State ▁* s ) ▁{ ▁int ▁byte _ count _ limit , ▁size , ▁ret ; ▁# if def ▁DEBUG _ IDE _ ATA PI ▁printf (" reply : ▁tx _ size =% d ▁elem _ tx _ size =% d ▁index =% d \ n ", ▁s -> packet _ transfer _ size , ▁s -> element ary _ transfer _ size , ▁s -> io _ buffer _ index ); ▁# end if ▁if ▁( s -> packet _ transfer _ size ▁<= ▁0) ▁{ ▁/* ▁end ▁of ▁transfer ▁*/ ▁ide _ transfer _ stop ( s ); ▁s -> status ▁= ▁READ Y _ STAT ; ▁s -> n sect or ▁= ▁( s -> n sect or ▁&

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sla v io _ led _ mem _ writes ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁M isc State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁s addr ; ▁s addr ▁= ▁addr ▁& ▁L ED _ MAX ADDR ; ▁MI SC _ DP RI NT F (" Write ▁diagnostic ▁L ED ▁reg ▁0 x " ▁TARGET _ F MT _ pl x ▁" ▁= ▁% x \ n ", ▁addr , ▁val ); ▁switch ▁( s addr ) ▁{ ▁case ▁0: ▁s -> led s ▁= ▁val ; ▁break ; ▁default : ▁break ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁coroutine _ fn ▁b dr v _ co _ dis card ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors ) ▁{ ▁int ▁max _ dis card ; ▁if ▁(! bs -> dr v ) ▁{ ▁return ▁- EN O MEDI UM ; ▁} ▁else ▁if ▁( b dr v _ check _ request ( bs , ▁sector _ num , ▁nb _ sect ors )) ▁{ ▁return ▁- E IO ; ▁} ▁else ▁if ▁( bs -> read _ only ) ▁{ ▁return ▁- ER OF S ; ▁} ▁b dr v _ reset _ dirty ( bs , ▁sector _ num , ▁nb _ sect ors ); ▁/* ▁Do ▁nothing ▁if ▁disabled . ▁*/ ▁if ▁(! ( bs -> open _ flags ▁& ▁B DR V _ O

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x ln x _ ep 10 8_ machine _ init ( Machine Class ▁* mc ) ▁{ ▁mc -> desc ▁= ▁" X il inx ▁Z yn q MP ▁EP 108 ▁board "; ▁mc -> init ▁= ▁x ln x _ ep 10 8_ init ; ▁mc -> block _ default _ type ▁= ▁IF _ IDE ; ▁mc -> units _ per _ default _ bus ▁= ▁1; ▁mc -> ignore _ memory _ transaction _ failures ▁= ▁true ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ logical i ( TC G Context ▁* s , ▁A Arch 64 Insn ▁insn , ▁TC G Type ▁ext , ▁TC G Reg ▁rd , ▁TC G Reg ▁rn , ▁uint 64_ t ▁lim m ) ▁{ ▁unsigned ▁h , ▁l , ▁r , ▁c ; ▁assert ( is _ lim m ( lim m )); ▁h ▁= ▁clz 64 ( lim m ); ▁l ▁= ▁ct z 64 ( lim m ); ▁if ▁( l ▁== ▁0) ▁{ ▁r ▁= ▁0; ▁/* ▁form ▁0 ... .0 1 .... 1 ▁*/ ▁c ▁= ▁ct z 64 ( ~ lim m ) ▁- ▁1; ▁if ▁( h ▁== ▁0) ▁{ ▁r ▁= ▁clz 64 ( ~ lim m ); ▁/* ▁form ▁1 .. 10. .0 1 .. 1 ▁*/ ▁c ▁+= ▁r ; ▁} ▁} ▁else ▁{ ▁r ▁= ▁64 ▁- ▁l ; ▁/* ▁form ▁1 ..

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁i ch 9_ pm _ init ( PC ID evice ▁* l pc _ pc i , ▁I CH 9 LP CP M Re gs ▁* pm , ▁bool ▁sm m _ enabled , ▁qemu _ irq ▁sc i _ irq ) ▁{ ▁memory _ region _ init ( & pm -> io , ▁OBJECT ( l pc _ pc i ), ▁" ich 9 - pm ", ▁I CH 9_ PM IO _ SIZE ); ▁memory _ region _ set _ enabled ( & pm -> io , ▁false ); ▁memory _ region _ add _ sub region ( pc i _ address _ space _ io ( l pc _ pc i ), ▁0, ▁& pm -> io ); ▁ac pi _ pm _ tm r _ init ( & pm -> ac pi _ re gs , ▁i ch 9_ pm _ update _ sc i _ fn , ▁& pm -> io ); ▁ac

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ sys ( Dis as Context ▁* s , ▁uint 32_ t ▁insn , ▁bool ▁is read , ▁unsigned ▁int ▁op 0, ▁unsigned ▁int ▁op 1, ▁unsigned ▁int ▁op 2, ▁unsigned ▁int ▁cr n , ▁unsigned ▁int ▁crm , ▁unsigned ▁int ▁rt ) ▁{ ▁const ▁ARM CP Reg Info ▁* ri ; ▁TC G v _ i 64 ▁tc g _ rt ; ▁ri ▁= ▁get _ arm _ cp _ reg info ( s -> cp _ re gs , ▁EN CODE _ AA 64_ CP _ REG ( CP _ REG _ ARM 64_ SY S REG _ CP , ▁cr n , ▁crm , ▁op 0, ▁op 1, ▁op 2 )); ▁if ▁(! ri ) ▁{ ▁/* ▁Unknown ▁register ; ▁this ▁might ▁be ▁a ▁guest ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Visitor ▁* visitor _ input _ test _ init _ raw ( Test Input Visitor Data ▁* data , ▁const ▁char ▁* json _ string ) ▁{ ▁return ▁visitor _ input _ test _ init _ internal ( data , ▁json _ string , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ info _ version ( Monitor ▁* mon ) ▁{ ▁monitor _ printf ( mon , ▁"% s \ n ", ▁Q EM U _ VERSION ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q crypto _ iv gen _ ess iv _ init ( Q Crypto IV Gen ▁* iv gen , ▁const ▁uint 8_ t ▁* key , ▁size _ t ▁n key , ▁Error ▁** err p ) ▁{ ▁uint 8_ t ▁* salt ; ▁size _ t ▁n hash ; ▁size _ t ▁ns alt ; ▁Q Crypto IV Gen E SS IV ▁* ess iv ▁= ▁g _ new 0( Q Crypto IV Gen E SS IV , ▁1); ▁/* ▁Not ▁necessarily ▁the ▁same ▁as ▁n key ▁*/ ▁ns alt ▁= ▁q crypto _ cipher _ get _ key _ len ( iv gen -> cipher ); ▁n hash ▁= ▁q crypto _ hash _ digest _ len ( iv gen -> hash ); ▁/* ▁S alt ▁must ▁be ▁larger ▁of ▁hash ▁s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m peg 1_ encode _ sequence _ header ( M peg Enc Context ▁* s ) ▁{ ▁unsigned ▁int ▁vb v _ buffer _ size ; ▁unsigned ▁int ▁fps , ▁v ; ▁int ▁n ; ▁U INT 64 ▁time _ code ; ▁if ▁(( s -> picture _ number ▁% ▁s -> g op _ size ) ▁== ▁0) ▁{ ▁/* ▁m peg 1 ▁header ▁repeated ▁every ▁g op ▁*/ ▁put _ header ( s , ▁SE Q _ START _ CODE ); ▁/* ▁search ▁closest ▁frame ▁rate ▁*/ ▁{ ▁int ▁i , ▁d min , ▁d ; ▁s -> frame _ rate _ index ▁= ▁0; ▁d min ▁= ▁0 x 7 ffff fff ; ▁for ( i =1; i < 9 ; i ++) ▁{ ▁d ▁= ▁abs ( s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ put _ h 2 64_ qp el 4_ mc 33 _ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ h v _ q rt _4 w _ ms a ( src ▁+ ▁stride ▁- ▁2, ▁src ▁- ▁( stride ▁* ▁2) ▁+ ▁sizeof ( uint 8_ t ), ▁stride , ▁dst , ▁stride , ▁4 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁m peg _ m ux _ init ( AV Format Context ▁* ctx ) ▁{ ▁M peg M ux Context ▁* s ▁= ▁ctx -> priv _ data ; ▁int ▁bitrate , ▁i , ▁m pa _ id , ▁m pv _ id , ▁h 2 64_ id , ▁m ps _ id , ▁ac 3_ id , ▁dt s _ id , ▁l pc m _ id , ▁j ; ▁AV Stream ▁* st ; ▁Stream Info ▁* stream ; ▁int ▁audio _ bit rate ; ▁int ▁video _ bit rate ; ▁s -> packet _ number ▁= ▁0; ▁s -> is _ v cd ▁= ▁( CONFIG _ M PEG 1 VC D _ MU X ER ▁&& ▁ctx -> o format ▁== ▁& ff _ mpeg 1 v cd _ m ux er ); ▁s -> is _ sv cd ▁= ▁( CONFI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ds put il _ init _ mm x 2( DS P Context ▁* c , ▁AV Codec Context ▁* av ctx , ▁int ▁mm _ flags ) ▁{ ▁const ▁int ▁bit _ depth ▁= ▁av ctx -> bits _ per _ raw _ sample ; ▁const ▁int ▁high _ bit _ depth ▁= ▁bit _ depth ▁> ▁8 ; ▁c -> prefetch ▁= ▁prefetch _ mm x 2; ▁if ▁(! high _ bit _ depth ) ▁{ ▁c -> put _ pixels _ tab [0] [1] ▁= ▁put _ pixels 16_ x 2_ mm x 2; ▁c -> put _ pixels _ tab [0] [2] ▁= ▁put _ pixels 16_ y 2_ mm x 2; ▁c -> avg _ pixels _ tab [0][0] ▁= ▁avg _ pixels 16_ mm x 2; ▁c -> av

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁va api _ encode _ h 2 64_ init _ sequence _ params ( AV Codec Context ▁* av ctx ) ▁{ ▁V A API Encode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁V A Enc Sequence Parameter Buffer H 264 ▁* v seq ▁= ▁ctx -> codec _ sequence _ params ; ▁V A Enc Picture Parameter Buffer H 264 ▁* v pic ▁= ▁ctx -> codec _ picture _ params ; ▁V A API Encode H 264 Context ▁* priv ▁= ▁ctx -> priv _ data ; ▁V A API Encode H 264 M isc Sequence Params ▁* m seq ▁= ▁& priv -> misc _ sequence _ params ; ▁int ▁i ; ▁{ ▁v seq

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁if _ start ( Sl ir p ▁* sl ir p ) ▁{ ▁uint 64_ t ▁now ▁= ▁qemu _ clock _ get _ ns ( Q EM U _ C LOCK _ RE AL TIME ); ▁bool ▁from _ batch q , ▁next _ from _ batch q ; ▁struct ▁m buf ▁* if m , ▁* if m _ next , ▁* if qt ; ▁DEBUG _ CALL (" if _ start "); ▁if ▁( sl ir p -> if _ start _ bus y ) ▁{ ▁return ; ▁} ▁sl ir p -> if _ start _ bus y ▁= ▁true ; ▁if ▁( sl ir p -> if _ fast q . if q _ next ▁!= ▁& sl ir p -> if _ fast q ) ▁{ ▁if m _ next ▁= ▁sl ir p -> if _ fast q . if q _ next ; ▁next _ from _ batch 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁handle _ ti ( ES P State ▁* s ) ▁{ ▁uint 32_ t ▁dm al en , ▁min len ; ▁if ▁( s -> d ma ▁&& ▁! s -> d ma _ enabled ) ▁{ ▁s -> d ma _ cb ▁= ▁handle _ ti ; ▁return ; ▁} ▁dm al en ▁= ▁s -> r re gs [ ES P _ TC LO ]; ▁dm al en ▁|= ▁s -> r re gs [ ES P _ T CM ID ] ▁<< ▁8 ; ▁dm al en ▁|= ▁s -> r re gs [ ES P _ T CH I ] ▁<< ▁16 ; ▁if ▁( dm al en == 0) ▁{ ▁dm al en =0 x 10000 ; ▁} ▁s -> d ma _ counter ▁= ▁dm al en ; ▁if ▁( s -> do _ cmd ) ▁min len ▁= ▁( dm al en ▁< ▁3 2) ▁? ▁dm al en ▁: ▁32 ; ▁else ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l si 53 c 89 5 a _ register _ devices ( void ) ▁{ ▁type _ register _ static ( & l si _ info ); ▁type _ register _ static _ alias ( & l si _ info , ▁" l si "); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁receive _ from _ chr _ layer ( SC LP Console ▁* s con , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size ) ▁{ ▁/* ▁read ▁data ▁must ▁fit ▁into ▁current ▁buffer ▁*/ ▁assert ( size ▁<= ▁SIZE _ BUFFER _ VT 2 20 ▁- ▁s con -> io v _ data _ len ); ▁/* ▁put ▁byte - stream ▁from ▁character ▁layer ▁into ▁buffer ▁*/ ▁mem c py ( & s con -> io v [ s con -> io v _ bs ], ▁buf , ▁size ); ▁s con -> io v _ data _ len ▁+= ▁size ; ▁s con -> io v _ s cl p _ rest ▁+= ▁size ; ▁s con -> io v _ bs ▁+= ▁size ; ▁s con -> event

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb re dir _ do _ attach ( void ▁* op aque ) ▁{ ▁USB Red ir Device ▁* dev ▁= ▁opaque ; ▁/* ▁In ▁order ▁to ▁work ▁properly ▁with ▁X H CI ▁controllers ▁we ▁need ▁these ▁caps ▁*/ ▁if ▁(( dev -> dev . port -> speed mask ▁& ▁USB _ SPE ED _ MASK _ SUP ER ) ▁&& ▁! ( ▁usb _ re dir _ cap _ ep _ info _ max _ packet _ size ) ▁&& ▁usb _ re dir _ cap _64 bits _ ids ))) ▁{ ▁ERROR (" usb - re dir - host ▁lack s ▁capabilities ▁needed ▁for ▁use ▁with ▁X H CI \ n "); ▁usb re dir _ reject _ device ( dev ); ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁set _ band width ( AC 3 Encode Context ▁* s , ▁int ▁cutoff ) ▁{ ▁int ▁ch , ▁bw _ code ; ▁if ▁( c utoff ) ▁{ ▁/* ▁calculate ▁bandwidth ▁based ▁on ▁user - specified ▁cutoff ▁frequency ▁*/ ▁int ▁fb w _ coeff s ; ▁cutoff ▁= ▁av _ clip ( c utoff , ▁1, ▁s -> sample _ rate ▁>> ▁1); ▁fb w _ coeff s ▁= ▁cutoff ▁* ▁2 ▁* ▁AC 3_ MAX _ CO E FS ▁/ ▁s -> sample _ rate ; ▁bw _ code ▁= ▁av _ clip (( fb w _ coeff s ▁- ▁7 3) ▁/ ▁3, ▁0, ▁60 ); ▁} ▁else ▁{ ▁/* ▁use ▁default ▁bandwidth ▁setting ▁*/ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uy 2 To UV )( uint 8_ t ▁* dst U , ▁uint 8_ t ▁* dst V , ▁const ▁uint 8_ t ▁* src 1, ▁const ▁uint 8_ t ▁* src 2, ▁long ▁width , ▁uint 32_ t ▁* unused ) ▁{ ▁# if ▁COM PI LE _ TEMPLATE _ MM X ▁__ asm __ ▁volatile ( ▁" mov q ▁" M ANG LE ( bm 0101 0101 )", ▁%% mm 4 ▁\ n \ t " ▁" mov ▁% 0, ▁% %" REG _ a " ▁\ n \ t " ▁" 1: ▁\ n \ t " ▁" mov q ▁( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁8 ( % 1, ▁% %" REG _ a ", 4 ), ▁%% mm 1 ▁\ n \ t " ▁" ps rl w ▁$ 8, ▁%% mm 0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x t ens a _ k c 70 5_ init ( Machine State ▁* machine ) ▁{ ▁static ▁const ▁L x Board Desc ▁k c 70 5_ board ▁= ▁{ ▁. flash _ base ▁= ▁0 xf 0000000 , ▁. flash _ size ▁= ▁0 x 08 000000 , ▁. flash _ boot _ base ▁= ▁0 x 06 000000 , ▁. flash _ sect or _ size ▁= ▁0 x 2 0000, ▁. s ram _ size ▁= ▁0 x 2 000000 , ▁}; ▁lx _ init ( & k c 70 5_ board , ▁machine ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt queue _ un map _ sg ( V irt Queue ▁* v q , ▁const ▁V irt Queue Element ▁* elem , ▁unsigned ▁int ▁len ) ▁{ ▁unsigned ▁int ▁offset ; ▁int ▁i ; ▁offset ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁elem -> in _ num ; ▁i ++) ▁{ ▁size _ t ▁size ▁= ▁MIN ( len ▁- ▁offset , ▁elem -> in _ sg [ i ]. io v _ len ); ▁cpu _ ph ysical _ memory _ un map ( elem -> in _ sg [ i ]. io v _ base , ▁elem -> in _ sg [ i ]. io v _ len , ▁1, ▁size ); ▁offset ▁+= ▁size ; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁elem -> out _ num ; ▁i ++) ▁c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ re open _ prepare ( B DR V Re open State ▁* state , ▁Block Re open Queue ▁* queue , ▁Error ▁** err p ) ▁{ ▁B DR V V mdk State ▁* s ; ▁int ▁ret ▁= ▁-1; ▁int ▁i ; ▁V mdk Extent ▁* e ; ▁assert ( state ▁!= ▁NULL ); ▁assert ( state -> bs ▁!= ▁NULL ); ▁if ▁( queue ▁== ▁NULL ) ▁{ ▁error _ set g ( err p , ▁" No ▁reopen ▁queue ▁for ▁VM DK ▁extent s "); ▁goto ▁exit ; ▁} ▁s ▁= ▁state -> bs -> op aque ; ▁assert ( s ▁!= ▁NULL ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> num _ ext ents ; ▁i ++) ▁{ ▁e ▁= ▁& s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁tc g _ out _ goto _ label ( TC G Context ▁* s , ▁int ▁label _ index ) ▁{ ▁TC G Label ▁* l ▁= ▁& s -> labels [ label _ index ]; ▁if ▁(! l -> has _ value ) ▁{ ▁tc g _ out _ re loc ( s , ▁s -> code _ ptr , ▁R _ A ARCH 64_ J UMP 26, ▁label _ index , ▁0); ▁tc g _ out _ goto _ no addr ( s ); ▁} ▁else ▁{ ▁tc g _ out _ goto ( s , ▁l -> u . value _ ptr ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ac 97 _ map ▁( PC ID evice ▁* pc i _ dev , ▁int ▁region _ num , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁size , ▁int ▁type ) ▁{ ▁P CI AC 97 Link State ▁* d ▁= ▁( PC I AC 97 Link State ▁* ) ▁pci _ dev ; ▁AC 97 Link State ▁* s ▁= ▁& d -> ac 97 ; ▁if ▁(! region _ num ) ▁{ ▁s -> base [0] ▁= ▁addr ; ▁register _ i op ort _ read ▁( addr , ▁256 ▁* ▁1, ▁1, ▁nam _ read b , ▁d ); ▁register _ i op ort _ read ▁( addr , ▁256 ▁* ▁2, ▁2, ▁nam _ read w , ▁d ); ▁register _ i op ort _ read ▁( addr , ▁256 ▁* ▁4, ▁4, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁vm state _ un register ( Device State ▁* dev , ▁const ▁VM State Description ▁* v ms d , ▁void ▁* op aque ) ▁{ ▁Save State Entry ▁* se , ▁* new _ se ; ▁Q TAIL Q _ FORE A CH _ SAFE ( se , ▁& save vm _ state . handlers , ▁entry , ▁new _ se ) ▁{ ▁if ▁( se -> v ms d ▁== ▁vms d ▁&& ▁se -> op aque ▁== ▁opaque ) ▁{ ▁Q TAIL Q _ REMOVE ( & save vm _ state . handlers , ▁se , ▁entry ); ▁if ▁( se -> compat ) ▁{ ▁g _ free ( se -> compat ); ▁} ▁g _ free ( se ); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁xen fb _ send _ m otion ( struct ▁X en Input ▁* x en fb , ▁int ▁rel _ x , ▁int ▁rel _ y , ▁int ▁rel _ z ) ▁{ ▁union ▁x enk bd _ in _ event ▁event ; ▁mem set ( & event , ▁0, ▁X EN KB D _ IN _ EVENT _ SIZE ); ▁event . type ▁= ▁X EN KB D _ TYPE _ M OT ION ; ▁event . m otion . rel _ x ▁= ▁rel _ x ; ▁event . m otion . rel _ y ▁= ▁rel _ y ; ▁# if ▁__ X EN _ LATE ST _ INTERFACE _ VERSION __ ▁>= ▁0 x 000 30 207 ▁event . m otion . rel _ z ▁= ▁rel _ z ; ▁# end if ▁return ▁xen fb _ k bd _ event ( x en 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁J VD em ux Context ▁* j v ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* v st , ▁* ast ; ▁int 64_ t ▁audio _ pts ▁= ▁0; ▁int 64_ t ▁offset ; ▁int ▁i ; ▁av io _ skip ( pb , ▁80 ); ▁ast ▁= ▁av _ new _ stream ( s , ▁0); ▁v st ▁= ▁av _ new _ stream ( s , ▁1); ▁if ▁(! ast ▁|| ▁! v st ) ▁return ▁A VER ROR ( EN O ME M ); ▁v st -> codec -> codec _ type ▁= ▁CODE C _ TYPE _ VI DEO ; ▁v st -> codec -> co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ write _ col r _ tag ( AV IO Context ▁* pb , ▁MO V Track ▁* track ) ▁{ ▁// ▁Ref ▁( MO V ): ▁https :// developer . apple . com / library / mac / tech notes / tn 2 16 2/ _ index . html # // apple _ ref / doc / uid / DT S 400 1 30 70 - CH 1- T NT AG 9 ▁// ▁Ref ▁( MP 4 ): ▁ISO / I EC ▁14 49 6 -12 : 2012 ▁if ▁( track -> enc -> color _ prim aries ▁== ▁AV COL _ PRI _ UN SPE CIFIED ▁&& ▁track -> enc -> color _ tr c ▁== ▁AV COL _ TR C _ UN SPE CIFIED ▁&& ▁track -> enc -> color space ▁== ▁AV COL 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sl ir p _ socket _ load ( Q EM U File ▁* f , ▁struct ▁socket ▁* so ) ▁{ ▁if ▁( tcp _ attach ( so ) ▁< ▁0) ▁return ▁- EN O ME M ; ▁so -> so _ ur gc ▁= ▁qemu _ get _ be 32 ( f ); ▁so -> so _ ff amily ▁= ▁qemu _ get _ be 16 ( f ); ▁switch ▁( so -> so _ ff amily ) ▁{ ▁case ▁AF _ INET : ▁so -> so _ f addr . s _ addr ▁= ▁qemu _ get _ be 32 ( f ); ▁so -> so _ f port ▁= ▁qemu _ get _ be 16 ( f ); ▁break ; ▁default : ▁error _ report ( ▁" so _ ff amily ▁unknown , ▁unable ▁to ▁restore ▁so _ f addr ▁and

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q dev _ print _ dev info ( Device Info ▁* info , ▁char ▁* dest , ▁int ▁len ) ▁{ ▁int ▁pos ▁= ▁0; ▁pos ▁+= ▁sn printf ( dest + pos , ▁len - pos , ▁" name ▁\" % s \", ▁bus ▁% s ", ▁info -> name , ▁info -> bus _ info -> name ); ▁if ▁( info -> alias ) ▁pos ▁+= ▁sn printf ( dest + pos , ▁len - pos , ▁", ▁alias ▁\" % s \" ", ▁info -> alias ); ▁if ▁( info -> desc ) ▁pos ▁+= ▁sn printf ( dest + pos , ▁len - pos , ▁", ▁desc ▁\" % s \" ", ▁info -> desc ); ▁if ▁( info -> no _ user ) ▁pos ▁+= ▁sn printf

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ last _ needed _ nal ( H 264 Context ▁* h , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁int ▁next _ av c ▁= ▁h -> is _ av c ▁? ▁0 ▁: ▁buf _ size ; ▁int ▁n al _ index ▁= ▁0; ▁int ▁buf _ index ▁= ▁0; ▁int ▁n als _ needed ▁= ▁0; ▁while (1) ▁{ ▁int ▁n al size ▁= ▁0; ▁int ▁dst _ length , ▁bit _ length , ▁consumed ; ▁const ▁uint 8_ t ▁* ptr ; ▁if ▁( buf _ index ▁>= ▁next _ av c ) ▁{ ▁n al size ▁= ▁get _ av c _ nal size ( h , ▁buf , ▁buf _ size , ▁& buf _ index ); ▁if ▁( nal size ▁< ▁0) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁e 1000 e _ write _ packet _ to _ guest ( E 1000 E Core ▁* core , ▁struct ▁Net Rx P kt ▁* pk t , ▁const ▁E 1000 E _ Rx Ring ▁* rx r , ▁const ▁E 1000 E _ R SS Info ▁* rss _ info ) ▁{ ▁PC ID evice ▁* d ▁= ▁core -> owner ; ▁d ma _ addr _ t ▁base ; ▁uint 8_ t ▁desc [ E 1000 _ MAX _ R X _ DESC _ LEN ]; ▁size _ t ▁desc _ size ; ▁size _ t ▁desc _ offset ▁= ▁0; ▁size _ t ▁i ov _ of s ▁= ▁0; ▁struct ▁i ove c ▁* io v ▁= ▁net _ rx _ pk t _ get _ i ove c ( pk t ); ▁size _ t ▁size ▁= ▁net _ rx _ pk t _ get _ total _ l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cir r us _ do _ copy ( C ir r us V GA State ▁* s , ▁int ▁dst , ▁int ▁src , ▁int ▁w , ▁int ▁h ) ▁{ ▁int ▁sx ▁= ▁0, ▁sy ▁= ▁0; ▁int ▁dx ▁= ▁0, ▁dy ▁= ▁0; ▁int ▁depth ▁= ▁0; ▁int ▁notify ▁= ▁0; ▁/* ▁make ▁sure ▁to ▁only ▁copy ▁if ▁it ' s ▁a ▁plain ▁copy ▁R OP ▁*/ ▁if ▁(* s -> cir r us _ rop ▁== ▁cir r us _ bit bl t _ rop _ f wd _ src ▁|| ▁* s -> cir r us _ rop ▁== ▁cir r us _ bit bl t _ rop _ b kw d _ src ) ▁{ ▁int ▁width , ▁height ; ▁depth ▁= ▁s -> v ga . get _ b pp ( & s -> v ga ) ▁/ ▁8 ; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ l 1_ entry ( Block Driver State ▁* bs , ▁int ▁l 1_ index ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁buf [ L 1_ ENT RIES _ PER _ SE CTOR ]; ▁int ▁l 1_ start _ index ; ▁int ▁i , ▁ret ; ▁l 1_ start _ index ▁= ▁l 1_ index ▁& ▁~ ( L 1_ ENT RIES _ PER _ SE CTOR ▁- ▁1); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁L 1_ ENT RIES _ PER _ SE CTOR ; ▁i ++) ▁{ ▁buf [ i ] ▁= ▁cpu _ to _ be 64 ( s -> l 1_ table [ l 1_ start _ index ▁+ ▁i ]); ▁} ▁BL K DB G _ EVENT ( bs -> file , ▁BL K DB G _ L 1_ U

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v host _ dev _ init ( struct ▁v host _ dev ▁* h dev , ▁void ▁* op aque , ▁V host Backend Type ▁backend _ type ) ▁{ ▁uint 64_ t ▁features ; ▁int ▁i , ▁r ; ▁if ▁( v host _ set _ backend _ type ( h dev , ▁backend _ type ) ▁< ▁0) ▁{ ▁close (( uint ptr _ t ) op aque ); ▁return ▁-1; ▁} ▁if ▁( h dev -> v host _ ops -> v host _ backend _ init ( h dev , ▁opaque ) ▁< ▁0) ▁{ ▁close (( uint ptr _ t ) op aque ); ▁return ▁- err no ; ▁} ▁r ▁= ▁h dev -> v host _ ops -> v host _ call ( h dev , ▁V HOST _ SET _ OWNER 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ read ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁if ▁(! dr v ) ▁return ▁- EN O MEDI UM ; ▁if ▁( dr v -> b dr v _ p read ) ▁{ ▁int ▁ret , ▁len ; ▁len ▁= ▁nb _ sect ors ▁* ▁512 ; ▁ret ▁= ▁drv -> b dr v _ p read ( bs , ▁sector _ num ▁* ▁5 12, ▁buf , ▁len ); ▁if ▁( ret ▁< ▁0) ▁return ▁ret ; ▁else ▁if ▁( ret ▁!= ▁len ) ▁return ▁- E IN VAL ; ▁else ▁{ ▁bs -> rd _ bytes ▁+= ▁( un signed ) ▁len ; ▁bs -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁make _ cd t 24 _ entry ( int ▁p 1, ▁int ▁p 2, ▁int 16_ t ▁* cd t ) ▁{ ▁int ▁r , ▁b ; ▁b ▁= ▁c dt [ p 2 ]; ▁r ▁= ▁c dt [ p 1] << 16 ; ▁return ▁( b + r ) ▁<< ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁AV Frame ▁* do _ ps nr ( AV Filter Context ▁* ctx , ▁AV Frame ▁* main , ▁const ▁AV Frame ▁* ref ) ▁{ ▁PS N R Context ▁* s ▁= ▁ctx -> priv ; ▁double ▁comp _ m se [4 ], ▁mse ▁= ▁0; ▁int ▁j , ▁c ; ▁AV Dictionary ▁** metadata ▁= ▁av priv _ frame _ get _ metadata p ( main ); ▁s -> compute _ m se ( s , ▁( const ▁uint 8_ t ▁** ) main -> data , ▁main -> lines ize , ▁( const ▁uint 8_ t ▁** ) ref -> data , ▁ref -> lines ize , ▁main -> width , ▁main -> height , ▁comp _ m se ); ▁for ▁( j ▁= ▁0; ▁j ▁< ▁s -> n

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mat ro sk a _ add _ index _ entries ( Mat ro sk a Dem ux Context ▁* mat ro sk a ) ▁{ ▁E b ml List ▁* index _ list ; ▁Mat ro sk a Index ▁* index ; ▁int ▁index _ scale ▁= ▁1; ▁int ▁i , ▁j ; ▁if ▁( mat ro sk a -> ctx -> flags ▁& ▁AV F MT _ FLAG _ IGN ID X ) ▁return ; ▁index _ list ▁= ▁& mat ro sk a -> index ; ▁index ▁= ▁index _ list -> elem ; ▁if ▁( index _ list -> nb _ elem ▁&& ▁index [0]. time ▁> ▁1 E 14 ▁/ ▁mat ro sk a -> time _ scale ) ▁{ ▁av _ log ( mat ro sk a -> ctx , ▁AV _ LOG _ WARNIN

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁down mix _3 f _2 r _ to _ mon o ( float ▁* samples ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁256 ; ▁i ++) ▁{ ▁samples [ i ] ▁+= ▁( samples [ i ▁+ ▁256 ] ▁+ ▁samples [ i ▁+ ▁512 ] ▁+ ▁samples [ i ▁+ ▁768 ] ▁+ ▁samples [ i ▁+ ▁1024 ]); ▁samples [ i ▁+ ▁256 ] ▁= ▁samples [ i ▁+ ▁512 ] ▁= ▁samples [ i ▁+ ▁768 ] ▁= ▁samples [ i ▁+ ▁1024 ] ▁= ▁0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁v td _ dec ide _ config ( Int el I OM MU State ▁* s , ▁Error ▁** err p ) ▁{ ▁X 86 I OM MU State ▁* x 86_ iom mu ▁= ▁X 86_ I OM MU _ DEVICE ( s ); ▁/* ▁Currently ▁Intel ▁IO MM U ▁IR ▁only ▁support ▁" kernel - irq ch ip ={ off | split }" ▁*/ ▁if ▁( x 86_ iom mu -> in tr _ supported ▁&& ▁k vm _ irq ch ip _ in _ kernel () ▁&& ▁! k vm _ irq ch ip _ is _ split ()) ▁{ ▁error _ set g ( err p , ▁" Int el ▁Inter rupt ▁Rem apping ▁cannot ▁work ▁with ▁" ▁" kernel - irq ch ip = on , ▁please ▁use ▁' spli

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁no _ init _ in ▁( H W Voice In ▁* hw , ▁struct ▁aud settings ▁* as ) ▁{ ▁audio _ pc m _ init _ info ▁( & hw -> info , ▁as ); ▁hw -> samples ▁= ▁1024 ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ns v _ read _ chunk ( AV Format Context ▁* s , ▁int ▁fill _ header ) ▁{ ▁N SV Context ▁* ns v ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st [2] ▁= ▁{ NULL , ▁NULL }; ▁N SV Stream ▁* n st ; ▁AV Packet ▁* pk t ; ▁int ▁i , ▁err ▁= ▁0; ▁uint 8_ t ▁aux count ; ▁/* ▁number ▁of ▁aux ▁metadata , ▁also ▁4 ▁bits ▁of ▁v size ▁*/ ▁uint 32_ t ▁v size ; ▁uint 16_ t ▁as ize ; ▁uint 16_ t ▁aux size ; ▁if ▁( ns v -> ahead [0]. data ▁|| ▁ns v -> ahead [1]. data ) ▁return ▁0; ▁// -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁block _ save _ complete ( Q EM U File ▁* f , ▁void ▁* op aque ) ▁{ ▁int ▁ret ; ▁D PRI NT F (" Enter ▁save ▁live ▁complete ▁submitted ▁% d ▁transferred ▁% d \ n ", ▁block _ mig _ state . submitted , ▁block _ mig _ state . transfer red ); ▁ret ▁= ▁flush _ bl ks ( f ); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁blk _ mig _ reset _ dirty _ cursor (); ▁/* ▁we ▁know ▁for ▁sure ▁that ▁save ▁bulk ▁is ▁completed ▁and ▁all ▁async ▁read ▁completed ▁*/ ▁blk _ mig _ lock (); ▁assert ( block _ mig _ state . submi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁mat ro sk a _ parse _ block ( Mat ro sk a Dem ux Context ▁* mat ro sk a , ▁uint 8_ t ▁* data , ▁int ▁size , ▁int 64_ t ▁pos , ▁uint 64_ t ▁cluster _ time , ▁uint 64_ t ▁duration , ▁int ▁is _ key frame , ▁int ▁is _ b frame ) ▁{ ▁int ▁res ▁= ▁0; ▁int ▁track ; ▁AV Stream ▁* st ; ▁AV Packet ▁* pk t ; ▁uint 8_ t ▁* orig data ▁= ▁data ; ▁int 16_ t ▁block _ time ; ▁uint 32_ t ▁* lace _ size ▁= ▁NULL ; ▁int ▁n , ▁flags , ▁l aces ▁= ▁0; ▁uint 64_ t ▁num ; ▁int ▁stream _ index ; ▁/* ▁first ▁byte ( s ): ▁track num 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ vp 56 _ init _ range _ decoder ( VP 56 Range Coder ▁* c , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁c -> high ▁= ▁255 ; ▁c -> bits ▁= ▁- 16 ; ▁c -> buffer ▁= ▁buf ; ▁c -> end ▁= ▁buf ▁+ ▁buf _ size ; ▁c -> code _ word ▁= ▁by test ream _ get _ be 24 ( & c -> buffer ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v ring _ pop ( V irt IO Device ▁* v dev , ▁V ring ▁* v ring , ▁V irt Queue Element ▁** p _ elem ) ▁{ ▁struct ▁v ring _ desc ▁desc ; ▁unsigned ▁int ▁i , ▁head , ▁found ▁= ▁0, ▁num ▁= ▁v ring -> vr . num ; ▁uint 16_ t ▁avail _ idx , ▁last _ avail _ idx ; ▁V irt Queue Element ▁* elem ▁= ▁NULL ; ▁int ▁ret ; ▁/* ▁If ▁there ▁was ▁a ▁fatal ▁error ▁then ▁ref use ▁operation ▁*/ ▁if ▁( v ring -> broken ) ▁{ ▁ret ▁= ▁- E FAULT ; ▁goto ▁out ; ▁} ▁/* ▁Check ▁it ▁isn ' t ▁doing ▁very ▁strange ▁things ▁with ▁descr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ connect _ control _ connection ( URL Context ▁* h ) ▁{ ▁char ▁buf [ CONTROL _ BUFFER _ SIZE ], ▁opts _ format [ 20 ]; ▁int ▁err ; ▁AV Dictionary ▁* opts ▁= ▁NULL ; ▁FTP Context ▁* s ▁= ▁h -> priv _ data ; ▁const ▁int ▁connect _ codes [] ▁= ▁{2 20, ▁0 }; ▁s -> conn _ control _ block _ flag ▁= ▁0; ▁if ▁(! s -> conn _ control ) ▁{ ▁ff _ url _ join ( buf , ▁sizeof ( buf ), ▁" tcp ", ▁NULL , ▁s -> hostname , ▁s -> server _ control _ port , ▁NULL ); ▁if ▁( s -> rw _ timeout ▁!= ▁-1) ▁{ ▁sn p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q pc i _ mem read ( Q PC ID evice ▁* dev , ▁void ▁* data , ▁void ▁* buf , ▁size _ t ▁len ) ▁{ ▁uint ptr _ t ▁addr ▁= ▁( uint ptr _ t ) data ; ▁g _ assert ( addr ▁>= ▁Q PC I _ PIO _ LIMIT ); ▁dev -> bus -> mem read ( dev -> bus , ▁addr , ▁buf , ▁len ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁is _ in tra _ more _ likely ( ER Context ▁* s ) ▁{ ▁int ▁is _ in tra _ likely , ▁i , ▁j , ▁und am aged _ count , ▁skip _ amount , ▁mb _ x , ▁mb _ y ; ▁if ▁(! s -> last _ pic . f ▁|| ▁! s -> last _ pic . f -> data [0]) ▁return ▁1; ▁// ▁no ▁previous ▁frame ▁available ▁-> ▁use ▁spatial ▁prediction ▁und am aged _ count ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> mb _ num ; ▁i ++) ▁{ ▁const ▁int ▁mb _ xy ▁= ▁s -> mb _ index 2 xy [ i ]; ▁const ▁int ▁error ▁= ▁s -> error _ status _ table [ mb _ xy ]; ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁Release ( void ▁* ctx ) ▁{ ▁Context Info ▁* ci ; ▁ci ▁= ▁( Context Info ▁* ) ▁ctx ; ▁if ▁( ci -> cache ) ▁{ ▁im lib _ context _ set _ image ( ci -> cache -> image ); ▁im lib _ free _ image (); ▁av _ free ( ci -> cache ); ▁} ▁if ▁( ctx ) ▁{ ▁if ▁( ci -> image Over la id ) ▁{ ▁im lib _ context _ set _ image ( ci -> image Over la id ); ▁im lib _ free _ image (); ▁} ▁ff _ eval _ free ( ci -> expr _ x ); ▁ff _ eval _ free ( ci -> expr _ y ); ▁ff _ eval _ free ( ci -> expr _ R ); ▁ff _ eval _ free ( ci -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ a io _ flush ( void ) ▁{ ▁A io Handler ▁* node ; ▁int ▁ret ; ▁do ▁{ ▁ret ▁= ▁0; ▁/* ▁* ▁If ▁there ▁are ▁pending ▁em ulated ▁aio ▁start ▁them ▁now ▁so ▁flush ▁* ▁will ▁be ▁able ▁to ▁return ▁1. ▁*/ ▁qemu _ a io _ wait (); ▁LIST _ FORE A CH ( node , ▁& a io _ handlers , ▁node ) ▁{ ▁ret ▁|= ▁node -> io _ flush ( node -> op aque ); ▁} ▁} ▁while ▁( ret ▁> ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁quantize _ and _ encode _ band _ cost _ ZERO _ m ips ( struct ▁A AC Enc Context ▁* s , ▁Put Bit Context ▁* pb , ▁const ▁float ▁* in , ▁float ▁* out , ▁const ▁float ▁* scaled , ▁int ▁size , ▁int ▁scale _ idx , ▁int ▁cb , ▁const ▁float ▁lambda , ▁const ▁float ▁u pl im , ▁int ▁* bits , ▁const ▁float ▁ROUND ING ) ▁{ ▁int ▁i ; ▁if ▁( bits ) ▁* bits ▁= ▁0; ▁if ▁( out ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁size ; ▁i ▁+= ▁4) ▁{ ▁out [ i ▁] ▁= ▁0.0 f ; ▁out [ i +1] ▁= ▁0.0 f ; ▁out [ i + 2] ▁= ▁0.0 f ; ▁out [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁xen _ platform _ init fn ( PC ID evice ▁* dev ) ▁{ ▁P CI X en Platform State ▁* d ▁= ▁X EN _ PL ATFORM ( dev ); ▁uint 8_ t ▁* pc i _ conf ; ▁pci _ conf ▁= ▁dev -> config ; ▁pci _ set _ word ( pc i _ conf ▁+ ▁P CI _ COMMAND , ▁P CI _ COMMAND _ IO ▁| ▁P CI _ COMMAND _ MEMORY ); ▁pci _ config _ set _ prog _ interface ( pc i _ conf , ▁0); ▁pci _ conf [ PC I _ INTER R UP T _ P IN ] ▁= ▁1; ▁platform _ i op ort _ bar _ setup ( d ); ▁pci _ register _ bar ( dev , ▁0, ▁P CI _ BASE _ ADDRESS _ SPACE _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mmap _ release _ buffer ( AV Packet ▁* pk t ) ▁{ ▁struct ▁v 4 l 2_ buffer ▁buf ; ▁int ▁res , ▁fd ; ▁struct ▁buff _ data ▁* buf _ descriptor ▁= ▁pkt -> priv ; ▁if ▁( pk t -> data ▁== ▁NULL ) ▁return ; ▁mem set ( & buf , ▁0, ▁sizeof ( struct ▁v 4 l 2_ buffer )); ▁buf . type ▁= ▁V 4 L 2_ BU F _ TYPE _ VI DEO _ CAP T URE ; ▁buf . memory ▁= ▁V 4 L 2_ MEMORY _ MM AP ; ▁buf . index ▁= ▁buf _ descriptor -> index ; ▁fd ▁= ▁buf _ descriptor -> fd ; ▁av _ free ( buf _ descriptor ); ▁res ▁= ▁io ctl ( f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁coroutine _ fn ▁c 1_ fn ( void ▁* op aque ) ▁{ ▁Cor outine ▁* c 2 ▁= ▁opaque ; ▁qemu _ cor outine _ enter ( c 2, ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write _ target _ commit ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁const ▁uint 8_ t * ▁buffer , ▁int ▁nb _ sect ors ) ▁{ ▁B DR V V V F AT State * ▁s ▁= ▁bs -> op aque ; ▁return ▁try _ commit ( s ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁show _ pack ets ( AV Format Context ▁* fmt _ ctx ) ▁{ ▁AV Packet ▁pkt ; ▁av _ init _ packet ( & pk t ); ▁probe _ array _ header (" pack ets ", ▁0); ▁while ▁(! av _ read _ frame ( fmt _ ctx , ▁& pk t )) ▁show _ packet ( fmt _ ctx , ▁& pk t ); ▁probe _ array _ footer (" pack ets ", ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd h ci _ write _ data port ( SD H CI State ▁* s , ▁uint 32_ t ▁value , ▁unsigned ▁size ) ▁{ ▁unsigned ▁i ; ▁/* ▁Check ▁that ▁there ▁is ▁free ▁space ▁left ▁in ▁a ▁buffer ▁*/ ▁if ▁(! ( s -> pr n st s ▁& ▁SD H C _ SPACE _ AVAILABLE )) ▁{ ▁ERR PRI NT (" Can ' t ▁write ▁to ▁data ▁buffer : ▁buffer ▁full \ n "); ▁return ; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁size ; ▁i ++) ▁{ ▁s -> f ifo _ buffer [ s -> data _ count ] ▁= ▁value ▁& ▁0 xFF ; ▁s -> data _ count ++; ▁value ▁>>= ▁8 ; ▁if ▁( s -> data _ count ▁>=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁o map _ ul pd _ pm _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁struct ▁o map _ mp u _ state _ s ▁* s ▁= ▁( struct ▁o map _ mp u _ state _ s ▁* ) ▁opaque ; ▁uint 16_ t ▁ret ; ▁if ▁( size ▁!= ▁2) ▁{ ▁return ▁o map _ bad width _ read 16 ( op aque , ▁addr ); ▁} ▁switch ▁( addr ) ▁{ ▁case ▁0 x 14 : ▁/* ▁IT _ STATUS ▁*/ ▁ret ▁= ▁s -> ul pd _ pm _ re gs [ addr ▁>> ▁2 ]; ▁s -> ul pd _ pm _ re gs [ addr ▁>> ▁2] ▁= ▁0; ▁qemu _ irq _ lower ( s -> irq [1] [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mil k ym ist _ mem card _ init ( Sys Bus Device ▁* dev ) ▁{ ▁M il k ym ist Mem card State ▁* s ▁= ▁M IL K Y MI ST _ ME MC ARD ( dev ); ▁Drive Info ▁* d info ; ▁Block Driver State ▁* bs ; ▁d info ▁= ▁drive _ get _ next ( IF _ SD ); ▁bs ▁= ▁d info ▁? ▁blk _ bs ( blk _ by _ legacy _ d info ( d info )) ▁: ▁NULL ; ▁s -> card ▁= ▁sd _ init ( bs , ▁false ); ▁if ▁( s -> card ▁== ▁NULL ) ▁{ ▁return ▁-1; ▁} ▁s -> enabled ▁= ▁bs ▁&& ▁b dr v _ is _ insert ed ( bs ); ▁memory _ region _ init _ io ( & s ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁visitor _ output _ setup _ internal ( Test Output Visitor Data ▁* data , ▁bool ▁human ) ▁{ ▁data -> human ▁= ▁human ; ▁data -> so v ▁= ▁string _ output _ visitor _ new ( human ); ▁g _ assert ( data -> so v ); ▁data -> ov ▁= ▁string _ output _ get _ visitor ( data -> so v ); ▁g _ assert ( data -> ov ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ ri ff ( AV Format Context ▁* s , ▁AV IO Context ▁* pb ) ▁{ ▁A VI Context ▁* avi ▁= ▁s -> priv _ data ; ▁char ▁header [ 8 ]; ▁int ▁i ; ▁/* ▁check ▁RI FF ▁header ▁*/ ▁av io _ read ( pb , ▁header , ▁4 ); ▁av i -> ri ff _ end ▁= ▁av io _ rl 32 ( pb ); ▁/* ▁RI FF ▁chunk ▁size ▁*/ ▁av i -> ri ff _ end ▁+= ▁av io _ t ell ( pb ); ▁/* ▁RI FF ▁chunk ▁end ▁*/ ▁av io _ read ( pb , ▁header + 4, ▁4 ); ▁for ( i =0; ▁av i _ headers [ i ] [0]; ▁i ++) ▁if (! mem cmp ( header , ▁av i _ headers [ i ], ▁8 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁_ eth _ get _ rss _ ex _ src _ addr ( const ▁struct ▁i ove c ▁* pk t , ▁int ▁pkt _ f rag s , ▁size _ t ▁dst hdr _ offset , ▁struct ▁ip 6_ ext _ hdr ▁* ext _ hdr , ▁struct ▁in 6_ address ▁* src _ addr ) ▁{ ▁size _ t ▁bytes _ left ▁= ▁( ext _ hdr -> ip 6 r _ len ▁+ ▁1) ▁* ▁8 ▁- ▁sizeof (* ext _ hdr ); ▁struct ▁ip 6_ option _ hdr ▁opt hdr ; ▁size _ t ▁opt _ offset ▁= ▁dst hdr _ offset ▁+ ▁sizeof (* ext _ hdr ); ▁while ▁( bytes _ left ▁> ▁sizeof ( o pth dr )) ▁{ ▁size _ t ▁input _ size ▁= ▁i ov _ size ( pk t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁alt ive c _ uy vy _ rgb 32 ▁( Sw s Context ▁* c , ▁unsigned ▁char ▁** in , ▁int ▁* in str ides , ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁unsigned ▁char ▁** o plan es , ▁int ▁* out str ides ) ▁{ ▁int ▁w ▁= ▁c -> src W ; ▁int ▁h ▁= ▁src Slice H ; ▁int ▁i , j ; ▁vector ▁unsigned ▁char ▁u y vy ; ▁vector ▁signed ▁short ▁Y , U , V ; ▁vector ▁signed ▁short ▁vx , ux , uv x ; ▁vector ▁signed ▁short ▁R 0, G 0, B 0, R 1, G 1, B 1; ▁vector ▁unsigned ▁char ▁R , G , B ; ▁vector ▁unsigned ▁char ▁* out ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁inc _ ref counts ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁uint 16_ t ▁* refcount _ table , ▁int ▁ref count _ table _ size , ▁int 64_ t ▁offset , ▁int 64_ t ▁size ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁start , ▁last , ▁cluster _ offset , ▁k ; ▁if ▁( size ▁<= ▁0) ▁return ; ▁start ▁= ▁start _ of _ cluster ( s , ▁offset ); ▁last ▁= ▁start _ of _ cluster ( s , ▁offset ▁+ ▁size ▁- ▁1); ▁for ( cluster _ offset ▁= ▁start ; ▁cluster _ offset ▁<= ▁last ; ▁c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st w _ ph ys ( target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁uint 16_ t ▁v ▁= ▁t swap 16 ( val ); ▁cpu _ ph ysical _ memory _ write ( addr , ▁( const ▁uint 8_ t ▁* ) & v , ▁2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ branch ( Dis as Context ▁* ctx , ▁int ▁insn _ bytes ) ▁{ ▁if ▁( ctx -> h flags ▁& ▁M IP S _ H FLAG _ B MASK ) ▁{ ▁int ▁proc _ h flags ▁= ▁ctx -> h flags ▁& ▁M IP S _ H FLAG _ B MASK ; ▁/* ▁Branch es ▁completion ▁*/ ▁ctx -> h flags ▁&= ▁~ M IP S _ H FLAG _ B MASK ; ▁ctx -> b state ▁= ▁BS _ BR ANCH ; ▁save _ cpu _ state ( ctx , ▁0); ▁/* ▁FIX ME : ▁Need ▁to ▁clear ▁can _ do _ io . ▁*/ ▁switch ▁( proc _ h flags ▁& ▁M IP S _ H FLAG _ B MASK _ BASE ) ▁{ ▁case ▁M IP S _ H FLAG _ FB NS L OT :

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sl ir p _ cleanup ( Sl ir p ▁* sl ir p ) ▁{ ▁TA IL Q _ REMOVE ( & sl ir p _ instances , ▁sl ir p , ▁entry ); ▁unregister _ save vm (" sl ir p ", ▁sl ir p ); ▁qemu _ free ( sl ir p -> tf tp _ prefix ); ▁qemu _ free ( sl ir p -> boot p _ filename ); ▁qemu _ free ( sl ir p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sc si _ req _ abort ( SC SI Request ▁* req , ▁int ▁status ) ▁{ ▁if ▁(! req -> en queued ) ▁{ ▁return ; ▁} ▁sc si _ req _ ref ( req ); ▁sc si _ req _ de queue ( req ); ▁req -> io _ cancel ed ▁= ▁true ; ▁if ▁( req -> ops -> cancel _ io ) ▁{ ▁req -> ops -> cancel _ io ( req ); ▁} ▁sc si _ req _ complete ( req , ▁status ); ▁sc si _ req _ un ref ( req ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁r dt _ free _ ex tr ad ata ▁( Payload Context ▁* r dt ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁MAX _ ST RE AMS ; ▁i ++) ▁if ▁( r dt -> rm st [ i ]) ▁{ ▁ff _ rm _ free _ rm stream ( r dt -> rm st [ i ]); ▁av _ fre ep ( & r dt -> rm st [ i ]); ▁} ▁if ▁( r dt -> rm ctx ) ▁av _ close _ input _ stream ( r dt -> rm ctx ); ▁av _ fre ep ( & r dt -> ml ti _ data ); ▁av _ free ( r dt ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ ds dt ( G Array ▁* table _ data , ▁G Array ▁* link er , ▁Ac pi Pm Info ▁* pm , ▁Ac pi M isc Info ▁* misc , ▁P c P ci Info ▁* pc i , ▁Machine State ▁* machine ) ▁{ ▁C rs Range Entry ▁* entry ; ▁A ml ▁* ds dt , ▁* sb _ scope , ▁* scope , ▁* dev , ▁* method , ▁* field , ▁* pkg , ▁* cr s ; ▁G Ptr Array ▁* mem _ ranges ▁= ▁g _ ptr _ array _ new _ with _ free _ func ( cr s _ range _ free ); ▁G Ptr Array ▁* io _ ranges ▁= ▁g _ ptr _ array _ new _ with _ free _ func ( cr s _ range _ free ); ▁PC Machine S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁arm _ cpu _ do _ interrupt _ a arch 64 ( CPU State ▁* cs ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁ARM _ CPU ( cs ); ▁CPU ARM State ▁* env ▁= ▁& cpu -> env ; ▁unsigned ▁int ▁new _ el ▁= ▁env -> exception . target _ el ; ▁target _ ulong ▁addr ▁= ▁env -> cp 15. v bar _ el [ new _ el ]; ▁unsigned ▁int ▁new _ mode ▁= ▁a arch 64_ p state _ mode ( new _ el , ▁true ); ▁if ▁( arm _ current _ el ( env ) ▁< ▁new _ el ) ▁{ ▁if ▁( env -> a arch 64) ▁{ ▁addr ▁+= ▁0 x 400 ; ▁} ▁else ▁{ ▁addr ▁+= ▁0 x 600 ; ▁} ▁} ▁else ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁pc _ machine _ get _ nv dim m ( Object ▁* obj , ▁Error ▁** err p ) ▁{ ▁PC Machine State ▁* pc ms ▁= ▁PC _ MA CHINE ( obj ); ▁return ▁pc ms -> nv dim m ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ header ( G Array ▁* link er , ▁G Array ▁* table _ data , ▁Ac pi Table Header ▁* h , ▁const ▁char ▁* sig , ▁int ▁len , ▁uint 8_ t ▁rev , ▁const ▁char ▁* o em _ table _ id ) ▁{ ▁mem c py ( & h -> signature , ▁sig , ▁4 ); ▁h -> length ▁= ▁cpu _ to _ le 32 ( len ); ▁h -> revision ▁= ▁rev ; ▁mem c py ( h -> o em _ id , ▁AC PI _ BUILD _ APP NAME 6, ▁6 ); ▁if ▁( o em _ table _ id ) ▁{ ▁str nc py (( char ▁* ) h -> o em _ table _ id , ▁o em _ table _ id , ▁sizeof ( h -> o em _ table _ id )); ▁} ▁else ▁{ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ quant _ table ( Range Coder ▁* c , ▁int 16_ t ▁* quant _ table , ▁int ▁scale ) ▁{ ▁int ▁v ; ▁int ▁i ▁= ▁0; ▁uint 8_ t ▁state [ CONTEXT _ SIZE ]; ▁mem set ( state , ▁12 8, ▁sizeof ( state )); ▁for ▁( v ▁= ▁0; ▁i ▁< ▁128 ; ▁v ++) ▁{ ▁unsigned ▁len ▁= ▁get _ symbol ( c , ▁state , ▁0) ▁+ ▁1; ▁if ▁( len ▁> ▁128 ▁- ▁i ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁while ▁( len --) ▁{ ▁quant _ table [ i ] ▁= ▁scale ▁* ▁v ; ▁i ++; ▁} ▁} ▁for ▁( i ▁= ▁1; ▁i ▁< ▁128 ; ▁i ++) ▁quant _ table [ 256 ▁- 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁tb _ un re liable ( AV Codec Context ▁* c ) ▁{ ▁if ▁( c -> time _ base . den ▁>= ▁101 L ▁* ▁c -> time _ base . num ▁|| ▁c -> time _ base . den ▁< ▁5 L ▁* ▁c -> time _ base . num ▁|| ▁// ▁c -> codec _ tag ▁== ▁AV _ RL 32 (" DIV X ") ▁|| ▁// ▁c -> codec _ tag ▁== ▁AV _ RL 32 (" X V ID ") ▁|| ▁c -> codec _ id ▁== ▁AV _ CODE C _ ID _ M PEG 2 VI DEO ▁|| ▁c -> codec _ id ▁== ▁AV _ CODE C _ ID _ H 2 64) ▁return ▁1; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sw r _ init ( struct ▁Sw r Context ▁* s ){ ▁s -> in _ buffer _ index = ▁0; ▁s -> in _ buffer _ count = ▁0; ▁s -> res ample _ in _ constraint = ▁0; ▁free _ temp ( & s -> post in ); ▁free _ temp ( & s -> mid buf ); ▁free _ temp ( & s -> pre out ); ▁free _ temp ( & s -> in _ buffer ); ▁sw ri _ audio _ convert _ free ( & s -> ▁in _ convert ); ▁sw ri _ audio _ convert _ free ( & s -> out _ convert ); ▁sw ri _ audio _ convert _ free ( & s -> full _ convert ); ▁s -> ▁in . plan ar = ▁av _ sample _ fmt _ is 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sv q 1_ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁MP V _ decode _ defaults ( s ); ▁s -> av ctx ▁= ▁av ctx ; ▁s -> width ▁= ▁( av ctx -> width + 3) & ~ 3; ▁s -> height ▁= ▁( av ctx -> height + 3) & ~ 3; ▁s -> codec _ id = ▁av ctx -> codec -> id ; ▁av ctx -> pix _ fmt ▁= ▁PI X _ F MT _ Y UV 4 10 P ; ▁av ctx -> has _ b _ frames = ▁1; ▁// ▁not ▁true , ▁but ▁D P ▁frames ▁and ▁these ▁behave ▁like ▁un id irectional ▁b ▁frames ▁s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rm _ read _ audio _ stream _ info ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Stream ▁* st , ▁RM Stream ▁* ast , ▁int ▁read _ all ) ▁{ ▁char ▁buf [ 256 ]; ▁uint 32_ t ▁version ; ▁int ▁ret ; ▁/* ▁ra ▁type ▁header ▁*/ ▁version ▁= ▁av io _ rb 16 ( pb ); ▁/* ▁version ▁*/ ▁if ▁( version ▁== ▁3) ▁{ ▁unsigned ▁bytes _ per _ minute ; ▁int ▁header _ size ▁= ▁av io _ rb 16 ( pb ); ▁int 64_ t ▁start pos ▁= ▁av io _ t ell ( pb ); ▁av io _ skip ( pb , ▁8 ); ▁bytes _ per _ minute ▁= ▁av io _ rb 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁show _ license ( void ▁* opt ctx , ▁const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁printf ( ▁# if ▁CONFIG _ NON F REE ▁" This ▁version ▁of ▁% s ▁has ▁non free ▁parts ▁compiled ▁in .\ n " ▁" Th erefore ▁it ▁is ▁not ▁leg ally ▁red ist rib utable .\ n ", ▁program _ name ▁# el if ▁CONFIG _ G PL V 3 ▁"% s ▁is ▁free ▁software ; ▁you ▁can ▁red ist ribute ▁it ▁and / or ▁modify \ n " ▁" it ▁under ▁the ▁terms ▁of ▁the ▁GNU ▁General ▁Public ▁License ▁as ▁published ▁by \ n " ▁" the ▁Free ▁Software ▁Foundation ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ rt sp _ make _ setup _ request ( AV Format Context ▁* s , ▁const ▁char ▁* host , ▁int ▁port , ▁int ▁lower _ transport , ▁const ▁char ▁* real _ challenge ) ▁{ ▁RT SP State ▁* rt ▁= ▁s -> priv _ data ; ▁int ▁r tx ▁= ▁0, ▁j , ▁i , ▁err , ▁inter leave ▁= ▁0, ▁port _ off ; ▁RT SP Stream ▁* rt sp _ st ; ▁RT SP Message Header ▁reply 1, ▁* reply ▁= ▁& reply 1; ▁char ▁cmd [ 20 48 ]; ▁const ▁char ▁* trans _ pref ; ▁if ▁( rt -> transport ▁== ▁RT SP _ TRAN SPORT _ R DT ) ▁trans _ pref ▁= ▁" x - pn - t ng "

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ fm tp ( AV Format Context ▁* s , ▁AV Stream ▁* stream , ▁Payload Context ▁* data , ▁const ▁char ▁* attr , ▁const ▁char ▁* value ) ▁{ ▁AV Codec Parameters ▁* par ▁= ▁stream -> codec par ; ▁int ▁res , ▁i ; ▁if ▁(! str cmp ( attr , ▁" config ")) ▁{ ▁res ▁= ▁parse _ fm tp _ config ( par , ▁value ); ▁if ▁( res ▁< ▁0) ▁return ▁res ; ▁} ▁if ▁( par -> codec _ id ▁== ▁AV _ CODE C _ ID _ A AC ) ▁{ ▁/* ▁Looking ▁for ▁a ▁known ▁attribute ▁*/ ▁for ▁( i ▁= ▁0; ▁attr _ names [ i ]. str ; ▁++ i ) ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ff server _ set _ int _ param ( int ▁* dest , ▁const ▁char ▁* value , ▁int ▁factor , ▁int ▁min , ▁int ▁max , ▁FF Server Config ▁* config , ▁const ▁char ▁* error _ msg , ▁...) ▁{ ▁int ▁tmp ; ▁char ▁* tail p ; ▁if ▁(! value ▁|| ▁! value [0]) ▁goto ▁error ; ▁errno ▁= ▁0; ▁tmp ▁= ▁str tol ( value , ▁& tail p , ▁0); ▁if ▁( tmp ▁< ▁min ▁|| ▁tmp ▁> ▁max ) ▁goto ▁error ; ▁if ▁( factor ) ▁{ ▁if ▁( FF AB S ( tmp ) ▁> ▁INT _ MAX ▁/ ▁FF AB S ( factor )) ▁goto ▁error ; ▁tmp ▁*= ▁factor ; ▁} ▁if ▁( tail p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁find _ tag ( AV IO Context ▁* pb , ▁uint 32_ t ▁tag 1) ▁{ ▁unsigned ▁int ▁tag ; ▁int 64_ t ▁size ; ▁for ▁( ; ;) ▁{ ▁if ▁( url _ fe of ( pb )) ▁return ▁A VER ROR _ EOF ; ▁size ▁= ▁next _ tag ( pb , ▁& tag ); ▁if ▁( tag ▁== ▁tag 1) ▁break ; ▁wav _ seek _ tag ( pb , ▁size , ▁SE EK _ CUR ); ▁} ▁return ▁size ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ float _ d sp _ init _ x 86 ( AV Float DS P Context ▁* fd sp ) ▁{ ▁int ▁cpu _ flags ▁= ▁av _ get _ cpu _ flags (); ▁# if ▁HAVE _6 REG S ▁&& ▁HAVE _ IN LINE _ AS M ▁if ▁( IN LINE _ AM D 3 D NOW EXT ( cpu _ flags )) ▁{ ▁fd sp -> vector _ f mul _ window ▁= ▁vector _ f mul _ window _3 d now ext ; ▁} ▁if ▁( IN LINE _ SS E ( cpu _ flags )) ▁{ ▁fd sp -> vector _ f mul _ window ▁= ▁vector _ f mul _ window _ s se ; ▁} ▁# end if ▁if ▁( EXTERNAL _ SS E ( cpu _ flags )) ▁{ ▁fd sp -> vector _ f 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁o map 2_ in th _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁struct ▁o map _ in tr _ handler _ s ▁* s ▁= ▁( struct ▁o map _ in tr _ handler _ s ▁* ) ▁opaque ; ▁int ▁offset ▁= ▁addr ; ▁int ▁bank _ no , ▁line _ no ; ▁struct ▁o map _ in tr _ handler _ bank _ s ▁* bank ▁= ▁NULL ; ▁if ▁(( offset ▁& ▁0 xf 80) ▁== ▁0 x 80) ▁{ ▁bank _ no ▁= ▁( offset ▁& ▁0 x 60 ) ▁>> ▁5; ▁if ▁( bank _ no ▁< ▁s -> nb anks ) ▁{ ▁offset ▁&= ▁~ 0 x 60 ; ▁bank ▁= ▁& s -> bank 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁get _ limits ( M peg Enc Context ▁* s , ▁int ▁* range , ▁int ▁* x min , ▁int ▁* y min , ▁int ▁* x max , ▁int ▁* y max , ▁int ▁f _ code ) ▁{ ▁* range ▁= ▁8 ▁* ▁(1 ▁<< ▁( f _ code ▁- ▁1 )); ▁/* ▁XXX : ▁temporary ▁kl udge ▁to ▁avoid ▁overflow ▁for ▁ms mpeg 4 ▁*/ ▁if ▁( s -> out _ format ▁== ▁F MT _ H 26 3 ▁&& ▁! s -> h 26 3_ ms mpeg 4) ▁* range ▁*= ▁2; ▁if ▁( s -> un restrict ed _ mv ) ▁{ ▁* x min ▁= ▁- 16 ; ▁* y min ▁= ▁- 16 ; ▁if ▁( s -> h 26 3_ plus ) ▁* range ▁*= ▁2; ▁if ( s -> av 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁device _ try _ init ( AV Format Context ▁* ctx , ▁enum ▁AV Pixel Format ▁pix _ fmt , ▁int ▁* width , ▁int ▁* height , ▁uint 32_ t ▁* des ired _ format , ▁enum ▁AV Codec ID ▁* codec _ id ) ▁{ ▁int ▁ret , ▁i ; ▁* des ired _ format ▁= ▁av priv _ fmt _ ff 2 v 4 l ( pix _ fmt , ▁ctx -> video _ codec _ id ); ▁if ▁(* des ired _ format ) ▁{ ▁ret ▁= ▁device _ init ( ctx , ▁width , ▁height , ▁* des ired _ format ); ▁if ▁( ret ▁< ▁0) ▁{ ▁* des ired _ format ▁= ▁0; ▁if ▁( ret ▁!= ▁A VER ROR ( E IN VAL )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l si _ soft _ reset ( L SI State ▁* s ) ▁{ ▁l si _ request ▁* p ; ▁D PRI NT F (" Reset \ n "); ▁s -> car ry ▁= ▁0; ▁s -> msg _ action ▁= ▁0; ▁s -> msg _ len ▁= ▁0; ▁s -> waiting ▁= ▁0; ▁s -> ds a ▁= ▁0; ▁s -> dn ad ▁= ▁0; ▁s -> dbc ▁= ▁0; ▁s -> temp ▁= ▁0; ▁mem set ( s -> scr atch , ▁0, ▁sizeof ( s -> scr atch )); ▁s -> ist at 0 ▁= ▁0; ▁s -> ist at 1 ▁= ▁0; ▁s -> d cmd ▁= ▁0 x 40 ; ▁s -> d stat ▁= ▁L SI _ D STAT _ DF E ; ▁s -> di en ▁= ▁0; ▁s -> s ist 0 ▁= ▁0; ▁s -> s ist 1 ▁= ▁0; ▁s -> si 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m cl ms _ predict ( W mall Decode Ctx ▁* s , ▁int ▁i coef , ▁int ▁* pred ) ▁{ ▁int ▁i ch , ▁i ; ▁int ▁order ▁= ▁s -> m cl ms _ order ; ▁int ▁num _ channels ▁= ▁s -> num _ channels ; ▁for ▁( ich ▁= ▁0; ▁i ch ▁< ▁num _ channels ; ▁i ch ++) ▁{ ▁pred [ ich ] ▁= ▁0; ▁if ▁(! s -> is _ channel _ coded [ ich ]) ▁continue ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁order ▁* ▁num _ channels ; ▁i ++) ▁pred [ ich ] ▁+= ▁s -> m cl ms _ prev values [ i ▁+ ▁s -> m cl ms _ recent ] ▁* ▁s -> m cl ms _ coeff s [ i ▁+ ▁order ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ d py _ copy ( Display State ▁* ds , ▁int ▁src _ x , ▁int ▁src _ y , ▁int ▁dst _ x , ▁int ▁dst _ y , ▁int ▁w , ▁int ▁h ) ▁{ ▁V nc Display ▁* vd ▁= ▁ds -> op aque ; ▁V nc State ▁* vs ▁= ▁v d -> clients ; ▁while ▁( vs ▁!= ▁NULL ) ▁{ ▁if ▁( vn c _ has _ feature ( vs , ▁V NC _ FEATURE _ COPY RECT )) ▁v nc _ copy ( vs , ▁src _ x , ▁src _ y , ▁dst _ x , ▁dst _ y , ▁w , ▁h ); ▁else ▁/* ▁TODO ▁*/ ▁v nc _ update ( vs , ▁dst _ x , ▁dst _ y , ▁w , ▁h ); ▁vs ▁= ▁vs -> next ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁em ulated _ exit fn ( CC ID Card State ▁* base ) ▁{ ▁Em ulated State ▁* card ▁= ▁DO _ UP CAST ( Em ulated State , ▁base , ▁base ); ▁V Event ▁* ve vent ▁= ▁v event _ new ( VE VENT _ LAST , ▁NULL , ▁NULL ); ▁v event _ queue _ ve vent ( ve vent ); ▁/* ▁stop ▁v event ▁thread ▁*/ ▁qemu _ mut ex _ lock ( & card -> ap du _ thread _ quit _ mut ex ); ▁card -> quit _ ap du _ thread ▁= ▁1; ▁/* ▁stop ▁handle _ ap du ▁thread ▁*/ ▁qemu _ cond _ signal ( & card -> handle _ ap du _ cond ); ▁qemu _ cond _ wa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁get _ chrom a _ qp ( H 264 Context ▁* h , ▁int ▁q scale ){ ▁return ▁h -> pp s . chrom a _ qp _ table [ q scale ▁& ▁0 xff ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁A AC _ RE NAME ( ff _ ps _ read _ data )( AV Codec Context ▁* av ctx , ▁Get Bit Context ▁* gb _ host , ▁PS Context ▁* ps , ▁int ▁bits _ left ) ▁{ ▁int ▁e ; ▁int ▁bit _ count _ start ▁= ▁get _ bits _ count ( gb _ host ); ▁int ▁header ; ▁int ▁bits _ consumed ; ▁Get Bit Context ▁gbc ▁= ▁* gb _ host , ▁* gb ▁= ▁& gb c ; ▁header ▁= ▁get _ bits 1( gb ); ▁if ▁( header ) ▁{ ▁// enable _ ps _ header ▁ps -> enable _ i id ▁= ▁get _ bits 1( gb ); ▁if ▁( ps -> enable _ i id ) ▁{ ▁int ▁iid _ mode ▁= ▁get _ bits (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ g ab 2_ sub ( AV Format Context ▁* s , ▁AV Stream ▁* st , ▁AV Packet ▁* pk t ) ▁{ ▁if ▁( pk t -> size ▁>= ▁7 ▁&& ▁pkt -> size ▁< ▁INT _ MAX ▁- ▁AV PRO BE _ P ADDING _ SIZE ▁&& ▁! str cmp ( pk t -> data , ▁" G AB 2") ▁&& ▁AV _ RL 16 ( pk t -> data ▁+ ▁5) ▁== ▁2) ▁{ ▁uint 8_ t ▁desc [ 256 ]; ▁int ▁score ▁= ▁AV PRO BE _ S CORE _ EXTENSION , ▁ret ; ▁A VI Stream ▁* ast ▁= ▁st -> priv _ data ; ▁AV InputFormat ▁* sub _ dem ux er ; ▁AV R ational ▁time _ base ; ▁int ▁size ; ▁AV IO Context ▁* p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q virt io _ pc i _ device _ enable ( Q V irt io PC ID evice ▁* d ) ▁{ ▁q pc i _ device _ enable ( d -> pd ev ); ▁d -> addr ▁= ▁q pc i _ iom ap ( d -> pd ev , ▁0, ▁NULL ); ▁g _ assert ( d -> addr ▁!= ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁movie _ request _ frame ( AV Filter Link ▁* out link ) ▁{ ▁AV Filter Buffer Ref ▁* out pic ref ; ▁Movie Context ▁* movie ▁= ▁out link -> src -> priv ; ▁int ▁ret ; ▁if ▁( movie -> is _ done ) ▁return ▁A VER ROR _ EOF ; ▁if ▁(( ret ▁= ▁movie _ get _ frame ( out link )) ▁< ▁0) ▁return ▁ret ; ▁out pic ref ▁= ▁av filter _ ref _ buffer ( movie -> pic ref , ▁~ 0); ▁ff _ start _ frame ( out link , ▁out pic ref ); ▁ff _ draw _ slice ( out link , ▁0, ▁out link -> h , ▁1); ▁ff _ end _ frame ( out link 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁process _ client ( AV IO Context ▁* client , ▁const ▁char ▁* in _ uri ) ▁{ ▁AV IO Context ▁* input ▁= ▁NULL ; ▁uint 8_ t ▁buf [10 24 ]; ▁int ▁ret , ▁n , ▁reply _ code ; ▁uint 8_ t ▁* resource ▁= ▁NULL ; ▁while ▁(( ret ▁= ▁av io _ handshake ( client )) ▁> ▁0) ▁{ ▁av _ opt _ get ( client , ▁" resource ", ▁AV _ OPT _ SEARCH _ CHILD REN , ▁& resource ); ▁// ▁check ▁for ▁str len ( resource ) ▁is ▁necessary , ▁because ▁av _ opt _ get () ▁// ▁may ▁return ▁empty ▁string . ▁if ▁( resource ▁&& ▁str l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁pred _ direct _ m otion ( H 264 Context ▁* ▁const ▁h , ▁int ▁* mb _ type ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁const ▁int ▁mb _ xy ▁= ▁s -> mb _ x ▁+ ▁s -> mb _ y * s -> mb _ stride ; ▁const ▁int ▁b 8_ xy ▁= ▁2* s -> mb _ x ▁+ ▁2* s -> mb _ y * h -> b 8_ stride ; ▁const ▁int ▁b 4_ xy ▁= ▁4 * s -> mb _ x ▁+ ▁4 * s -> mb _ y * h -> b _ stride ; ▁const ▁int ▁mb _ type _ col ▁= ▁h -> ref _ list [1] [0]. mb _ type [ mb _ xy ]; ▁const ▁int 16_ t ▁(* l 1 mv 0) [2] ▁= ▁( const 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b dr v _ q ed _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁B DR V Q ED State ▁* s ▁= ▁bs -> op aque ; ▁Q ED Header ▁le _ header ; ▁int 64_ t ▁file _ size ; ▁int ▁ret ; ▁s -> bs ▁= ▁bs ; ▁Q SI MPLE Q _ INIT ( & s -> alloc ating _ write _ reqs ); ▁ret ▁= ▁b dr v _ p read ( bs -> file , ▁0, ▁& le _ header , ▁sizeof ( le _ header )); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁q ed _ header _ le _ to _ cpu ( & le _ header , ▁& s -> header ); ▁if ▁( s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ put _ h 2 64_ qp el 8_ mc 3 1_ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ h v _ q rt _8 w _ ms a ( src ▁- ▁2, ▁src ▁- ▁( stride ▁* ▁2) ▁+ ▁sizeof ( uint 8_ t ), ▁stride , ▁dst , ▁stride , ▁8 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ pipe ( const ▁char ▁* id , ▁Ch ard ev Backend ▁* backend , ▁Ch ard ev Return ▁* ret , ▁Error ▁** err p ) ▁{ ▁Ch ard ev Host dev ▁* opts ▁= ▁backend -> u . pipe ; ▁const ▁char ▁* filename ▁= ▁opts -> device ; ▁Char Driver State ▁* chr ; ▁Win Char State ▁* s ; ▁chr ▁= ▁qemu _ chr _ alloc (); ▁s ▁= ▁g _ new 0( Win Char State , ▁1); ▁chr -> op aque ▁= ▁s ; ▁chr -> chr _ write ▁= ▁win _ chr _ write ; ▁chr -> chr _ close ▁= ▁win _ chr _ close ; ▁if ▁( win _ chr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁HEL PER ( cl z )( uint 32_ t ▁x ) ▁{ ▁int ▁count ; ▁for ▁( count ▁= ▁32 ; ▁x ; ▁count --) ▁x ▁>>= ▁1; ▁return ▁count ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ get _ fallback _ sm mu _ info ( Power PC CPU ▁* cpu , ▁struct ▁k vm _ pp c _ sm mu _ info ▁* info ) ▁{ ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁mem set ( info , ▁0, ▁sizeof (* info )); ▁/* ▁We ▁don ' t ▁have ▁the ▁new ▁K VM _ P PC _ GET _ S MM U _ INFO ▁io ctl , ▁so ▁* ▁need ▁to ▁" guess " ▁what ▁the ▁supported ▁page ▁sizes ▁are . ▁* ▁* ▁For ▁that ▁to ▁work ▁we ▁make ▁a ▁few ▁assumptions : ▁* ▁* ▁- ▁If ▁K VM _ CAP _ P PC _ GET _ P V INFO ▁is ▁suppo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ ire t _ protected ( int ▁shift ) ▁{ ▁helper _ ret _ protected ( shift , ▁1, ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ b h _ schedule ( Q EM UB H ▁* b h ) ▁{ ▁A io Context ▁* ctx ; ▁ctx ▁= ▁bh -> ctx ; ▁bh -> idle ▁= ▁0; ▁/* ▁The ▁memory ▁barrier ▁implicit ▁in ▁atomic _ x ch g ▁makes ▁sure ▁that : ▁* ▁1. ▁idle ▁& ▁any ▁writes ▁needed ▁by ▁the ▁callback ▁are ▁done ▁before ▁the ▁* ▁locations ▁are ▁read ▁in ▁the ▁aio _ b h _ poll . ▁* ▁2. ▁ctx ▁is ▁loaded ▁before ▁scheduled ▁is ▁set ▁and ▁the ▁callback ▁has ▁a ▁chance ▁* ▁to ▁execute . ▁*/ ▁if ▁( atomic _ x ch g ( & b h -> s cheduled , ▁1) ▁== ▁0) ▁{ ▁aio _ not

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Sp ice Timer ▁* timer _ add ( Sp ice Timer Func ▁func , ▁void ▁* op aque ) ▁{ ▁Sp ice Timer ▁* timer ; ▁timer ▁= ▁qemu _ m alloc z ( size of (* timer )); ▁timer -> timer ▁= ▁qemu _ new _ timer ( rt _ clock , ▁func , ▁opaque ); ▁Q TAIL Q _ INSERT _ TAIL ( & tim ers , ▁timer , ▁next ); ▁return ▁timer ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ virt io _ pc i _ v q _ vector _ use ( V irt IO PC I Proxy ▁* proxy , ▁unsigned ▁int ▁queue _ no , ▁unsigned ▁int ▁vector , ▁M SI Message ▁msg ) ▁{ ▁V irt Queue ▁* v q ▁= ▁virt io _ get _ queue ( proxy -> v dev , ▁queue _ no ); ▁Event Notifier ▁* n ▁= ▁virt io _ queue _ get _ guest _ notifier ( v q ); ▁V irt IO IR Q FD ▁* irq fd ▁= ▁& proxy -> vector _ irq fd [ vector ]; ▁int ▁ret ; ▁if ▁( irq fd -> users ▁== ▁0) ▁{ ▁ret ▁= ▁k vm _ irq ch ip _ add _ m si _ route ( k vm _ state , ▁msg )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁output _ packet ( InputStream ▁* ist , ▁OutputStream ▁* ost _ table , ▁int ▁nb _ ost ream s , ▁const ▁AV Packet ▁* pk t ) ▁{ ▁int ▁ret ▁= ▁0, ▁i ; ▁int ▁got _ output ; ▁int 64_ t ▁pkt _ pts ▁= ▁AV _ NO PT S _ VALUE ; ▁AV Packet ▁av pk t ; ▁if ▁( ist -> next _ d ts ▁== ▁AV _ NO PT S _ VALUE ) ▁ist -> next _ d ts ▁= ▁ist -> d ts ; ▁if ▁( ist -> next _ pts ▁== ▁AV _ NO PT S _ VALUE ) ▁ist -> next _ pts ▁= ▁ist -> pts ; ▁if ▁( pk t ▁== ▁NULL ) ▁{ ▁/* ▁EOF ▁handling ▁*/ ▁av _ init _ packet ( & av

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁search _ for _ quant izers _ an mr ( AV Codec Context ▁* av ctx , ▁A AC Enc Context ▁* s , ▁Single Channel Element ▁* s ce , ▁const ▁float ▁lambda ) ▁{ ▁int ▁q , ▁w , ▁w 2, ▁g , ▁start ▁= ▁0; ▁int ▁i , ▁j ; ▁int ▁idx ; ▁T re ll is Path ▁paths [ T REL LI S _ ST AGE S ][ T REL LI S _ STATE S ]; ▁int ▁band addr [ T REL LI S _ ST AGE S ]; ▁int ▁min q ; ▁float ▁min cost ; ▁float ▁q 0 f ▁= ▁F LT _ MAX , ▁q 1 f ▁= ▁0.0 f , ▁q nr g f ▁= ▁0.0 f ; ▁int ▁q 0, ▁q 1, ▁q cnt ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁<

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁create _ fixed _ disk ( int ▁fd , ▁uint 8_ t ▁* buf , ▁int 64_ t ▁total _ size ) ▁{ ▁int ▁ret ▁= ▁- E IO ; ▁/* ▁Add ▁footer ▁to ▁total ▁size ▁*/ ▁total _ size ▁+= ▁512 ; ▁if ▁( f truncate ( fd , ▁total _ size ) ▁!= ▁0) ▁{ ▁ret ▁= ▁- err no ; ▁goto ▁fail ; ▁} ▁if ▁( l seek ( fd , ▁-5 12, ▁SE EK _ END ) ▁< ▁0) ▁{ ▁goto ▁fail ; ▁} ▁if ▁( write ( fd , ▁buf , ▁HEADER _ SIZE ) ▁!= ▁HEADER _ SIZE ) ▁{ ▁goto ▁fail ; ▁} ▁ret ▁= ▁0; ▁fail : ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ read dir _ r ( Fs Context ▁* ctx , ▁V 9 fs F id Open State ▁* fs , ▁struct ▁dire nt ▁* entry , ▁struct ▁dire nt ▁** result ) ▁{ ▁return ▁read dir _ r ( fs -> dir , ▁entry , ▁result ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁z r le _ send _ frame buffer _ update ( V nc State ▁* vs , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h ) ▁{ ▁bool ▁be ▁= ▁!! ( vs -> client ds . flags ▁& ▁Q EM U _ B IG _ ENDIAN _ FLAG ); ▁size _ t ▁bytes ; ▁int ▁z y wr le _ level ; ▁if ▁( vs -> z r le . type ▁== ▁V NC _ ENCODING _ ZY WR LE ) ▁{ ▁if ▁(! vs -> vd -> loss y ▁|| ▁vs -> t ight . quality ▁< ▁0 ▁|| ▁vs -> t ight . quality ▁== ▁9 ) ▁{ ▁z y wr le _ level ▁= ▁0; ▁vs -> z r le . type ▁= ▁V NC _ ENCODING _ Z R LE ; ▁} ▁else ▁if ▁( vs -> t ig

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁mm io _ ide _ status _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁MM IO State ▁* s = ▁opaque ; ▁return ▁ide _ status _ read ( & s -> bus , ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ flush _ page ( CPU State ▁* env , ▁target _ ulong ▁addr ) ▁{ ▁int ▁i ; ▁# if ▁defined ( DEBUG _ TL B ) ▁printf (" tl b _ flush _ page : ▁" ▁TARGET _ F MT _ l x ▁"\ n ", ▁addr ); ▁# end if ▁/* ▁must ▁reset ▁current ▁TB ▁so ▁that ▁interrupt s ▁cannot ▁modify ▁the ▁links ▁while ▁we ▁are ▁modifying ▁them ▁*/ ▁env -> current _ tb ▁= ▁NULL ; ▁addr ▁&= ▁TARGET _ PAGE _ MASK ; ▁i ▁= ▁( addr ▁>> ▁TARGET _ PAGE _ BITS ) ▁& ▁( CPU _ TL B _ SIZE ▁- ▁1); ▁tl b _ flush _ entry ( & env -> tl b _ table [0] 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ slice _ thread _ free ( AV Codec Context ▁* av ctx ) ▁{ ▁Thread Context ▁* c ▁= ▁av ctx -> thread _ op aque ; ▁int ▁i ; ▁p thread _ mut ex _ lock ( & c -> current _ job _ lock ); ▁c -> done ▁= ▁1; ▁p thread _ cond _ broadcast ( & c -> current _ job _ cond ); ▁p thread _ mut ex _ un lock ( & c -> current _ job _ lock ); ▁for ▁( i =0; ▁i < av ctx -> thread _ count ; ▁i ++) ▁p thread _ join ( c -> workers [ i ], ▁NULL ); ▁p thread _ mut ex _ destroy ( & c -> current _ job _ lock ); ▁p thread _ co

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ass _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ sub _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁char ▁* ptr ▁= ▁av pk t -> data ; ▁int ▁len , ▁size ▁= ▁av pk t -> size ; ▁while ▁( size ▁> ▁0) ▁{ ▁ASS Dialog ▁* dialog ▁= ▁ff _ ass _ split _ dialog ( av ctx -> priv _ data , ▁ptr , ▁0, ▁NULL ); ▁int ▁duration ▁= ▁dialog -> end ▁- ▁dialog -> start ; ▁len ▁= ▁ff _ ass _ add _ rect ( data , ▁ptr , ▁0, ▁duration , ▁1); ▁if ▁( len ▁< ▁0) ▁return ▁len ; ▁ptr ▁+= ▁len 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁init _ blk _ migration ( Q EM U File ▁* f ) ▁{ ▁Block Driver State ▁* bs ; ▁Bl k Mig Dev State ▁* b md s ; ▁int 64_ t ▁sector s ; ▁B dr v Next Iterator ▁it ; ▁int ▁i , ▁num _ bs ▁= ▁0; ▁struct ▁{ ▁Bl k Mig Dev State ▁* b md s ; ▁Block Driver State ▁* bs ; ▁} ▁* b md s _ bs ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁block _ mig _ state . submitted ▁= ▁0; ▁block _ mig _ state . read _ done ▁= ▁0; ▁block _ mig _ state . transfer red ▁= ▁0; ▁block _ mig _ state . total _ sect or _ sum ▁= ▁0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁find _ dirty _ height ( V nc State ▁* vs , ▁int ▁y , ▁int ▁last _ x , ▁int ▁x ) ▁{ ▁int ▁h ; ▁for ▁( h ▁= ▁1; ▁h ▁< ▁( vs -> server ds . height ▁- ▁y ); ▁h ++) ▁{ ▁int ▁tmp _ x ; ▁if ▁(! vn c _ get _ bit ( vs -> dirty _ row [ y ▁+ ▁h ], ▁last _ x )) ▁break ; ▁for ▁( tmp _ x ▁= ▁last _ x ; ▁tmp _ x ▁< ▁x ; ▁tmp _ x ++) ▁v nc _ clear _ bit ( vs -> dirty _ row [ y ▁+ ▁h ], ▁tmp _ x ); ▁} ▁return ▁h ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ dispatch _ cmd _ failure ( void ) ▁{ ▁Q Dict ▁* req ▁= ▁q dict _ new (); ▁Q Object ▁* resp ; ▁q dict _ put _ obj ( req , ▁" execute ", ▁Q OBJECT ( q string _ from _ str (" user _ def _ cmd 2 "))); ▁resp ▁= ▁q mp _ dispatch ( Q OBJECT ( req )); ▁assert ( resp ▁!= ▁NULL ); ▁assert ( q dict _ has key ( q object _ to _ q dict ( resp ), ▁" error ")); ▁q object _ dec ref ( resp ); ▁Q DE CRE F ( req ); ▁/* ▁check ▁that ▁with ▁extra ▁arguments ▁it ▁throws ▁an ▁error ▁*/ ▁req ▁= ▁q dict _ new

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁add _ index _ entry ( AV Stream ▁* st , ▁int 64_ t ▁pos , ▁int 64_ t ▁timestamp , ▁int ▁flags ) ▁{ ▁AV Index Entry ▁* entries , ▁* ie ; ▁entries ▁= ▁av _ fast _ real loc ( st -> index _ entries , ▁& st -> index _ entries _ allocated _ size , ▁( st -> nb _ index _ entries ▁+ ▁1) ▁* ▁sizeof ( AV Index Entry )); ▁if ▁( entries ) ▁{ ▁st -> index _ entries ▁= ▁entries ; ▁ie ▁= ▁& entries [ st -> nb _ index _ entries ++ ]; ▁ie -> pos ▁= ▁pos ; ▁ie -> timestamp ▁= ▁timestamp ; ▁ie -> flags ▁= ▁fla

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rv 10_ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁M peg Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁int ▁i , ▁ret ; ▁int ▁slice _ count ; ▁const ▁uint 8_ t ▁* slices _ hdr ▁= ▁NULL ; ▁av _ d log ( av ctx , ▁" **** * frame ▁% d ▁size =% d \ n ", ▁av ctx -> frame _ number , ▁buf _ size ); ▁/* ▁no ▁supp lement 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ff _ rm _ read _ md pr _ codec data ▁( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Stream ▁* st , ▁RM Stream ▁* rst , ▁int ▁codec _ data _ size ) ▁{ ▁unsigned ▁int ▁v ; ▁int ▁size ; ▁int 64_ t ▁codec _ pos ; ▁int ▁ret ; ▁av priv _ set _ pts _ info ( st , ▁64, ▁1, ▁1000); ▁codec _ pos ▁= ▁av io _ t ell ( pb ); ▁v ▁= ▁av io _ rb 32 ( pb ); ▁if ▁( v ▁== ▁M K TAG (0 x fd , ▁' a ', ▁' r ', ▁'. ')) ▁{ ▁/* ▁ra ▁type ▁header ▁*/ ▁if ▁( rm _ read _ audio _ stream _ info ( s , ▁pb , ▁st , ▁rst , ▁0 )) ▁ret

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁put _ uint 64 ( Q EM U File ▁* f , ▁void ▁* pv , ▁size _ t ▁size ) ▁{ ▁uint 64_ t ▁* v ▁= ▁pv ; ▁qemu _ put _ be 64 s ( f , ▁v ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q JSON ▁* q json _ new ( void ) ▁{ ▁Q JSON ▁* json ▁= ▁Q JSON ( object _ new ( TYPE _ Q JSON )); ▁return ▁json ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁k q emu _ record _ dump ( void ) ▁{ ▁PC Record ▁** pr , ▁* r ; ▁int ▁i , ▁h ; ▁FILE ▁* f ; ▁int 64_ t ▁total , ▁sum ; ▁pr ▁= ▁m alloc ( size of ( PC Record ▁* ) ▁* ▁nb _ pc _ records ); ▁i ▁= ▁0; ▁total ▁= ▁0; ▁for ( h ▁= ▁0; ▁h ▁< ▁PC _ REC _ HASH _ SIZE ; ▁h ++) ▁{ ▁for ( r ▁= ▁pc _ rec _ hash [ h ]; ▁r ▁!= ▁NULL ; ▁r ▁= ▁r -> next ) ▁{ ▁pr [ i ++ ] ▁= ▁r ; ▁total ▁+= ▁r -> count ; ▁} ▁} ▁q sort ( pr , ▁nb _ pc _ records , ▁sizeof ( PC Record ▁* ), ▁pc _ rec _ cmp ); ▁f ▁= ▁f open ("/ tmp / k q e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc net _ receive ( void ▁* op aque , ▁const ▁uint 8_ t ▁* buf , ▁size _ t ▁size ) ▁{ ▁PC Net State ▁* s ▁= ▁opaque ; ▁int ▁is _ pad r ▁= ▁0, ▁is _ b cast ▁= ▁0, ▁is _ l ad r ▁= ▁0; ▁uint 8_ t ▁buf 1[ 60 ]; ▁int ▁remaining ; ▁int ▁crc _ err ▁= ▁0; ▁if ▁( CS R _ DR X ( s ) ▁|| ▁CS R _ STOP ( s ) ▁|| ▁CS R _ SP ND ( s ) ▁|| ▁! size ) ▁return ; ▁# if def ▁PC NET _ DEBUG ▁printf (" pc net _ receive ▁size =% d \ n ", ▁size ); ▁# end if ▁/* ▁if ▁too ▁small ▁buffer , ▁then ▁expand ▁it ▁*/ ▁if ▁( si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nb d _ reply _ ready ( void ▁* op aque ) ▁{ ▁N bd Client Session ▁* s ▁= ▁opaque ; ▁uint 64_ t ▁i ; ▁int ▁ret ; ▁if ▁( s -> reply . handle ▁== ▁0) ▁{ ▁/* ▁No ▁reply ▁already ▁in ▁flight . ▁Fetch ▁a ▁header . ▁It ▁is ▁possible ▁* ▁that ▁another ▁thread ▁has ▁done ▁the ▁same ▁thing ▁in ▁parallel , ▁so ▁* ▁the ▁socket ▁is ▁not ▁readable ▁anymore . ▁*/ ▁ret ▁= ▁nb d _ receive _ reply ( s -> sock , ▁& s -> reply ); ▁if ▁( ret ▁== ▁- E AG AIN ) ▁{ ▁return ; ▁} ▁if ▁( ret ▁< ▁0) ▁{ ▁s -> reply . h

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ff m _ write _ data ( AV Format Context ▁* s , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size , ▁int 64_ t ▁pts , ▁int ▁header ) ▁{ ▁FF M Context ▁* ff m ▁= ▁s -> priv _ data ; ▁int ▁len ; ▁if ▁( header ▁&& ▁ff m -> frame _ offset ▁== ▁0) ▁{ ▁ff m -> frame _ offset ▁= ▁ff m -> packet _ ptr ▁- ▁ff m -> packet ▁+ ▁FF M _ HEADER _ SIZE ; ▁ff m -> pts ▁= ▁pts ; ▁} ▁/* ▁write ▁as ▁many ▁packets ▁as ▁needed ▁*/ ▁while ▁( size ▁> ▁0) ▁{ ▁len ▁= ▁ff m -> packet _ end ▁- ▁ff m -> packet _ ptr ; ▁if ▁( len ▁>

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁vms v ga _ cursor _ define ( struct ▁vms v ga _ state _ s ▁* s , ▁struct ▁vms v ga _ cursor _ definition _ s ▁* c ) ▁{ ▁Q EM U Cursor ▁* q c ; ▁int ▁i , ▁pixels ; ▁qc ▁= ▁cursor _ alloc ( c -> width , ▁c -> height ); ▁qc -> hot _ x ▁= ▁c -> hot _ x ; ▁qc -> hot _ y ▁= ▁c -> hot _ y ; ▁switch ▁( c -> b pp ) ▁{ ▁case ▁1: ▁cursor _ set _ mon o ( q c , ▁0 xff ffff , ▁0 x 000000 , ▁( void *) c -> image , ▁1, ▁( void *) c -> mask ); ▁# if def ▁DEBUG ▁cursor _ print _ ascii _ art ( q c , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁F UN CC ( pred 4 x 4_ horizontal _ add )( uint 8_ t ▁* _ pix , ▁const ▁int 16_ t ▁* _ block , ▁ptr diff _ t ▁stride ) ▁{ ▁int ▁i ; ▁pixel ▁* pix ▁= ▁( pixel *) _ pix ; ▁const ▁dct coef ▁* block ▁= ▁( const ▁dct coef *) _ block ; ▁stride ▁>>= ▁sizeof ( pixel ) -1; ▁for ( i =0; ▁i < 4; ▁i ++){ ▁pixel ▁v ▁= ▁pix [-1 ]; ▁pix [0] = ▁v ▁+= ▁block [0]; ▁pix [1] = ▁v ▁+= ▁block [1]; ▁pix [2] = ▁v ▁+= ▁block [2 ]; ▁pix [3] = ▁v ▁+ ▁block [3 ]; ▁pix += ▁stride ; ▁block += ▁4; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁set _ proc _ name ( const ▁char ▁* s ) ▁{ ▁# if def ▁__ linux __ ▁char ▁name [ 16 ]; ▁if ▁(! s ) ▁return ; ▁name [ size of ( name ) ▁- ▁1] ▁= ▁0; ▁str nc py ( name , ▁s , ▁sizeof ( name )); ▁/* ▁Could ▁rewrite ▁argv [0] ▁too , ▁but ▁that ' s ▁a ▁bit ▁more ▁complicated . ▁This ▁simple ▁way ▁is ▁enough ▁for ▁` top '. ▁*/ ▁pr ctl ( PR _ SET _ NAME , ▁name ); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁nb d _ client _ session _ co _ flush ( N bd Client Session ▁* client ) ▁{ ▁struct ▁nb d _ request ▁request ; ▁struct ▁nb d _ reply ▁reply ; ▁s size _ t ▁ret ; ▁if ▁(! ( client -> nb df lags ▁& ▁N BD _ FLAG _ SEND _ FL USH )) ▁{ ▁return ▁0; ▁} ▁request . type ▁= ▁N BD _ CMD _ FL USH ; ▁if ▁( client -> nb df lags ▁& ▁N BD _ FLAG _ SEND _ F UA ) ▁{ ▁request . type ▁|= ▁N BD _ CMD _ FLAG _ F UA ; ▁} ▁request . from ▁= ▁0; ▁request . len ▁= ▁0; ▁nb d _ cor outine _ start ( client , ▁& request ); ▁ret ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ open cl _ buffer _ read ( uint 8_ t ▁* dst _ buf , ▁cl _ mem ▁src _ cl _ buf , ▁size _ t ▁buf _ size ) ▁{ ▁cl _ int ▁status ; ▁void ▁* mapped ▁= ▁cl En queue Map Buffer ( gpu _ env . command _ queue , ▁src _ cl _ buf , ▁CL _ TRUE , CL _ MAP _ READ , ▁0, ▁buf _ size , ▁0, ▁NULL , ▁NULL , ▁& status ); ▁if ▁( status ▁!= ▁CL _ SUCCESS ) ▁{ ▁av _ log ( & open cl utils , ▁AV _ LOG _ ERROR , ▁" Could ▁not ▁map ▁Open CL ▁buffer : ▁% s \ n ", ▁open cl _ err str ( status )); ▁return ▁A VER ROR _ EXTERNAL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ st sc ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁AV Stream ▁* st ; ▁MO V Stream Context ▁* sc ; ▁unsigned ▁int ▁i , ▁entries ; ▁if ▁( c -> fc -> nb _ streams ▁< ▁1) ▁return ▁0; ▁st ▁= ▁c -> fc -> streams [ c -> fc -> nb _ streams -1 ]; ▁sc ▁= ▁st -> priv _ data ; ▁av io _ r 8 ( pb ); ▁/* ▁version ▁*/ ▁av io _ rb 24 ( pb ); ▁/* ▁flags ▁*/ ▁entries ▁= ▁av io _ rb 32 ( pb ); ▁av _ log ( c -> fc , ▁AV _ LOG _ TRA CE , ▁" track [ % i ]. st sc . entries ▁= ▁% 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av i _ read _ tag ( AV Format Context ▁* s , ▁AV Stream ▁* st , ▁uint 32_ t ▁tag , ▁uint 32_ t ▁size ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁char ▁key [5] ▁= ▁{ ▁0 ▁}; ▁char ▁* value ; ▁size ▁+= ▁( size ▁& ▁1); ▁if ▁( size ▁== ▁U INT _ MAX ) ▁return ▁A VER ROR ( E IN VAL ); ▁value ▁= ▁av _ m alloc ( size ▁+ ▁1); ▁if ▁(! value ) ▁return ▁A VER ROR ( EN O ME M ); ▁av io _ read ( pb , ▁value , ▁size ); ▁value [ size ] ▁= ▁0; ▁AV _ W L 32 ( key , ▁tag ); ▁return ▁av _ dict _ set ( st ▁? ▁& st -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁hybrid _ analysis ( float ▁out [ 91 ][ 32 ][ 2], ▁float ▁in [5 ][ 44 ][ 2], ▁float ▁L [2 ][ 38 ][ 64 ], ▁int ▁is 34, ▁int ▁len ) ▁{ ▁int ▁i , ▁j ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁5; ▁i ++) ▁{ ▁for ▁( j ▁= ▁0; ▁j ▁< ▁38 ; ▁j ++) ▁{ ▁in [ i ][ j + 6] [0] ▁= ▁L [0] [ j ][ i ]; ▁in [ i ][ j + 6] [1] ▁= ▁L [1] [ j ][ i ]; ▁} ▁} ▁if ▁( is 34 ) ▁{ ▁hybrid 4_ 8_ 12 _ cx ( in [0], ▁out , ▁f 34 _0_ 12, ▁12, ▁len ); ▁hybrid 4_ 8_ 12 _ cx ( in [1], ▁out + 12, ▁f 34 _1_ 8, ▁8, ▁len ); ▁hybrid 4_ 8_ 12 _ cx ( in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ file _ set _ rate _ limit ( Q EM U File ▁* f , ▁int 64_ t ▁limit ) ▁{ ▁f -> x fer _ limit ▁= ▁limit ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q object _ input _ type _ bool ( Visitor ▁* v , ▁const ▁char ▁* name , ▁bool ▁* obj , ▁Error ▁** err p ) ▁{ ▁Q Object Input Visitor ▁* q iv ▁= ▁to _ q iv ( v ); ▁Q Object ▁* q obj ▁= ▁q object _ input _ get _ object ( q iv , ▁name , ▁true , ▁err p ); ▁Q Bool ▁* q bool ; ▁if ▁(! q obj ) ▁{ ▁return ; ▁} ▁q bool ▁= ▁q object _ to _ q bool ( q obj ); ▁if ▁(! q bool ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER _ TYPE , ▁name ▁? ▁name ▁: ▁" null ", ▁" boolean "); ▁return ; ▁} ▁* obj

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ get _ regist ers ( CPU State ▁* cs ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁S 39 0_ CPU ( cs ); ▁CP US 390 X State ▁* env ▁= ▁& cpu -> env ; ▁struct ▁k vm _ one _ reg ▁reg ; ▁struct ▁k vm _ s re gs ▁s re gs ; ▁struct ▁k vm _ re gs ▁regs ; ▁int ▁i , ▁r ; ▁/* ▁get ▁the ▁PS W ▁*/ ▁env -> p sw . addr ▁= ▁cs -> k vm _ run -> p sw _ addr ; ▁env -> p sw . mask ▁= ▁cs -> k vm _ run -> p sw _ mask ; ▁/* ▁the ▁GP RS ▁*/ ▁if ▁( cap _ sync _ re gs ▁&& ▁cs -> k vm _ run -> k vm _ valid _ re gs ▁& ▁K VM _ SYNC _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁select _ watch dog ( const ▁char ▁* p ) ▁{ ▁Watch dog Timer Model ▁* model ; ▁Q emu Opts ▁* opts ; ▁/* ▁- watch dog ▁? ▁lists ▁available ▁devices ▁and ▁exits ▁clean ly . ▁*/ ▁if ▁( str cmp ( p , ▁" ? ") ▁== ▁0) ▁{ ▁LIST _ FORE A CH ( model , ▁& watch dog _ list , ▁entry ) ▁{ ▁f printf ( stderr , ▁"\ t % s \ t % s \ n ", ▁model -> wd t _ name , ▁model -> wd t _ description ); ▁} ▁return ▁2; ▁} ▁LIST _ FORE A CH ( model , ▁& watch dog _ list , ▁entry ) ▁{ ▁if ▁( str case cmp ( model -> wd t _ name , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ bal loon _ handle _ output ( V irt IO Device ▁* v dev , ▁V irt Queue ▁* v q ) ▁{ ▁V irt IO Bal loon ▁* s ▁= ▁VI RT IO _ B AL LO ON ( v dev ); ▁V irt Queue Element ▁elem ; ▁Memory Region Section ▁section ; ▁while ▁( virt queue _ pop ( v q , ▁& elem )) ▁{ ▁size _ t ▁offset ▁= ▁0; ▁uint 32_ t ▁p fn ; ▁while ▁( io v _ to _ buf ( elem . out _ sg , ▁elem . out _ num , ▁offset , ▁& p fn , ▁4) ▁== ▁4) ▁{ ▁ram _ addr _ t ▁pa ; ▁ram _ addr _ t ▁addr ; ▁int ▁p ▁= ▁virt io _ ld l _ p ( v dev 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁v orb is _ decode _ init ( AV Codec Context ▁* av c context ) ▁{ ▁v orb is _ context ▁* vc ▁= ▁av c context -> priv _ data ; ▁uint 8_ t ▁* headers ▁= ▁av c context -> ex tr ad ata ; ▁int ▁headers _ len ▁= ▁av c context -> ex tr ad ata _ size ; ▁uint 8_ t ▁* header _ start [3 ]; ▁int ▁header _ len [3 ]; ▁Get Bit Context ▁* gb ▁= ▁& vc -> gb ; ▁int ▁hdr _ type , ▁ret ; ▁vc -> av c context ▁= ▁av c context ; ▁ff _ ds put il _ init ( & vc -> d sp , ▁av c context ); ▁ff _ fmt _ conver

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁blk _ send ( Q EM U File ▁* f , ▁Bl k Mig Block ▁* ▁blk ) ▁{ ▁int ▁len ; ▁uint 64_ t ▁flags ▁= ▁BL K _ M IG _ FLAG _ DEVICE _ BLOCK ; ▁if ▁( block _ mig _ state . zero _ blocks ▁&& ▁buffer _ is _ zero ( blk -> buf , ▁BLOCK _ SIZE )) ▁{ ▁flags ▁|= ▁BL K _ M IG _ FLAG _ ZERO _ BLOCK ; ▁} ▁/* ▁sector ▁number ▁and ▁flags ▁*/ ▁qemu _ put _ be 64 ( f , ▁( blk -> sect or ▁<< ▁B DR V _ SE CTOR _ BITS ) ▁| ▁flags ); ▁/* ▁device ▁name ▁*/ ▁len ▁= ▁str len ( b dr v _ get _ device _ name ( blk -> b md 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int 64_ t ▁q mp _ guest _ fs freeze _ freeze ( Error ▁** err ) ▁{ ▁int ▁ret ▁= ▁0, ▁i ▁= ▁0; ▁Fs Mount List ▁mount s ; ▁struct ▁Fs Mount ▁* mount ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁fd ; ▁s log (" guest - fs freeze ▁called "); ▁execute _ fs freeze _ hook ( FS F REE ZE _ HO OK _ F REE ZE , ▁& local _ err ); ▁if ▁( error _ is _ set ( & local _ err )) ▁{ ▁error _ propag ate ( err , ▁local _ err ); ▁return ▁-1; ▁} ▁Q TAIL Q _ INIT ( & mount s ); ▁build _ fs _ mount _ list ( & mount s , ▁& local _ err );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ dev tree _ set prop _ string ( void ▁* fd t , ▁const ▁char ▁* node _ path , ▁const ▁char ▁* property , ▁const ▁char ▁* string ) ▁{ ▁int ▁offset ; ▁offset ▁= ▁fd t _ path _ offset ( fd t , ▁node _ path ); ▁if ▁( offset ▁< ▁0) ▁return ▁offset ; ▁return ▁fd t _ set prop _ string ( fd t , ▁offset , ▁property , ▁string ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁calc _ opt imal _ r ice _ params ( R ice Context ▁* rc , ▁int ▁p order , ▁uint 32_ t ▁* sums , ▁int ▁n , ▁int ▁pred _ order ) ▁{ ▁int ▁i ; ▁int ▁k , ▁cnt , ▁part ; ▁uint 32_ t ▁all _ bits ; ▁part ▁= ▁(1 ▁<< ▁p order ); ▁all _ bits ▁= ▁4 ▁* ▁part ; ▁cnt ▁= ▁( n ▁>> ▁p order ) ▁- ▁pred _ order ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁part ; ▁i ++) ▁{ ▁k ▁= ▁find _ opt imal _ param ( sums [ i ], ▁cnt ); ▁rc -> params [ i ] ▁= ▁k ; ▁all _ bits ▁+= ▁r ice _ encode _ count ( sums [ i ], ▁cnt , ▁k ); ▁cnt 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁external _ snapshot _ commit ( Bl k Action State ▁* common ) ▁{ ▁External Snapshot State ▁* state ▁= ▁DO _ UP CAST ( External Snapshot State , ▁common , ▁common ); ▁b dr v _ set _ a io _ context ( state -> new _ bs , ▁state -> a io _ context ); ▁/* ▁This ▁removes ▁our ▁old ▁bs ▁and ▁adds ▁the ▁new ▁bs ▁*/ ▁b dr v _ append ( state -> new _ bs , ▁state -> old _ bs ); ▁/* ▁We ▁don ' t ▁need ▁( or ▁want ) ▁to ▁use ▁the ▁transactional ▁* ▁b dr v _ re open _ multiple () ▁across ▁all ▁the ▁entries

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ image _ alloc ( uint 8_ t ▁* pointer s [4 ], ▁int ▁lines izes [4 ], ▁int ▁w , ▁int ▁h , ▁enum ▁Pixel Format ▁pix _ fmt , ▁int ▁align ) ▁{ ▁int ▁i , ▁ret ; ▁uint 8_ t ▁* buf ; ▁if ▁(( ret ▁= ▁av _ image _ check _ size ( w , ▁h , ▁0, ▁NULL )) ▁< ▁0) ▁return ▁ret ; ▁if ▁(( ret ▁= ▁av _ image _ fill _ lines izes ( lines izes , ▁pix _ fmt , ▁w )) ▁< ▁0) ▁return ▁ret ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁4; ▁i ++) ▁lines izes [ i ] ▁= ▁F FA LI GN ( lines izes [ i ], ▁align ); ▁if ▁(( ret ▁= ▁av _ image _ fill _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rc 40 30 _ d ma _ as _ update _ one ( rc 40 30 State ▁* s , ▁int ▁index , ▁uint 32_ t ▁frame ) ▁{ ▁if ▁( index ▁< ▁MAX _ TL _ ENT RIES ) ▁{ ▁memory _ region _ set _ enabled ( & s -> d ma _ m rs [ index ], ▁false ); ▁} ▁if ▁(! frame ) ▁{ ▁return ; ▁} ▁if ▁( index ▁>= ▁MAX _ TL _ ENT RIES ) ▁{ ▁qemu _ log _ mask ( LOG _ UN IMP , ▁" rc 40 30 : ▁trying ▁to ▁use ▁too ▁high ▁" ▁" translation ▁table ▁entry ▁% d ▁( max ▁allowed =% d )", ▁index , ▁MAX _ TL _ ENT RIES ); ▁return ; ▁} ▁memory _ region

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁virt io _ sc si _ data _ plane _ handle _ cmd ( V irt IO Device ▁* v dev , ▁V irt Queue ▁* v q ) ▁{ ▁V irt IO SC SI ▁* s ▁= ▁( V irt IO SC SI ▁* ) v dev ; ▁assert ( s -> ctx ▁&& ▁s -> data plane _ started ); ▁return ▁virt io _ sc si _ handle _ cmd _ v q ( s , ▁v q ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁USB Device ▁* usb _ host _ device _ open ( const ▁char ▁* dev name ) ▁{ ▁struct ▁usb _ device _ info ▁bus _ info , ▁dev _ info ; ▁USB Device ▁* d ▁= ▁NULL ; ▁USB Host Device ▁* dev ; ▁char ▁ctl path [ PATH _ MAX ▁+ ▁1 ]; ▁char ▁bus path [ PATH _ MAX ▁+ ▁1 ]; ▁int ▁b fd , ▁df d , ▁bus , ▁address , ▁i ; ▁int ▁ug end ebug ▁= ▁U GEN _ DEBUG _ LEVEL ; ▁if ▁( usb _ host _ find _ device ( & bus , ▁& address , ▁dev name ) ▁< ▁0) ▁return ▁NULL ; ▁sn printf ( bus path , ▁PATH _ MAX , ▁"/ dev / usb % d ", ▁bus ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁tw in _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁int ▁ret ; ▁T win Context ▁* t ctx ▁= ▁av ctx -> priv _ data ; ▁int ▁is amp f , ▁ib ps ; ▁t ctx -> av ctx ▁= ▁av ctx ; ▁av ctx -> sample _ fmt ▁= ▁AV _ SA MPLE _ F MT _ FL TP ; ▁if ▁(! av ctx -> ex tr ad ata ▁|| ▁av ctx -> ex tr ad ata _ size ▁< ▁12 ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Missing ▁or ▁incomplete ▁extr ad ata \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁av ctx -> channels ▁= ▁AV _ RB 32 ( av c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁copy _ ch apters ( Input File ▁* if ile , ▁Output File ▁* o file , ▁int ▁copy _ metadata ) ▁{ ▁AV Format Context ▁* is ▁= ▁if ile -> ctx ; ▁AV Format Context ▁* os ▁= ▁of ile -> ctx ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁is -> nb _ ch apters ; ▁i ++) ▁{ ▁AV Ch apter ▁* in _ ch ▁= ▁is -> ch apters [ i ], ▁* out _ ch ; ▁int 64_ t ▁ts _ off ▁= ▁av _ res cale _ q ( o file -> start _ time ▁- ▁if ile -> ts _ offset , ▁AV _ TIME _ BASE _ Q , ▁in _ ch -> time _ base ); ▁int 64_ t ▁rt ▁= ▁( o file -> re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁trace _ record _ start ( Trace Buffer Record ▁* rec , ▁Trace Event ID ▁event , ▁size _ t ▁datas ize ) ▁{ ▁unsigned ▁int ▁idx , ▁rec _ off , ▁old _ idx , ▁new _ idx ; ▁uint 32_ t ▁rec _ len ▁= ▁sizeof ( Trace Record ) ▁+ ▁datas ize ; ▁uint 64_ t ▁event _ u 64 ▁= ▁event ; ▁uint 64_ t ▁timestamp _ ns ▁= ▁get _ clock (); ▁do ▁{ ▁old _ idx ▁= ▁g _ atomic _ int _ get ( & trace _ idx ); ▁s mp _ r mb (); ▁new _ idx ▁= ▁old _ idx ▁+ ▁rec _ len ; ▁if ▁( new _ idx ▁- ▁write out _ idx ▁> ▁TRACE _ BU F _ LEN ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁float 64 ▁round And Pack Float 64 ( ▁flag ▁z Sign , ▁int 16 ▁z Exp , ▁uint 64_ t ▁z Sig ▁STATUS _ PARAM ) ▁{ ▁int 8 ▁rounding Mode ; ▁flag ▁round Ne arest Even ; ▁int 16 ▁round Increment , ▁round Bits ; ▁flag ▁is T iny ; ▁rounding Mode ▁= ▁STATUS ( float _ rounding _ mode ); ▁round Ne arest Even ▁= ▁( ▁rounding Mode ▁== ▁float _ round _ nearest _ even ▁); ▁round Increment ▁= ▁0 x 200 ; ▁if ▁( ▁! ▁round Ne arest Even ▁) ▁{ ▁if ▁( ▁rounding Mode ▁== ▁float _ round _ to _ zero ▁) ▁{ ▁round Increment

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁xen _ re map _ bucket ( Map CacheEntry ▁* entry , ▁hw addr ▁size , ▁hw addr ▁address _ index ) ▁{ ▁uint 8_ t ▁* v addr _ base ; ▁xen _ p fn _ t ▁* pf ns ; ▁int ▁* err ; ▁unsigned ▁int ▁i ; ▁hw addr ▁nb _ p fn ▁= ▁size ▁>> ▁X C _ PAGE _ SHIFT ; ▁trace _ x en _ re map _ bucket ( address _ index ); ▁pf ns ▁= ▁g _ m alloc 0( nb _ p fn ▁* ▁sizeof ▁( x en _ p fn _ t )); ▁err ▁= ▁g _ m alloc 0( nb _ p fn ▁* ▁sizeof ▁( int )); ▁if ▁( entry -> v addr _ base ▁!= ▁NULL ) ▁{ ▁if ▁( mun map ( entry -> v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁usb _ packet _ complete ( US B Device ▁* dev , ▁USB Packet ▁* p ) ▁{ ▁USB Endpoint ▁* ep ▁= ▁p -> ep ; ▁int ▁ret ; ▁assert ( p -> state ▁== ▁USB _ PA CKET _ AS Y NC ); ▁assert ( Q TAIL Q _ FIRST ( & ep -> queue ) ▁== ▁p ); ▁usb _ packet _ set _ state ( p , ▁USB _ PA CKET _ COMPLETE ); ▁Q TAIL Q _ REMOVE ( & ep -> queue , ▁p , ▁queue ); ▁dev -> port -> ops -> complete ( dev -> port , ▁p ); ▁while ▁(! Q TAIL Q _ EMPTY ( & ep -> queue )) ▁{ ▁p ▁= ▁Q TAIL Q _ FIRST ( & ep -> queue ); ▁if ▁( p -> state 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dyn _ buf _ write ( void ▁* op aque , ▁U INT 8 ▁* buf , ▁int ▁buf _ size ) ▁{ ▁Dyn Buffer ▁* d ▁= ▁opaque ; ▁int ▁new _ size , ▁new _ allocated _ size ; ▁U INT 8 ▁* new _ buffer ; ▁/* ▁real locate ▁buffer ▁if ▁needed ▁*/ ▁new _ size ▁= ▁d -> pos ▁+ ▁buf _ size ; ▁new _ allocated _ size ▁= ▁d -> allocated _ size ; ▁while ▁( new _ size ▁> ▁new _ allocated _ size ) ▁{ ▁if ▁(! new _ allocated _ size ) ▁new _ allocated _ size ▁= ▁new _ size ; ▁else ▁new _ allocated _ size ▁= ▁( new _ allocated _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁RE NAME ( y uv 4 20 _ rgb 24 )( Sw s Context ▁* c , ▁uint 8_ t * ▁src [], ▁int ▁src Stride [], ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁uint 8_ t * ▁dst [], ▁int ▁dst Stride [] ){ ▁int ▁y , ▁h _ size ; ▁if ( c -> src Format ▁== ▁PI X _ F MT _ Y UV 4 22 P ){ ▁src Stride [1] ▁*= ▁2; ▁src Stride [2] ▁*= ▁2; ▁} ▁h _ size = ▁( c -> dst W + 7) & ~ 7 ; ▁if ( h _ size * 3 ▁> ▁dst Stride [0]) ▁h _ size - =8 ; ▁__ asm __ ▁__ vol atile __ ▁(" px or ▁% mm 4, ▁% mm 4 ;" ▁/* ▁zero ▁mm 4 ▁*/ ▁); ▁f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁hex _ to _ data ( uint 8_ t ▁* data , ▁const ▁char ▁* p ) ▁{ ▁int ▁c , ▁len , ▁v ; ▁len ▁= ▁0; ▁v ▁= ▁1; ▁for ( ; ;) ▁{ ▁skip _ spaces ( & p ); ▁if ▁(* p ▁== ▁'\ 0 ') ▁break ; ▁c ▁= ▁t ou pper (( un signed ▁char )* p ++ ); ▁if ▁( c ▁>= ▁'0' ▁&& ▁c ▁<= ▁'9 ') ▁c ▁= ▁c ▁- ▁'0 '; ▁else ▁if ▁( c ▁>= ▁' A ' ▁&& ▁c ▁<= ▁' F ') ▁c ▁= ▁c ▁- ▁' A ' ▁+ ▁10; ▁else ▁break ; ▁v ▁= ▁( v ▁<< ▁4) ▁| ▁c ; ▁if ▁( v ▁& ▁0 x 100 ) ▁{ ▁if ▁( data ) ▁data [ len ] ▁= ▁v ; ▁len ++; ▁v ▁= ▁1; ▁} ▁} ▁return ▁len ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁RE NAME ( d ct _ quant ize )( M peg Enc Context ▁* s , ▁int 16_ t ▁* block , ▁int ▁n , ▁int ▁q scale , ▁int ▁* overflow ) ▁{ ▁x 86_ reg ▁last _ non _ zero _ p 1; ▁int ▁level =0, ▁q ; ▁// =0 ▁is ▁because ▁gcc ▁says ▁un initialized ▁... ▁const ▁uint 16_ t ▁* q mat , ▁* bias ; ▁LOCAL _ ALI G NED _16 ( int 16_ t , ▁temp _ block , ▁[ 64 ]); ▁av _ assert 2 (( 7 & ( int )( & temp _ block [0] )) ▁== ▁0); ▁// did ▁gcc ▁align ▁it ▁correctly ? ▁// s -> fd ct ▁( block ); ▁RE NAME _ FD CT ( ff _ fd ct )(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q dm 2_ fft _ decode _ ton es ▁( Q DM 2 Context ▁* q , ▁int ▁duration , ▁Get Bit Context ▁* gb , ▁int ▁b ) ▁{ ▁int ▁channel , ▁st ere o , ▁phase , ▁exp ; ▁int ▁local _ int _ 4, ▁local _ int _ 8, ▁st ere o _ phase , ▁local _ int _10 ; ▁int ▁local _ int _1 4, ▁st ere o _ exp , ▁local _ int _ 20, ▁local _ int _2 8 ; ▁int ▁n , ▁offset ; ▁local _ int _4 ▁= ▁0; ▁local _ int _2 8 ▁= ▁0; ▁local _ int _20 ▁= ▁2; ▁local _ int _8 ▁= ▁(4 ▁- ▁duration ); ▁local _ int _10 ▁= ▁1 ▁<< ▁( q -> group _ order 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cuda _ receive _ packet ( C U DA State ▁* s , ▁const ▁uint 8_ t ▁* data , ▁int ▁len ) ▁{ ▁uint 8_ t ▁ob uf [ 16 ] ▁= ▁{ ▁CUDA _ PA CKET , ▁0, ▁data [0] ▁}; ▁int ▁autop oll ; ▁uint 32_ t ▁ti ; ▁switch ( data [0]) ▁{ ▁case ▁CUDA _ A UT OP OLL : ▁autop oll ▁= ▁( data [1] ▁!= ▁0); ▁if ▁( aut op oll ▁!= ▁s -> aut op oll ) ▁{ ▁s -> aut op oll ▁= ▁autop oll ; ▁if ▁( aut op oll ) ▁{ ▁timer _ mod ( s -> adb _ poll _ timer , ▁qemu _ clock _ get _ ns ( Q EM U _ C LOCK _ VI RTUAL ) ▁+ ▁( get _ ticks _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁bitmap _ free ( Q c ow 2 Bitmap ▁* bm ) ▁{ ▁g _ free ( bm -> name ); ▁g _ free ( bm );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vp 6_ parse _ coeff ( VP 56 Context ▁* s ) ▁{ ▁V P 56 Range Coder ▁* c ▁= ▁s -> cc p ; ▁V P 56 Model ▁* model ▁= ▁s -> model p ; ▁uint 8_ t ▁* perm ute ▁= ▁s -> id ct _ sc ant able ; ▁uint 8_ t ▁* model 1, ▁* model 2, ▁* model 3; ▁int ▁coeff , ▁sign , ▁coeff _ idx ; ▁int ▁b , ▁i , ▁cg , ▁idx , ▁ctx ; ▁int ▁pt ▁= ▁0; ▁/* ▁plane ▁type ▁(0 ▁for ▁Y , ▁1 ▁for ▁U ▁or ▁V ) ▁*/ ▁if ▁( c -> end ▁>= ▁c -> buffer ▁&& ▁c -> bits ▁>= ▁0) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" End ▁of ▁AC ▁st

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ pass ive _ mode _ ep sv ( FTP Context ▁* s ) ▁{ ▁char ▁* res ▁= ▁NULL , ▁* start ▁= ▁NULL , ▁* end ▁= ▁NULL ; ▁int ▁i ; ▁static ▁const ▁char ▁d ▁= ▁' | '; ▁static ▁const ▁char ▁* command ▁= ▁" EP SV \ r \ n "; ▁static ▁const ▁int ▁eps v _ codes [] ▁= ▁{ 22 9, ▁0 }; ▁if ▁( ftp _ send _ command ( s , ▁command , ▁eps v _ codes , ▁& res ) ▁!= ▁2 29 ▁|| ▁! res ) ▁goto ▁fail ; ▁for ▁( i ▁= ▁0; ▁res [ i ]; ▁++ i ) ▁{ ▁if ▁( res [ i ] ▁== ▁' (' ) ▁{ ▁start ▁= ▁res ▁+ ▁i ▁+ ▁1; ▁} ▁else ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ enqueue _ packet ( V LAN Client State ▁* sender , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size , ▁Net Packet Sent ▁* sent _ cb ) ▁{ ▁V LAN Packet ▁* packet ; ▁packet ▁= ▁qemu _ m alloc ( size of ( V LAN Packet ) ▁+ ▁size ); ▁packet -> sender ▁= ▁sender ; ▁packet -> size ▁= ▁size ; ▁packet -> sent _ cb ▁= ▁sent _ cb ; ▁mem c py ( packet -> data , ▁buf , ▁size ); ▁TA IL Q _ INSERT _ TAIL ( & sender -> vlan -> send _ queue , ▁packet , ▁entry ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁uint 64_ t ▁cpu _ pp c _ get _ tb ( CP UP PC State ▁* env ) ▁{ ▁/* ▁TO ▁FIX ▁*/ ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 16_ t ▁net _ checksum _ tcp ud p ( uint 16_ t ▁length , ▁uint 16_ t ▁proto , ▁uint 8_ t ▁* addrs , ▁uint 8_ t ▁* buf ) ▁{ ▁uint 32_ t ▁sum ▁= ▁0; ▁sum ▁+= ▁net _ checksum _ add ( length , ▁buf ); ▁// ▁payload ▁sum ▁+= ▁net _ checksum _ add ( 8, ▁addrs ); ▁// ▁src ▁+ ▁dst ▁address ▁sum ▁+= ▁proto ▁+ ▁length ; ▁// ▁protocol ▁& ▁length ▁return ▁net _ checksum _ finish ( sum ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ loop _ exit ( CPU State ▁* env 1) ▁{ ▁env 1 -> current _ tb ▁= ▁NULL ; ▁long j mp ( env 1 -> j mp _ env , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p pc _ hw _ interrupt ▁( CP UP PC State ▁* env ) ▁{ ▁int ▁raised ▁= ▁0; ▁# if ▁1 ▁if ▁( log level ▁& ▁CPU _ LOG _ INT ) ▁{ ▁f printf ( log file , ▁"% s : ▁% p ▁pending ▁% 08 x ▁req ▁% 08 x ▁me ▁% d ▁ee ▁% d \ n ", ▁__ func __, ▁env , ▁env -> pending _ interrupt s , ▁env -> interrupt _ request , ▁ms r _ me , ▁ms r _ ee ); ▁} ▁# end if ▁/* ▁Ra ise ▁it ▁*/ ▁if ▁( env -> pending _ interrupt s ▁& ▁(1 ▁<< ▁P PC _ INTER R UP T _ RE SET )) ▁{ ▁/* ▁External ▁reset ▁/ ▁critical ▁input ▁*/ ▁/* ▁XXX : ▁critica

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁gen _ inter mediate _ code _ internal ( CPU State ▁* env , ▁Translation Block ▁* tb , ▁int ▁search _ pc ) ▁{ ▁uint 16_ t ▁* gen _ op c _ end ; ▁uint 32_ t ▁pc _ start ; ▁int ▁j , ▁l j ; ▁struct ▁Dis as Context ▁ctx ; ▁struct ▁Dis as Context ▁* dc ▁= ▁& ctx ; ▁uint 32_ t ▁next _ page _ start , ▁org _ flags ; ▁target _ ulong ▁npc ; ▁int ▁num _ ins ns ; ▁int ▁max _ ins ns ; ▁qemu _ log _ try _ set _ file ( stderr ); ▁pc _ start ▁= ▁tb -> pc ; ▁dc -> env ▁= ▁env ; ▁dc -> tb ▁= ▁tb ; ▁org _ flags ▁= ▁dc -> sy

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁add _ bytes _ l 2_ c ( uint 8_ t ▁* dst , ▁uint 8_ t ▁* src 1, ▁uint 8_ t ▁* src 2, ▁int ▁w ) ▁{ ▁long ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁<= ▁w ▁- ▁sizeof ( long ); ▁i ▁+= ▁sizeof ( long )) ▁{ ▁long ▁a ▁= ▁* ( long ▁* )( src 1 ▁+ ▁i ); ▁long ▁b ▁= ▁* ( long ▁* )( src 2 ▁+ ▁i ); ▁* ( long ▁* )( dst ▁+ ▁i ) ▁= ▁(( a ▁& ▁pb _7 f ) ▁+ ▁( b ▁& ▁pb _7 f )) ▁^ ▁(( a ▁^ ▁b ) ▁& ▁pb _ 80 ); ▁} ▁for ▁( ; ▁i ▁< ▁w ; ▁i ++) ▁dst [ i ] ▁= ▁src 1[ i ] ▁+ ▁src 2[ i ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁calculate _ ref counts ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁B dr v Check Mode ▁fix , ▁bool ▁* rebuild , ▁uint 16_ t ▁** refcount _ table , ▁int 64_ t ▁* nb _ clusters ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁i ; ▁Q C ow Snapshot ▁* sn ; ▁int ▁ret ; ▁if ▁(! * refcount _ table ) ▁{ ▁int 64_ t ▁old _ size ▁= ▁0; ▁ret ▁= ▁real loc _ refcount _ array ( s , ▁ref count _ table , ▁& old _ size , ▁* nb _ clusters ); ▁if ▁( ret ▁< ▁0) ▁{ ▁res -> check _ err

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ne 2000 _ i op ort _ write ( void ▁* op aque , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁NE 2000 State ▁* s ▁= ▁opaque ; ▁int ▁offset , ▁page ; ▁addr ▁&= ▁0 xf ; ▁# if def ▁DEBUG _ NE 2000 ▁printf (" NE 2000 : ▁write ▁addr =0 x % x ▁val =0 x % 02 x \ n ", ▁addr , ▁val ); ▁# end if ▁if ▁( addr ▁== ▁E 8 39 0_ CMD ) ▁{ ▁/* ▁control ▁register ▁*/ ▁s -> cmd ▁= ▁val ; ▁if ▁( val ▁& ▁E 8 39 0_ START ) ▁{ ▁s -> is r ▁&= ▁~ EN IS R _ RE SET ; ▁/* ▁test ▁specific ▁case : ▁zero ▁length ▁trans f ert ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vc 1_ filter _ line ( uint 8_ t * ▁src , ▁int ▁stride , ▁int ▁pq ){ ▁int ▁a 0, ▁a 1, ▁a 2, ▁a 3, ▁d , ▁clip , ▁filt 3 ▁= ▁0; ▁uint 8_ t ▁* cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ; ▁a 0 ▁= ▁(2 *( src [ -2 * stride ] ▁- ▁src [ ▁1 * stride ]) ▁- ▁5 *( src [-1 * stride ] ▁- ▁src [ ▁0 * stride ]) ▁+ ▁4) ▁>> ▁3; ▁if ( FF AB S ( a 0) ▁< ▁pq ){ ▁a 1 ▁= ▁(2 *( src [ -4 * stride ] ▁- ▁src [-1 * stride ]) ▁- ▁5 *( src [ -3 * stride ] ▁- ▁src [ -2 * stride ]) ▁+ ▁4) ▁>> ▁3; ▁a 2 ▁= ▁(2 *( src [ ▁0 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁r le _ unpack ( const ▁unsigned ▁char ▁* src , ▁unsigned ▁char ▁* dest , ▁int ▁src _ count , ▁int ▁src _ size , ▁int ▁dest _ len ) ▁{ ▁unsigned ▁char ▁* pd ; ▁int ▁i , ▁l ; ▁unsigned ▁char ▁* dest _ end ▁= ▁dest ▁+ ▁dest _ len ; ▁Get Byte Context ▁gb ; ▁by test ream 2_ init ( & gb , ▁src , ▁src _ size ); ▁pd ▁= ▁dest ; ▁if ▁( src _ count ▁& ▁1) ▁{ ▁if ▁( by test ream 2_ get _ bytes _ left ( & gb ) ▁< ▁1) ▁return ▁0; ▁* pd ++ ▁= ▁by test ream 2_ get _ byte u ( & gb ); ▁} ▁src _ count ▁>>= ▁1;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁re check _ dis card _ flags ( AV Format Context ▁* s , ▁int ▁first ) ▁{ ▁H LS Context ▁* c ▁= ▁s -> priv _ data ; ▁int ▁i , ▁changed ▁= ▁0; ▁/* ▁Check ▁if ▁any ▁new ▁streams ▁are ▁needed ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁c -> n _ play lists ; ▁i ++) ▁c -> play lists [ i ] -> cur _ needed ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> nb _ streams ; ▁i ++) ▁{ ▁AV Stream ▁* st ▁= ▁s -> streams [ i ]; ▁struct ▁playlist ▁* pl s ▁= ▁c -> play lists [ s -> streams [ i ] -> id ]; ▁if ▁( st -> dis card ▁< ▁AV DI SC 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁t pm _ pas sthrough _ unix _ transfer ( int ▁t pm _ fd , ▁const ▁T P ML oc ality ▁* lo ct y _ data ) ▁{ ▁return ▁t pm _ pas sthrough _ unix _ tx _ buf s ( tp m _ fd , ▁lo ct y _ data -> w _ buffer . buffer , ▁lo ct y _ data -> w _ offset , ▁lo ct y _ data -> r _ buffer . buffer , ▁lo ct y _ data -> r _ buffer . size ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ tw ▁( int ▁flags ) ▁{ ▁if ▁(! likely (! (( ( int 32_ t ) T 0 ▁< ▁( int 32_ t ) T 1 ▁&& ▁( flags ▁& ▁0 x 10 )) ▁|| ▁(( int 32_ t ) T 0 ▁> ▁( int 32_ t ) T 1 ▁&& ▁( flags ▁& ▁0 x 08 )) ▁|| ▁(( int 32_ t ) T 0 ▁== ▁( int 32_ t ) T 1 ▁&& ▁( flags ▁& ▁0 x 04 )) ▁|| ▁(( uint 32_ t ) T 0 ▁< ▁( uint 32_ t ) T 1 ▁&& ▁( flags ▁& ▁0 x 02 )) ▁|| ▁(( uint 32_ t ) T 0 ▁> ▁( uint 32_ t ) T 1 ▁&& ▁( flags ▁& ▁0 x 01 )) ))) ▁{ ▁do _ raise _ exception _ err ( EX CP _ PRO GRAM , ▁EX CP _ TR AP ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sh 4_ translate _ init ( void ) ▁{ ▁int ▁i ; ▁static ▁const ▁char ▁* ▁const ▁g reg names [ 24 ] ▁= ▁{ ▁" R 0_ B ANK 0 ", ▁" R 1_ B ANK 0 ", ▁" R 2_ B ANK 0 ", ▁" R 3_ B ANK 0 ", ▁" R 4_ B ANK 0 ", ▁" R 5_ B ANK 0 ", ▁" R 6_ B ANK 0 ", ▁" R 7_ B ANK 0 ", ▁" R 8 ", ▁" R 9 ", ▁" R 10 ", ▁" R 11 ", ▁" R 12 ", ▁" R 13 ", ▁" R 14 ", ▁" R 15 ", ▁" R 0_ B ANK 1", ▁" R 1_ B ANK 1", ▁" R 2_ B ANK 1", ▁" R 3_ B ANK 1", ▁" R 4_ B ANK 1", ▁" R 5_ B ANK 1", ▁" R 6_ B ANK 1", ▁" R 7_ B ANK 1" ▁}; ▁static ▁const ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV Stream ▁* add _ audio _ stream ( AV Format Context ▁* oc , ▁int ▁codec _ id ) ▁{ ▁AV Codec ▁* codec ; ▁AV Codec Context ▁* c ; ▁AV Stream ▁* st ; ▁st ▁= ▁av _ new _ stream ( oc , ▁1); ▁if ▁(! st ) ▁{ ▁f printf ( stderr , ▁" Could ▁not ▁alloc ▁stream \ n "); ▁exit (1); ▁} ▁/* ▁find ▁the ▁MP 2 ▁encoder ▁*/ ▁codec ▁= ▁av codec _ find _ encoder ( codec _ id ); ▁if ▁(! codec ) ▁{ ▁f printf ( stderr , ▁" codec ▁not ▁found \ n "); ▁exit (1); ▁} ▁c ▁= ▁& st -> codec ; ▁c -> codec _ type ▁= ▁CODE C _ TYPE _ AU

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁lib open jpeg _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Lib Open J PEG Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁int ▁err ▁= ▁A VER ROR ( EN O ME M ); ▁op j _ set _ default _ encoder _ parameters ( & ctx -> enc _ params ); ▁ctx -> enc _ params . cp _ rs iz ▁= ▁ctx -> profile ; ▁ctx -> enc _ params . mode ▁= ▁!! av ctx -> global _ quality ; ▁ctx -> enc _ params . cp _ c in ema ▁= ▁ctx -> c in ema _ mode ; ▁ctx -> enc _ params . prog _ order ▁= ▁ctx -> prog _ order ; ▁ct

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁unsigned ▁int ▁m si _ nr _ vectors ( uint 16_ t ▁flags ) ▁{ ▁return ▁1 U ▁<< ▁(( flags ▁& ▁P CI _ M SI _ FLAGS _ Q SIZE ) ▁>> ▁( ff s ( PC I _ M SI _ FLAGS _ Q SIZE ) ▁- ▁1 )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁open r isc _ sim _ init ( Machine State ▁* machine ) ▁{ ▁ram _ addr _ t ▁ram _ size ▁= ▁machine -> ram _ size ; ▁const ▁char ▁* cpu _ model ▁= ▁machine -> cpu _ model ; ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁Open RI SC CPU ▁* cpu ▁= ▁NULL ; ▁Memory Region ▁* ram ; ▁int ▁n ; ▁if ▁(! cpu _ model ) ▁{ ▁cpu _ model ▁= ▁" or 12 00 "; ▁} ▁for ▁( n ▁= ▁0; ▁n ▁< ▁s mp _ cpus ; ▁n ++) ▁{ ▁cpu ▁= ▁OPEN RI SC _ CPU ( cpu _ generic _ init ( TYPE _ OPEN RI SC _ CPU , ▁cpu 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁oh ci _ reset ( void ▁* op aque ) ▁{ ▁O H CI State ▁* oh ci ▁= ▁opaque ; ▁O H CI Port ▁* port ; ▁int ▁i ; ▁oh ci _ bus _ stop ( oh ci ); ▁oh ci -> ctl ▁= ▁0; ▁oh ci -> old _ ctl ▁= ▁0; ▁oh ci -> status ▁= ▁0; ▁oh ci -> in tr _ status ▁= ▁0; ▁oh ci -> in tr ▁= ▁O H CI _ INT R _ MI E ; ▁oh ci -> h cc a ▁= ▁0; ▁oh ci -> ctrl _ head ▁= ▁oh ci -> ctrl _ cur ▁= ▁0; ▁oh ci -> bulk _ head ▁= ▁oh ci -> bulk _ cur ▁= ▁0; ▁oh ci -> per _ cur ▁= ▁0; ▁oh ci -> done ▁= ▁0; ▁oh ci -> done _ count ▁= ▁7 ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ f sub ( CP UP PC State ▁* env , ▁uint 64_ t ▁arg 1, ▁uint 64_ t ▁arg 2) ▁{ ▁CPU _ Double U ▁f arg 1, ▁f arg 2; ▁f arg 1. ll ▁= ▁arg 1; ▁f arg 2. ll ▁= ▁arg 2; ▁if ▁( un likely ( float 64_ is _ infinity ( f arg 1. d ) ▁&& ▁float 64_ is _ infinity ( f arg 2. d ) ▁&& ▁float 64_ is _ neg ( f arg 1. d ) ▁== ▁float 64_ is _ neg ( f arg 2. d ))) ▁{ ▁/* ▁Mag nitude ▁subtraction ▁of ▁inf init ies ▁*/ ▁f arg 1. ll ▁= ▁f load _ invalid _ op _ ex cp ( env , ▁PO WER PC _ EX CP _ FP _ V X I SI ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁net _ socket _ connect _ init ( Net Client State ▁* peer , ▁const ▁char ▁* model , ▁const ▁char ▁* name , ▁const ▁char ▁* host _ str ) ▁{ ▁Net Socket State ▁* s ; ▁int ▁fd , ▁connected , ▁ret ; ▁struct ▁sock addr _ in ▁s addr ; ▁if ▁( parse _ host _ port ( & s addr , ▁host _ str ) ▁< ▁0) ▁return ▁-1; ▁fd ▁= ▁qemu _ socket ( PF _ INET , ▁SOCK _ STREAM , ▁0); ▁if ▁( fd ▁< ▁0) ▁{ ▁per ror (" socket "); ▁return ▁-1; ▁} ▁qemu _ set _ non block ( fd ); ▁connected ▁= ▁0; ▁for ( ; ;) ▁{ ▁ret ▁= ▁con

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁load _ kernel ▁( void ) ▁{ ▁int 64_ t ▁kernel _ entry , ▁kernel _ high ; ▁long ▁init rd _ size ; ▁ram _ addr _ t ▁init rd _ offset ; ▁int ▁big _ endian ; ▁uint 32_ t ▁* prom _ buf ; ▁long ▁prom _ size ; ▁int ▁prom _ index ▁= ▁0; ▁uint 64_ t ▁(* x late _ to _ k seg 0) ▁( void ▁* op aque , ▁uint 64_ t ▁addr ); ▁# if def ▁TARGET _ WORDS _ B IG ENDIAN ▁big _ endian ▁= ▁1; ▁# else ▁big _ endian ▁= ▁0; ▁# end if ▁if ▁( load _ elf ( loader params . kernel _ filename , ▁cpu _ m ips _ k seg 0_ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ validate _ fail _ union _ anon ( Test Input Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁User Def An on Union ▁* tmp ▁= ▁NULL ; ▁Visitor ▁* v ; ▁Error ▁* err p ▁= ▁NULL ; ▁v ▁= ▁validate _ test _ init ( data , ▁" 3.1 4 "); ▁visit _ type _ User Def An on Union ( v , ▁& tmp , ▁NULL , ▁& err p ); ▁g _ assert ( error _ is _ set ( & err p )); ▁q api _ free _ User Def An on Union ( tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v host _ virt queue _ init ( struct ▁v host _ dev ▁* dev , ▁struct ▁v host _ virt queue ▁* v q , ▁int ▁n ) ▁{ ▁struct ▁v host _ v ring _ file ▁file ▁= ▁{ ▁. index ▁= ▁n , ▁}; ▁int ▁r ▁= ▁event _ notifier _ init ( & v q -> masked _ notifier , ▁0); ▁if ▁( r ▁< ▁0) ▁{ ▁return ▁r ; ▁} ▁file . fd ▁= ▁event _ notifier _ get _ fd ( & v q -> masked _ notifier ); ▁r ▁= ▁dev -> v host _ ops -> v host _ call ( dev , ▁V HOST _ SET _ VR ING _ CALL , ▁& file ); ▁if ▁( r ) ▁{ ▁r ▁= ▁- err no ; ▁goto ▁fail 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁filter _ frame ( AV Filter Link ▁* in link , ▁AV Frame ▁* src _ buffer ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁in link -> dst ; ▁A Temp o Context ▁* ate mp o ▁= ▁ctx -> priv ; ▁AV Filter Link ▁* out link ▁= ▁ctx -> outputs [0]; ▁int ▁ret ▁= ▁0; ▁int ▁n _ in ▁= ▁src _ buffer -> nb _ samples ; ▁int ▁n _ out ▁= ▁( int )( 0.5 ▁+ ▁(( double ) n _ in ) ▁/ ▁at emp o -> temp o ); ▁const ▁uint 8_ t ▁* src ▁= ▁src _ buffer -> data [0]; ▁const ▁uint 8_ t ▁* src _ end ▁= ▁src ▁+ ▁n _ in ▁* ▁at emp o -> strid

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁v host _ net ▁* v host _ net _ init ( V host Net Options ▁* options ) ▁{ ▁int ▁r ; ▁bool ▁backend _ kernel ▁= ▁options -> backend _ type ▁== ▁V HOST _ BACK END _ TYPE _ KER NEL ; ▁struct ▁v host _ net ▁* net ▁= ▁g _ m alloc ( size of ▁* net ); ▁if ▁(! options -> net _ backend ) ▁{ ▁f printf ( stderr , ▁" v host - net ▁requires ▁net ▁backend ▁to ▁be ▁setup \ n "); ▁goto ▁fail ; ▁} ▁if ▁( backend _ kernel ) ▁{ ▁r ▁= ▁v host _ net _ get _ fd ( options -> net _ backend ); ▁if ▁( r ▁< ▁0) ▁{ ▁goto ▁fa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁USB Device ▁* usb _ ms d _ init ( const ▁char ▁* filename ) ▁{ ▁static ▁int ▁nr =0; ▁char ▁id [ 8 ]; ▁Q emu Opts ▁* opts ; ▁Drive Info ▁* d info ; ▁USB Device ▁* dev ; ▁int ▁fatal _ error ; ▁const ▁char ▁* p 1; ▁char ▁fmt [ 32 ]; ▁/* ▁parse ▁- usb device ▁disk : ▁syntax ▁into ▁drive ▁opts ▁*/ ▁sn printf ( id , ▁sizeof ( id ), ▁" usb % d ", ▁nr ++ ); ▁opts ▁= ▁qemu _ opts _ create ( & q emu _ drive _ opts , ▁id , ▁0); ▁p 1 ▁= ▁str chr ( filename , ▁': '); ▁if ▁( p 1 ++) ▁{ ▁const ▁char ▁* p 2; ▁if

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁rv 34 _ mc ( RV 34 Dec Context ▁* r , ▁const ▁int ▁block _ type , ▁const ▁int ▁x off , ▁const ▁int ▁y off , ▁int ▁mv _ off , ▁const ▁int ▁width , ▁const ▁int ▁height , ▁int ▁dir , ▁const ▁int ▁third p el , ▁int ▁weighted , ▁qp el _ mc _ func ▁(* qp el _ mc )[ 16 ], ▁h 2 64_ chrom a _ mc _ func ▁(* chrom a _ mc )) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& r -> s ; ▁uint 8_ t ▁* Y , ▁* U , ▁* V , ▁* src Y , ▁* src U , ▁* src V ; ▁int ▁d xy , ▁mx , ▁my , ▁u mx , ▁u my , ▁lx , ▁ly , ▁u vm x , ▁u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁migrate _ fd _ connect ( Migration State ▁* s ) ▁{ ▁s -> state ▁= ▁M IG _ STATE _ SET UP ; ▁trace _ migrate _ set _ state ( M IG _ STATE _ SET UP ); ▁/* ▁This ▁is ▁a ▁best ▁1 st ▁approx imation . ▁ns ▁to ▁ms ▁*/ ▁s -> expected _ d ow nt ime ▁= ▁max _ d ow nt ime /1 000000 ; ▁s -> cleanup _ b h ▁= ▁qemu _ b h _ new ( migrate _ fd _ cleanup , ▁s ); ▁qemu _ file _ set _ rate _ limit ( s -> file , ▁s -> band width _ limit ▁/ ▁X FER _ LIMIT _ R ATIO ); ▁qemu _ thread _ create ( & s -> thread , ▁migratio

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc 405 cr _ cl k _ setup ▁( pp c 405 cr _ c pc _ t ▁* c pc ) ▁{ ▁uint 64_ t ▁V CO _ out , ▁P LL _ out ; ▁uint 32_ t ▁CPU _ cl k , ▁T MR _ cl k , ▁SD RAM _ cl k , ▁PL B _ cl k , ▁OP B _ cl k , ▁EXT _ cl k , ▁U ART _ cl k ; ▁int ▁M , ▁D 0, ▁D 1, ▁D 2; ▁D 0 ▁= ▁(( c pc -> pl l mr ▁>> ▁26 ) ▁& ▁0 x 3) ▁+ ▁1; ▁/* ▁C BD V ▁*/ ▁if ▁( c pc -> pl l mr ▁& ▁0 x 8 0000000 ) ▁{ ▁D 1 ▁= ▁( (( c pc -> pl l mr ▁>> ▁20 ) ▁- ▁1) ▁& ▁0 xF ) ▁+ ▁1; ▁/* ▁FB D V ▁*/ ▁D 2 ▁= ▁8 ▁- ▁(( c pc -> pl l mr ▁>> ▁16 ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁cmd 64 6_ cmd _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁CMD 646 BAR ▁* cmd 646 bar ▁= ▁opaque ; ▁if ▁( addr ▁!= ▁2 ▁|| ▁size ▁!= ▁1) ▁{ ▁return ▁(( uint 64_ t ) 1 ▁<< ▁( size ▁* ▁8 )) ▁- ▁1; ▁} ▁return ▁ide _ status _ read ( cmd 646 bar -> bus , ▁addr ▁+ ▁2); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁hp et _ ram _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁H PE T State ▁* s ▁= ▁opaque ; ▁uint 64_ t ▁cur _ tick , ▁index ; ▁D PRI NT F (" q emu : ▁Enter ▁hp et _ ram _ read l ▁at ▁% " ▁PRI x 64 ▁"\ n ", ▁addr ); ▁index ▁= ▁addr ; ▁/* address ▁range ▁of ▁all ▁T N ▁regs */ ▁if ▁( index ▁>= ▁0 x 100 ▁&& ▁index ▁<= ▁0 x 3 ff ) ▁{ ▁uint 8_ t ▁timer _ id ▁= ▁( addr ▁- ▁0 x 100 ) ▁/ ▁0 x 20 ; ▁H PE T Timer ▁* timer ▁= ▁& s -> timer [ timer _ id ]; ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ init _ pc i ( V irt IO PC I Proxy ▁* proxy , ▁V irt IO Device ▁* v dev , ▁uint 16_ t ▁vendor , ▁uint 16_ t ▁device , ▁uint 16_ t ▁class _ code , ▁uint 8_ t ▁p if ) ▁{ ▁uint 8_ t ▁* config ; ▁uint 32_ t ▁size ; ▁proxy -> v dev ▁= ▁v dev ; ▁config ▁= ▁proxy -> pc i _ dev . config ; ▁pci _ config _ set _ vendor _ id ( config , ▁vendor ); ▁pci _ config _ set _ device _ id ( config , ▁device ); ▁config [0 x 08 ] ▁= ▁VI RT IO _ PC I _ ABI _ VERSION ; ▁config [0 x 09 ] ▁= ▁p if ; ▁pci _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ device _ add ( const ▁char ▁* dev name , ▁int ▁is _ hot plug ) ▁{ ▁const ▁char ▁* p ; ▁USB Device ▁* dev ; ▁if ▁(! free _ usb _ ports ) ▁return ▁-1; ▁if ▁( str start ( dev name , ▁" host :", ▁& p )) ▁{ ▁dev ▁= ▁usb _ host _ device _ open ( p ); ▁} ▁else ▁if ▁(! str cmp ( dev name , ▁" mouse ")) ▁{ ▁dev ▁= ▁usb _ mouse _ init (); ▁} ▁else ▁if ▁(! str cmp ( dev name , ▁" tab let ")) ▁{ ▁dev ▁= ▁usb _ tab let _ init (); ▁} ▁else ▁if ▁(! str cmp ( dev name , ▁" keyboard ")) ▁{ ▁dev ▁= ▁usb

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁i oin st _ handle _ ms ch ( S 390 CPU ▁* cpu , ▁uint 64_ t ▁reg 1, ▁uint 32_ t ▁ip b ) ▁{ ▁int ▁css id , ▁ssid , ▁sch id , ▁m ; ▁Sub ch Dev ▁* sch ; ▁S CH IB ▁sch ib ; ▁uint 64_ t ▁addr ; ▁int ▁ret ▁= ▁- EN O DEV ; ▁int ▁cc ; ▁CP US 390 X State ▁* env ▁= ▁& cpu -> env ; ▁uint 8_ t ▁ar ; ▁addr ▁= ▁decode _ based isp _ s ( env , ▁ip b , ▁& ar ); ▁if ▁( addr ▁& ▁3) ▁{ ▁program _ interrupt ( env , ▁PG M _ SPE CI FI CATION , ▁2); ▁return ; ▁} ▁if ▁( s 39 0_ cpu _ virt _ mem _ read ( cpu , ▁addr , ▁ar , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁load _ u image ( const ▁char ▁* filename , ▁target _ ulong ▁* ep , ▁target _ ulong ▁* load addr , ▁int ▁* is _ linux ) ▁{ ▁int ▁fd ; ▁int ▁size ; ▁u boot _ image _ header _ t ▁h ; ▁u boot _ image _ header _ t ▁* hdr ▁= ▁& h ; ▁uint 8_ t ▁* data ▁= ▁NULL ; ▁int ▁ret ▁= ▁-1; ▁fd ▁= ▁open ( filename , ▁O _ RD ONLY ▁| ▁O _ BINARY ); ▁if ▁( fd ▁< ▁0) ▁return ▁-1; ▁size ▁= ▁read ( fd , ▁hdr , ▁sizeof ( ub oot _ image _ header _ t )); ▁if ▁( size ▁< ▁0) ▁goto ▁out ; ▁b swap _ ub oot _ header ( hdr ); ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m pc _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁M PC Context ▁* c ▁= ▁s -> priv _ data ; ▁int ▁ret , ▁size , ▁size 2, ▁cur bits , ▁cur ▁= ▁c -> cur frame ; ▁int 64_ t ▁tmp , ▁pos ; ▁if ▁( c -> cur frame ▁>= ▁c -> f count ) ▁return ▁-1; ▁if ( c -> cur frame ▁!= ▁c -> last frame ▁+ ▁1 ){ ▁url _ f seek ( s -> pb , ▁c -> frames [ c -> cur frame ]. pos , ▁SE EK _ SET ); ▁c -> cur bits ▁= ▁c -> frames [ c -> cur frame ]. skip ; ▁} ▁c -> last frame ▁= ▁c -> cur frame ; ▁c -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁hp et _ ram _ writ el ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁value ) ▁{ ▁int ▁i ; ▁H PE T State ▁* s ▁= ▁( H PE T State ▁* ) op aque ; ▁uint 64_ t ▁old _ val , ▁new _ val , ▁val , ▁index ; ▁D PRI NT F (" q emu : ▁Enter ▁hp et _ ram _ writ el ▁at ▁% " ▁PRI x 64 ▁" ▁= ▁% # x \ n ", ▁addr , ▁value ); ▁index ▁= ▁addr ; ▁old _ val ▁= ▁hp et _ ram _ read l ( op aque , ▁addr ); ▁new _ val ▁= ▁value ; ▁/* address ▁range ▁of ▁all ▁T N ▁regs */ ▁if ▁( index ▁>= ▁0 x 100 ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ dump _ state ( CPU State ▁* env , ▁FILE ▁* f , ▁f printf _ function ▁cpu _ f printf , ▁int ▁flags ) ▁{ ▁int ▁i ; ▁cpu _ f printf ( f , ▁" PC =% 08 x \ n ", ▁env -> pc ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁16 ; ▁++ i ) ▁{ ▁cpu _ f printf ( f , ▁" A % 02 d =% 08 x % c ", ▁i , ▁env -> re gs [ i ], ▁( i ▁% ▁4) ▁== ▁3 ▁? ▁'\ n ' ▁: ▁' ▁'); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁net _ init _ socket ( const ▁Net Client Options ▁* opts , ▁const ▁char ▁* name , ▁Net Client State ▁* peer , ▁Error ▁** err p ) ▁{ ▁/* ▁FIX ME ▁error _ set g ( err p , ▁...) ▁on ▁failure ▁*/ ▁Error ▁* err ▁= ▁NULL ; ▁const ▁Net dev Socket Options ▁* sock ; ▁assert ( opts -> kind ▁== ▁NET _ CLIENT _ OPTIONS _ K IND _ SOCKET ); ▁sock ▁= ▁opts -> socket ; ▁if ▁( sock -> has _ fd ▁+ ▁sock -> has _ listen ▁+ ▁sock -> has _ connect ▁+ ▁sock -> has _ m cast ▁+ ▁sock -> has _ ud p ▁!= ▁1) ▁{ ▁error _ report

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁visit _ type _ bool ( Visitor ▁* v , ▁bool ▁* obj , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁if ▁(! error _ is _ set ( err p )) ▁{ ▁v -> type _ bool ( v , ▁obj , ▁name , ▁err p ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁av _ flatten ▁void ▁h 2 64_ loop _ filter _ chrom a _ in tra _ c ( uint 8_ t ▁* pix , ▁int ▁x stride , ▁int ▁y stride , ▁int ▁alpha , ▁int ▁beta ) ▁{ ▁int ▁d ; ▁for ( ▁d ▁= ▁0; ▁d ▁< ▁8 ; ▁d ++ ▁) ▁{ ▁const ▁int ▁p 0 ▁= ▁pix [-1 * x stride ]; ▁const ▁int ▁p 1 ▁= ▁pix [ -2 * x stride ]; ▁const ▁int ▁q 0 ▁= ▁pix [0]; ▁const ▁int ▁q 1 ▁= ▁pix [1 * x stride ]; ▁if ( ▁FF AB S ( ▁p 0 ▁- ▁q 0 ▁) ▁< ▁alpha ▁&& ▁FF AB S ( ▁p 1 ▁- ▁p 0 ▁) ▁< ▁beta ▁&& ▁FF AB S ( ▁q 1 ▁- ▁q 0 ▁) ▁< ▁be

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁protocol _ version ( V nc State ▁* vs , ▁uint 8_ t ▁* version , ▁size _ t ▁len ) ▁{ ▁char ▁local [1 3 ]; ▁mem c py ( local , ▁version , ▁12 ); ▁local [ 12 ] ▁= ▁0; ▁if ▁( ss can f ( local , ▁" RF B ▁% 03 d . % 03 d \ n ", ▁& vs -> major , ▁& vs -> minor ) ▁!= ▁2) ▁{ ▁V NC _ DEBUG (" Malformed ▁protocol ▁version ▁% s \ n ", ▁local ); ▁v nc _ client _ error ( vs ); ▁return ▁0; ▁} ▁V NC _ DEBUG (" Client ▁request ▁protocol ▁version ▁% d . % d \ n ", ▁vs -> major , ▁vs -> minor ); ▁if ▁( vs -> m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁qemu _ irq ▁* px a 2 xx _ pic _ init ( target _ ph ys _ addr _ t ▁base , ▁CPU State ▁* env ) ▁{ ▁struct ▁p xa 2 xx _ pic _ state _ s ▁* s ; ▁int ▁i om em type ; ▁qemu _ irq ▁* q i ; ▁s ▁= ▁( struct ▁p xa 2 xx _ pic _ state _ s ▁* ) ▁qemu _ m alloc z ( size of ( struct ▁p xa 2 xx _ pic _ state _ s )); ▁if ▁(! s ) ▁return ▁NULL ; ▁s -> cpu _ env ▁= ▁env ; ▁s -> base ▁= ▁base ; ▁s -> int _ pending [0] ▁= ▁0; ▁s -> int _ pending [1] ▁= ▁0; ▁s -> int _ enabled [0] ▁= ▁0; ▁s -> int _ enabled [1] ▁= ▁0; ▁s -> i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mp _ decode _ frame ( MP AD ecode Context ▁* s , ▁OUT _ INT ▁** samples , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁int ▁i , ▁nb _ frames , ▁ch , ▁ret ; ▁OUT _ INT ▁* samples _ ptr ; ▁init _ get _ bits ( & s -> gb , ▁buf ▁+ ▁HEADER _ SIZE , ▁( buf _ size ▁- ▁HEADER _ SIZE ) ▁* ▁8 ); ▁/* ▁skip ▁error ▁protection ▁field ▁*/ ▁if ▁( s -> error _ prot ection ) ▁skip _ bits ( & s -> gb , ▁16 ); ▁switch ( s -> layer ) ▁{ ▁case ▁1: ▁s -> av ctx -> frame _ size ▁= ▁3 84 ; ▁nb _ frames ▁= ▁mp 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Inet SocketAddress ▁* ssh _ config ( Q Dict ▁* options , ▁Error ▁** err p ) ▁{ ▁Inet SocketAddress ▁* inet ▁= ▁NULL ; ▁Q Dict ▁* addr ▁= ▁NULL ; ▁Q Object ▁* cr um ple d _ addr ▁= ▁NULL ; ▁Visitor ▁* iv ▁= ▁NULL ; ▁Error ▁* local _ error ▁= ▁NULL ; ▁q dict _ extract _ sub q dict ( options , ▁& addr , ▁" server ."); ▁if ▁(! q dict _ size ( addr )) ▁{ ▁error _ set g ( err p , ▁" SSH ▁server ▁address ▁missing "); ▁goto ▁out ; ▁} ▁cr um ple d _ addr ▁= ▁q dict _ cr um ple ( addr , ▁err p ); ▁if ▁(! c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁sd h ci _ buff _ access _ is _ sequ ential ( SD H CI State ▁* s , ▁unsigned ▁byte _ num ) ▁{ ▁if ▁(( s -> data _ count ▁& ▁0 x 3) ▁!= ▁byte _ num ) ▁{ ▁ERR PRI NT (" Non - sequ ential ▁access ▁to ▁Buffer ▁Data ▁Port ▁register " ▁" is ▁pro hib ited \ n "); ▁return ▁false ; ▁} ▁return ▁true ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ neg ot iate _ write ( Q IO Channel ▁* i oc , ▁const ▁void ▁* buffer , ▁size _ t ▁size ) ▁{ ▁s size _ t ▁ret ; ▁gu int ▁watch ; ▁assert ( q emu _ in _ cor outine ()); ▁/* ▁N eg otiation ▁are ▁always ▁in ▁main ▁loop . ▁*/ ▁watch ▁= ▁q io _ channel _ add _ watch ( i oc , ▁G _ IO _ OUT , ▁nb d _ neg ot iate _ continue , ▁qemu _ cor outine _ self (), ▁NULL ); ▁ret ▁= ▁write _ sync ( i oc , ▁buffer , ▁size , ▁NULL ); ▁g _ source _ remove ( watch ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁aio _ read _ done ( void ▁* op aque , ▁int ▁ret ) ▁{ ▁struct ▁aio _ ctx ▁* ctx ▁= ▁opaque ; ▁struct ▁time val ▁t 2; ▁get time of day ( & t 2, ▁NULL ); ▁if ▁( ret ▁< ▁0) ▁{ ▁printf (" read v ▁failed : ▁% s \ n ", ▁strerror (- ret )); ▁goto ▁out ; ▁} ▁if ▁( ctx -> P flag ) ▁{ ▁void ▁* cmp _ buf ▁= ▁m alloc ( ctx -> q io v . size ); ▁mem set ( cmp _ buf , ▁ctx -> pattern , ▁ctx -> q io v . size ); ▁if ▁( mem cmp ( ctx -> buf , ▁cmp _ buf , ▁ctx -> q io v . size )) ▁{ ▁printf (" Pattern ▁verifi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spr _ read _ t bu ▁( Dis as Context ▁* ctx , ▁int ▁g pr n , ▁int ▁spr n ) ▁{ ▁if ▁( use _ ic ount ) ▁{ ▁gen _ io _ start (); ▁} ▁gen _ helper _ load _ t bu ( cpu _ g pr [ g pr n ], ▁cpu _ env ); ▁if ▁( use _ ic ount ) ▁{ ▁gen _ io _ end (); ▁gen _ stop _ exception ( ctx ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nv dim m _ build _ common _ ds m ( A ml ▁* dev ) ▁{ ▁A ml ▁* method , ▁* if ctx , ▁* function , ▁* ds m _ mem , ▁* un patch ed , ▁* result _ size ; ▁uint 8_ t ▁byte _ list [1]; ▁method ▁= ▁a ml _ method ( NV DI MM _ COM MON _ DS M , ▁4, ▁A ML _ SER IALIZED ); ▁function ▁= ▁a ml _ arg (2); ▁d sm _ mem ▁= ▁a ml _ name ( NV DI MM _ AC PI _ ME M _ ADDR ); ▁/* ▁* ▁do ▁not ▁support ▁any ▁method ▁if ▁D SM ▁memory ▁address ▁has ▁not ▁been ▁* ▁patched . ▁*/ ▁un patch ed ▁= ▁a ml _ if ( aml _ equal (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁gn ut ls _ anon _ server _ credentials ▁v nc _ tls _ initialize _ anon _ cred ( void ) ▁{ ▁gn ut ls _ anon _ server _ credentials ▁anon _ cred ; ▁int ▁ret ; ▁if ▁(( ret ▁= ▁gn ut ls _ anon _ allocate _ server _ credentials ( & anon _ cred )) ▁< ▁0) ▁{ ▁V NC _ DEBUG (" Cannot ▁allocate ▁credentials ▁% s \ n ", ▁gn ut ls _ str error ( ret )); ▁return ▁NULL ; ▁} ▁gn ut ls _ anon _ set _ server _ dh _ params ( anon _ cred , ▁dh _ params ); ▁return ▁anon _ cred ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁zero _ single _ l 2( Block Driver State ▁* bs , ▁uint 64_ t ▁offset , ▁unsigned ▁int ▁nb _ clusters ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁* l 2_ table ; ▁int ▁l 2_ index ; ▁int ▁ret ; ▁int ▁i ; ▁ret ▁= ▁get _ cluster _ table ( bs , ▁offset , ▁& l 2_ table , ▁& l 2_ index ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁/* ▁Limit ▁nb _ clusters ▁to ▁one ▁L 2 ▁table ▁*/ ▁nb _ clusters ▁= ▁MIN ( nb _ clusters , ▁s -> l 2_ size ▁- ▁l 2_ index ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁nb _ c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Address Space ▁* s 39 0_ pc i _ d ma _ iom mu ( PC I Bus ▁* bus , ▁void ▁* op aque , ▁int ▁dev fn ) ▁{ ▁S 390 pc i State ▁* s ▁= ▁opaque ; ▁return ▁& s -> pb dev [ PC I _ SL OT ( dev fn ) ]. as ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ info _ commands ( void ) ▁{ ▁char ▁* resp , ▁* info , ▁* info _ buf , ▁* end p ; ▁info _ buf ▁= ▁info ▁= ▁h mp (" help ▁info "); ▁while ▁(* info ) ▁{ ▁/* ▁Extract ▁the ▁info ▁command , ▁ignore ▁parameters ▁and ▁description ▁*/ ▁g _ assert ( str n cmp ( info , ▁" info ▁", ▁5) ▁== ▁0); ▁end p ▁= ▁str chr ( & info [5 ], ▁' ▁'); ▁g _ assert ( end p ▁!= ▁NULL ); ▁* end p ▁= ▁'\ 0 '; ▁/* ▁Now ▁run ▁the ▁info ▁command ▁*/ ▁if ▁( verbose ) ▁{ ▁f printf ( stderr , ▁"\ t % s \ n ", ▁info ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ mov ( TC G Context ▁* s , ▁TC G Type ▁type , ▁TC G Reg ▁ret , ▁TC G Reg ▁arg ) ▁{ ▁uint 8_ t ▁* old _ code _ ptr ▁= ▁s -> code _ ptr ; ▁assert ( ret ▁!= ▁arg ); ▁# if ▁TC G _ TARGET _ REG _ BITS ▁== ▁32 ▁tc g _ out _ op _ t ( s , ▁INDEX _ op _ mov _ i 32 ); ▁# else ▁tc g _ out _ op _ t ( s , ▁INDEX _ op _ mov _ i 64 ); ▁# end if ▁tc g _ out _ r ( s , ▁ret ); ▁tc g _ out _ r ( s , ▁arg ); ▁old _ code _ ptr [1] ▁= ▁s -> code _ ptr ▁- ▁old _ code _ ptr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁do _ token _ in ( US B Device ▁* s , ▁USB Packet ▁* p ) ▁{ ▁int ▁request , ▁value , ▁index ; ▁int ▁ret ▁= ▁0; ▁assert ( p -> de ve p ▁== ▁0); ▁request ▁= ▁( s -> setup _ buf [0] ▁<< ▁8) ▁| ▁s -> setup _ buf [1]; ▁value ▁= ▁( s -> setup _ buf [3] ▁<< ▁8) ▁| ▁s -> setup _ buf [2 ]; ▁index ▁= ▁( s -> setup _ buf [5] ▁<< ▁8) ▁| ▁s -> setup _ buf [4 ]; ▁switch ( s -> setup _ state ) ▁{ ▁case ▁SET UP _ STATE _ ACK : ▁if ▁(! ( s -> setup _ buf [0] ▁& ▁USB _ DIR _ IN )) ▁{ ▁ret ▁= ▁usb _ device _ ha

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁backup _ do _ c ow ( Backup Block Job ▁* job , ▁int 64_ t ▁offset , ▁uint 64_ t ▁bytes , ▁bool ▁* error _ is _ read , ▁bool ▁is _ write _ notifier ) ▁{ ▁Block Backend ▁* blk ▁= ▁job -> common . blk ; ▁C ow Request ▁cow _ request ; ▁struct ▁i ove c ▁i ov ; ▁Q EM UI O Vector ▁bounce _ q io v ; ▁void ▁* b ounce _ buffer ▁= ▁NULL ; ▁int ▁ret ▁= ▁0; ▁int 64_ t ▁start , ▁end ; ▁/* ▁bytes ▁*/ ▁int ▁n ; ▁/* ▁bytes ▁*/ ▁qemu _ co _ rw lock _ rd lock ( & job -> flush _ rw lock ); ▁star

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁inject _ error ( Block Driver State ▁* bs , ▁Bl k debug Rule ▁* rule ) ▁{ ▁B DR V Bl k debug State ▁* s ▁= ▁bs -> op aque ; ▁int ▁error ▁= ▁rule -> options . inject . error ; ▁bool ▁immediately ▁= ▁rule -> options . inject . im mediately ; ▁if ▁( rule -> options . inject . once ) ▁{ ▁Q SI MPLE Q _ REMOVE ( & s -> active _ rules , ▁rule , ▁Bl k debug Rule , ▁active _ next ); ▁remove _ rule ( rule ); ▁} ▁if ▁(! im mediately ) ▁{ ▁aio _ co _ schedule ( q emu _ get _ current _ a io _ context (),

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pf lash _ write ( pf lash _ t ▁* p fl , ▁hw addr ▁offset , ▁uint 32_ t ▁value , ▁int ▁width , ▁int ▁be ) ▁{ ▁uint 8_ t ▁* p ; ▁uint 8_ t ▁cmd ; ▁cmd ▁= ▁value ; ▁D PRI NT F ("% s : ▁writing ▁offset ▁" ▁TARGET _ F MT _ pl x ▁" ▁value ▁% 08 x ▁width ▁% d ▁w cycle ▁0 x % x \ n ", ▁__ func __, ▁offset , ▁value , ▁width , ▁p fl -> w cycle ); ▁if ▁(! p fl -> w cycle ) ▁{ ▁/* ▁Set ▁the ▁device ▁in ▁I / O ▁access ▁mode ▁*/ ▁memory _ region _ rom _ device _ set _ readable ( & p fl -> mem , ▁false );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ init _ vc pu ( CPU State ▁* cpu ) ▁{ ▁K VM State ▁* s ▁= ▁k vm _ state ; ▁long ▁mmap _ size ; ▁int ▁ret ; ▁D PRI NT F (" k vm _ init _ vc pu \ n "); ▁ret ▁= ▁k vm _ vm _ io ctl ( s , ▁K VM _ CREATE _ V CPU , ▁( void ▁* ) k vm _ arch _ vc pu _ id ( cpu )); ▁if ▁( ret ▁< ▁0) ▁{ ▁D PRI NT F (" k vm _ create _ vc pu ▁failed \ n "); ▁goto ▁err ; ▁} ▁cpu -> k vm _ fd ▁= ▁ret ; ▁cpu -> k vm _ state ▁= ▁s ; ▁cpu -> k vm _ vc pu _ dirty ▁= ▁true ; ▁mmap _ size ▁= ▁k vm _ io ctl ( s , ▁K VM _ GET _ V C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁arm _ cpu _ do _ interrupt ( CPU State ▁* cs ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁ARM _ CPU ( cs ); ▁CPU ARM State ▁* env ▁= ▁& cpu -> env ; ▁unsigned ▁int ▁new _ el ▁= ▁env -> exception . target _ el ; ▁assert (! arm _ feature ( env , ▁ARM _ FEATURE _ M )); ▁arm _ log _ exception ( cs -> exception _ index ); ▁qemu _ log _ mask ( CPU _ LOG _ INT , ▁"... from ▁EL % d ▁to ▁EL % d \ n ", ▁arm _ current _ el ( env ), ▁new _ el ); ▁if ▁( q emu _ log level _ mask ( CPU _ LOG _ INT ) ▁&& ▁! ex cp _ is _ internal ( cs

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ net _ flush _ tx ( V irt ION et ▁* n , ▁V irt Queue ▁* v q ) ▁{ ▁V irt Queue Element ▁elem ; ▁if ▁(! ( n -> v dev . status ▁& ▁VI RT IO _ CONFIG _ S _ D RIVER _ OK )) ▁return ; ▁if ▁( n -> async _ tx . elem . out _ num ) ▁{ ▁virt io _ queue _ set _ notification ( n -> tx _ v q , ▁0); ▁return ; ▁} ▁while ▁( virt queue _ pop ( v q , ▁& elem )) ▁{ ▁s size _ t ▁ret , ▁len ▁= ▁0; ▁unsigned ▁int ▁out _ num ▁= ▁elem . out _ num ; ▁struct ▁i ove c ▁* out _ sg ▁= ▁& elem . out _ sg [0]; ▁u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁flush _ queued _ data ( V irt IO Serial Port ▁* port , ▁bool ▁discard ) ▁{ ▁assert ( port ▁|| ▁discard ); ▁do _ flush _ queued _ data ( port , ▁port -> ov q , ▁& port -> v ser -> v dev , ▁discard ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h dev _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁B DR V Raw State ▁* s ▁= ▁bs -> op aque ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁# if ▁defined (__ APP LE __) ▁&& ▁defined (__ MA CH __) ▁const ▁char ▁* filename ▁= ▁q dict _ get _ str ( options , ▁" filename "); ▁char ▁b sd _ path [ MAX PATH LEN ] ▁= ▁""; ▁bool ▁error _ occ urred ▁= ▁false ; ▁/* ▁If ▁using ▁a ▁real ▁cd rom ▁*/ ▁if ▁( str cmp ( filename , ▁"/ dev / cd rom ") ▁== ▁0) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sc si _ bus _ legacy _ handle _ cmdline ( SC SI Bus ▁* bus ) ▁{ ▁Location ▁loc ; ▁Drive Info ▁* d info ; ▁int ▁res ▁= ▁0, ▁unit ; ▁loc _ push _ none ( & loc ); ▁for ▁( unit ▁= ▁0; ▁unit ▁< ▁bus -> info -> max _ target ; ▁unit ++) ▁{ ▁d info ▁= ▁drive _ get ( IF _ SC SI , ▁bus -> bus nr , ▁unit ); ▁if ▁( d info ▁== ▁NULL ) ▁{ ▁continue ; ▁} ▁qemu _ opts _ loc _ restore ( d info -> opts ); ▁if ▁(! sc si _ bus _ legacy _ add _ drive ( bus , ▁d info -> b dr v , ▁unit , ▁false , ▁-1 )) ▁{ ▁res ▁= ▁-1; ▁b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁link _ filter _ in outs ( AV Filter Context ▁* fil t _ ctx , ▁AV Filter In Out ▁** curr _ inputs , ▁AV Filter In Out ▁** open _ inputs , ▁AV Class ▁* log _ ctx ) ▁{ ▁int ▁pad ▁= ▁filt _ ctx -> input _ count , ▁ret ; ▁while ▁( pad --) ▁{ ▁AV Filter In Out ▁* p ▁= ▁* curr _ inputs ; ▁if ▁(! p ) ▁{ ▁av _ log ( log _ ctx , ▁AV _ LOG _ ERROR , ▁" Not ▁enough ▁inputs ▁specified ▁for ▁the ▁\" % s \" ▁filter .\ n ", ▁filt _ ctx -> filter -> name ); ▁return ▁A VER ROR ( E IN VAL ); ▁} ▁* curr _ input

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x 86_ cpu _ common _ class _ init ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁X 86 CPU Class ▁* x cc ▁= ▁X 86_ CPU _ CLASS ( oc ); ▁CPU Class ▁* cc ▁= ▁CPU _ CLASS ( oc ); ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( oc ); ▁x cc -> parent _ real ize ▁= ▁dc -> real ize ; ▁dc -> real ize ▁= ▁x 86_ cpu _ real iz ef n ; ▁dc -> bus _ type ▁= ▁TYPE _ IC C _ B US ; ▁dc -> props ▁= ▁x 86_ cpu _ properties ; ▁x cc -> parent _ reset ▁= ▁cc -> reset ; ▁cc -> reset ▁= ▁x 86_ cpu _ reset ; ▁cc -> reset _ dum

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q pa _ init _ in ▁( H W Voice In ▁* hw , ▁aud settings _ t ▁* as ) ▁{ ▁int ▁error ; ▁static ▁pa _ sample _ spec ▁ss ; ▁aud settings _ t ▁obt _ as ▁= ▁* as ; ▁PA Voice In ▁* pa ▁= ▁( PA Voice In ▁* ) ▁hw ; ▁ss . format ▁= ▁aud fmt _ to _ pa ▁( as -> fmt , ▁as -> endian ness ); ▁ss . channels ▁= ▁as -> n channels ; ▁ss . rate ▁= ▁as -> freq ; ▁obt _ as . fmt ▁= ▁pa _ to _ aud fmt ▁( ss . format , ▁& ob t _ as . endian ness ); ▁pa -> s ▁= ▁pa _ simple _ new ▁( ▁conf . server , ▁" q emu ", ▁PA _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁helper _ compute _ f pr f ▁( uint 64_ t ▁arg , ▁uint 32_ t ▁set _ f pr f ) ▁{ ▁CPU _ Double U ▁f arg ; ▁int ▁isn eg ; ▁int ▁ret ; ▁f arg . ll ▁= ▁arg ; ▁isn eg ▁= ▁float 64_ is _ neg ( f arg . d ); ▁if ▁( un likely ( float 64_ is _ nan ( f arg . d ))) ▁{ ▁if ▁( float 64_ is _ signal ing _ nan ( f arg . d )) ▁{ ▁/* ▁Signal ing ▁NaN : ▁flags ▁are ▁undefined ▁*/ ▁ret ▁= ▁0 x 00 ; ▁} ▁else ▁{ ▁/* ▁Qu iet ▁NaN ▁*/ ▁ret ▁= ▁0 x 11 ; ▁} ▁} ▁else ▁if ▁( un likely ( float 64_ is _ infinity ( f arg . d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁v ga _ i op ort _ write ( void ▁* op aque , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁V GA Common State ▁* s ▁= ▁opaque ; ▁int ▁index ; ▁/* ▁check ▁port ▁range ▁access ▁depending ▁on ▁color / mon och rome ▁mode ▁*/ ▁if ▁( v ga _ i op ort _ invalid ( s , ▁addr )) ▁{ ▁return ; ▁} ▁# if def ▁DEBUG _ V GA ▁printf (" V GA : ▁write ▁addr =0 x % 04 x ▁data =0 x % 02 x \ n ", ▁addr , ▁val ); ▁# end if ▁switch ( addr ) ▁{ ▁case ▁V GA _ ATT _ W : ▁if ▁( s -> ar _ flip _ f lop ▁== ▁0) ▁{ ▁val ▁&= ▁0 x 3 f ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb net _ can _ receive ( Net Client State ▁* nc ) ▁{ ▁USB Net State ▁* s ▁= ▁qemu _ get _ nic _ op aque ( nc ); ▁if ▁(! s -> dev . config ) ▁{ ▁return ▁0; ▁} ▁if ▁( is _ r nd is ( s ) ▁&& ▁s -> r nd is _ state ▁!= ▁R ND IS _ DATA _ INIT IALIZED ) ▁{ ▁return ▁1; ▁} ▁return ▁! s -> in _ len ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dhcp _ decode ( const ▁uint 8_ t ▁* buf , ▁int ▁size , ▁int ▁* p msg _ type ) ▁{ ▁const ▁uint 8_ t ▁* p , ▁* p _ end ; ▁int ▁len , ▁tag ; ▁* p msg _ type ▁= ▁0; ▁p ▁= ▁buf ; ▁p _ end ▁= ▁buf ▁+ ▁size ; ▁if ▁( size ▁< ▁5) ▁return ; ▁if ▁( mem cmp ( p , ▁rfc 15 33 _ cookie , ▁4) ▁!= ▁0) ▁return ; ▁p ▁+= ▁4; ▁while ▁( p ▁< ▁p _ end ) ▁{ ▁tag ▁= ▁p [0]; ▁if ▁( tag ▁== ▁RFC 15 33 _ P AD ) ▁{ ▁p ++; ▁} ▁else ▁if ▁( tag ▁== ▁RFC 15 33 _ END ) ▁{ ▁break ; ▁} ▁else ▁{ ▁p ++; ▁if ▁( p ▁>= ▁p _ end ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁x h ci _ fire _ ctl _ transfer ( X H CI State ▁* x h ci , ▁X H C IT rans fer ▁* x fer ) ▁{ ▁X H C IT RB ▁* tr b _ setup , ▁* tr b _ status ; ▁uint 8_ t ▁bm Request Type ; ▁tr b _ setup ▁= ▁& x fer -> tr bs [0]; ▁tr b _ status ▁= ▁& x fer -> tr bs [ x fer -> tr b _ count -1 ]; ▁trace _ usb _ x h ci _ x fer _ start ( x fer , ▁x fer -> ep ctx -> slot id , ▁x fer -> ep ctx -> ep id , ▁x fer -> stream id ); ▁/* ▁at ▁most ▁one ▁Event ▁Data ▁TR B ▁allowed ▁after ▁STATUS ▁*/ ▁if ▁( TR B _ TYPE (* tr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ free _ timer ( Q EM UT imer ▁* ts ) ▁{ ▁g _ free ( ts ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁dv d sub _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁D VD Sub Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁av _ fre ep ( & ctx -> buf ); ▁ctx -> buf _ size ▁= ▁0; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ disk _ em ulate _ read _ toc ( SC SI Request ▁* req , ▁uint 8_ t ▁* out buf ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁req -> dev ); ▁int ▁start _ track , ▁format , ▁ms f , ▁to cl en ; ▁uint 64_ t ▁nb _ sect ors ; ▁ms f ▁= ▁req -> cmd . buf [1] ▁& ▁2; ▁format ▁= ▁req -> cmd . buf [2] ▁& ▁0 xf ; ▁start _ track ▁= ▁req -> cmd . buf [6 ]; ▁b dr v _ get _ geometry ( s -> q dev . conf . bs , ▁& nb _ sect ors ); ▁D PRI NT F (" Read ▁TO C ▁( track ▁% d ▁fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ in validate _ cache ( Block Driver State ▁* bs , ▁Error ▁** err p ) ▁{ ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁ret ; ▁if ▁(! bs -> dr v ) ▁{ ▁return ; ▁} ▁if ▁(! ( bs -> open _ flags ▁& ▁B DR V _ O _ IN ACTIVE )) ▁{ ▁return ; ▁} ▁bs -> open _ flags ▁&= ▁~ B DR V _ O _ IN ACTIVE ; ▁if ▁( bs -> dr v -> b dr v _ in validate _ cache ) ▁{ ▁bs -> dr v -> b dr v _ in validate _ cache ( bs , ▁& local _ err ); ▁} ▁else ▁if ▁( bs -> file ) ▁{ ▁b dr v _ in validate _ cache ( bs -> file -> bs , ▁& loca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ u h ci _ vt 82 c 6 86 b _ init fn ( PC ID evice ▁* dev ) ▁{ ▁U H CI State ▁* s ▁= ▁DO _ UP CAST ( U H CI State , ▁dev , ▁dev ); ▁uint 8_ t ▁* pc i _ conf ▁= ▁s -> dev . config ; ▁pci _ config _ set _ vendor _ id ( pc i _ conf , ▁P CI _ VE ND OR _ ID _ VI A ); ▁pci _ config _ set _ device _ id ( pc i _ conf , ▁P CI _ DEVICE _ ID _ VI A _ U H CI ); ▁/* ▁USB ▁misc ▁control ▁1 /2 ▁*/ ▁pci _ set _ long ( pc i _ conf ▁+ ▁0 x 4 0,0 x 0000 1000 ); ▁/* ▁PM ▁capability ▁*/ ▁pci _ set _ long ( pc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁gen _ i w mm xt _ shift ( uint 32_ t ▁insn , ▁uint 32_ t ▁mask , ▁TC G v ▁dest ) ▁{ ▁int ▁rd ▁= ▁( ins n ▁>> ▁0) ▁& ▁0 xf ; ▁TC G v ▁tmp ; ▁if ▁( ins n ▁& ▁(1 ▁<< ▁8 )) ▁{ ▁if ▁( rd ▁< ▁ARM _ I W MM XT _ w C GR 0 ▁|| ▁rd ▁> ▁ARM _ I W MM XT _ w C GR 3) ▁{ ▁return ▁1; ▁} ▁else ▁{ ▁tmp ▁= ▁iw mm xt _ load _ cre g ( rd ); ▁} ▁} ▁else ▁{ ▁tmp ▁= ▁new _ tmp (); ▁iw mm xt _ load _ reg ( cpu _ V 0, ▁rd ); ▁tc g _ gen _ trunc _ i 64_ i 32 ( tmp , ▁cpu _ V 0); ▁} ▁tc g _ gen _ and i _ i 32 ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ v ga _ pro be _ n vid ia _3 d 0_ quir k ( V FI OP C ID evice ▁* v dev ) ▁{ ▁V FI O Qu ir k ▁* quir k ; ▁V F ION vid ia 3 d 0 Qu ir k ▁* data ; ▁if ▁(! vf io _ pc i _ is ( v dev , ▁P CI _ VE ND OR _ ID _ NV ID IA , ▁P CI _ ANY _ ID ) ▁|| ▁! v dev -> bars [1]. region . size ) ▁{ ▁return ; ▁} ▁quir k ▁= ▁g _ m alloc 0( size of (* quir k )); ▁quir k -> data ▁= ▁data ▁= ▁g _ m alloc 0( size of (* data )); ▁quir k -> mem ▁= ▁g _ m alloc 0( size of ( Memory Region ) ▁* ▁2); ▁quir k -> nr _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cookie _ string ( AV Dictionary ▁* dict , ▁char ▁** cookies ) ▁{ ▁AV Dictionary Entry ▁* e ▁= ▁NULL ; ▁int ▁len ▁= ▁1; ▁// ▁determine ▁how ▁much ▁memory ▁is ▁needed ▁for ▁the ▁cookies ▁string ▁while ▁( e ▁= ▁av _ dict _ get ( dict , ▁"", ▁e , ▁AV _ DICT _ IGNO RE _ SUFFIX )) ▁len ▁+= ▁str len ( e -> key ) ▁+ ▁str len ( e -> value ) ▁+ ▁1; ▁// ▁real locate ▁the ▁cookies ▁e ▁= ▁NULL ; ▁if ▁(* cookies ) ▁av _ free (* cookies ); ▁* cookies ▁= ▁av _ m alloc ( len ); ▁if ▁(! cookies ) ▁return ▁A V

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ ph ysical _ address ▁( CP UM IP S State ▁* env , ▁hw addr ▁* ph ysical , ▁int ▁* prot , ▁target _ ulong ▁real _ address , ▁int ▁rw , ▁int ▁access _ type ) ▁{ ▁/* ▁User ▁mode ▁can ▁only ▁access ▁use g / x use g ▁*/ ▁int ▁user _ mode ▁= ▁( env -> h flags ▁& ▁M IP S _ H FLAG _ MODE ) ▁== ▁M IP S _ H FLAG _ UM ; ▁int ▁supervisor _ mode ▁= ▁( env -> h flags ▁& ▁M IP S _ H FLAG _ MODE ) ▁== ▁M IP S _ H FLAG _ SM ; ▁int ▁kernel _ mode ▁= ▁! user _ mode ▁&& ▁! super visor _ mode ; ▁# if ▁defin

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ ht ab _ fd ( s P AP R Machine State ▁* sp ap r ) ▁{ ▁if ▁( sp ap r -> ht ab _ fd ▁>= ▁0) ▁{ ▁return ▁sp ap r -> ht ab _ fd ; ▁} ▁sp ap r -> ht ab _ fd ▁= ▁k vm pp c _ get _ ht ab _ fd ( false ); ▁if ▁( sp ap r -> ht ab _ fd ▁< ▁0) ▁{ ▁error _ report (" Unable ▁to ▁open ▁fd ▁for ▁reading ▁hash ▁table ▁from ▁K VM : ▁% s ", ▁strerror ( err no )); ▁} ▁return ▁sp ap r -> ht ab _ fd ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q object _ input _ start _ list ( Visitor ▁* v , ▁const ▁char ▁* name , ▁Generic List ▁** list , ▁size _ t ▁size , ▁Error ▁** err p ) ▁{ ▁Q Object Input Visitor ▁* q iv ▁= ▁to _ q iv ( v ); ▁Q Object ▁* q obj ▁= ▁q object _ input _ get _ object ( q iv , ▁name , ▁true , ▁err p ); ▁const ▁Q ListEntry ▁* entry ; ▁if ▁( list ) ▁{ ▁* list ▁= ▁NULL ; ▁} ▁if ▁(! q obj ) ▁{ ▁return ; ▁} ▁if ▁( q object _ type ( q obj ) ▁!= ▁Q TYPE _ Q LIST ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q ga _ file _ write _ read ( g const pointer ▁fix ) ▁{ ▁const ▁Test Fixture ▁* fixture ▁= ▁fix ; ▁const ▁unsigned ▁char ▁hel loworld [] ▁= ▁" Hello ▁World ! \ n "; ▁const ▁char ▁* b 64 ; ▁g char ▁* cmd , ▁* enc ; ▁Q Dict ▁* ret , ▁* val ; ▁int 64_ t ▁id , ▁eof ; ▁g size ▁count ; ▁/* ▁open ▁*/ ▁ret ▁= ▁q mp _ fd ( fixture -> fd , ▁" {' execute ': ▁' guest - file - open ', " ▁" ▁' arguments ': ▁{ ▁' path ': ▁' foo ', ▁' mode ': ▁' w +' ▁} ▁} "); ▁g _ assert _ non null ( ret ); ▁q mp _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ visitor _ out _ native _ list _ uint 16 ( Test Output Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁test _ native _ list ( data , ▁unused , ▁USER _ DEF _ N ATIVE _ LIST _ UN ION _ K IND _ U 16 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁xen _9 p fs _ connect ( struct ▁X en Device ▁* x end ev ) ▁{ ▁int ▁i ; ▁X en 9 p fs Dev ▁* x en _9 pd ev ▁= ▁container _ of ( x end ev , ▁X en 9 p fs Dev , ▁x end ev ); ▁V 9 fs State ▁* s ▁= ▁& x en _9 pd ev -> state ; ▁Q emu Opts ▁* fs dev ; ▁if ▁( x en store _ read _ fe _ int ( & x en _9 pd ev -> x end ev , ▁" num - r ings ", ▁& x en _9 pd ev -> num _ r ings ) ▁== ▁-1 ▁|| ▁xen _9 pd ev -> num _ r ings ▁> ▁MAX _ RING S ▁|| ▁xen _9 pd ev -> num _ r ings ▁< ▁1) ▁{ ▁return ▁-1; ▁} ▁xen _9 pd e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ opt _ gen _ mov ( TC G Context ▁* s , ▁TC G Op ▁* op , ▁TC G Arg ▁* args , ▁TC G Arg ▁dst , ▁TC G Arg ▁src ) ▁{ ▁if ▁( tem ps _ are _ cop ies ( dst , ▁src )) ▁{ ▁tc g _ op _ remove ( s , ▁op ); ▁return ; ▁} ▁if ▁( temp _ is _ const ( src )) ▁{ ▁tc g _ opt _ gen _ mov i ( s , ▁op , ▁args , ▁dst , ▁tem ps [ src ]. val ); ▁return ; ▁} ▁TC G Op code ▁new _ op ▁= ▁op _ to _ mov ( op -> op c ); ▁tc g _ target _ ulong ▁mask ; ▁op -> op c ▁= ▁new _ op ; ▁reset _ temp ( dst ); ▁mask ▁= ▁tem p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁ff _ ds put il _ init _ vis ( DS P Context ▁* c , ▁AV Codec Context ▁* av ctx ) ▁{ ▁/* ▁VIS - specific ▁optimizations ▁*/ ▁int ▁accel ▁= ▁vis _ level ▁(); ▁const ▁int ▁high _ bit _ depth ▁= ▁av ctx -> bits _ per _ raw _ sample ▁> ▁8 ; ▁if ▁( accel ▁& ▁AC CEL _ SP AR C _ VI S ) ▁{ ▁if ▁( av ctx -> bits _ per _ raw _ sample ▁<= ▁8 ▁&& ▁av ctx -> id ct _ al go ▁== ▁FF _ ID CT _ SI MPLE VI S ) ▁{ ▁c -> id ct _ put ▁= ▁ff _ simple _ id ct _ put _ vis ; ▁c -> id ct _ add ▁= ▁ff _ simple _ id 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁vp 8_ mc ( VP 8 Context ▁* s , ▁int ▁l um a , ▁uint 8_ t ▁* dst , ▁uint 8_ t ▁* src , ▁const ▁V P 56 mv ▁* mv , ▁int ▁x _ off , ▁int ▁y _ off , ▁int ▁block _ w , ▁int ▁block _ h , ▁int ▁width , ▁int ▁height , ▁int ▁lines ize , ▁vp 8_ mc _ func ▁mc _ func [3 ][ 3 ]) ▁{ ▁if ▁( AV _ R N 32 A ( mv )) ▁{ ▁static ▁const ▁uint 8_ t ▁idx [3 ][ 8] ▁= ▁{ ▁{ ▁0, ▁1, ▁2, ▁1, ▁2, ▁1, ▁2, ▁1 ▁}, ▁// ▁nr . ▁of ▁left ▁extra ▁pixels , ▁// ▁also ▁function ▁pointer ▁index ▁{ ▁0, ▁3, ▁5, ▁3, ▁5, ▁3, ▁5, ▁3 ▁}, ▁// ▁nr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁parse _ uint 16 ( Device State ▁* dev , ▁Property ▁* prop , ▁const ▁char ▁* str ) ▁{ ▁uint 16_ t ▁* ptr ▁= ▁q dev _ get _ prop _ ptr ( dev , ▁prop ); ▁const ▁char ▁* fmt ; ▁/* ▁accept ▁both ▁hex ▁and ▁decimal ▁*/ ▁fmt ▁= ▁str n case cmp ( str , ▁"0 x ", 2) ▁== ▁0 ▁? ▁"% " ▁PRI x 16 ▁: ▁"% " ▁PRI u 16 ; ▁if ▁( ss can f ( str , ▁fmt , ▁ptr ) ▁!= ▁1) ▁return ▁- E IN VAL ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁DEC LA RE _ LO OP _ FILTER ( mm x ext ) ▁DEC LA RE _ LO OP _ FILTER ( s se 2) ▁DEC LA RE _ LO OP _ FILTER ( ss se 3) ▁DEC LA RE _ LO OP _ FILTER ( s se 4) ▁# end if ▁/* ▁HAVE _ Y AS M ▁*/ ▁# define ▁V P 8_ L UM A _ MC _ F UNC ( ID X , ▁SIZE , ▁OPT ) ▁\ ▁c -> put _ vp 8_ ep el _ pixels _ tab [ ID X ][0] [2] ▁= ▁ff _ put _ vp 8_ ep el ▁## ▁SIZE ▁## ▁_ h 6_ ▁## ▁OPT ; ▁\ ▁c -> put _ vp 8_ ep el _ pixels _ tab [ ID X ][ 2] [0] ▁= ▁ff _ put _ vp 8_ ep el ▁## ▁SIZE ▁## ▁_ v 6_ ▁## ▁OPT ; ▁\ ▁c -> put _ vp 8_ e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ bat ▁( CPU State ▁* env , ▁mm u _ ctx _ t ▁* ctx , ▁target _ ulong ▁virtual , ▁int ▁rw , ▁int ▁type ) ▁{ ▁target _ ulong ▁* B AT lt , ▁* B AT ut , ▁* B AT u , ▁* B AT l ; ▁target _ ulong ▁base , ▁BE PI l , ▁BE PI u , ▁bl ; ▁int ▁i ; ▁int ▁ret ▁= ▁-1; ▁# if ▁defined ▁( DEBUG _ B AT S ) ▁if ▁( log level ▁!= ▁0) ▁{ ▁f printf ( log file , ▁"% s : ▁% c B AT ▁v ▁0 x " ▁ADDR X ▁"\ n ", ▁__ func __, ▁type ▁== ▁ACCESS _ CODE ▁? ▁' I ' ▁: ▁' D ', ▁virtual ); ▁} ▁# end if ▁switch ▁( type ) ▁{ ▁ca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* migration _ thread ( void ▁* op aque ) ▁{ ▁Migration State ▁* s ▁= ▁opaque ; ▁/* ▁Used ▁by ▁the ▁bandwidth ▁cal cs , ▁updated ▁later ▁*/ ▁int 64_ t ▁initial _ time ▁= ▁qemu _ clock _ get _ ms ( Q EM U _ C LOCK _ RE AL TIME ); ▁int 64_ t ▁setup _ start ▁= ▁qemu _ clock _ get _ ms ( Q EM U _ C LOCK _ HOST ); ▁int 64_ t ▁initial _ bytes ▁= ▁0; ▁int 64_ t ▁max _ size ▁= ▁0; ▁int 64_ t ▁start _ time ▁= ▁initial _ time ; ▁int 64_ t ▁end _ time ; ▁bool ▁old _ vm _ running ▁= ▁false ; ▁bool ▁ente

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁replay _ input _ event ( Q emu Console ▁* src , ▁InputEvent ▁* evt ) ▁{ ▁if ▁( re play _ mode ▁== ▁RE PLAY _ MODE _ PLAY ) ▁{ ▁/* ▁Nothing ▁*/ ▁} ▁else ▁if ▁( re play _ mode ▁== ▁RE PLAY _ MODE _ RECORD ) ▁{ ▁replay _ add _ input _ event ( q api _ clone _ Input Event ( evt )); ▁} ▁else ▁{ ▁qemu _ input _ event _ send _ impl ( src , ▁evt ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁unsigned ▁int ▁get _ uint ( Short en Context ▁* s , ▁int ▁k ) ▁{ ▁if ▁( s -> version ▁!= ▁0) ▁k ▁= ▁get _ ur _ g ol omb _ short en ( & s -> gb , ▁U LONG SIZE ); ▁return ▁get _ ur _ g ol omb _ short en ( & s -> gb , ▁k ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁scale _ co efs ▁( ▁int 32_ t ▁* dst , ▁const ▁int 32_ t ▁* src , ▁int ▁dyn rng , ▁int ▁len ) ▁{ ▁int ▁i , ▁shift , ▁round ; ▁int 16_ t ▁mul ; ▁int ▁temp , ▁temp 1, ▁temp 2, ▁temp 3, ▁temp 4, ▁temp 5, ▁temp 6, ▁temp 7 ; ▁mul ▁= ▁( dyn rng ▁& ▁0 x 1 f ) ▁+ ▁0 x 20 ; ▁shift ▁= ▁4 ▁- ▁(( dyn rng ▁<< ▁2 3) ▁>> ▁28 ); ▁if ▁( shift ▁> ▁0 ▁) ▁{ ▁round ▁= ▁1 ▁<< ▁( shift -1 ); ▁for ▁( i =0; ▁i < len ; ▁i += 8) ▁{ ▁temp ▁= ▁src [ i ] ▁* ▁mul ; ▁temp 1 ▁= ▁src [ i +1] ▁* ▁mul ; ▁temp ▁= ▁temp ▁+ ▁roun

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁handle _ parse _ opts ( Q emu Opts ▁* opts , ▁Fs Driver Entry ▁* f se , ▁Error ▁** err p ) ▁{ ▁const ▁char ▁* sec _ model ▁= ▁qemu _ opt _ get ( opts , ▁" security _ model "); ▁const ▁char ▁* path ▁= ▁qemu _ opt _ get ( opts , ▁" path "); ▁if ▁( sec _ model ) ▁{ ▁error _ report (" Invalid ▁argument ▁security _ model ▁specified ▁with ▁handle ▁fs driver "); ▁return ▁-1; ▁} ▁if ▁(! path ) ▁{ ▁error _ report (" fs dev : ▁No ▁path ▁specified "); ▁return ▁-1; ▁} ▁f se -> path ▁= ▁g _ str dup ( pat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁v nc _ s asl _ client _ cleanup ( V nc State ▁* vs ) ▁{ ▁if ▁( vs -> s asl . conn ) ▁{ ▁vs -> s asl . run SSF ▁= ▁vs -> s asl . wait Write SSF ▁= ▁vs -> s asl . want SSF ▁= ▁0; ▁vs -> s asl . encoded Length ▁= ▁vs -> s asl . encoded Offset ▁= ▁0; ▁vs -> s asl . encoded ▁= ▁NULL ; ▁g _ free ( vs -> s asl . username ); ▁free ( vs -> s asl . me ch list ); ▁vs -> s asl . username ▁= ▁vs -> s asl . me ch list ▁= ▁NULL ; ▁sasl _ dis pose ( & vs -> s asl . conn ); ▁vs -> s asl . conn ▁= ▁NULL ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁integ rator cm _ init ( Sys Bus Device ▁* dev ) ▁{ ▁Integ rator CM State ▁* s ▁= ▁INT E GR ATOR _ CM ( dev ); ▁s -> cm _ os c ▁= ▁0 x 01 0000 48 ; ▁/* ▁??? ▁What ▁should ▁the ▁high ▁bits ▁of ▁this ▁value ▁be ? ▁*/ ▁s -> cm _ aux os c ▁= ▁0 x 000 7 f eff ; ▁s -> cm _ sd ram ▁= ▁0 x 0001 112 2; ▁if ▁( s -> mem sz ▁>= ▁256 ) ▁{ ▁integ rator _ s pd [ 31 ] ▁= ▁64 ; ▁s -> cm _ sd ram ▁|= ▁0 x 10 ; ▁} ▁else ▁if ▁( s -> mem sz ▁>= ▁128 ) ▁{ ▁integ rator _ s pd [ 31 ] ▁= ▁32 ; ▁s -> cm _ sd ram ▁|= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁unt erm inated _ array _ comma ( void ) ▁{ ▁Q Object ▁* obj ▁= ▁q object _ from _ json ("[ 32, ", ▁NULL ); ▁g _ assert ( obj ▁== ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sv q 1_ decode _ frame _ header ( Get Bit Context ▁* bit buf , ▁M peg Enc Context ▁* s ) ▁{ ▁int ▁frame _ size _ code ; ▁skip _ bits ( bit buf , ▁8 ); ▁/* ▁temporal _ reference ▁*/ ▁/* ▁frame ▁type ▁*/ ▁s -> p ict _ type ▁= ▁get _ bits ( bit buf , ▁2) ▁+ ▁1; ▁if ▁( s -> p ict _ type ▁== ▁4) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( s -> p ict _ type ▁== ▁AV _ PI CT URE _ TYPE _ I ) ▁{ ▁/* ▁unknown ▁fields ▁*/ ▁if ▁( s -> f _ code ▁== ▁0 x 50 ▁|| ▁s -> f _ code ▁== ▁0 x 60 ) ▁{ ▁int ▁c su

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁prepare _ grab ( void ) ▁{ ▁f printf ( stderr , ▁" Must ▁supply ▁at ▁least ▁one ▁input ▁file \ n "); ▁exit (1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁compare _ codec _ desc ( const ▁void ▁* a , ▁const ▁void ▁* b ) ▁{ ▁const ▁AV Codec Descriptor ▁* ▁const ▁* da ▁= ▁a ; ▁const ▁AV Codec Descriptor ▁* ▁const ▁* db ▁= ▁b ; ▁return ▁(* da ) -> type ▁!= ▁(* db ) -> type ▁? ▁(* da ) -> type ▁- ▁(* db ) -> type ▁: ▁str cmp (( * da ) -> name , ▁(* db ) -> name ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁add _ a io _ request ( B DR V Sh eep dog State ▁* s , ▁A IO Req ▁* a io _ req , ▁struct ▁i ove c ▁* io v , ▁int ▁nio v , ▁int ▁create , ▁enum ▁A IO CB State ▁ai oc b _ type ) ▁{ ▁int ▁nr _ cop ies ▁= ▁s -> in ode . nr _ cop ies ; ▁Sh eep dog Obj Req ▁hdr ; ▁unsigned ▁int ▁w len ; ▁int ▁ret ; ▁uint 64_ t ▁oid ▁= ▁aio _ req -> oid ; ▁unsigned ▁int ▁dat al en ▁= ▁aio _ req -> data _ len ; ▁uint 64_ t ▁offset ▁= ▁aio _ req -> offset ; ▁uint 8_ t ▁flags ▁= ▁aio _ req -> flags ; ▁u

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ write back _ async _ complete _ packet ( E H CI Packet ▁* p ) ▁{ ▁E H CI Queue ▁* q ▁= ▁p -> queue ; ▁int ▁state ; ▁state ▁= ▁eh ci _ get _ state ( q -> eh ci , ▁q -> async ); ▁eh ci _ state _ exec uting ( q ); ▁eh ci _ state _ write back ( q ); ▁/* ▁F rees ▁the ▁packet ! ▁*/ ▁if ▁(! ( q -> q h . token ▁& ▁Q TD _ TOKEN _ H ALT )) ▁{ ▁eh ci _ state _ ad v queue ( q ); ▁eh ci _ set _ state ( q -> eh ci , ▁q -> async , ▁state );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ld st _ pair ▁( Dis as Context ▁* ctx , ▁uint 32_ t ▁op c , ▁int ▁rd , ▁int ▁base , ▁int 16_ t ▁offset ) ▁{ ▁const ▁char ▁* op n ▁= ▁" ld st _ pair "; ▁TC G v ▁t 0, ▁t 1; ▁if ▁( ctx -> h flags ▁& ▁M IP S _ H FLAG _ B MASK ▁|| ▁rd ▁== ▁31 ▁|| ▁rd ▁== ▁base ) ▁{ ▁generate _ exception ( ctx , ▁EX CP _ RI ); ▁return ; ▁} ▁t 0 ▁= ▁tc g _ temp _ new (); ▁t 1 ▁= ▁tc g _ temp _ new (); ▁gen _ base _ offset _ addr ( ctx , ▁t 0, ▁base , ▁offset ); ▁switch ▁( op c ) ▁{ ▁case ▁LW P : ▁save _ cpu 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁w dt _ diag 28 8_ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁DI AG 288 Class ▁* diag 288 ▁= ▁DI AG 28 8_ CLASS ( k lass ); ▁dc -> real ize ▁= ▁w dt _ diag 28 8_ real ize ; ▁dc -> un real ize ▁= ▁w dt _ diag 28 8_ un real ize ; ▁dc -> reset ▁= ▁w dt _ diag 28 8_ reset ; ▁set _ bit ( DEVICE _ CATEGORY _ MI SC , ▁dc -> categories ); ▁dc -> v ms d ▁= ▁& vm state _ diag 288 ; ▁diag 288 -> handle _ timer ▁= ▁w dt _ diag 28 8_ han

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ est imate _ m otion _ b ( M peg Enc Context ▁* ▁s , ▁int ▁mb _ x , ▁int ▁mb _ y , ▁int 16_ t ▁(* mv _ table ) [2], ▁uint 8_ t ▁* ref _ picture , ▁int ▁f _ code ) ▁{ ▁int ▁mx , ▁my , ▁range , ▁d min ; ▁int ▁xmin , ▁ymin , ▁xmax , ▁ymax ; ▁int ▁rel _ x min , ▁rel _ y min , ▁rel _ x max , ▁rel _ y max ; ▁int ▁pred _ x =0, ▁pred _ y =0; ▁int ▁P [6 ][ 2 ]; ▁const ▁int ▁shift = ▁1 + s -> qu arter _ sample ; ▁const ▁int ▁mot _ stride ▁= ▁s -> mb _ width ▁+ ▁2; ▁const ▁int ▁mot _ xy ▁= ▁( mb _ y ▁+ ▁1)

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ nal _ units ( H 264 Context ▁* h , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁AV Codec Context ▁* ▁const ▁av ctx = ▁s -> av ctx ; ▁H 264 Context ▁* h x ; ▁/// < ▁thread ▁context ▁int ▁buf _ index ; ▁int ▁context _ count ; ▁int ▁next _ av c ; ▁int ▁pass ▁= ▁! ( av ctx -> active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ); ▁int ▁n als _ needed =0; ▁/// < ▁number ▁of ▁N AL s ▁that ▁need ▁decoding ▁before ▁the ▁next ▁frame ▁thread ▁start

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dn x hd _ find _ frame _ end ( DN X HD Parser Context ▁* d ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁Parse Context ▁* pc ▁= ▁& d ctx -> pc ; ▁uint 64_ t ▁state ▁= ▁pc -> state 64 ; ▁int ▁pic _ found ▁= ▁pc -> frame _ start _ found ; ▁int ▁i ▁= ▁0; ▁if ▁(! pic _ found ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁buf _ size ; ▁i ++) ▁{ ▁state ▁= ▁( state ▁<< ▁8) ▁| ▁buf [ i ]; ▁if ▁( ff _ dn x hd _ check _ header _ prefix ( state ▁& ▁0 xff ffffffff 00 LL ) ▁!= ▁0) ▁{ ▁i ++; ▁pic _ found ▁= ▁1; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁va api _ encode _ h 2 64_ init _ constant _ bit rate ( AV Codec Context ▁* av ctx ) ▁{ ▁V A API Encode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁V A API Encode H 264 Context ▁* priv ▁= ▁ctx -> priv _ data ; ▁int ▁h rd _ buffer _ size ; ▁int ▁h rd _ initial _ buffer _ full ness ; ▁if ▁( av ctx -> bit _ rate ▁> ▁INT 32_ MAX ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Target ▁bitrate ▁of ▁2^ 31 ▁b ps ▁or ▁" ▁" high er ▁is ▁not ▁supported .\ n "); ▁return ▁A VER ROR ( E IN VAL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( plan ar 2 x )( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁long ▁src Width , ▁long ▁src Height , ▁long ▁src Stride , ▁long ▁dst Stride ) ▁{ ▁long ▁x , y ; ▁dst [0] = ▁src [0]; ▁// ▁first ▁line ▁for ( x =0; ▁x < src Width -1; ▁x ++){ ▁dst [2 * x +1 ]= ▁(3 * src [ x ] ▁+ ▁src [ x +1 ]) >> 2; ▁dst [2 * x + 2] = ▁( ▁src [ x ] ▁+ ▁3 * src [ x +1 ]) >> 2; ▁} ▁dst [2 * src Width -1] = ▁src [ src Width -1 ]; ▁dst += ▁dst Stride ; ▁for ( y =1; ▁y < src Height ; ▁y ++){ ▁# if ▁de

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ mt ms r ( Dis as Context ▁* ctx ) ▁{ ▁# if ▁defined ( CONFIG _ USER _ ONLY ) ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ REG ); ▁# else ▁if ▁( un likely ( ctx -> pr )) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ PRI V _ REG ); ▁return ; ▁} ▁if ▁( ctx -> op code ▁& ▁0 x 0001 0000 ) ▁{ ▁/* ▁Special ▁form ▁that ▁does ▁not ▁need ▁any ▁synchron isation ▁*/ ▁TC G v ▁t 0 ▁= ▁tc g _ temp _ new (); ▁tc g _ gen _ and i _ tl ( t 0, ▁cpu _ g pr [ r S ( ctx -> op c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁flat view _ ref ( Flat View ▁* view ) ▁{ ▁atomic _ inc ( & view -> ref ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h uff _ build 10 ( V LC ▁* vlc , ▁uint 8_ t ▁* len ) ▁{ ▁H uff Entry ▁he [10 24 ]; ▁uint 32_ t ▁codes [10 24 ]; ▁uint 8_ t ▁bits [10 24 ]; ▁uint 16_ t ▁syms [10 24 ]; ▁uint 32_ t ▁code ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁1024 ; ▁i ++) ▁{ ▁he [ i ]. sym ▁= ▁10 23 ▁- ▁i ; ▁he [ i ]. len ▁= ▁len [ i ]; ▁} ▁AV _ Q S ORT ( he , ▁1024 , ▁H uff Entry , ▁h uff _ cmp _ len 10 ); ▁code ▁= ▁1; ▁for ▁( i ▁= ▁10 23 ; ▁i ▁>= ▁0; ▁i --) ▁{ ▁codes [ i ] ▁= ▁code ▁>> ▁( 32 ▁- ▁he [ i ]. len ); ▁bits [ i ] ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ task _ complete ( void ) ▁{ ▁Q IO Task ▁* task ; ▁Object ▁* obj ▁= ▁object _ new ( TYPE _ D UMMY ); ▁Object ▁* src ; ▁struct ▁Test Task Data ▁data ▁= ▁{ ▁NULL , ▁NULL , ▁false ▁}; ▁task ▁= ▁q io _ task _ new ( obj , ▁task _ callback , ▁& data , ▁NULL ); ▁src ▁= ▁q io _ task _ get _ source ( task ); ▁q io _ task _ complete ( task ); ▁g _ assert ( obj ▁== ▁src ); ▁object _ un ref ( obj ); ▁object _ un ref ( src ); ▁g _ assert ( data . source ▁== ▁obj ); ▁g _ assert ( data . err ▁== ▁NU

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nut _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁N UT Context ▁* n ut ▁= ▁s -> priv _ data ; ▁Byte IO Context ▁* bc ▁= ▁& s -> pb ; ▁int 64_ t ▁pos ; ▁int ▁init ed _ stream _ count ; ▁nut -> av f = ▁s ; ▁av _ set _ pts _ info ( s , ▁60, ▁1, ▁AV _ TIME _ BASE ); ▁/* ▁main ▁header ▁*/ ▁pos =0; ▁for ( ; ; ){ ▁if ▁( find _ start code ( bc , ▁MAIN _ START CODE , ▁pos ) < 0 ){ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" no ▁main ▁start code ▁found \ n "); ▁return ▁-1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ v 4 l 2_ m 2 m _ codec _ re init ( V 4 L 2 m 2 m Context * ▁s ) ▁{ ▁int ▁ret ; ▁av _ log ( s -> av ctx , ▁AV _ LOG _ DEBUG , ▁" re init ▁context \ n "); ▁/* ▁1. ▁stream off ▁*/ ▁ret ▁= ▁ff _ v 4 l 2_ context _ set _ status ( & s -> capture , ▁V ID IO C _ ST REA MO FF ); ▁if ▁( ret ) ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" capture ▁V ID IO C _ ST REA MO FF \ n "); ▁/* ▁2. ▁un map ▁the ▁capture ▁buffers ▁( v 4 l 2 ▁and ▁ffmpeg ): ▁* ▁we ▁must ▁wait ▁for ▁all ▁references ▁to ▁be ▁released

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁w sv qa _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁W s V qa Dem ux Context ▁* w sv qa ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ; ▁unsigned ▁char ▁* header ; ▁unsigned ▁char ▁scratch [ V Q A _ PRE A MB LE _ SIZE ]; ▁unsigned ▁int ▁chunk _ tag ; ▁unsigned ▁int ▁chunk _ size ; ▁/* ▁initialize ▁the ▁video ▁decoder ▁stream ▁*/ ▁st ▁= ▁av _ new _ stream ( s , ▁0); ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁av _ set _ pts _ in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ w ma _ init ( AV Codec Context ▁* av ctx , ▁int ▁flags 2) ▁{ ▁W MA Codec Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁float ▁b ps 1, ▁high _ freq ; ▁volatile ▁float ▁b ps ; ▁int ▁sample _ rate 1; ▁int ▁coef _ vlc _ table ; ▁if ▁( ▁av ctx -> sample _ rate ▁<= ▁0 ▁|| ▁av ctx -> sample _ rate ▁> ▁50000 ▁|| ▁av ctx -> channels ▁<= ▁0 ▁|| ▁av ctx -> channels ▁> ▁2 ▁|| ▁av ctx -> bit _ rate ▁<= ▁0) ▁return ▁-1; ▁ff _ fmt _ convert _ init ( & s -> fmt _ conv , ▁av ctx ); ▁av priv _ float _ d sp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff _ iv i _ decode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁I VI 45 Dec Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁iv i _ free _ buffers ( & ctx -> plan es [0]); ▁if ▁( ctx -> mb _ vlc . cust _ tab . table ) ▁ff _ free _ vlc ( & ctx -> mb _ vlc . cust _ tab ); ▁av _ frame _ free ( & ctx -> p _ frame ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ check _ nic _ model _ list ( N IC Info ▁* nd , ▁const ▁char ▁* ▁const ▁* models , ▁const ▁char ▁* default _ model ) ▁{ ▁int ▁i , ▁exit _ status ▁= ▁0; ▁if ▁(! nd -> model ) ▁nd -> model ▁= ▁str dup ( default _ model ); ▁if ▁( str cmp ( nd -> model , ▁" ? ") ▁!= ▁0) ▁{ ▁for ▁( i ▁= ▁0 ▁; ▁models [ i ]; ▁i ++) ▁if ▁( str cmp ( nd -> model , ▁models [ i ]) ▁== ▁0) ▁return ▁i ; ▁f printf ( stderr , ▁" q emu : ▁Unsupported ▁N IC ▁model : ▁% s \ n ", ▁nd -> model ); ▁exit _ status ▁= ▁1; ▁} ▁f prin

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ s 39 0_ notify ( void ▁* op aque , ▁uint 16_ t ▁vector ) ▁{ ▁V irt IOS 390 Device ▁* dev ▁= ▁( V irt IOS 390 Device *) op aque ; ▁uint 64_ t ▁token ▁= ▁s 39 0_ virt io _ device _ v q _ token ( dev , ▁vector ); ▁/* ▁XXX ▁k vm ▁dependency ! ▁*/ ▁k vm _ s 39 0_ virt io _ irq ( s 39 0_ cpu _ addr 2 state (0 ), ▁0, ▁token ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁check _ th rottle _ config ( Th rottle Config ▁* cfg , ▁Error ▁** err p ) ▁{ ▁if ▁( th rottle _ conflict ing ( cfg , ▁err p )) ▁{ ▁return ▁false ; ▁} ▁if ▁(! th rottle _ is _ valid ( cfg , ▁err p )) ▁{ ▁return ▁false ; ▁} ▁if ▁( th rottle _ max _ is _ missing _ limit ( cfg , ▁err p )) ▁{ ▁return ▁false ; ▁} ▁return ▁true ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ block ( B ink Audio Context ▁* s , ▁short ▁* out , ▁int ▁use _ d ct ) ▁{ ▁int ▁ch , ▁i , ▁j , ▁k ; ▁float ▁q , ▁quant [ 25 ]; ▁int ▁width , ▁coeff ; ▁Get Bit Context ▁* gb ▁= ▁& s -> gb ; ▁if ▁( use _ d ct ) ▁skip _ bits ( gb , ▁2); ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁s -> channels ; ▁ch ++) ▁{ ▁FFT Sample ▁* coeff s ▁= ▁s -> coeff s _ ptr [ ch ]; ▁if ▁( s -> version _ b ) ▁{ ▁coeffs [0] ▁= ▁av _ int 2 f lt ( get _ bits ( gb , ▁32 )) ▁* ▁s -> root ; ▁coeffs [1] ▁= ▁av _ int 2 f lt ( get _ bi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ main _ loop _ start ( void ) ▁{ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg _ m ux _ write _ packet ( AV Format Context ▁* ctx , ▁int ▁stream _ index , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size , ▁int 64_ t ▁pts ) ▁{ ▁M peg M ux Context ▁* s ▁= ▁ctx -> priv _ data ; ▁AV Stream ▁* st ▁= ▁ctx -> streams [ stream _ index ]; ▁Stream Info ▁* stream ▁= ▁st -> priv _ data ; ▁int 64_ t ▁dt s ; ▁int ▁len ; ▁/* ▁XXX : ▁system ▁clock ▁should ▁be ▁computed ▁precisely , ▁especially ▁for ▁C BR ▁case . ▁The ▁current ▁mode ▁gives ▁at ▁least ▁something ▁co her ent ▁*/ ▁if ▁( strea

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ dev init ( const ▁char ▁* cpu _ model , ▁unsigned ▁int ▁id , ▁uint 64_ t ▁prom _ addr , ▁qemu _ irq ▁** cpu _ ir qs ) ▁{ ▁CPU State ▁* cs ; ▁SPAR C CPU ▁* cpu ; ▁CP US PAR C State ▁* env ; ▁cpu ▁= ▁SPAR C _ CPU ( cpu _ generic _ init ( TYPE _ SP AR C _ CPU , ▁cpu _ model )); ▁if ▁( cpu ▁== ▁NULL ) ▁{ ▁f printf ( stderr , ▁" q emu : ▁Unable ▁to ▁find ▁S par c ▁CPU ▁definition \ n "); ▁exit (1); ▁} ▁env ▁= ▁& cpu -> env ; ▁cpu _ s par c _ set _ id ( env , ▁id ); ▁if ▁( id ▁== ▁0) ▁{ ▁qe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁void ▁av codec _ register ( AV Codec ▁* codec ) ▁{ ▁AV Codec ▁** p ; ▁av codec _ init (); ▁p ▁= ▁& first _ av codec ; ▁while ▁(* p ▁!= ▁NULL ) ▁p ▁= ▁& (* p ) -> next ; ▁* p ▁= ▁codec ; ▁codec -> next ▁= ▁NULL ; ▁if ▁( codec -> init _ static _ data ) ▁codec -> init _ static _ data ( codec ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ n aa _ id ( const ▁uint 8_ t ▁* p , ▁uint 64_ t ▁* p _ ww n ) ▁{ ▁int ▁i ; ▁if ▁(( p [1] ▁& ▁0 xF ) ▁== ▁3) ▁{ ▁/* ▁N AA ▁design ator ▁type ▁*/ ▁if ▁( p [3] ▁!= ▁8) ▁{ ▁return ▁- E IN VAL ; ▁} ▁* p _ ww n ▁= ▁ld q _ be _ p ( p ▁+ ▁4 ); ▁return ▁0; ▁} ▁if ▁(( p [1] ▁& ▁0 xF ) ▁== ▁8) ▁{ ▁/* ▁SC SI ▁name ▁string ▁design ator ▁type ▁*/ ▁if ▁( p [3] ▁< ▁20 ▁|| ▁mem cmp ( & p [4 ], ▁" n aa .", ▁4 )) ▁{ ▁return ▁- E IN VAL ; ▁} ▁if ▁( p [3] ▁> ▁20 ▁&& ▁p [ 24 ] ▁!= ▁', ') ▁{ ▁return ▁- E IN

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ i _ picture _ header ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁int ▁pq index , ▁status ▁= ▁0; ▁/* ▁Pro log ▁common ▁to ▁all ▁fram etypes ▁should ▁be ▁done ▁in ▁caller ▁*/ ▁// BF ▁= ▁Buffer ▁Full ness ▁if ▁( v -> profile ▁<= ▁PROFILE _ MAIN ▁&& ▁get _ bits ( gb , ▁7 )) ▁{ ▁av _ log ( v -> s . av ctx , ▁AV _ LOG _ DEBUG , ▁" I ▁Buffer Full ness ▁not ▁0 \ n "); ▁} ▁/* ▁Quant izer ▁stuff ▁*/ ▁pq index ▁= ▁get _ bits ( gb , ▁5 ); ▁if ▁( v -> quant izer _ mode ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁show _ stream ( AV Format Context ▁* fmt _ ctx , ▁int ▁stream _ idx ) ▁{ ▁AV Stream ▁* stream ▁= ▁fmt _ ctx -> streams [ stream _ idx ]; ▁AV Codec Context ▁* dec _ ctx ; ▁AV Codec ▁* dec ; ▁char ▁val _ str [ 128 ]; ▁AV Dictionary Entry ▁* tag ▁= ▁NULL ; ▁AV R ational ▁display _ aspect _ ratio ; ▁printf ("[ STREAM ]\ n "); ▁printf (" index =% d \ n ", ▁stream -> index ); ▁if ▁(( dec _ ctx ▁= ▁stream -> codec )) ▁{ ▁if ▁(( dec ▁= ▁dec _ ctx -> codec )) ▁{ ▁printf (" codec _ name =% s \ n ", ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁encode _ block ( M peg Enc Context ▁* s , ▁int 16_ t ▁* block , ▁int ▁n ) ▁{ ▁int ▁i , ▁j , ▁table _ id ; ▁int ▁component , ▁dc , ▁last _ index , ▁val , ▁run ; ▁M J peg Context ▁* m ▁= ▁s -> m jpeg _ ctx ; ▁/* ▁DC ▁coef ▁*/ ▁component ▁= ▁( n ▁<= ▁3 ▁? ▁0 ▁: ▁( n & 1) ▁+ ▁1); ▁table _ id ▁= ▁( n ▁<= ▁3 ▁? ▁0 ▁: ▁1); ▁dc ▁= ▁block [0]; ▁/* ▁overflow ▁is ▁impossible ▁*/ ▁val ▁= ▁dc ▁- ▁s -> last _ dc [ component ]; ▁ff _ m jpeg _ encode _ coef ( m , ▁table _ id , ▁val , ▁0); ▁s -> last _ dc [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁RE NAME ( sw Scale )( Sw s Context ▁* c , ▁uint 8_ t * ▁src Param [], ▁int ▁src Stride Param [], ▁int ▁src Slice Y , ▁int ▁src Slice H , ▁uint 8_ t * ▁dst Param [], ▁int ▁dst Stride [] ){ ▁/* ▁load ▁a ▁few ▁things ▁into ▁local ▁vars ▁to ▁make ▁the ▁code ▁more ▁readable ? ▁and ▁faster ▁*/ ▁const ▁int ▁src W = ▁c -> src W ; ▁const ▁int ▁dst W = ▁c -> dst W ; ▁const ▁int ▁dst H = ▁c -> dst H ; ▁const ▁int ▁chr Dst W = ▁c -> chr Dst W ; ▁const ▁int ▁l um X Inc = ▁c -> l um X Inc ; ▁const ▁int ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v sc si _ queue _ cmd ( V SC SI State ▁* s , ▁v sc si _ req ▁* req ) ▁{ ▁union ▁sr p _ i u ▁* sr p ▁= ▁& req -> i u . sr p ; ▁S CS ID evice ▁* s dev ; ▁int ▁n , ▁id , ▁lun ; ▁v sc si _ decode _ id _ lun ( be 64_ to _ cpu ( sr p -> cmd . lun ), ▁& id , ▁& lun ); ▁/* ▁Q emu ▁vs . ▁linux ▁issue ▁with ▁L UN s ▁to ▁be ▁sorted ▁out ▁... ▁*/ ▁s dev ▁= ▁( id ▁< ▁8 ▁&& ▁lun ▁< ▁16 ) ▁? ▁s -> bus . dev s [ id ] ▁: ▁NULL ; ▁if ▁(! s dev ) ▁{ ▁d printf (" V SC SI : ▁Command ▁for ▁id ▁% d ▁with ▁no ▁driv

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁do _ send v _ recv v ( int ▁sock fd , ▁struct ▁i ove c ▁* io v , ▁int ▁len , ▁int ▁offset , ▁int ▁do _ send v ) ▁{ ▁int ▁ret , ▁diff , ▁i ov len ; ▁struct ▁i ove c ▁* last _ io v ; ▁/* ▁last _ io v ▁is ▁inclusive , ▁so ▁count ▁from ▁one . ▁*/ ▁i ov len ▁= ▁1; ▁last _ io v ▁= ▁i ov ; ▁len ▁+= ▁offset ; ▁while ▁( last _ io v -> io v _ len ▁< ▁len ) ▁{ ▁len ▁-= ▁last _ io v -> io v _ len ; ▁last _ io v ++; ▁i ov len ++; ▁} ▁diff ▁= ▁last _ io v -> io v _ len ▁- ▁len ; ▁last _ io v -> io v _ len

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vp 9_ decode _ frame ( AV Codec Context ▁* ctx , ▁void ▁* frame , ▁int ▁* got _ frame , ▁AV Packet ▁* pk t ) ▁{ ▁const ▁uint 8_ t ▁* data ▁= ▁pkt -> data ; ▁int ▁size ▁= ▁pkt -> size ; ▁V P 9 Context ▁* s ▁= ▁ctx -> priv _ data ; ▁int ▁res , ▁tile _ row , ▁tile _ col , ▁i , ▁ref , ▁row , ▁col ; ▁int ▁retain _ seg map _ ref ▁= ▁s -> s . frames [ REF _ FRAME _ SE G MAP ]. segment ation _ map ▁&& ▁(! s -> s . h . segment ation . enabled ▁|| ▁! s -> s . h . segment ation . update _ map ); ▁ptr d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁gt 64 12 0_ read l ▁( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁GT 64 120 State ▁* s ▁= ▁opaque ; ▁P CI Host State ▁* ph b ▁= ▁P CI _ HOST _ BR ID GE ( s ); ▁uint 32_ t ▁val ; ▁uint 32_ t ▁s addr ; ▁s addr ▁= ▁( addr ▁& ▁0 xff f ) ▁>> ▁2; ▁switch ▁( s addr ) ▁{ ▁/* ▁CPU ▁Configuration ▁*/ ▁case ▁GT _ MULTI : ▁/* ▁Only ▁one ▁GT 64 xxx ▁is ▁present ▁on ▁the ▁CPU ▁bus , ▁return ▁the ▁initial ▁value ▁*/ ▁val ▁= ▁s -> re gs [ s addr ]; ▁break ; ▁/* ▁CPU ▁Er

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ opt _ set ( Q emu Opts ▁* opts , ▁const ▁char ▁* name , ▁const ▁char ▁* value ) ▁{ ▁Q emu Opt ▁* opt ; ▁opt ▁= ▁qemu _ opt _ find ( opts , ▁name ); ▁if ▁(! opt ) ▁{ ▁Q emu Opt Desc ▁* desc ▁= ▁opts -> list -> desc ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁desc [ i ]. name ▁!= ▁NULL ; ▁i ++) ▁{ ▁if ▁( str cmp ( desc [ i ]. name , ▁name ) ▁== ▁0) ▁{ ▁break ; ▁} ▁} ▁if ▁( desc [ i ]. name ▁== ▁NULL ) ▁{ ▁if ▁( i ▁== ▁0) ▁{ ▁/* ▁empty ▁list ▁-> ▁allow ▁any ▁*/ ; ▁} ▁else ▁{ ▁f printf ( stderr , ▁" option ▁\"

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ init fn ( SC S ID evice ▁* dev ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁dev ); ▁Error ▁* err ▁= ▁NULL ; ▁if ▁(! s -> q dev . conf . bs ) ▁{ ▁error _ report (" drive ▁property ▁not ▁set "); ▁return ▁-1; ▁} ▁if ▁(! ( s -> features ▁& ▁(1 ▁<< ▁SC SI _ DIS K _ F _ REMO V ABLE )) ▁&& ▁! b dr v _ is _ insert ed ( s -> q dev . conf . bs )) ▁{ ▁error _ report (" Device ▁needs ▁media , ▁but ▁drive ▁is ▁empty "); ▁return ▁-1; ▁} ▁blk conf _ serial ( & s -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ update _ fr index ( E H CI State ▁* eh ci , ▁int ▁frames ) ▁{ ▁int ▁i ; ▁if ▁(! eh ci _ enabled ( eh ci )) ▁{ ▁return ; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁frames ; ▁i ++) ▁{ ▁eh ci -> fr index ▁+= ▁8 ; ▁if ▁( eh ci -> fr index ▁== ▁0 x 0000 2 000) ▁{ ▁eh ci _ raise _ irq ( eh ci , ▁USB ST S _ FL R ); ▁} ▁if ▁( eh ci -> fr index ▁== ▁0 x 0000 4 000) ▁{ ▁eh ci _ raise _ irq ( eh ci , ▁USB ST S _ FL R ); ▁eh ci -> fr index ▁= ▁0; ▁if ▁( eh ci -> usb st s _ fr index ▁>= ▁0 x 0000 4 000) ▁{ ▁eh 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁M XF Codec UL ▁* mx f _ get _ codec _ ul ( const ▁M XF Codec UL ▁* ul s , ▁UID ▁* uid ) ▁{ ▁while ▁( ul s -> id ▁!= ▁CODE C _ ID _ NONE ) ▁{ ▁if ( mx f _ match _ uid ( ul s -> uid , ▁* uid , ▁16 )) ▁break ; ▁ul s ++; ▁} ▁return ▁ul s ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p ty _ chr _ state ( Char Driver State ▁* chr , ▁int ▁connected ) ▁{ ▁P ty Char Driver ▁* s ▁= ▁chr -> op aque ; ▁if ▁(! connected ) ▁{ ▁if ▁( s -> fd _ tag ) ▁{ ▁g _ source _ remove ( s -> fd _ tag ); ▁s -> fd _ tag ▁= ▁0; ▁} ▁s -> connected ▁= ▁0; ▁s -> pol ling ▁= ▁0; ▁/* ▁( re -) connect ▁poll ▁interval ▁for ▁idle ▁guest s : ▁once ▁per ▁second . ▁* ▁We ▁check ▁more ▁frequently ▁in ▁case ▁the ▁guest s ▁sends ▁data ▁to ▁* ▁the ▁virtual ▁device ▁linked ▁to ▁our ▁p ty . ▁*/ ▁p ty _ chr _ re

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁h 26 3_ decode _ picture _ header ( M peg Enc Context ▁* s ) ▁{ ▁int ▁format , ▁width , ▁height ; ▁/* ▁picture ▁header ▁*/ ▁if ▁( get _ bits ( & s -> gb , ▁2 2) ▁!= ▁0 x 20) ▁return ▁-1; ▁skip _ bits ( & s -> gb , ▁8 ); ▁/* ▁picture ▁timestamp ▁*/ ▁if ▁( get _ bits 1( & s -> gb ) ▁!= ▁1) ▁return ▁-1; ▁/* ▁marker ▁*/ ▁if ▁( get _ bits 1( & s -> gb ) ▁!= ▁0) ▁return ▁-1; ▁/* ▁h 26 3 ▁id ▁*/ ▁skip _ bits 1( & s -> gb ); ▁/* ▁split ▁screen ▁off ▁*/ ▁skip _ bits 1( & s -> gb ); ▁/* ▁camera ▁off ▁*/ ▁skip

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁st ell aris _ init ( const ▁char ▁* kernel _ filename , ▁const ▁char ▁* cpu _ model , ▁Display State ▁* ds , ▁st ell aris _ board _ info ▁* board ) ▁{ ▁static ▁const ▁int ▁u art _ irq [] ▁= ▁{ 5, ▁6, ▁33, ▁34 }; ▁static ▁const ▁int ▁timer _ irq [] ▁= ▁{ 19, ▁21, ▁23, ▁35 }; ▁static ▁const ▁uint 32_ t ▁gp io _ addr [ 7] ▁= ▁{ ▁0 x 4 000 4 000, ▁0 x 4 000 5 000, ▁0 x 4 000 6 000, ▁0 x 4 000 7 000, ▁0 x 400 24 000, ▁0 x 400 25 000, ▁0 x 400 26 000 }; ▁static ▁const ▁int ▁gp io _ irq [ 7] ▁= ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ video _ out ( AV Format Context ▁* s , ▁OutputStream ▁* ost , ▁InputStream ▁* ist , ▁AV Frame ▁* in _ picture , ▁int ▁* frame _ size , ▁float ▁quality ) ▁{ ▁int ▁nb _ frames , ▁i , ▁ret , ▁av _ unused ▁resample _ changed ; ▁AV Frame ▁* final _ picture , ▁* formatted _ picture ; ▁AV Codec Context ▁* enc , ▁* dec ; ▁double ▁sync _ ipt s ; ▁enc ▁= ▁o st -> st -> codec ; ▁dec ▁= ▁ist -> st -> codec ; ▁sync _ ipt s ▁= ▁get _ sync _ ipt s ( ost ) ▁/ ▁av _ q 2 d ( enc -> time _ base ); ▁/* ▁b

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁continue _ after _ map _ failure ( void ▁* op aque ) ▁{ ▁D MA A IO CB ▁* db s ▁= ▁( D MA A IO CB ▁* ) op aque ; ▁db s -> b h ▁= ▁qemu _ b h _ new ( res chedule _ d ma , ▁db s ); ▁qemu _ b h _ schedule ( db s -> b h ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ mem _ writ el ( void ▁* ptr , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁E H CI State ▁* s ▁= ▁ptr ; ▁uint 32_ t ▁* mm io ▁= ▁( uint 32_ t ▁* )( & s -> mm io [ addr ]); ▁uint 32_ t ▁old ▁= ▁* mm io ; ▁int ▁i ; ▁trace _ usb _ eh ci _ mm io _ writ el ( addr , ▁addr 2 str ( addr ), ▁val ); ▁/* ▁Only ▁aligned ▁reads ▁are ▁allowed ▁on ▁O H CI ▁*/ ▁if ▁( addr ▁& ▁3) ▁{ ▁f printf ( stderr , ▁" usb - eh ci : ▁M is - aligned ▁write ▁to ▁addr ▁0 x " ▁TARGET _ F MT _ pl x ▁"\ n 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁s P AP R DR Connector ▁* sp ap r _ d rc _ by _ index ( uint 32_ t ▁index ) ▁{ ▁Object ▁* obj ; ▁char ▁name [ 256 ]; ▁sn printf ( name , ▁sizeof ( name ), ▁"% s /% x ", ▁D RC _ CONTAINER _ PATH , ▁index ); ▁obj ▁= ▁object _ resolve _ path ( name , ▁NULL ); ▁return ▁! obj ▁? ▁NULL ▁: ▁SP AP R _ DR _ CONNECT OR ( obj ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ fn m add ▁( uint 64_ t ▁arg 1, ▁uint 64_ t ▁arg 2, ▁uint 64_ t ▁arg 3) ▁{ ▁CPU _ Double U ▁f arg 1, ▁f arg 2, ▁f arg 3; ▁f arg 1. ll ▁= ▁arg 1; ▁f arg 2. ll ▁= ▁arg 2; ▁f arg 3. ll ▁= ▁arg 3; ▁if ▁( un likely ( float 64_ is _ signal ing _ nan ( f arg 1. d ) ▁|| ▁float 64_ is _ signal ing _ nan ( f arg 2. d ) ▁|| ▁float 64_ is _ signal ing _ nan ( f arg 3. d ))) ▁{ ▁/* ▁s NaN ▁operation ▁*/ ▁f arg 1. ll ▁= ▁f load _ invalid _ op _ ex cp ( PO WER PC _ EX CP _ FP _ V X SN AN ); ▁} ▁else

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cow _ pro be ( const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁const ▁char ▁* filename ) ▁{ ▁const ▁struct ▁cow _ header _ v 2 ▁* c ow _ header ▁= ▁( const ▁void ▁* ) buf ; ▁if ▁( buf _ size ▁>= ▁sizeof ( struct ▁cow _ header _ v 2) ▁&& ▁be 32_ to _ cpu ( c ow _ header -> magic ) ▁== ▁CO W _ M AGIC ▁&& ▁be 32_ to _ cpu ( c ow _ header -> version ) ▁== ▁CO W _ VERSION ) ▁return ▁100; ▁else ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁ram _ bytes _ remaining ( void ) ▁{ ▁return ▁ram _ save _ remaining () ▁* ▁TARGET _ PAGE _ SIZE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ ics ( A AC Context ▁* ▁ac , ▁Single Channel Element ▁* ▁s ce , ▁Get Bit Context ▁* ▁gb , ▁int ▁common _ window , ▁int ▁scale _ flag ) ▁{ ▁P ulse ▁pulse ; ▁Temporal Noise Sh aping ▁* ▁t ns ▁= ▁& s ce -> t ns ; ▁Individual Channel Stream ▁* ▁ics ▁= ▁& s ce -> ics ; ▁float ▁* ▁out ▁= ▁s ce -> coeff s ; ▁int ▁global _ gain , ▁pulse _ present ▁= ▁0; ▁/* ▁This ▁assignment ▁is ▁to ▁sil ence ▁a ▁G CC ▁warning ▁about ▁the ▁variable ▁being ▁used ▁* ▁un initialized ▁when ▁in ▁fact ▁it ▁always 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁s size _ t ▁buffered _ flush ( Q EM U File Buffered ▁* s ) ▁{ ▁size _ t ▁offset ▁= ▁0; ▁s size _ t ▁ret ▁= ▁0; ▁D PRI NT F (" flush ing ▁% z u ▁byte ( s ) ▁of ▁data \ n ", ▁s -> buffer _ size ); ▁while ▁( s -> bytes _ x fer ▁< ▁s -> x fer _ limit ▁&& ▁offset ▁< ▁s -> buffer _ size ) ▁{ ▁size _ t ▁to _ send ▁= ▁MIN ( s -> buffer _ size ▁- ▁offset , ▁s -> x fer _ limit ▁- ▁s -> bytes _ x fer ); ▁ret ▁= ▁migrate _ fd _ put _ buffer ( s -> migration _ state , ▁s -> buffer ▁+ ▁offset , ▁to _ send ); ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pci _ q dev _ register ( PC ID evice Info ▁* info ) ▁{ ▁info -> q dev . init ▁= ▁pci _ q dev _ init ; ▁info -> q dev . bus _ type ▁= ▁B US _ TYPE _ PC I ; ▁q dev _ register ( & info -> q dev ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v host _ net _ stop _ one ( struct ▁v host _ net ▁* net , ▁V irt IO Device ▁* dev ) ▁{ ▁struct ▁v host _ v ring _ file ▁file ▁= ▁{ ▁. fd ▁= ▁-1 ▁}; ▁if ▁(! net -> dev . started ) ▁{ ▁return ; ▁} ▁if ▁( net -> nc -> info -> type ▁== ▁NET _ CLIENT _ OPTIONS _ K IND _ T AP ) ▁{ ▁for ▁( file . index ▁= ▁0; ▁file . index ▁< ▁net -> dev . nv qs ; ▁++ file . index ) ▁{ ▁const ▁V host Ops ▁* v host _ ops ▁= ▁net -> dev . v host _ ops ; ▁int ▁r ▁= ▁v host _ ops -> v host _ call ( & net -> dev , ▁V H

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁rt sp _ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁RT SP State ▁* rt ▁= ▁s -> priv _ data ; ▁char ▁host [10 24 ], ▁path [10 24 ], ▁tcp name [10 24 ], ▁cmd [ 20 48 ]; ▁URL Context ▁* rt sp _ hd ; ▁int ▁port , ▁i , ▁ret , ▁err ; ▁RT SP Header ▁reply 1, ▁* reply ▁= ▁& reply 1; ▁unsigned ▁char ▁* content ▁= ▁NULL ; ▁AV Stream ▁* st ; ▁RT SP Stream ▁* rt sp _ st ; ▁int ▁protocol _ mask ; ▁rt sp _ abort _ req ▁= ▁0; ▁/* ▁extract ▁hostname ▁and ▁port ▁*/ ▁url _ split

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ s 390 x _ handle _ mm u _ fault ▁( CPU State ▁* env , ▁target _ ulong ▁address , ▁int ▁rw , ▁int ▁mm u _ idx , ▁int ▁is _ soft mm u ) ▁{ ▁target _ ulong ▁phys ; ▁int ▁prot ; ▁/* ▁XXX : ▁implement ▁mm u ▁*/ ▁phys ▁= ▁address ; ▁prot ▁= ▁PAGE _ READ ▁| ▁PAGE _ WRITE ; ▁return ▁tl b _ set _ page ( env , ▁address ▁& ▁TARGET _ PAGE _ MASK , ▁phys ▁& ▁TARGET _ PAGE _ MASK , ▁prot , ▁mm u _ idx , ▁is _ soft mm u ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁inc _ ref counts ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁void ▁** refcount _ table , ▁int 64_ t ▁* refcount _ table _ size , ▁int 64_ t ▁offset , ▁int 64_ t ▁size ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁uint 64_ t ▁start , ▁last , ▁cluster _ offset , ▁k , ▁ref count ; ▁int ▁ret ; ▁if ▁( size ▁<= ▁0) ▁{ ▁return ▁0; ▁} ▁start ▁= ▁start _ of _ cluster ( s , ▁offset ); ▁last ▁= ▁start _ of _ cluster ( s , ▁offset ▁+ ▁size ▁- ▁1); ▁for ( cluster _ offset ▁= ▁star

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁g ic _ do _ cpu _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁value , ▁unsigned ▁size ) ▁{ ▁G IC State ▁** back ref ▁= ▁( G IC State ▁** ) op aque ; ▁G IC State ▁* s ▁= ▁* back ref ; ▁int ▁id ▁= ▁( back ref ▁- ▁s -> back ref ); ▁g ic _ cpu _ write ( s , ▁id , ▁addr , ▁value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st q _ be _ ph ys ( target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁val ) ▁{ ▁val ▁= ▁cpu _ to _ be 64 ( val ); ▁cpu _ ph ysical _ memory _ write ( addr , ▁& val , ▁8 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fb _ initial ise ( struct ▁X en Device ▁* x end ev ) ▁{ ▁struct ▁X en FB ▁* fb ▁= ▁container _ of ( x end ev , ▁struct ▁X en FB , ▁c . x end ev ); ▁struct ▁xen fb _ page ▁* fb _ page ; ▁int ▁vide or am ; ▁int ▁rc ; ▁if ▁( x en store _ read _ fe _ int ( x end ev , ▁" v ide or am ", ▁& v ide or am ) ▁== ▁-1) ▁vide or am ▁= ▁0; ▁rc ▁= ▁common _ bind ( & fb -> c ); ▁if ▁( rc ▁!= ▁0) ▁return ▁rc ; ▁fb _ page ▁= ▁fb -> c . page ; ▁rc ▁= ▁xen fb _ configure _ fb ( fb , ▁vide or am ▁* ▁1024 ▁* ▁1024

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ ext s ( int ▁ot , ▁TC G v ▁reg ) ▁{ ▁switch ( ot ) ▁{ ▁case ▁O T _ BYTE : ▁tc g _ gen _ ext 8 s _ tl ( reg , ▁reg ); ▁break ; ▁case ▁O T _ WORD : ▁tc g _ gen _ ext 16 s _ tl ( reg , ▁reg ); ▁break ; ▁case ▁O T _ LONG : ▁tc g _ gen _ ext 32 s _ tl ( reg , ▁reg ); ▁break ; ▁default : ▁break ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁is _ valid _ option _ list ( const ▁char ▁* param ) ▁{ ▁size _ t ▁buf len ▁= ▁str len ( param ) ▁+ ▁1; ▁char ▁* buf ▁= ▁g _ m alloc ( buf len ); ▁const ▁char ▁* p ▁= ▁param ; ▁bool ▁result ▁= ▁true ; ▁while ▁(* p ) ▁{ ▁p ▁= ▁get _ opt _ value ( buf , ▁buf len , ▁p ); ▁if ▁(* p ▁&& ▁! * ++ p ) ▁{ ▁result ▁= ▁false ; ▁goto ▁out ; ▁} ▁if ▁(! * buf ▁|| ▁* buf ▁== ▁', ') ▁{ ▁result ▁= ▁false ; ▁goto ▁out ; ▁} ▁} ▁out : ▁free ( buf ); ▁return ▁result ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ alloc _ tables ( H 264 Context ▁* h ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁const ▁int ▁big _ mb _ num = ▁s -> mb _ stride ▁* ▁( s -> mb _ height +1 ); ▁const ▁int ▁row _ mb _ num = ▁2* s -> mb _ stride * s -> av ctx -> thread _ count ; ▁int ▁x , y ; ▁FF _ AL LOC Z _ OR _ G OTO ( h -> s . av ctx , ▁h -> in tra 4 x 4_ pred _ mode , ▁row _ mb _ num ▁* ▁8 ▁* ▁sizeof ( uint 8_ t ), ▁fail ) ▁FF _ AL LOC Z _ OR _ G OTO ( h -> s . av ctx , ▁h -> non _ zero _ count ▁, ▁big _ mb _ num

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁Copy Ret ▁copy _ frame ( AV Codec Context ▁* av ctx , ▁BC _ DT S _ PRO C _ OUT ▁* output , ▁void ▁* data , ▁int ▁* data _ size , ▁uint 8_ t ▁second _ field ) ▁{ ▁BC _ STATUS ▁ret ; ▁BC _ DT S _ STATUS ▁decoder _ status ; ▁uint 8_ t ▁is _ p aff ; ▁uint 8_ t ▁next _ frame _ same ; ▁uint 8_ t ▁inter laced ; ▁CH D Context ▁* priv ▁= ▁av ctx -> priv _ data ; ▁uint 8_ t ▁bottom _ field ▁= ▁( output -> Pic Info . flags ▁& ▁V DEC _ FLAG _ B OTTOM FIELD ) ▁== ▁V DEC _ FLAG _ B OTTOM FIELD ; ▁uint 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁net _ l 2 tp v 3_ cleanup ( Net Client State ▁* nc ) ▁{ ▁Net L 2 TP V 3 State ▁* s ▁= ▁DO _ UP CAST ( Net L 2 TP V 3 State , ▁nc , ▁nc ); ▁qemu _ pur ge _ queued _ pack ets ( nc ); ▁l 2 tp v 3_ read _ poll ( s , ▁false ); ▁l 2 tp v 3_ write _ poll ( s , ▁false ); ▁if ▁( s -> fd ▁> ▁0) ▁{ ▁close ( s -> fd ); ▁} ▁destroy _ vector ( s -> msg vec , ▁MAX _ L 2 TP V 3_ MS GC NT , ▁IO V SIZE ); ▁g _ free ( s -> vec ); ▁g _ free ( s -> header _ buf ); ▁g _ free ( s -> d gram _ dst ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁A io Handler ▁* find _ a io _ handler ( int ▁fd ) ▁{ ▁A io Handler ▁* node ; ▁LIST _ FORE A CH ( node , ▁& a io _ handlers , ▁node ) ▁{ ▁if ▁( node -> fd ▁== ▁fd ) ▁return ▁node ; ▁} ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 2 y uv 1) ( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* l um Src , ▁const ▁int 16_ t ▁* chr Src , ▁const ▁int 16_ t ▁* al p Src , ▁uint 8_ t ▁* dest , ▁uint 8_ t ▁* u Dest , ▁uint 8_ t ▁* v Dest , ▁uint 8_ t ▁* a Dest , ▁long ▁dst W , ▁long ▁chr Dst W ) ▁{ ▁int ▁i ; ▁# if ▁COM PI LE _ TEMPLATE _ MM X ▁if (! ( c -> flags ▁& ▁S WS _ BIT EX ACT )) ▁{ ▁long ▁p = ▁4; ▁const ▁int 16_ t ▁* src [4] = ▁{ al p Src ▁+ ▁dst W , ▁l um Src ▁+ ▁dst W , ▁chr Src ▁+ ▁chr Dst W , ▁chr Src

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁x 86_ cpu _ g db _ write _ register ( CPU State ▁* cs , ▁uint 8_ t ▁* mem _ buf , ▁int ▁n ) ▁{ ▁X 86 CPU ▁* cpu ▁= ▁X 86_ CPU ( cs ); ▁CPU X 86 State ▁* env ▁= ▁& cpu -> env ; ▁uint 32_ t ▁tmp ; ▁if ▁( n ▁< ▁CPU _ NB _ REG S ) ▁{ ▁if ▁( TARGET _ LONG _ BITS ▁== ▁64 ▁&& ▁env -> h flags ▁& ▁H F _ CS 64_ MASK ) ▁{ ▁env -> re gs [ g pr _ map [ n ]] ▁= ▁l dt ul _ p ( mem _ buf ); ▁return ▁sizeof ( target _ ulong ); ▁} ▁else ▁if ▁( n ▁< ▁CPU _ NB _ REG S 32) ▁{ ▁n ▁= ▁g pr _ map 32 [ n ]; ▁env -> re gs [ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ decode _ seq _ parameter _ set ( Get Bit Context ▁* gb , ▁AV Codec Context ▁* av ctx , ▁H 264 Param Sets ▁* ps ) ▁{ ▁AV Buffer Ref ▁* sp s _ buf ; ▁int ▁profile _ id c , ▁level _ id c , ▁constraint _ set _ flags ▁= ▁0; ▁unsigned ▁int ▁sp s _ id ; ▁int ▁i , ▁log 2_ max _ frame _ num _ minus 4; ▁S PS ▁* sp s ; ▁profile _ id c ▁= ▁get _ bits ( gb , ▁8 ); ▁constraint _ set _ flags ▁|= ▁get _ bits 1( gb ) ▁<< ▁0; ▁// ▁constraint _ set 0_ flag ▁constraint _ set _ flags ▁|= ▁get _ bits 1( gb )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁c ch ip _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁T y ph oon State ▁* s ▁= ▁opaque ; ▁uint 64_ t ▁old val , ▁new val ; ▁switch ▁( addr ) ▁{ ▁case ▁0 x 0000 : ▁/* ▁C SC : ▁C ch ip ▁System ▁Configuration ▁Register . ▁*/ ▁/* ▁All ▁sorts ▁of ▁data ▁here ; ▁nothing ▁relevant ▁R W . ▁*/ ▁break ; ▁case ▁0 x 00 40 : ▁/* ▁M TR : ▁Memory ▁Tim ing ▁Register . ▁*/ ▁/* ▁All ▁sorts ▁of ▁stuff ▁related ▁to ▁real ▁D RAM . ▁*/ ▁break ; ▁case ▁0 x 00 80 : ▁/* ▁MI S

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ex yn os 42 10_ combin er _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁struct ▁Ex yn os 42 10 Combin er State ▁* s ▁= ▁( struct ▁Ex yn os 42 10 Combin er State ▁* ) op aque ; ▁uint 32_ t ▁req _ quad _ base _ n ; ▁/* ▁Base ▁of ▁registers ▁quad . ▁Multip ly ▁it ▁by ▁4 ▁and ▁get ▁a ▁start ▁of ▁corresponding ▁group ▁quad ▁*/ ▁uint 32_ t ▁grp _ quad _ base _ n ; ▁/* ▁Base ▁of ▁group ▁quad ▁*/ ▁uint 32_ t ▁reg _ n ; ▁/* ▁Register ▁numbe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁bt _ submit _ acl ( struct ▁H CI Info ▁* info , ▁const ▁uint 8_ t ▁* data , ▁int ▁length ) ▁{ ▁struct ▁bt _ h ci _ s ▁* h ci ▁= ▁h ci _ from _ info ( info ); ▁uint 16_ t ▁handle ; ▁int ▁dat al en , ▁flags ; ▁struct ▁bt _ link _ s ▁* link ; ▁if ▁( length ▁< ▁H CI _ ACL _ H DR _ SIZE ) ▁{ ▁f printf ( stderr , ▁"% s : ▁ACL ▁packet ▁too ▁short ▁( % iB )\ n ", ▁__ FUNCTION __, ▁length ); ▁return ; ▁} ▁handle ▁= ▁acl _ handle (( data [1] ▁<< ▁8) ▁| ▁data [0]); ▁flags ▁= ▁acl _ flags (( data [1] ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ co _ flush ( Block Driver State ▁* bs ) ▁{ ▁B DR V N BD State ▁* s ▁= ▁bs -> op aque ; ▁return ▁nb d _ client _ session _ co _ flush ( & s -> client ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q io v _ is _ aligned ( Q EM UI O Vector ▁* q io v ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁q io v -> nio v ; ▁i ++) ▁{ ▁if ▁(( uint ptr _ t ) ▁q io v -> io v [ i ]. io v _ base ▁% ▁B DR V _ SE CTOR _ SIZE ) ▁{ ▁return ▁0; ▁} ▁} ▁return ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁seq video _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁Seq Video Context ▁* seq ▁= ▁av ctx -> priv _ data ; ▁seq -> frame . reference ▁= ▁1; ▁seq -> frame . buffer _ hints ▁= ▁FF _ BUFFER _ H INT S _ VALID ▁| ▁FF _ BUFFER _ H INT S _ PRE SER VE ▁| ▁FF _ BUFFER _ H INT S _ RE US ABLE ; ▁if ▁( av ctx -> re get _ buffer ( av ctx , ▁& seq -> f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁s size _ t ▁im x _ f ec _ receive ( Net Client State ▁* nc , ▁const ▁uint 8_ t ▁* buf , ▁size _ t ▁len ) ▁{ ▁IM XF EC State ▁* s ▁= ▁IM X _ F EC ( q emu _ get _ nic _ op aque ( nc )); ▁IM XF EC Buf Desc ▁bd ; ▁uint 32_ t ▁flags ▁= ▁0; ▁uint 32_ t ▁addr ; ▁uint 32_ t ▁crc ; ▁uint 32_ t ▁buf _ addr ; ▁uint 8_ t ▁* crc _ ptr ; ▁unsigned ▁int ▁buf _ len ; ▁size _ t ▁size ▁= ▁len ; ▁F EC _ PRI NT F (" len ▁% d \ n ", ▁( int ) size ); ▁if ▁(! s -> re gs [ E NET _ RD AR ]) ▁{ ▁qemu _ log _ mask ( LOG _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁breakpoint _ handler ( CPU State ▁* env ) ▁{ ▁CP UB reak point ▁* bp ; ▁if ▁( env -> watch point _ hit ) ▁{ ▁if ▁( env -> watch point _ hit -> flags ▁& ▁B P _ CPU ) ▁{ ▁env -> watch point _ hit ▁= ▁NULL ; ▁if ▁( check _ hw _ break points ( env , ▁0 )) ▁raise _ exception ( EX CP 01_ DB ); ▁else ▁cpu _ resume _ from _ signal ( env , ▁NULL ); ▁} ▁} ▁else ▁{ ▁TA IL Q _ FORE A CH ( bp , ▁& env -> break points , ▁entry ) ▁if ▁( bp -> pc ▁== ▁env -> e ip ) ▁{ ▁if ▁( bp -> flags ▁& ▁B P _ CPU ) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁gd _ button _ event ( G tk Widget ▁* widget , ▁G dk Event Button ▁* button , ▁void ▁* op aque ) ▁{ ▁Virtual Console ▁* vc ▁= ▁opaque ; ▁Gtk Display State ▁* s ▁= ▁vc -> s ; ▁Input Button ▁btn ; ▁/* ▁implicitly ▁grab ▁the ▁input ▁at ▁the ▁first ▁click ▁in ▁the ▁relative ▁mode ▁*/ ▁if ▁( button -> button ▁== ▁1 ▁&& ▁button -> type ▁== ▁G DK _ BUTTON _ PRESS ▁&& ▁! q emu _ input _ is _ absolute () ▁&& ▁! gd _ is _ grab _ active ( s )) ▁{ ▁gtk _ check _ menu _ item _ set _ active ( GT K _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* ▁attribute _ align _ arg ▁worker ( void ▁* v ){ ▁AV Codec Context ▁* av ctx ▁= ▁v ; ▁Thread Context ▁* c ▁= ▁av ctx -> internal -> frame _ thread _ encoder ; ▁AV Packet ▁* pk t ▁= ▁NULL ; ▁while (! c -> exit ){ ▁int ▁got _ packet , ▁ret ; ▁AV Frame ▁* frame ; ▁Task ▁task ; ▁if (! pk t ) ▁pkt = ▁av _ m alloc z ( size of (* pk t )); ▁if (! pk t ) ▁continue ; ▁av _ init _ packet ( pk t ); ▁p thread _ mut ex _ lock ( & c -> task _ f ifo _ mut ex ); ▁while ▁( av _ f ifo _ size ( c -> task _ f 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁_ decode _ op c ( Dis as Context ▁* ▁ctx ) ▁{ ▁/* ▁This ▁code ▁tries ▁to ▁make ▁mov cal ▁em ulation ▁sufficient ly ▁accurate ▁for ▁Linux ▁purposes . ▁This ▁instruction ▁writes ▁memory , ▁and ▁prior ▁to ▁that , ▁always ▁alloc ates ▁a ▁cache ▁line . ▁It ▁is ▁used ▁in ▁two ▁contexts : ▁- ▁in ▁mem c py , ▁where ▁data ▁is ▁copied ▁in ▁blocks , ▁the ▁first ▁write ▁of ▁to ▁a ▁block ▁uses ▁mov ca . l ▁for ▁performance . ▁- ▁in ▁arch / sh / mm / cache - sh 4. c , ▁mov cal . l ▁+ ▁o cb i ▁combination

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁wm 87 50 _ set _ b cl k _ in ( void ▁* op aque , ▁int ▁h z ) ▁{ ▁struct ▁wm 87 50 _ s ▁* s ▁= ▁( struct ▁wm 87 50 _ s ▁* ) ▁opaque ; ▁s -> ext _ ad c _ hz ▁= ▁h z ; ▁s -> ext _ d ac _ hz ▁= ▁h z ; ▁wm 87 50 _ cl k _ update ( s , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p mac _ d ma _ write ( Block Backend ▁* blk , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁void ▁(* cb )( void ▁* op aque , ▁int ▁ret ), ▁void ▁* op aque ) ▁{ ▁DB D MA _ io ▁* io ▁= ▁opaque ; ▁MAC IO IDE State ▁* m ▁= ▁io -> op aque ; ▁IDE State ▁* s ▁= ▁id eb us _ active _ if ( & m -> bus ); ▁d ma _ addr _ t ▁d ma _ addr , ▁d ma _ len ; ▁void ▁* mem ; ▁int ▁n sect or , ▁remainder ; ▁int ▁extra ▁= ▁0; ▁qemu _ i ove c _ destroy ( & io -> io v ); ▁qemu _ i ove c _ init ( & io -> io v , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ delete ( Block Driver State ▁* bs ) ▁{ ▁assert (! bs -> job ); ▁assert ( b dr v _ op _ block er _ is _ empty ( bs )); ▁assert (! bs -> ref cnt ); ▁assert ( Q LIST _ EMPTY ( & bs -> dirty _ bit maps )); ▁b dr v _ close ( bs ); ▁/* ▁remove ▁from ▁list , ▁if ▁necessary ▁*/ ▁b dr v _ make _ anon ( bs ); ▁g _ free ( bs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v td _ iom mu _ re play ( I OM MU Memory Region ▁* iom mu _ mr , ▁IO MM U Notifier ▁* n ) ▁{ ▁V TD Address Space ▁* v td _ as ▁= ▁container _ of ( iom mu _ mr , ▁V TD Address Space , ▁i omm u ); ▁Intel I OM MU State ▁* s ▁= ▁v td _ as -> iom mu _ state ; ▁uint 8_ t ▁bus _ n ▁= ▁pci _ bus _ num ( v td _ as -> bus ); ▁V TD Context Entry ▁ce ; ▁/* ▁* ▁The ▁replay ▁can ▁be ▁triggered ▁by ▁either ▁a ▁invalid ation ▁or ▁a ▁newly ▁* ▁created ▁entry . ▁No ▁matter ▁what , ▁we ▁release ▁existing ▁map

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁sd _ wp _ addr ( SD State ▁* sd , ▁uint 32_ t ▁addr ) ▁{ ▁return ▁sd -> wp _ groups [ addr ▁>> ▁( H W BLOCK _ SHIFT ▁+ ▁SE CTOR _ SHIFT ▁+ ▁W P GROUP _ SHIFT ) ]; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁console _ handle _ escape ( Q emu Console ▁* s ) ▁{ ▁int ▁i ; ▁for ▁( i =0; ▁i < s -> nb _ esc _ params ; ▁i ++) ▁{ ▁switch ▁( s -> esc _ params [ i ]) ▁{ ▁case ▁0: ▁/* ▁reset ▁all ▁console ▁attributes ▁to ▁default ▁*/ ▁s -> t _ attrib ▁= ▁s -> t _ attrib _ default ; ▁break ; ▁case ▁1: ▁s -> t _ attrib . bold ▁= ▁1; ▁break ; ▁case ▁4: ▁s -> t _ attrib . ul ine ▁= ▁1; ▁break ; ▁case ▁5: ▁s -> t _ attrib . b link ▁= ▁1; ▁break ; ▁case ▁7: ▁s -> t _ attrib . in vers ▁= ▁1; ▁break ; ▁case ▁8: ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁write _ vec _ element ( Dis as Context ▁* s , ▁TC G v _ i 64 ▁tc g _ src , ▁int ▁dest idx , ▁int ▁element , ▁TC G Mem Op ▁mem op ) ▁{ ▁int ▁vect _ off ▁= ▁vec _ reg _ offset ( dest idx , ▁element , ▁mem op ▁& ▁MO _ SIZE ); ▁switch ▁( mem op ) ▁{ ▁case ▁MO _8 : ▁tc g _ gen _ st 8_ i 64 ( tc g _ src , ▁cpu _ env , ▁vect _ off ); ▁break ; ▁case ▁MO _16 : ▁tc g _ gen _ st 16_ i 64 ( tc g _ src , ▁cpu _ env , ▁vect _ off ); ▁break ; ▁case ▁MO _32 : ▁tc g _ gen _ st 32_ i 64 ( tc g _ src , ▁cpu _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁always _ inline ▁void ▁gen _ ext _ h ( void ▁(* tc g _ gen _ ext _ i 64 )( TC G v ▁t 0, ▁TC G v ▁t 1), ▁int ▁ra , ▁int ▁rb , ▁int ▁rc , ▁int ▁is lit , ▁uint 8_ t ▁lit ) ▁{ ▁if ▁( un likely ( rc ▁== ▁31 )) ▁return ; ▁if ▁( ra ▁!= ▁3 1) ▁{ ▁if ▁( is lit ) ▁{ ▁if ▁( lit ▁!= ▁0) ▁tc g _ gen _ sh li _ i 64 ( cpu _ ir [ rc ], ▁cpu _ ir [ ra ], ▁64 ▁- ▁(( lit ▁& ▁7) ▁* ▁8 )); ▁else ▁tc g _ gen _ mov _ i 64 ( cpu _ ir [ rc ], ▁cpu _ ir [ ra ]); ▁} ▁else ▁{ ▁TC G v ▁tmp 1, ▁tmp 2; ▁tmp 1 ▁= ▁tc g _ temp _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ init _ de quant _ tables ( H 264 Context ▁* h ) ▁{ ▁int ▁i , ▁x ; ▁init _ de quant 4_ coeff _ table ( h ); ▁if ▁( h -> pp s . transform _8 x 8_ mode ) ▁init _ de quant 8_ coeff _ table ( h ); ▁if ▁( h -> sp s . transform _ b yp ass ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁6 ; ▁i ++) ▁for ▁( x ▁= ▁0; ▁x ▁< ▁16 ; ▁x ++) ▁h -> de quant 4_ coeff [ i ][0] [ x ] ▁= ▁1 ▁<< ▁6 ; ▁if ▁( h -> pp s . transform _8 x 8_ mode ) ▁for ▁( i ▁= ▁0; ▁i ▁< ▁6 ; ▁i ++) ▁for ▁( x ▁= ▁0; ▁x ▁< ▁64 ; ▁x ++) ▁h -> de quan

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁g 7 22 _ encode _ init ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁G 7 22 Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁int ▁ret ; ▁if ▁( av ctx -> channels ▁!= ▁1) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Only ▁mon o ▁tracks ▁are ▁allowed .\ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁c -> band [0]. scale _ factor ▁= ▁8 ; ▁c -> band [1]. scale _ factor ▁= ▁2; ▁c -> prev _ samples _ pos ▁= ▁22 ; ▁if ▁( av ctx -> tre ll is ) ▁{ ▁int ▁front ier ▁= ▁1 ▁<< ▁av ctx -> tre ll is ; ▁int 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁l si _ mm io _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁L SI State ▁* s ▁= ▁opaque ; ▁return ▁l si _ reg _ read b ( s , ▁addr ▁& ▁0 xff ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁crypt ode v _ builtin _ create _ cipher _ session ( ▁Crypto Dev Backend Builtin ▁* builtin , ▁Crypto Dev Backend Sym Session Info ▁* sess _ info , ▁Error ▁** err p ) ▁{ ▁int ▁algo ; ▁int ▁mode ; ▁Q Crypto Cipher ▁* cipher ; ▁int ▁index ; ▁Crypto Dev Backend Builtin Session ▁* sess ; ▁if ▁( sess _ info -> op _ type ▁!= ▁VI RT IO _ CRY P TO _ SY M _ OP _ C IP HER ) ▁{ ▁error _ set g ( err p , ▁" Unsupported ▁opt ype ▁: % u ", ▁sess _ info -> op _ type ); ▁return ▁-1; ▁} ▁index ▁= ▁crypt ode v 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁env list _ free ( env list _ t ▁* env list ) ▁{ ▁struct ▁env list _ entry ▁* entry ; ▁assert ( env list ▁!= ▁NULL ); ▁while ▁( env list -> el _ entries . l h _ first ▁!= ▁NULL ) ▁{ ▁entry ▁= ▁env list -> el _ entries . l h _ first ; ▁LIST _ REMOVE ( entry , ▁ev _ link ); ▁free (( char ▁* ) entry -> ev _ var ); ▁free ( entry ); ▁} ▁free ( env list ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ h ba _ enable ( void ) ▁{ ▁A H CI Q State ▁* ah ci ; ▁ah ci ▁= ▁ah ci _ boot (); ▁ah ci _ pc i _ enable ( ah ci ); ▁ah ci _ h ba _ enable ( ah ci ); ▁ah ci _ shutdown ( ah ci ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁write v _ f ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁struct ▁time val ▁t 1, ▁t 2; ▁int ▁C flag ▁= ▁0, ▁q flag ▁= ▁0; ▁int ▁c , ▁cnt ; ▁char ▁* buf ; ▁int 64_ t ▁offset ; ▁/* ▁Some ▁compilers ▁get ▁confused ▁and ▁warn ▁if ▁this ▁is ▁not ▁initialized . ▁*/ ▁int ▁total ▁= ▁0; ▁int ▁nr _ io v ; ▁int ▁pattern ▁= ▁0 x cd ; ▁Q EM UI O Vector ▁q io v ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" C q P : ")) ▁!= ▁EOF ) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' C ': ▁C flag ▁= ▁1; ▁break ; ▁case ▁' q ': ▁q flag ▁= ▁1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁RE NAME ( chr Range To J peg )( int 16_ t ▁* dst , ▁int ▁width ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁width ; ▁i ++) ▁{ ▁dst [ i ▁] ▁= ▁( FF MIN ( dst [ i ▁], 307 75 )* 4 66 3 ▁- ▁9 28 999 2) >> 12 ; ▁// -2 64 ▁dst [ i + V OF W ] ▁= ▁( FF MIN ( dst [ i + V OF W ], 307 75 )* 4 66 3 ▁- ▁9 28 999 2) >> 12 ; ▁// -2 64 ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ p ce ( AV Codec Context ▁* av ctx , ▁M PEG 4 Audio Config ▁* m 4 ac , ▁enum ▁Channel Position ▁new _ che _ pos [4 ][ MAX _ E LE M _ ID ], ▁Get Bit Context ▁* gb ) ▁{ ▁int ▁num _ front , ▁num _ side , ▁num _ back , ▁num _ l fe , ▁num _ assoc _ data , ▁num _ cc , ▁sampling _ index ; ▁int ▁comment _ len ; ▁skip _ bits ( gb , ▁2); ▁// ▁object _ type ▁sampling _ index ▁= ▁get _ bits ( gb , ▁4 ); ▁if ▁( m 4 ac -> sampling _ index ▁!= ▁sampling _ index ) ▁av _ log ( av ctx , ▁AV _ LOG _ WA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ws _ s nd _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame _ ptr , ▁AV Packet ▁* av pk t ) ▁{ ▁W SS nd Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁int ▁in _ size , ▁out _ size , ▁ret ; ▁int ▁sample ▁= ▁128 ; ▁uint 8_ t ▁* samples ; ▁uint 8_ t ▁* samples _ end ; ▁if ▁(! buf _ size ) ▁return ▁0; ▁if ▁( buf _ size ▁< ▁4) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" packet ▁is

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁void ▁h ys cale ( Sw s Context ▁* c , ▁int 16_ t ▁* dst , ▁int ▁dst Width , ▁const ▁uint 8_ t ▁* src _ in [4 ], ▁int ▁src W , ▁int ▁x Inc , ▁const ▁int 16_ t ▁* h L um Filter , ▁const ▁int 16_ t ▁* h L um Filter Pos , ▁int ▁h L um Filter Size , ▁uint 8_ t ▁* format Conv Buffer , ▁uint 32_ t ▁* pal , ▁int ▁is Alpha ) ▁{ ▁void ▁(* to Y V 12 )( uint 8_ t ▁* , ▁const ▁uint 8_ t ▁* , ▁int , ▁uint 32_ t ▁* ) ▁= ▁is Alpha ▁? ▁c -> al p To Y V 12 ▁: ▁c -> l um To Y V 12 ; ▁void ▁(* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ always _ inline ▁av _ flatten ▁void ▁h 2 64_ loop _ filter _ chrom a _ c ( uint 8_ t ▁* pix , ▁int ▁x stride , ▁int ▁y stride , ▁int ▁alpha , ▁int ▁beta , ▁int 8_ t ▁* tc 0) ▁{ ▁int ▁i , ▁d ; ▁for ( ▁i ▁= ▁0; ▁i ▁< ▁4; ▁i ++ ▁) ▁{ ▁const ▁int ▁tc ▁= ▁tc 0 [ i ]; ▁if ( ▁tc ▁<= ▁0 ▁) ▁{ ▁pix ▁+= ▁2* y stride ; ▁continue ; ▁} ▁for ( ▁d ▁= ▁0; ▁d ▁< ▁2; ▁d ++ ▁) ▁{ ▁const ▁int ▁p 0 ▁= ▁pix [-1 * x stride ]; ▁const ▁int ▁p 1 ▁= ▁pix [ -2 * x stride ]; ▁const ▁int ▁q 0 ▁= ▁pix [0]; ▁const ▁int ▁q 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ mpeg 4_ decode _ picture _ header ( M peg Enc Context ▁* ▁s , ▁Get Bit Context ▁* gb ) ▁{ ▁int ▁start code , ▁v ; ▁/* ▁search ▁next ▁start ▁code ▁*/ ▁align _ get _ bits ( gb ); ▁start code ▁= ▁0 xff ; ▁for ( ; ;) ▁{ ▁v ▁= ▁get _ bits ( gb , ▁8 ); ▁start code ▁= ▁(( start code ▁<< ▁8) ▁| ▁v ) ▁& ▁0 xffffffff ; ▁if ( get _ bits _ count ( gb ) ▁>= ▁gb -> size * 8 ){ ▁if ( gb -> size == 1 ▁&& ▁s -> div x _ version ){ ▁printf (" frame ▁skip ▁% d \ n ", ▁gb -> size ); ▁return ▁FRAME _ SK I PED ; ▁// 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m peg video _ extract _ headers ( AV Codec Parser Context ▁* s , ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁Parse Context 1 ▁* pc ▁= ▁s -> priv _ data ; ▁const ▁uint 8_ t ▁* buf _ end ; ▁const ▁uint 8_ t ▁* buf _ start = ▁buf ; ▁uint 32_ t ▁start _ code ; ▁int ▁frame _ rate _ index , ▁ext _ type , ▁bytes _ left ; ▁int ▁frame _ rate _ ext _ n , ▁frame _ rate _ ext _ d ; ▁int ▁picture _ structure , ▁top _ field _ first , ▁repeat _ first _ field , ▁progress

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁set _ chrom a _ format ( AV Codec Context ▁* av ctx ) ▁{ ▁int ▁num _ formats ▁= ▁sizeof ( sch ro _ pixel _ format _ map ) ▁/ ▁sizeof ( sch ro _ pixel _ format _ map [0]); ▁int ▁idx ; ▁S ch ro Encoder Params ▁* p _ sch ro _ params ▁= ▁av ctx -> priv _ data ; ▁for ▁( idx ▁= ▁0; ▁idx ▁< ▁num _ formats ; ▁++ idx ) ▁{ ▁if ▁( sch ro _ pixel _ format _ map [ idx ]. ff _ pix _ fmt ▁== ▁av ctx -> pix _ fmt ) ▁{ ▁p _ sch ro _ params -> format -> chrom a _ format ▁= ▁sch ro _ pixel _ format _ map [ idx

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁IE EE _ AR ITH 2( sqrt t ) ▁IE EE _ AR ITH 2( cv t st ) ▁IE EE _ AR ITH 2( cv t ts ) ▁static ▁void ▁gen _ cv tt q ( Dis as Context ▁* ctx , ▁int ▁rb , ▁int ▁rc , ▁int ▁fn 11) ▁{ ▁TC G v ▁vb , ▁vc ; ▁/* ▁No ▁need ▁to ▁set ▁flush zero , ▁since ▁we ▁have ▁an ▁integer ▁output . ▁*/ ▁vb ▁= ▁gen _ ie ee _ input ( ctx , ▁rb , ▁fn 11, ▁0); ▁vc ▁= ▁dest _ f pr ( ctx , ▁rc ); ▁/* ▁Al most ▁all ▁integer ▁conversions ▁use ▁cropped ▁rounding , ▁and ▁most ▁also ▁do ▁not ▁have ▁integer ▁overflow ▁enabled . ▁Special ▁ca

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ serial _ device _ exit ( Device State ▁* dev ) ▁{ ▁V irt IO Serial ▁* v ser ▁= ▁VI RT IO _ SER IAL ( dev ); ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( dev ); ▁unregister _ save vm ( dev , ▁" virt io - console ", ▁v ser ); ▁g _ free ( v ser -> iv qs ); ▁g _ free ( v ser -> ov qs ); ▁g _ free ( v ser -> ports _ map ); ▁if ▁( v ser -> post _ load ) ▁{ ▁g _ free ( v ser -> post _ load -> connected ); ▁timer _ del ( v ser -> post _ load -> timer ); ▁timer _ free ( v ser -> post _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ init _ vc pu ( CPU State ▁* c env ) ▁{ ▁int ▁ret ▁= ▁0; ▁struct ▁k vm _ s re gs ▁s re gs ; ▁s re gs . pv r ▁= ▁c env -> spr [ SP R _ P VR ]; ▁ret ▁= ▁k vm _ vc pu _ io ctl ( c env , ▁K VM _ SET _ S REG S , ▁& s re gs ); ▁idle _ timer ▁= ▁qemu _ new _ timer _ ns ( vm _ clock , ▁k vm _ k ick _ env , ▁c env ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ queue _ notify _ v q ( V irt Queue ▁* v q ) ▁{ ▁if ▁( v q -> v ring . desc ▁&& ▁v q -> handle _ output ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁v q -> v dev ; ▁trace _ virt io _ queue _ notify ( v dev , ▁v q ▁- ▁v dev -> v q , ▁v q ); ▁v q -> handle _ output ( v dev , ▁v q );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁mp _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁M otion Pixels Context ▁* mp ▁= ▁av ctx -> priv _ data ; ▁int ▁w 4 ▁= ▁( av ctx -> width ▁+ ▁3) ▁& ▁~ 3; ▁int ▁h 4 ▁= ▁( av ctx -> height ▁+ ▁3) ▁& ▁~ 3; ▁if ( av ctx -> ex tr ad ata _ size ▁< ▁2 ){ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" ex tr ad ata ▁too ▁small \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁motion pixels _ table init (); ▁mp -> av ctx ▁= ▁av ctx ; ▁ff _ ds put il _ init ( & mp -> d sp , ▁av ctx ); ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁put _ payload _ header ( ▁AV Format Context ▁* s , ▁AS F Stream ▁* stream , ▁int ▁presentation _ time , ▁int ▁m _ obj _ size , ▁int ▁m _ obj _ offset , ▁int ▁payload _ len ▁) ▁{ ▁AS F Context ▁* as f ▁= ▁s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁& as f -> pb ; ▁int ▁val ; ▁val ▁= ▁stream -> num ; ▁if ▁( s -> streams [ val ▁- ▁1] -> codec . coded _ frame -> key _ frame ) ▁val ▁|= ▁AS F _ PL _ FLAG _ KEY _ FRAME ; ▁put _ byte ( pb , ▁val ); ▁put _ byte ( pb , ▁stream -> seq ); ▁// Media ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pc m _ encode _ frame ( AV Codec Context ▁* av ctx , ▁unsigned ▁char ▁* frame , ▁int ▁buf _ size , ▁void ▁* data ) ▁{ ▁int ▁n , ▁sample _ size , ▁v ; ▁short ▁* samples ; ▁unsigned ▁char ▁* dst ; ▁switch ( av ctx -> codec -> id ) ▁{ ▁case ▁CODE C _ ID _ PC M _ S 16 LE : ▁case ▁CODE C _ ID _ PC M _ S 16 BE : ▁case ▁CODE C _ ID _ PC M _ U 16 LE : ▁case ▁CODE C _ ID _ PC M _ U 16 BE : ▁sample _ size ▁= ▁2; ▁break ; ▁default : ▁sample _ size ▁= ▁1; ▁break ; ▁} ▁n ▁= ▁buf _ size ▁/ ▁sample _ size 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁h Scale _ alt ive c _ real ( int 16_ t ▁* dst , ▁int ▁dst W , ▁uint 8_ t ▁* src , ▁int ▁src W , ▁int ▁x Inc , ▁int 16_ t ▁* filter , ▁int 16_ t ▁* filter Pos , ▁int ▁filter Size ) ▁{ ▁register ▁int ▁i ; ▁int ▁__ attribute __ ▁(( aligned ▁( 16 ))) ▁temp o [4 ]; ▁if ▁( filter Size ▁% ▁4) ▁{ ▁for ( i =0; ▁i < dst W ; ▁i ++) ▁{ ▁register ▁int ▁j ; ▁register ▁int ▁src Pos ▁= ▁filter Pos [ i ]; ▁register ▁int ▁val ▁= ▁0; ▁for ( j =0; ▁j < filter Size ; ▁j ++) ▁{ ▁val ▁+= ▁(( int ) src [ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p pc _ store _ x er ▁( CP UP PC State ▁* env , ▁uint 32_ t ▁value ) ▁{ ▁x er _ so ▁= ▁( value ▁>> ▁X ER _ SO ) ▁& ▁0 x 01 ; ▁x er _ ov ▁= ▁( value ▁>> ▁X ER _ O V ) ▁& ▁0 x 01 ; ▁x er _ ca ▁= ▁( value ▁>> ▁X ER _ CA ) ▁& ▁0 x 01 ; ▁x er _ cmp ▁= ▁( value ▁>> ▁X ER _ C MP ) ▁& ▁0 xFF ; ▁x er _ bc ▁= ▁( value ▁>> ▁X ER _ BC ) ▁& ▁0 x 3 F ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁property _ get _ enum ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Enum Property ▁* prop ▁= ▁opaque ; ▁int ▁value ; ▁value ▁= ▁prop -> get ( obj , ▁err p ); ▁visit _ type _ enum ( v , ▁& value , ▁prop -> strings , ▁NULL , ▁name , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁path _ has _ protocol ( const ▁char ▁* path ) ▁{ ▁# if def ▁_ W IN 32 ▁if ▁( is _ windows _ drive ( path ) ▁|| ▁is _ windows _ drive _ prefix ( path )) ▁{ ▁return ▁0; ▁} ▁# end if ▁return ▁str chr ( path , ▁': ') ▁!= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m ch _ init ( PC ID evice ▁* d ) ▁{ ▁int ▁i ; ▁M CH PC I State ▁* m ch ▁= ▁M CH _ PC I _ DEVICE ( d ); ▁/* ▁setup ▁pci ▁memory ▁regions ▁*/ ▁memory _ region _ init _ alias ( & m ch -> pc i _ hole , ▁OBJECT ( m ch ), ▁" pc i - hole ", ▁m ch -> pc i _ address _ space , ▁m ch -> below _4 g _ mem _ size , ▁0 x 1 00000000 ULL ▁- ▁m ch -> below _4 g _ mem _ size ); ▁memory _ region _ add _ sub region ( m ch -> system _ memory , ▁m ch -> below _4 g _ mem _ size , ▁& m ch -> pc i _ hole ); ▁pc _ ini

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h 26 1_ find _ frame _ end ( Parse Context ▁* pc , ▁AV Codec Context * ▁av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ){ ▁int ▁v op _ found , ▁i , ▁j , ▁bits _ left , ▁last _ bits ; ▁uint 32_ t ▁state ; ▁H 26 1 Context ▁* h ▁= ▁av ctx -> priv _ data ; ▁if ( h ){ ▁bits _ left ▁= ▁h -> bits _ left ; ▁last _ bits ▁= ▁h -> last _ bits ; ▁} ▁else { ▁bits _ left ▁= ▁0; ▁last _ bits ▁= ▁0; ▁} ▁v op _ found = ▁pc -> frame _ start _ found ; ▁state = ▁pc -> state ; ▁if ( bits _ left ! =0 ▁&& ▁!

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁address _ space _ write ( Address Space ▁* as , ▁target _ ph ys _ addr _ t ▁addr , ▁const ▁uint 8_ t ▁* buf , ▁int ▁len ) ▁{ ▁address _ space _ rw ( as , ▁addr , ▁( uint 8_ t ▁* ) buf , ▁len , ▁true ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁audio _ run _ capture ▁( Audio State ▁* s ) ▁{ ▁Capture Voice Out ▁* cap ; ▁for ▁( cap ▁= ▁s -> cap _ head . l h _ first ; ▁cap ; ▁cap ▁= ▁cap -> entries . le _ next ) ▁{ ▁int ▁live , ▁r pos , ▁captured ; ▁H W Voice Out ▁* hw ▁= ▁& cap -> hw ; ▁SW Voice Out ▁* sw ; ▁captured ▁= ▁live ▁= ▁audio _ pc m _ hw _ get _ live _ out ▁( hw ); ▁r pos ▁= ▁hw -> r pos ; ▁while ▁( live ) ▁{ ▁int ▁left ▁= ▁hw -> samples ▁- ▁r pos ; ▁int ▁to _ capture ▁= ▁audio _ MIN ▁( live , ▁left ); ▁st _ sample _ t ▁* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Char Driver State ▁* q emu _ chr _ alloc ( void ) ▁{ ▁Char Driver State ▁* chr ▁= ▁g _ m alloc 0( size of ( Char Driver State )); ▁return ▁chr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁e cc _ init ( target _ ph ys _ addr _ t ▁base , ▁qemu _ irq ▁irq , ▁uint 32_ t ▁version ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁dev ▁= ▁q dev _ create ( NULL , ▁" ec c mem ctl "); ▁q dev _ prop _ set _ uint 32 ( dev , ▁" version ", ▁version ); ▁q dev _ init ( dev ); ▁s ▁= ▁sys bus _ from _ q dev ( dev ); ▁sys bus _ connect _ irq ( s , ▁0, ▁irq ); ▁sys bus _ mm io _ map ( s , ▁0, ▁base ); ▁if ▁( version ▁== ▁0) ▁{ ▁// ▁SS -6 00 MP ▁only ▁sys bus _ mm io _ map ( s , ▁1, ▁base ▁+ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁pc ist b _ service _ call ( S 390 CPU ▁* cpu , ▁uint 8_ t ▁r 1, ▁uint 8_ t ▁r 3, ▁uint 64_ t ▁g addr , ▁uint 8_ t ▁ar ) ▁{ ▁CP US 390 X State ▁* env ▁= ▁& cpu -> env ; ▁S 390 PC I Bus Device ▁* pb dev ; ▁Memory Region ▁* mr ; ▁int ▁i ; ▁uint 32_ t ▁fh ; ▁uint 8_ t ▁pc ias ; ▁uint 8_ t ▁len ; ▁uint 8_ t ▁buffer [ 128 ]; ▁if ▁( env -> p sw . mask ▁& ▁PS W _ MASK _ P STATE ) ▁{ ▁program _ interrupt ( env , ▁PG M _ PRI VI LEG ED , ▁6 ); ▁return ▁0; ▁} ▁fh ▁= ▁env -> re gs [ r 1] ▁>> ▁32 ; ▁pc ias ▁= ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁monitor _ un blocked ( G IO Channel ▁* chan , ▁G IO Condition ▁cond , ▁void ▁* op aque ) ▁{ ▁monitor _ flush ( op aque ); ▁return ▁FALSE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁always _ inline ▁void ▁gen _ store _ spr ( int ▁reg , ▁TC G v ▁t ) ▁{ ▁tc g _ gen _ st _ tl ( t , ▁cpu _ env , ▁offset of ( CPU State , ▁spr [ reg ])); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ is _ read _ only ( Block Driver State ▁* bs ) ▁{ ▁return ▁bs -> read _ only ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁bw _ conf 1_ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁P CI Bus ▁* b ▁= ▁opaque ; ▁pci _ data _ write ( b , ▁addr , ▁val , ▁size ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ fill ( target _ ulong ▁addr , ▁int ▁is _ write , ▁int ▁is _ user , ▁void ▁* ret addr ) ▁{ ▁Translation Block ▁* tb ; ▁int ▁ret ; ▁unsigned ▁long ▁pc ; ▁CPU X 86 State ▁* saved _ env ; ▁/* ▁XXX : ▁hack ▁to ▁restore ▁env ▁in ▁all ▁cases , ▁even ▁if ▁not ▁called ▁from ▁generated ▁code ▁*/ ▁saved _ env ▁= ▁env ; ▁env ▁= ▁cpu _ single _ env ; ▁ret ▁= ▁cpu _ x 86_ handle _ mm u _ fault ( env , ▁addr , ▁is _ write , ▁is _ user , ▁1); ▁if ▁( ret ) ▁{ ▁if ▁( ret addr ) ▁{ ▁/* ▁now ▁we ▁have ▁a ▁real 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ t co 1_ status _ bits ( void ) ▁{ ▁TestData ▁d ; ▁uint 16_ t ▁ticks ▁= ▁8 ; ▁uint 16_ t ▁val ; ▁int ▁ret ; ▁d . args ▁= ▁NULL ; ▁d . n ore boot ▁= ▁true ; ▁test _ init ( & d ); ▁stop _ t co ( & d ); ▁clear _ t co _ status ( & d ); ▁reset _ on _ second _ timeout ( false ); ▁set _ t co _ timeout ( & d , ▁ticks ); ▁load _ t co ( & d ); ▁start _ t co ( & d ); ▁clock _ step ( ticks ▁* ▁T CO _ TI CK _ N SEC ); ▁q pc i _ io _ write b ( d . dev , ▁d . t co _ io _ base ▁+ ▁T CO _ DAT _ IN , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁block _ crypto _ create _ opts _ init ( Q Crypto Block Format ▁format , ▁Q emu Opts ▁* opts , ▁Error ▁** err p ) ▁{ ▁Opt s Visitor ▁* ov ; ▁Q Crypto Block Create Options ▁* ret ▁= ▁NULL ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁ret ▁= ▁g _ new 0( Q Crypto Block Create Options , ▁1); ▁ret -> format ▁= ▁format ; ▁o v ▁= ▁opts _ visitor _ new ( opts ); ▁visit _ start _ struct ( opts _ get _ visitor ( ov ), ▁NULL , ▁NULL , ▁0, ▁& local _ err ); ▁if ▁( local _ err ) ▁{ ▁goto ▁out ; ▁} ▁switch ▁( format ) ▁{ ▁case ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁RE NAME ( y uv 2 y uv X )( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* l um Filter , ▁const ▁int 16_ t ▁** l um Src , ▁int ▁l um Filter Size , ▁const ▁int 16_ t ▁* chr Filter , ▁const ▁int 16_ t ▁** chr US rc , ▁const ▁int 16_ t ▁** chr V Src , ▁int ▁chr Filter Size , ▁const ▁int 16_ t ▁** al p Src , ▁uint 8_ t ▁* dest , ▁uint 8_ t ▁* u Dest , ▁uint 8_ t ▁* v Dest , ▁uint 8_ t ▁* a Dest , ▁int ▁dst W , ▁int ▁chr Dst W ) ▁{ ▁if ▁( u Dest ) ▁{ ▁x 86_ reg ▁uv _ off ▁= ▁c -> uv _ off ; ▁Y SCALE Y 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁add _ cp reg _ to _ list ( g pointer ▁key , ▁g pointer ▁opaque ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁opaque ; ▁uint 64_ t ▁reg idx ; ▁const ▁ARM CP Reg Info ▁* ri ; ▁reg idx ▁= ▁* ( uint 32_ t ▁* ) key ; ▁ri ▁= ▁get _ arm _ cp _ reg info ( cpu -> cp _ re gs , ▁reg idx ); ▁if ▁(! ( ri -> type ▁& ▁ARM _ CP _ NO _ M IG RATE )) ▁{ ▁cpu -> cp reg _ indexes [ cpu -> cp reg _ array _ len ] ▁= ▁cp reg _ to _ k vm _ id ( reg idx ); ▁/* ▁The ▁value ▁array ▁need ▁not ▁be ▁initialized ▁at ▁this ▁point ▁*/ ▁cpu -> c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁x an _ h uff man _ decode ( un signed ▁char ▁* dest , ▁unsigned ▁char ▁* src ) ▁{ ▁unsigned ▁char ▁byte ▁= ▁* src ++; ▁unsigned ▁char ▁i val ▁= ▁byte ▁+ ▁0 x 16 ; ▁unsigned ▁char ▁* ▁ptr ▁= ▁src ▁+ ▁byte * 2; ▁unsigned ▁char ▁val ▁= ▁i val ; ▁int ▁counter ▁= ▁0; ▁unsigned ▁char ▁bits ▁= ▁* ptr ++; ▁while ▁( ▁val ▁!= ▁0 x 16 ▁) ▁{ ▁if ▁( ▁(1 ▁<< ▁counter ) ▁& ▁bits ▁) ▁val ▁= ▁src [ byte ▁+ ▁val ▁- ▁0 x 17 ]; ▁else ▁val ▁= ▁src [ val ▁- ▁0 x 17 ]; ▁if ▁( ▁val ▁< ▁0 x 16 ▁) ▁{ ▁* dest ++ ▁= ▁v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁alarm _ has _ dy nt icks ( struct ▁qemu _ alarm _ timer ▁* t ) ▁{ ▁return ▁t ▁&& ▁t -> re arm ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁if f _ read _ header ( AV Format Context ▁* s ) ▁{ ▁If f Dem ux Context ▁* iff ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ; ▁uint 8_ t ▁* buf ; ▁uint 32_ t ▁chunk _ id , ▁data _ size ; ▁uint 32_ t ▁screen mode ▁= ▁0, ▁num , ▁den ; ▁unsigned ▁transparency ▁= ▁0; ▁unsigned ▁masking ▁= ▁0; ▁// ▁no ▁mask ▁uint 8_ t ▁fmt [ 16 ]; ▁int ▁fmt _ size ; ▁st ▁= ▁av format _ new _ stream ( s , ▁NULL ); ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁st -> codec -> channels

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ status ( FTP Context ▁* s , ▁char ▁** line , ▁const ▁int ▁response _ codes []) ▁{ ▁int ▁err , ▁i , ▁dash ▁= ▁0, ▁result ▁= ▁0, ▁code _ found ▁= ▁0; ▁char ▁buf [ CONTROL _ BUFFER _ SIZE ]; ▁AV B Print ▁line _ buffer ; ▁if ▁( line ) ▁av _ b print _ init ( & line _ buffer , ▁0, ▁AV _ B PRI NT _ SIZE _ A UT OM ATIC ); ▁while ▁(! code _ found ▁|| ▁dash ) ▁{ ▁if ▁(( err ▁= ▁ftp _ get _ line ( s , ▁buf , ▁sizeof ( buf ))) ▁< ▁0) ▁{ ▁av _ b print _ final ize ( & line _ buffer , ▁NULL ); ▁retur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁arm _ sys ctl _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset ) ▁{ ▁arm _ sys ctl _ state ▁* s ▁= ▁( arm _ sys ctl _ state ▁* ) op aque ; ▁switch ▁( offset ) ▁{ ▁case ▁0 x 00 : ▁/* ▁ID ▁*/ ▁return ▁s -> sys _ id ; ▁case ▁0 x 04 : ▁/* ▁SW ▁*/ ▁/* ▁General ▁purpose ▁hardware ▁switches . ▁We ▁don ' t ▁have ▁a ▁useful ▁way ▁of ▁expos ing ▁these ▁to ▁the ▁user . ▁*/ ▁return ▁0; ▁case ▁0 x 08 : ▁/* ▁L ED ▁*/ ▁return ▁s -> led s ; ▁case ▁0 x 20 : ▁/* ▁LOCK ▁*/ ▁return ▁s -> loc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁run _ on _ cpu ( CPU State ▁* cpu , ▁void ▁(* func )( void ▁* data ), ▁void ▁* data ) ▁{ ▁struct ▁qemu _ work _ item ▁wi ; ▁if ▁( q emu _ cpu _ is _ self ( cpu )) ▁{ ▁func ( data ); ▁return ; ▁} ▁wi . func ▁= ▁func ; ▁wi . data ▁= ▁data ; ▁wi . free ▁= ▁false ; ▁if ▁( cpu -> queued _ work _ first ▁== ▁NULL ) ▁{ ▁cpu -> queued _ work _ first ▁= ▁& wi ; ▁} ▁else ▁{ ▁cpu -> queued _ work _ last -> next ▁= ▁& wi ; ▁} ▁cpu -> queued _ work _ last ▁= ▁& wi ; ▁wi . next ▁= ▁NULL ; ▁wi . done ▁= ▁false ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁double ▁av priv _ str tod ( char ▁* restrict ▁np tr , ▁char ▁** restrict ▁end ptr ) ▁{ ▁char ▁* end ; ▁double ▁res ; ▁/* ▁Skip ▁leading ▁spaces ▁*/ ▁while ▁( iss pace (* np tr )) ▁np tr ++; ▁if ▁(! av _ str n case cmp ( np tr , ▁" infinity ", ▁8 )) ▁{ ▁end ▁= ▁np tr ▁+ ▁8 ; ▁res ▁= ▁IN FIN ITY ; ▁} ▁else ▁if ▁(! av _ str n case cmp ( np tr , ▁" inf ", ▁3 )) ▁{ ▁end ▁= ▁np tr ▁+ ▁3; ▁res ▁= ▁IN FIN ITY ; ▁} ▁else ▁if ▁(! av _ str n case cmp ( np tr , ▁"+ infinity ", ▁9 )) ▁{ ▁end ▁= ▁np tr ▁+ ▁9 ; ▁res ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁update _ video _ pts ( Video State ▁* is , ▁double ▁pts , ▁int 64_ t ▁pos , ▁int ▁serial ) ▁{ ▁double ▁time ▁= ▁av _ get time () ▁/ ▁1000000 .0 ; ▁/* ▁update ▁current ▁video ▁pts ▁*/ ▁is -> video _ current _ pts ▁= ▁pts ; ▁is -> video _ current _ pts _ d rift ▁= ▁is -> video _ current _ pts ▁- ▁time ; ▁is -> video _ current _ pos ▁= ▁pos ; ▁is -> frame _ last _ pts ▁= ▁pts ; ▁check _ external _ clock _ sync ( is , ▁is -> video _ current _ pts ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁open _ f ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁int ▁flags ▁= ▁0; ▁int ▁readonly ▁= ▁0; ▁int ▁g rowable ▁= ▁0; ▁int ▁c ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" sn rg ")) ▁!= ▁EOF ) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' s ': ▁flags ▁|= ▁B DR V _ O _ SNAPSHOT ; ▁break ; ▁case ▁' n ': ▁flags ▁|= ▁B DR V _ O _ NO CACHE ; ▁break ; ▁case ▁' r ': ▁readonly ▁= ▁1; ▁break ; ▁case ▁' g ': ▁g rowable ▁= ▁1; ▁break ; ▁default : ▁return ▁command _ usage ( & open _ cmd ); ▁} ▁} ▁if ▁(! readonly ) ▁{ ▁flags ▁|= ▁B DR V _ O 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁event _ status _ media ( IDE State ▁* s , ▁uint 8_ t ▁* buf ) ▁{ ▁uint 8_ t ▁event _ code , ▁media _ status ; ▁media _ status ▁= ▁0; ▁if ▁( s -> tr ay _ open ) ▁{ ▁media _ status ▁= ▁MS _ T RAY _ OPEN ; ▁} ▁else ▁if ▁( b dr v _ is _ insert ed ( s -> bs )) ▁{ ▁media _ status ▁= ▁MS _ MEDIA _ PRE SENT ; ▁} ▁/* ▁Event ▁notification ▁descriptor ▁*/ ▁event _ code ▁= ▁ME C _ NO _ CHANGE ; ▁if ▁( media _ status ▁!= ▁MS _ T RAY _ OPEN ) ▁{ ▁if ▁( s -> events . new _ media ) ▁{ ▁event _ cod

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ sc si _ hot un plug ( Hot plug Handler ▁* hot plug _ dev , ▁Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁V irt IO Device ▁* v dev ▁= ▁VI RT IO _ DEVICE ( hot plug _ dev ); ▁V irt IO SC SI ▁* s ▁= ▁VI RT IO _ SC SI ( v dev ); ▁S CS ID evice ▁* sd ▁= ▁SC SI _ DEVICE ( dev ); ▁if ▁(( v dev -> guest _ features ▁>> ▁VI RT IO _ SC SI _ F _ H OT PL UG ) ▁& ▁1) ▁{ ▁virt io _ sc si _ push _ event ( s , ▁sd , ▁VI RT IO _ SC SI _ T _ TRAN SPORT _ RE SET , ▁VI RT IO _ SC SI _ E VT _ RE SET _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁q io _ channel _ socket _ connect _ sync ( Q IO Channel Socket ▁* i oc , ▁SocketAddress ▁* addr , ▁Error ▁** err p ) ▁{ ▁int ▁fd ; ▁trace _ q io _ channel _ socket _ connect _ sync ( i oc , ▁addr ); ▁fd ▁= ▁socket _ connect ( addr , ▁NULL , ▁NULL , ▁err p ); ▁if ▁( fd ▁< ▁0) ▁{ ▁trace _ q io _ channel _ socket _ connect _ fail ( i oc ); ▁return ▁-1; ▁} ▁trace _ q io _ channel _ socket _ connect _ complete ( i oc , ▁fd ); ▁if ▁( q io _ channel _ socket _ set _ fd ( i oc , ▁fd , ▁err p ) ▁< ▁0) ▁{ ▁cl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁save _ bits ( W MA Pro Decode Ctx ▁* s , ▁Get Bit Context * ▁gb , ▁int ▁len , ▁int ▁append ) ▁{ ▁int ▁buf len ; ▁/** ▁when ▁the ▁frame ▁data ▁does ▁not ▁need ▁to ▁be ▁concatenated , ▁the ▁input ▁buffer ▁is ▁reset ted ▁and ▁additional ▁bits ▁from ▁the ▁previous ▁frame ▁are ▁copy ed ▁and ▁skipped ▁later ▁so ▁that ▁a ▁fast ▁byte ▁copy ▁is ▁possible ▁*/ ▁if ▁(! append ) ▁{ ▁s -> frame _ offset ▁= ▁get _ bits _ count ( gb ) ▁& ▁7 ; ▁s -> num _ saved _ bits ▁= ▁s -> frame _ offset ; ▁init _ put _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ interval _ pack ets ( Writer Context ▁* w , ▁AV Format Context ▁* fmt _ ctx , ▁const ▁Read Interval ▁* interval , ▁int 64_ t ▁* cur _ ts ) ▁{ ▁AV Packet ▁pkt , ▁pkt 1; ▁AV Frame ▁* frame ▁= ▁NULL ; ▁int ▁ret ▁= ▁0, ▁i ▁= ▁0, ▁frame _ count ▁= ▁0; ▁int 64_ t ▁start ▁= ▁- INT 64_ MAX , ▁end ▁= ▁interval -> end ; ▁int ▁has _ start ▁= ▁0, ▁has _ end ▁= ▁interval -> has _ end ▁&& ▁! interval -> end _ is _ offset ; ▁av _ init _ packet ( & pk t ); ▁av _ log ( NULL , ▁AV _ LOG _ VER BOSE , ▁"

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁attribute _ align _ arg ▁av codec _ encode _ audio ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁const ▁short ▁* samples ) ▁{ ▁AV Packet ▁pkt ; ▁AV Frame ▁* frame ; ▁int ▁ret , ▁samples _ size , ▁got _ packet ; ▁av _ init _ packet ( & pk t ); ▁pkt . data ▁= ▁buf ; ▁pkt . size ▁= ▁buf _ size ; ▁if ▁( samples ) ▁{ ▁frame ▁= ▁av _ frame _ alloc (); ▁if ▁(! frame ) ▁return ▁A VER ROR ( EN O ME M ); ▁if ▁( av ctx -> frame _ size ) ▁{ ▁frame -> nb _ samples ▁= ▁av ctx -> frame _ s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁host _ cp uid ( uint 32_ t ▁function , ▁uint 32_ t ▁count , ▁uint 32_ t ▁* e ax , ▁uint 32_ t ▁* eb x , ▁uint 32_ t ▁* ec x , ▁uint 32_ t ▁* ed x ) ▁{ ▁# if ▁defined ( CONFIG _ K VM ) ▁uint 32_ t ▁vec [4 ]; ▁# if def ▁__ x 86_64 __ ▁asm ▁volatile (" cp uid " ▁: ▁" = a " ( vec [0] ), ▁" = b " ( vec [1] ), ▁" = c " ( vec [2] ), ▁" = d " ( vec [3 ]) ▁: ▁"0" ( function ), ▁" c " ( count ) ▁: ▁" cc "); ▁# else ▁asm ▁volatile (" push a ▁\ n \ t " ▁" cp uid ▁\ n \ t " ▁" mov ▁%% e ax , ▁0 ( % 1) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dx va 2_ map _ frame ( AV H W Frames Context ▁* ctx , ▁AV Frame ▁* dst , ▁const ▁AV Frame ▁* src , ▁int ▁flags ) ▁{ ▁ID irect 3 DS urface 9 ▁* surface ▁= ▁( ID irect 3 DS urface 9 *) src -> data [3 ]; ▁D X VA 2 Mapping ▁* map ; ▁D 3 DS UR FACE _ DESC ▁surface Desc ; ▁D 3 D LOCK ED _ RECT ▁Lock ed Rect ; ▁H RESULT ▁hr ; ▁int ▁i , ▁err , ▁nb _ plan es ; ▁int ▁lock _ flags ▁= ▁0; ▁nb _ plan es ▁= ▁av _ pix _ fmt _ count _ plan es ( dst -> format ); ▁hr ▁= ▁ID irect 3 DS urface 9_ Get Desc ( sur

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁show _ help ( void ) ▁{ ▁const ▁char ▁* prog ; ▁const ▁Option Def ▁* po ; ▁int ▁i , ▁expert ; ▁prog ▁= ▁do _ play ▁? ▁" ff play " ▁: ▁" ff mpeg "; ▁printf ("% s ▁version ▁" ▁FF M PEG _ VERSION ▁", ▁Copyright ▁( c ) ▁2000 , ▁200 1, ▁2002 ▁G er ard ▁L ant au \ n ", ▁prog ); ▁if ▁(! do _ play ) ▁{ ▁printf (" usage : ▁ffmpeg ▁[[ options ] ▁- i ▁input _ file ] ... ▁{ [ options ] ▁outfile } ... \ n " ▁" Hyper ▁fast ▁M PEG 1/ M PEG 4/ H 26 3/ RV ▁and ▁AC 3/ M PEG ▁audio ▁encoder \ n "); ▁} ▁else ▁{ ▁print

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁av _ col d ▁int ▁ff v 1_ common _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁FF V 1 Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁if ▁(! av ctx -> width ▁|| ▁! av ctx -> height ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁s -> av ctx ▁= ▁av ctx ; ▁s -> flags ▁= ▁av ctx -> flags ; ▁s -> picture . f ▁= ▁av codec _ alloc _ frame (); ▁s -> last _ picture . f ▁= ▁av _ frame _ alloc (); ▁ff _ ds put il _ init ( & s -> d sp , ▁av ctx ); ▁s -> width ▁= ▁av ctx -> width ; ▁s -> height ▁= ▁av ctx -> height ; ▁// ▁defaults ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v qa _ decode _ chunk ( V qa Context ▁* s ) ▁{ ▁unsigned ▁int ▁chunk _ type ; ▁unsigned ▁int ▁chunk _ size ; ▁int ▁byte _ skip ; ▁unsigned ▁int ▁index ▁= ▁0; ▁int ▁i ; ▁unsigned ▁char ▁r , ▁g , ▁b ; ▁int ▁index _ shift ; ▁int ▁res ; ▁int ▁cb f 0_ chunk ▁= ▁-1; ▁int ▁cb f z _ chunk ▁= ▁-1; ▁int ▁cb p 0_ chunk ▁= ▁-1; ▁int ▁cb p z _ chunk ▁= ▁-1; ▁int ▁c pl 0_ chunk ▁= ▁-1; ▁int ▁c pl z _ chunk ▁= ▁-1; ▁int ▁v pt z _ chunk ▁= ▁-1; ▁int ▁x , ▁y ; ▁int ▁lines ▁= ▁0; ▁int ▁pixel _ ptr ; ▁int ▁vec

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁platform _ mm io _ map ( PC ID evice ▁* d , ▁int ▁region _ num , ▁pc ibus _ t ▁addr , ▁pc ibus _ t ▁size , ▁int ▁type ) ▁{ ▁int ▁mm io _ io _ addr ; ▁mm io _ io _ addr ▁= ▁cpu _ register _ io _ memory _ simple ( & platform _ mm io _ handler , ▁DEVICE _ N ATIVE _ ENDIAN ); ▁cpu _ register _ ph ysical _ memory ( addr , ▁size , ▁mm io _ io _ addr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁bt _ submit _ h ci ( struct ▁H CI Info ▁* info , ▁const ▁uint 8_ t ▁* data , ▁int ▁length ) ▁{ ▁struct ▁bt _ h ci _ s ▁* h ci ▁= ▁h ci _ from _ info ( info ); ▁uint 16_ t ▁cmd ; ▁int ▁param len , ▁i ; ▁if ▁( length ▁< ▁H CI _ COMMAND _ H DR _ SIZE ) ▁goto ▁short _ h ci ; ▁mem c py ( & h ci -> last _ cmd , ▁data , ▁2); ▁cmd ▁= ▁( data [1] ▁<< ▁8) ▁| ▁data [0]; ▁param len ▁= ▁data [2 ]; ▁if ▁( cmd _ op code _ og f ( cmd ) ▁== ▁0 ▁|| ▁cmd _ op code _ oc f ( cmd ) ▁== ▁0) ▁/* ▁NO P ▁*/ ▁return 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ s 39 0_ register _ io _ adapter ( S 390 F LIC State ▁* fs , ▁uint 32_ t ▁id , ▁uint 8_ t ▁isc , ▁bool ▁swap , ▁bool ▁is _ mask able ) ▁{ ▁struct ▁k vm _ s 39 0_ io _ adapter ▁adapter ▁= ▁{ ▁. id ▁= ▁id , ▁. isc ▁= ▁isc , ▁. mask able ▁= ▁is _ mask able , ▁. swap ▁= ▁swap , ▁}; ▁KV MS 390 F LIC State ▁* f lic ▁= ▁K VM _ S 39 0_ F LIC ( fs ); ▁int ▁r , ▁ret ; ▁struct ▁k vm _ device _ attr ▁attr ▁= ▁{ ▁. group ▁= ▁K VM _ DEV _ F LIC _ AD AP TER _ REGI STER , ▁. addr ▁= ▁( uint 64_ t ) & 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dec _ calc ( Dis as Context ▁* dc , ▁uint 32_ t ▁insn ) ▁{ ▁uint 32_ t ▁op 0, ▁op 1, ▁op 2; ▁uint 32_ t ▁ra , ▁rb , ▁rd ; ▁op 0 ▁= ▁extract 32 ( ins n , ▁0, ▁4 ); ▁op 1 ▁= ▁extract 32 ( ins n , ▁8, ▁2); ▁op 2 ▁= ▁extract 32 ( ins n , ▁6, ▁2); ▁ra ▁= ▁extract 32 ( ins n , ▁16, ▁5 ); ▁rb ▁= ▁extract 32 ( ins n , ▁11, ▁5 ); ▁rd ▁= ▁extract 32 ( ins n , ▁21, ▁5 ); ▁switch ▁( op 0) ▁{ ▁case ▁0 x 0000 : ▁switch ▁( op 1) ▁{ ▁case ▁0 x 00 : ▁/* ▁l . add ▁*/ ▁LOG _ DIS (" l . add ▁r % d , ▁r % d , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q EM UC lock Type ▁timer list _ get _ clock ( Q EM UT imer List ▁* timer _ list ) ▁{ ▁return ▁timer _ list -> clock -> type ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁palette 8 to b gr 16 ( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁long ▁num _ pixels , ▁const ▁uint 8_ t ▁* palette ) ▁{ ▁long ▁i ; ▁for ( i =0; ▁i < num _ pixels ; ▁i ++) ▁(( uint 16_ t ▁* ) dst )[ i ] ▁= ▁b swap _16 (( ( uint 16_ t ▁* ) palette )[ ▁src [ i ] ▁]); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q io _ channel _ command _ final ize ( Object ▁* obj ) ▁{ ▁Q IO Channel Command ▁* i oc ▁= ▁Q IO _ CHANNEL _ COMMAND ( obj ); ▁if ▁( i oc -> read fd ▁!= ▁-1) ▁{ ▁close ( i oc -> read fd ); ▁i oc -> read fd ▁= ▁-1; ▁} ▁if ▁( i oc -> writ ef d ▁!= ▁-1) ▁{ ▁close ( i oc -> writ ef d ); ▁i oc -> writ ef d ▁= ▁-1; ▁} ▁if ▁( i oc -> pid ▁> ▁0) ▁{ ▁# if nd ef ▁WIN 32 ▁q io _ channel _ command _ abort ( i oc , ▁NULL ); ▁# end if ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ g ab 2_ sub ( AV Stream ▁* st , ▁AV Packet ▁* pk t ) ▁{ ▁if ▁(! str cmp ( pk t -> data , ▁" G AB 2") ▁&& ▁AV _ RL 16 ( pk t -> data + 5) ▁== ▁2) ▁{ ▁uint 8_ t ▁desc [ 256 ]; ▁int ▁score ▁= ▁AV PRO BE _ S CORE _ MAX ▁/ ▁2, ▁ret ; ▁A VI Stream ▁* ast ▁= ▁st -> priv _ data ; ▁AV InputFormat ▁* sub _ dem ux er ; ▁AV R ational ▁time _ base ; ▁AV IO Context ▁* pb ▁= ▁av io _ alloc _ context ( ▁pkt -> data ▁+ ▁7, ▁pkt -> size ▁- ▁7, ▁0, ▁NULL , ▁NULL , ▁NULL , ▁NULL ); ▁AV Probe Data ▁pd ; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ set _ string 3( void ▁* obj , ▁const ▁char ▁* name , ▁const ▁char ▁* val , ▁int ▁alloc , ▁const ▁AV Option ▁** o _ out ) ▁{ ▁int ▁ret ; ▁const ▁AV Option ▁* o ▁= ▁av _ opt _ find ( obj , ▁name , ▁NULL , ▁0, ▁0); ▁if ▁( o _ out ) ▁* o _ out ▁= ▁o ; ▁if ▁(! o ) ▁return ▁A VER ROR _ OPTION _ NOT _ FOUND ; ▁if ▁(! val ▁|| ▁o -> offset < =0) ▁return ▁A VER ROR ( E IN VAL ); ▁if ▁( o -> type ▁== ▁FF _ OPT _ TYPE _ BINARY ) ▁{ ▁uint 8_ t ▁** dst ▁= ▁( uint 8_ t ▁** ) (( ( uint 8_ t *) obj ) ▁+ ▁o -> o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ h _ l pf _ chrom a _ inter _ ms a ( uint 8_ t ▁* data , ▁int ▁img _ width , ▁int ▁alpha , ▁int ▁beta , ▁int 8_ t ▁* tc ) ▁{ ▁uint 8_ t ▁bs 0 ▁= ▁1; ▁uint 8_ t ▁bs 1 ▁= ▁1; ▁uint 8_ t ▁bs 2 ▁= ▁1; ▁uint 8_ t ▁bs 3 ▁= ▁1; ▁if ▁( tc [0] ▁< ▁0) ▁bs 0 ▁= ▁0; ▁if ▁( tc [1] ▁< ▁0) ▁bs 1 ▁= ▁0; ▁if ▁( tc [2] ▁< ▁0) ▁bs 2 ▁= ▁0; ▁if ▁( tc [3] ▁< ▁0) ▁bs 3 ▁= ▁0; ▁av c _ loop filter _ cb _ or _ cr _ inter _ edge _ ver _ ms a ( data , ▁bs 0, ▁bs 1, ▁bs 2, ▁bs 3, ▁tc [0], ▁tc [1], ▁tc [2], ▁tc [3 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sl ir p _ select _ poll ( fd _ set ▁* read fds , ▁fd _ set ▁* writ ef ds , ▁fd _ set ▁* xf ds , ▁int ▁select _ error ) ▁{ ▁Sl ir p ▁* sl ir p ; ▁struct ▁socket ▁* so , ▁* so _ next ; ▁int ▁ret ; ▁if ▁( Q TAIL Q _ EMPTY ( & sl ir p _ instances )) ▁{ ▁return ; ▁} ▁global _ read fds ▁= ▁read fds ; ▁global _ writ ef ds ▁= ▁writ ef ds ; ▁global _ xf ds ▁= ▁x fds ; ▁cur time ▁= ▁qemu _ get _ clock _ ms ( rt _ clock ); ▁Q TAIL Q _ FORE A CH ( sl ir p , ▁& sl ir p _ instances , ▁entry ) ▁{ ▁/* ▁* ▁See ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ cmp b ge ▁( uint 64_ t ▁op 1, ▁uint 64_ t ▁op 2) ▁{ ▁uint 8_ t ▁op a , ▁op b , ▁res ; ▁int ▁i ; ▁res ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁7 ; ▁i ++) ▁{ ▁op a ▁= ▁op 1 ▁>> ▁( i ▁* ▁8 ); ▁op b ▁= ▁op 2 ▁>> ▁( i ▁* ▁8 ); ▁if ▁( op a ▁>= ▁op b ) ▁res ▁|= ▁1 ▁<< ▁i ; ▁} ▁return ▁res ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁s 39 0_ i pl _ init ( Sys Bus Device ▁* dev ) ▁{ ▁S 390 IP L State ▁* i pl ▁= ▁S 39 0_ IP L ( dev ); ▁uint 64_ t ▁p entry ▁= ▁K ER N _ IMAGE _ START ; ▁int ▁kernel _ size ; ▁int ▁b ios _ size ; ▁char ▁* b ios _ filename ; ▁/* ▁* ▁Always ▁load ▁the ▁b ios ▁if ▁it ▁was ▁enfor ced , ▁* ▁even ▁if ▁an ▁external ▁kernel ▁has ▁been ▁defined . ▁*/ ▁if ▁(! i pl -> kernel ▁|| ▁i pl -> en force _ b ios ) ▁{ ▁uint 64_ t ▁fw base ▁= ▁( MIN ( ram _ size , ▁0 x 8 0000000 U ) ▁- ▁0 x 200 000) ▁& ▁~ 0 xffff 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt con _ parse ( const ▁char ▁* dev name ) ▁{ ▁Q emu Opts List ▁* device ▁= ▁qemu _ find _ opts (" device "); ▁static ▁int ▁index ▁= ▁0; ▁char ▁label [ 32 ]; ▁Q emu Opts ▁* bus _ opts , ▁* dev _ opts ; ▁if ▁( str cmp ( dev name , ▁" none ") ▁== ▁0) ▁return ▁0; ▁if ▁( index ▁== ▁MAX _ VI RT IO _ CON SO LES ) ▁{ ▁f printf ( stderr , ▁" q emu : ▁too ▁many ▁virt io ▁cons oles \ n "); ▁exit (1); ▁} ▁bus _ opts ▁= ▁qemu _ opts _ create ( device , ▁NULL , ▁0); ▁if ▁( arch _ type ▁== ▁Q EM U _ ARC

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁monitor _ put s ( Monitor ▁* mon , ▁const ▁char ▁* str ) ▁{ ▁char ▁c ; ▁for ( ; ;) ▁{ ▁c ▁= ▁* str ++; ▁if ▁( c ▁== ▁'\ 0 ') ▁break ; ▁if ▁( c ▁== ▁'\ n ') ▁{ ▁q string _ append _ chr ( mon -> out buf , ▁'\ r '); ▁} ▁q string _ append _ chr ( mon -> out buf , ▁c ); ▁if ▁( c ▁== ▁'\ n ') ▁{ ▁monitor _ flush ( mon ); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ mov l _ seg _ T 0( Dis as Context ▁* s , ▁int ▁seg _ reg ) ▁{ ▁if ▁( s -> pe ▁&& ▁! s -> vm 86 ) ▁{ ▁tc g _ gen _ trunc _ tl _ i 32 ( cpu _ tmp 2_ i 32, ▁cpu _ T 0); ▁gen _ helper _ load _ seg ( cpu _ env , ▁tc g _ const _ i 32 ( seg _ reg ), ▁cpu _ tmp 2_ i 32 ); ▁/* ▁abort ▁translation ▁because ▁the ▁add seg ▁value ▁may ▁change ▁or ▁because ▁ss 32 ▁may ▁change . ▁For ▁R _ SS , ▁translation ▁must ▁always ▁stop ▁as ▁a ▁special ▁handling ▁must ▁be ▁done ▁to ▁disable ▁hardware ▁interrup

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁gen _ inter mediate _ code _ a 64 ( ARM CPU ▁* cpu , ▁Translation Block ▁* tb ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁CPU ARM State ▁* env ▁= ▁& cpu -> env ; ▁Dis as Context ▁dc 1, ▁* dc ▁= ▁& dc 1; ▁target _ ulong ▁pc _ start ; ▁target _ ulong ▁next _ page _ start ; ▁int ▁num _ ins ns ; ▁int ▁max _ ins ns ; ▁pc _ start ▁= ▁tb -> pc ; ▁dc -> tb ▁= ▁tb ; ▁dc -> is _ j mp ▁= ▁DIS AS _ NEXT ; ▁dc -> pc ▁= ▁pc _ start ; ▁dc -> sing l est ep _ enabled ▁= ▁cs -> sing l est ep _ enabled ; ▁dc -> cond j mp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ st sc ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁AV Stream ▁* st ; ▁MO V Stream Context ▁* sc ; ▁unsigned ▁int ▁i , ▁entries ; ▁if ▁( c -> fc -> nb _ streams ▁< ▁1) ▁return ▁0; ▁st ▁= ▁c -> fc -> streams [ c -> fc -> nb _ streams -1 ]; ▁sc ▁= ▁st -> priv _ data ; ▁av io _ r 8 ( pb ); ▁/* ▁version ▁*/ ▁av io _ rb 24 ( pb ); ▁/* ▁flags ▁*/ ▁entries ▁= ▁av io _ rb 32 ( pb ); ▁av _ log ( c -> fc , ▁AV _ LOG _ TRA CE , ▁" track [ % i ]. st sc . entries ▁= ▁% 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ copy ( uint 8_ t ▁* frame , ▁int ▁width , ▁int ▁height , ▁const ▁uint 8_ t ▁* src , ▁const ▁uint 8_ t ▁* src _ end ) ▁{ ▁const ▁int ▁size ▁= ▁width ▁* ▁height ; ▁if ▁( src _ end ▁- ▁src ▁< ▁size ) ▁return ▁-1; ▁by test ream _ get _ buffer ( & src , ▁frame , ▁size ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 16_ t ▁nv me _ io _ cmd ( N v me Ctrl ▁* n , ▁N v me Cmd ▁* cmd , ▁N v me Request ▁* req ) ▁{ ▁N v me Namespace ▁* ns ; ▁uint 32_ t ▁ns id ▁= ▁le 32_ to _ cpu ( cmd -> ns id ); ▁if ▁( ns id ▁== ▁0 ▁|| ▁ns id ▁> ▁n -> num _ namespaces ) ▁{ ▁return ▁NV ME _ INVALID _ NS ID ▁| ▁NV ME _ DN R ; ▁} ▁ns ▁= ▁& n -> namespaces [ ns id ▁- ▁1 ]; ▁switch ▁( cmd -> op code ) ▁{ ▁case ▁NV ME _ CMD _ FL USH : ▁return ▁nv me _ flush ( n , ▁ns , ▁cmd , ▁req ); ▁case ▁NV ME _ CMD _ WRITE _ Z ER OS : ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁av filter _ link _ free ( AV Filter Link ▁** link ) ▁{ ▁if ▁(! * link ) ▁return ; ▁if ▁(( * link ) -> pool ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁PO OL _ SIZE ; ▁i ++) ▁{ ▁if ▁(( * link ) -> pool -> pic [ i ]) ▁{ ▁AV Filter Buffer Ref ▁* pic ref ▁= ▁(* link ) -> pool -> pic [ i ]; ▁/* ▁free ▁buffer : ▁pic refs ▁stored ▁in ▁the ▁pool ▁are ▁not ▁* ▁supposed ▁to ▁contain ▁a ▁free ▁callback ▁*/ ▁av _ fre ep ( & pic ref -> buf -> data [0]); ▁av _ fre ep ( & pic ref -> buf ); ▁av _ fre ep ( & pic ref -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁pl 110 _ read ( void ▁* op aque , ▁hw addr ▁offset , ▁unsigned ▁size ) ▁{ ▁pl 110 _ state ▁* s ▁= ▁( pl 110 _ state ▁* ) op aque ; ▁if ▁( offset ▁>= ▁0 x fe 0 ▁&& ▁offset ▁< ▁0 x 1000 ) ▁{ ▁return ▁id re gs [ s -> version ][ ( offset ▁- ▁0 x fe 0) ▁>> ▁2 ]; ▁} ▁if ▁( offset ▁>= ▁0 x 200 ▁&& ▁offset ▁< ▁0 x 400 ) ▁{ ▁return ▁s -> raw _ palette [( offset ▁- ▁0 x 200) ▁>> ▁2 ]; ▁} ▁switch ▁( offset ▁>> ▁2) ▁{ ▁case ▁0: ▁/* ▁L CD Timing 0 ▁*/ ▁return ▁s -> tim ing [0]; ▁case ▁1: ▁/* ▁L CD

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fill _ coding _ method _ array ▁( sb _ int 8_ array ▁t one _ level _ idx , ▁sb _ int 8_ array ▁t one _ level _ idx _ temp , ▁sb _ int 8_ array ▁coding _ method , ▁int ▁nb _ channels , ▁int ▁c , ▁int ▁super block type _2_ 3, ▁int ▁cm _ table _ select ) ▁{ ▁int ▁ch , ▁sb , ▁j ; ▁int ▁tmp , ▁acc , ▁es p _4 0, ▁comp ; ▁int ▁add 1, ▁add 2, ▁add 3, ▁add 4; ▁int 64_ t ▁mult res ; ▁// ▁This ▁should ▁never ▁happen ▁if ▁( nb _ channels ▁<= ▁0) ▁return ; ▁if ▁(! super block type _2_ 3) ▁{ ▁/* ▁This ▁c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁arm _ cpu _ dump _ state ( CPU State ▁* cs , ▁FILE ▁* f , ▁f printf _ function ▁cpu _ f printf , ▁int ▁flags ) ▁{ ▁ARM CPU ▁* cpu ▁= ▁ARM _ CPU ( cs ); ▁CPU ARM State ▁* env ▁= ▁& cpu -> env ; ▁int ▁i ; ▁if ▁( is _ a 64 ( env )) ▁{ ▁a arch 64_ cpu _ dump _ state ( cs , ▁f , ▁cpu _ f printf , ▁flags ); ▁return ; ▁} ▁for ( i =0; i < 16 ; i ++) ▁{ ▁cpu _ f printf ( f , ▁" R % 02 d =% 08 x ", ▁i , ▁env -> re gs [ i ]); ▁if ▁(( i ▁% ▁4) ▁== ▁3) ▁cpu _ f printf ( f , ▁"\ n "); ▁else ▁cpu _ f printf ( f ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁vm state _ load _ state ( Q EM U File ▁* f , ▁const ▁VM State Description ▁* v ms d , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁VM State Field ▁* field ▁= ▁vms d -> fields ; ▁int ▁ret ▁= ▁0; ▁trace _ vm state _ load _ state ( v ms d -> name , ▁version _ id ); ▁if ▁( version _ id ▁> ▁vms d -> version _ id ) ▁{ ▁error _ report ("% s : ▁incoming ▁version _ id ▁% d ▁is ▁too ▁new ▁" ▁" for ▁local ▁version _ id ▁% d ", ▁vms d -> name , ▁version _ id , ▁vms d -> version _ id ); ▁trace _ vm state _ load _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁xen _ log _ start ( Memory Listener ▁* listener , ▁Memory Region Section ▁* section ) ▁{ ▁X en IO State ▁* state ▁= ▁container _ of ( listener , ▁X en IO State , ▁memory _ listener ); ▁xen _ sync _ dirty _ bitmap ( state , ▁section -> offset _ within _ address _ space , ▁int 128 _ get 64 ( section -> size )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m peg video _ extract _ headers ( AV Codec Parser Context ▁* s , ▁AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁Parse Context 1 ▁* pc ▁= ▁s -> priv _ data ; ▁const ▁uint 8_ t ▁* buf _ end ; ▁uint 32_ t ▁start _ code ; ▁int ▁frame _ rate _ index , ▁ext _ type , ▁bytes _ left ; ▁int ▁frame _ rate _ ext _ n , ▁frame _ rate _ ext _ d ; ▁int ▁picture _ structure , ▁top _ field _ first , ▁repeat _ first _ field , ▁progress ive _ frame ; ▁int ▁horiz _ size _ ext , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ s mb ios _ ep _ address ( test _ data ▁* data ) ▁{ ▁uint 32_ t ▁off ; ▁/* ▁find ▁smb ios ▁entry ▁point ▁structure ▁*/ ▁for ▁( off ▁= ▁0 xf 0000 ; ▁off ▁< ▁0 x 100 000; ▁off ▁+= ▁0 x 10) ▁{ ▁uint 8_ t ▁sig [] ▁= ▁"_ SM _ "; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁sizeof ▁sig ▁- ▁1; ▁++ i ) ▁{ ▁sig [ i ] ▁= ▁read b ( off ▁+ ▁i ); ▁} ▁if ▁(! mem cmp ( sig , ▁"_ SM _ ", ▁sizeof ▁sig )) ▁{ ▁break ; ▁} ▁} ▁g _ assert _ cm ph ex ( off , ▁< , ▁0 x 100 000); ▁data -> s mb ios _ ep _ addr ▁= ▁off ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mov _ update _ d ts _ shift ( MO V Stream Context ▁* sc , ▁int ▁duration ) ▁{ ▁if ▁( duration ▁< ▁0) ▁{ ▁sc -> d ts _ shift ▁= ▁FF MAX ( sc -> d ts _ shift , ▁- duration );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fft _ calc _ c ( FF T Context ▁* s , ▁FFT Complex ▁* z ) ▁{ ▁int ▁nb its , ▁i , ▁n , ▁num _ transforms , ▁offset , ▁step ; ▁int ▁n 4, ▁n 2, ▁n 34 ; ▁FFT Sample ▁tmp 1, ▁tmp 2, ▁tmp 3, ▁tmp 4, ▁tmp 5, ▁tmp 6, ▁tmp 7, ▁tmp 8 ; ▁FFT Complex ▁* tmp z ; ▁const ▁int ▁fft _ size ▁= ▁(1 ▁<< ▁s -> nb its ); ▁int 64_ t ▁acc u ; ▁num _ transforms ▁= ▁(0 x 2 a ab ▁>> ▁( 16 ▁- ▁s -> nb its )) ▁| ▁1; ▁for ▁( n =0; ▁n < num _ transforms ; ▁n ++){ ▁offset ▁= ▁ff _ fft _ offsets _ l ut [ n ] ▁<< ▁2; ▁tmp z 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ pp c _ handle _ mm u _ fault ( CP UP PC State ▁* env , ▁target _ ulong ▁address , ▁int ▁rw , ▁int ▁mm u _ idx ) ▁{ ▁mm u _ ctx _ t ▁ctx ; ▁int ▁access _ type ; ▁int ▁ret ▁= ▁0; ▁if ▁( rw ▁== ▁2) ▁{ ▁/* ▁code ▁access ▁*/ ▁rw ▁= ▁0; ▁access _ type ▁= ▁ACCESS _ CODE ; ▁} ▁else ▁{ ▁/* ▁data ▁access ▁*/ ▁access _ type ▁= ▁env -> access _ type ; ▁} ▁ret ▁= ▁get _ ph ysical _ address ( env , ▁& ctx , ▁address , ▁rw , ▁access _ type ); ▁if ▁( ret ▁== ▁0) ▁{ ▁tl b _ set _ page ( env , ▁address ▁& ▁TARG

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ sp ice _ display _ init ( Display State ▁* ds ) ▁{ ▁assert ( sd py . ds ▁== ▁NULL ); ▁qemu _ sp ice _ display _ init _ common ( & sd py , ▁ds ); ▁register _ display chang elist ener ( ds , ▁& display _ listener ); ▁sd py . q xl . base . s if ▁= ▁& d py _ interface . base ; ▁qemu _ sp ice _ add _ interface ( & sd py . q xl . base ); ▁assert ( sd py . worker ); ▁qemu _ sp ice _ create _ host _ mem slot ( & sd py ); ▁qemu _ sp ice _ create _ host _ primary ( & sd py ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ is _ allocated ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int ▁* p num ) ▁{ ▁uint 64_ t ▁cluster _ offset ; ▁int ▁ret ; ▁* p num ▁= ▁nb _ sect ors ; ▁/* ▁FIX ME ▁We ▁can ▁get ▁errors ▁here , ▁but ▁the ▁b dr v _ is _ allocated ▁interface ▁can ' t ▁* ▁pass ▁them ▁on ▁today ▁*/ ▁ret ▁= ▁qc ow 2_ get _ cluster _ offset ( bs , ▁sector _ num ▁<< ▁9, ▁p num , ▁& cluster _ offset ); ▁if ▁( ret ▁< ▁0) ▁{ ▁* p num ▁= ▁0; ▁} ▁return ▁( cluster _ offset ▁!= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁migrate _ params _ test _ apply ( Mig rate Set Parameters ▁* params , ▁Migration Parameters ▁* dest ) ▁{ ▁* dest ▁= ▁migrate _ get _ current () -> parameters ; ▁/* ▁TODO ▁use ▁Q API _ CLO NE () ▁instead ▁of ▁duplic ating ▁it ▁inline ▁*/ ▁if ▁( params -> has _ compress _ level ) ▁{ ▁dest -> compress _ level ▁= ▁params -> compress _ level ; ▁} ▁if ▁( params -> has _ compress _ threads ) ▁{ ▁dest -> compress _ threads ▁= ▁params -> compress _ threads ; ▁} ▁if ▁( params -> has _ dec ompress _ t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ state _ reset ( CP UM IP S State ▁* env ) ▁{ ▁if ▁( q emu _ log level _ mask ( CPU _ LOG _ RE SET )) ▁{ ▁qemu _ log (" CPU ▁Reset ▁( CPU ▁% d )\ n ", ▁env -> cpu _ index ); ▁log _ cpu _ state ( env , ▁0); ▁} ▁mem set ( env , ▁0, ▁offset of ( CP UM IP S State , ▁breakpoints )); ▁tl b _ flush ( env , ▁1); ▁/* ▁Reset ▁registers ▁to ▁their ▁default ▁values ▁*/ ▁env -> CP 0_ PR id ▁= ▁env -> cpu _ model -> CP 0_ PR id ; ▁env -> CP 0_ Config 0 ▁= ▁env -> cpu _ model -> CP 0_ Config 0; ▁# if def ▁TA

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁b dr v _ op _ is _ blocked ( Block Driver State ▁* bs , ▁Block Op Type ▁op , ▁Error ▁** err p ) ▁{ ▁B dr v Op Block er ▁* block er ; ▁assert (( int ) ▁op ▁>= ▁0 ▁&& ▁op ▁< ▁BLOCK _ OP _ TYPE _ MAX ); ▁if ▁(! Q LIST _ EMPTY ( & bs -> op _ block ers [ op ])) ▁{ ▁block er ▁= ▁Q LIST _ FIRST ( & bs -> op _ block ers [ op ]); ▁if ▁( err p ) ▁{ ▁* err p ▁= ▁error _ copy ( block er -> reason ); ▁error _ prepend ( err p , ▁" Node ▁'% s ' ▁is ▁busy : ▁", ▁b dr v _ get _ device _ or _ node _ name ( bs )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block Job ▁* find _ block _ job ( const ▁char ▁* device , ▁A io Context ▁** a io _ context , ▁Error ▁** err p ) ▁{ ▁Block Backend ▁* blk ; ▁Block Driver State ▁* bs ; ▁* a io _ context ▁= ▁NULL ; ▁blk ▁= ▁blk _ by _ name ( device ); ▁if ▁(! blk ) ▁{ ▁goto ▁not found ; ▁} ▁* a io _ context ▁= ▁blk _ get _ a io _ context ( blk ); ▁aio _ context _ acquire (* a io _ context ); ▁if ▁(! blk _ is _ available ( blk )) ▁{ ▁goto ▁not found ; ▁} ▁bs ▁= ▁blk _ bs ( blk ); ▁if ▁(! bs -> job ) ▁{ ▁goto ▁not fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁bt _ h ci _ parse ( const ▁char ▁* str ) ▁{ ▁struct ▁H CI Info ▁* h ci ; ▁bd addr _ t ▁bd addr ; ▁if ▁( nb _ hc is ▁>= ▁MAX _ N IC S ) ▁{ ▁f printf ( stderr , ▁" q emu : ▁Too ▁many ▁bluetooth ▁H C Is ▁( max ▁% i ). \ n ", ▁MAX _ N IC S ); ▁return ▁-1; ▁} ▁h ci ▁= ▁h ci _ init ( str ); ▁if ▁(! h ci ) ▁return ▁-1; ▁bd addr . b [0] ▁= ▁0 x 52 ; ▁bd addr . b [1] ▁= ▁0 x 54 ; ▁bd addr . b [2] ▁= ▁0 x 00 ; ▁bd addr . b [3] ▁= ▁0 x 12 ; ▁bd addr . b [4] ▁= ▁0 x 34 ; ▁bd addr . b [5] ▁= ▁0 x 56 ▁+ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁cr is _ mm u _ translate _ page ( struct ▁cr is _ mm u _ result ▁* res , ▁CPU State ▁* env , ▁uint 32_ t ▁v addr , ▁int ▁rw , ▁int ▁user mode , ▁int ▁debug ) ▁{ ▁unsigned ▁int ▁v page ; ▁unsigned ▁int ▁idx ; ▁uint 32_ t ▁pid , ▁lo , ▁hi ; ▁uint 32_ t ▁tl b _ vpn , ▁tl b _ p fn ▁= ▁0; ▁int ▁tl b _ pid , ▁tl b _ g , ▁tl b _ v , ▁tl b _ k , ▁tl b _ w , ▁tl b _ x ; ▁int ▁cfg _ v , ▁cfg _ k , ▁cfg _ w , ▁cfg _ x ; ▁int ▁set , ▁match ▁= ▁0; ▁uint 32_ t ▁r _ cause ; ▁uint 32_ t ▁r _ cfg ; ▁int ▁rw 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ dst ( Dis as Context ▁* ctx ) ▁{ ▁if ▁( r A ( ctx -> op code ) ▁== ▁0) ▁{ ▁gen _ in val _ exception ( ctx , ▁PO WER PC _ EX CP _ IN VAL _ LS W X ); ▁} ▁else ▁{ ▁/* ▁interpreted ▁as ▁no - op ▁*/ ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁x 86_ cpu _ enable _ x save _ components ( X 86 CPU ▁* cpu ) ▁{ ▁CPU X 86 State ▁* env ▁= ▁& cpu -> env ; ▁int ▁i ; ▁if ▁(! ( env -> features [ FE AT _1_ EC X ] ▁& ▁CP UID _ EXT _ X SA VE )) ▁{ ▁return ; ▁} ▁env -> x save _ components ▁= ▁( X STATE _ FP _ MASK ▁| ▁X STATE _ SS E _ MASK ); ▁for ▁( i ▁= ▁2; ▁i ▁< ▁ARRAY _ SIZE ( x 86_ ext _ save _ areas ); ▁i ++) ▁{ ▁const ▁Ext Save Area ▁* es a ▁= ▁& x 86_ ext _ save _ areas [ i ]; ▁if ▁( env -> features [ es a -> feature ] ▁& ▁es a -> bits 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁mm u _ translate _ real ( CP US 390 X State ▁* env , ▁target _ ulong ▁r addr , ▁int ▁rw , ▁target _ ulong ▁* addr , ▁int ▁* flags ) ▁{ ▁/* ▁TODO : ▁low ▁address ▁protection ▁once ▁we ▁flush ▁the ▁tl b ▁on ▁cr ▁changes ▁*/ ▁* flags ▁= ▁PAGE _ READ ▁| ▁PAGE _ WRITE ; ▁* addr ▁= ▁mm u _ real 2 abs ( env , ▁r addr ); ▁/* ▁TODO : ▁storage ▁key ▁handling ▁*/ ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nic _ select ive _ reset ( EE PRO 100 State ▁* ▁s ) ▁{ ▁size _ t ▁i ; ▁uint 16_ t ▁* eep rom _ contents ▁= ▁e ep rom 93 xx _ data ( s -> eep rom ); ▁// ~ ▁e ep rom 93 xx _ reset ( s -> eep rom ); ▁mem c py ( eep rom _ contents , ▁s -> conf . mac addr . a , ▁6 ); ▁e ep rom _ contents [0 xa ] ▁= ▁0 x 4 000; ▁if ▁( s -> device ▁== ▁i 8 25 57 B ▁|| ▁s -> device ▁== ▁i 8 25 57 C ) ▁e ep rom _ contents [5] ▁= ▁0 x 0100 ; ▁uint 16_ t ▁sum ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁E EP ROM _ SIZE ▁- ▁1; ▁i ++

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pci _ bridge _ reset _ reg ( PC ID evice ▁* dev ) ▁{ ▁uint 8_ t ▁* conf ▁= ▁dev -> config ; ▁conf [ PC I _ PRI MARY _ B US ] ▁= ▁0; ▁conf [ PC I _ SECOND ARY _ B US ] ▁= ▁0; ▁conf [ PC I _ SUB ORD IN ATE _ B US ] ▁= ▁0; ▁conf [ PC I _ SEC _ LATE NCY _ T IMER ] ▁= ▁0; ▁conf [ PC I _ IO _ BASE ] ▁= ▁0; ▁conf [ PC I _ IO _ LIMIT ] ▁= ▁0; ▁pci _ set _ word ( conf ▁+ ▁P CI _ MEMORY _ BASE , ▁0); ▁pci _ set _ word ( conf ▁+ ▁P CI _ MEMORY _ LIMIT , ▁0); ▁pci _ set _ word ( conf ▁+ ▁P CI _ PRE F _ MEMORY 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm _ client _ sync _ dirty _ bitmap ( struct ▁CP UP h ys Memory Client ▁* client , ▁target _ ph ys _ addr _ t ▁start _ addr , ▁target _ ph ys _ addr _ t ▁end _ addr ) ▁{ ▁return ▁k vm _ ph ysical _ sync _ dirty _ bitmap ( start _ addr , ▁end _ addr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁b on ito _ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁P CI B on ito State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁s addr ; ▁s addr ▁= ▁( addr ▁- ▁B ON IT O _ RE GB ASE ) ▁>> ▁2; ▁D PRI NT F (" bon ito _ read l ▁" TARGET _ F MT _ pl x " ▁\ n ", ▁addr ); ▁switch ▁( s addr ) ▁{ ▁case ▁B ON IT O _ INT IS R : ▁return ▁s -> re gs [ s addr ]; ▁default : ▁return ▁s -> re gs [ s addr ]; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁struct ▁o map _ mp u _ state _ s ▁* om ap 3 10_ mp u _ init ( Memory Region ▁* system _ memory , ▁unsigned ▁long ▁sd ram _ size , ▁const ▁char ▁* core ) ▁{ ▁int ▁i ; ▁struct ▁o map _ mp u _ state _ s ▁* s ▁= ▁( struct ▁o map _ mp u _ state _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ mp u _ state _ s )); ▁qemu _ irq ▁d ma _ ir qs [6 ]; ▁Drive Info ▁* d info ; ▁Sys Bus Device ▁* bus dev ; ▁if ▁(! core ) ▁core ▁= ▁" ti 9 25 t "; ▁/* ▁Core ▁*/ ▁s -> mp u _ model ▁= ▁o map 3 10 ; ▁s -> cpu ▁= ▁cpu _ ar

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁nb d _ client _ close ( N BD Client ▁* client ) ▁{ ▁if ▁( client -> closing ) ▁{ ▁return ; ▁} ▁client -> closing ▁= ▁true ; ▁/* ▁Force ▁requests ▁to ▁finish . ▁They ▁will ▁drop ▁their ▁own ▁references , ▁* ▁then ▁we ' ll ▁close ▁the ▁socket ▁and ▁free ▁the ▁N BD Client . ▁*/ ▁shutdown ( client -> sock , ▁2); ▁/* ▁Also ▁tell ▁the ▁client , ▁so ▁that ▁they ▁release ▁their ▁reference . ▁*/ ▁if ▁( client -> close ) ▁{ ▁client -> close ( client ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁find _ dirty _ block ( RAM State ▁* rs , ▁Page Search Status ▁* p ss , ▁bool ▁* again , ▁ram _ addr _ t ▁* ram _ addr _ abs ) ▁{ ▁p ss -> offset ▁= ▁migration _ bitmap _ find _ dirty ( rs , ▁p ss -> block , ▁p ss -> offset , ▁ram _ addr _ abs ); ▁if ▁( p ss -> complete _ round ▁&& ▁p ss -> block ▁== ▁rs -> last _ seen _ block ▁&& ▁p ss -> offset ▁>= ▁rs -> last _ offset ) ▁{ ▁/* ▁* ▁We ' ve ▁been ▁once ▁around ▁the ▁RAM ▁and ▁haven ' t ▁found ▁anything . ▁* ▁Give ▁up . ▁*/ ▁* again ▁= ▁fals

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁OP PRO TO ▁op _ PO WER _ do z ▁( void ) ▁{ ▁if ▁( Ts 1 ▁> ▁T s 0) ▁T 0 ▁= ▁T 1 ▁- ▁T 0; ▁else ▁T 0 ▁= ▁0; ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ w mv 2_ decode _ secondary _ picture _ header ( M peg Enc Context ▁* s ) ▁{ ▁W mv 2 Context ▁* const ▁w ▁= ▁( W mv 2 Context ▁* ) ▁s ; ▁if ▁( s -> p ict _ type ▁== ▁AV _ PI CT URE _ TYPE _ I ) ▁{ ▁if ▁( w -> j _ type _ bit ) ▁w -> j _ type ▁= ▁get _ bits 1( & s -> gb ); ▁else ▁w -> j _ type ▁= ▁0; ▁// ▁FIX ME ▁check ▁if ▁(! w -> j _ type ) ▁{ ▁if ▁( w -> per _ mb _ rl _ bit ) ▁s -> per _ mb _ rl _ table ▁= ▁get _ bits 1( & s -> gb ); ▁else ▁s -> per _ mb _ rl _ table ▁= ▁0; ▁if ▁(! s -> per _ m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fill _ table ( uint 8_ t * ▁table [ 256 ▁+ ▁2* Y UV RGB _ TABLE _ HEAD RO OM ], ▁const ▁int ▁elem size , ▁const ▁int ▁inc , ▁void ▁* y _ tab ) ▁{ ▁int ▁i ; ▁uint 8_ t ▁* y _ table ▁= ▁y _ tab ; ▁y _ table ▁-= ▁elem size ▁* ▁( inc ▁>> ▁9 ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁256 ▁+ ▁2* Y UV RGB _ TABLE _ HEAD RO OM ; ▁i ++) ▁{ ▁int 64_ t ▁cb ▁= ▁av _ clip ( i - Y UV RGB _ TABLE _ HEAD RO OM , ▁0, ▁255 )* inc ; ▁table [ i ] ▁= ▁y _ table ▁+ ▁elem size ▁* ▁( cb ▁>> ▁16 ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁allocate _ buffers ( AL AC Context ▁* al ac ) ▁{ ▁int ▁ch ; ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁FF MIN ( al ac -> channels , ▁2); ▁ch ++) ▁{ ▁int ▁buf _ size ▁= ▁a la c -> max _ samples _ per _ frame ▁* ▁sizeof ( int 32_ t ); ▁FF _ AL LOC _ OR _ G OTO ( al ac -> av ctx , ▁a la c -> predict _ error _ buffer [ ch ], ▁buf _ size , ▁buf _ alloc _ fail ); ▁if ▁( al ac -> sample _ size ▁== ▁16 ) ▁{ ▁FF _ AL LOC _ OR _ G OTO ( al ac -> av ctx , ▁a la c -> output _ samples _ buffer [ ch ], ▁buf _ size , ▁buf 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁put _ cod ( J peg 2000 Encoder Context ▁* s ) ▁{ ▁J peg 2000 Coding Style ▁* cod st y ▁= ▁& s -> cod st y ; ▁if ▁( s -> buf _ end ▁- ▁s -> buf ▁< ▁14 ) ▁return ▁-1; ▁by test ream _ put _ be 16 ( & s -> buf , ▁JPEG 2000 _ CO D ); ▁by test ream _ put _ be 16 ( & s -> buf , ▁12 ); ▁// ▁L cod ▁by test ream _ put _ byte ( & s -> buf , ▁0); ▁// ▁S cod ▁// ▁S G cod ▁by test ream _ put _ byte ( & s -> buf , ▁0); ▁// ▁prog ression ▁level ▁by test ream _ put _ be 16 ( & s -> buf , ▁1); ▁// ▁num ▁of ▁l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁memory _ region _ test _ and _ clear _ dirty ( Memory Region ▁* mr , ▁hw addr ▁addr , ▁hw addr ▁size , ▁unsigned ▁client ) ▁{ ▁assert ( mr -> termin ates ); ▁return ▁cpu _ ph ysical _ memory _ test _ and _ clear _ dirty ( mr -> ram _ addr ▁+ ▁addr , ▁size , ▁client ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b dr v _ get _ cluster _ size ( Block Driver State ▁* bs ) ▁{ ▁Block Driver Info ▁b di ; ▁int ▁ret ; ▁ret ▁= ▁b dr v _ get _ info ( bs , ▁& bd i ); ▁if ▁( ret ▁< ▁0 ▁|| ▁b di . cluster _ size ▁== ▁0) ▁{ ▁return ▁bs -> request _ alignment ; ▁} ▁else ▁{ ▁return ▁b di . cluster _ size ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁libs ch ro ed inger _ encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* pk t , ▁const ▁AV Frame ▁* frame , ▁int ▁* got _ packet ) ▁{ ▁int ▁enc _ size ▁= ▁0; ▁S ch ro Encoder Params ▁* p _ sch ro _ params ▁= ▁av ctx -> priv _ data ; ▁S ch ro Encoder ▁* encoder ▁= ▁p _ sch ro _ params -> encoder ; ▁struct ▁F FS ch ro Encoded Frame ▁* p _ frame _ output ▁= ▁NULL ; ▁int ▁go ▁= ▁1; ▁S ch ro Buffer ▁* enc _ buf ; ▁int ▁presentation _ frame ; ▁int ▁parse _ code ; ▁int ▁last _ frame _ in _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁fill _ default _ ref _ list ( H 264 Context ▁* h ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁int ▁i ; ▁int ▁smallest _ p oc _ greater _ than _ current ▁= ▁-1; ▁int ▁structure _ sel ; ▁Picture ▁sorted _ short _ ref [ 32 ]; ▁Picture ▁field _ entry _ list [2 ][ 32 ]; ▁Picture ▁* frame _ list [2 ]; ▁if ▁( FIELD _ PI CT URE ) ▁{ ▁structure _ sel ▁= ▁PI CT _ FRAME ; ▁frame _ list [0] ▁= ▁field _ entry _ list [0]; ▁frame _ list [1] ▁= ▁field _ entry _ list [1]; ▁} ▁else ▁{ ▁structure _ sel ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ save vm _ state _ complete ( Q EM U File ▁* f ) ▁{ ▁Q JSON ▁* v md esc ; ▁int ▁v md esc _ len ; ▁Save State Entry ▁* se ; ▁int ▁ret ; ▁trace _ save vm _ state _ complete (); ▁cpu _ synchron ize _ all _ states (); ▁Q TAIL Q _ FORE A CH ( se , ▁& save vm _ state . handlers , ▁entry ) ▁{ ▁if ▁(! se -> ops ▁|| ▁! se -> ops -> save _ live _ complete ) ▁{ ▁continue ; ▁} ▁if ▁( se -> ops ▁&& ▁se -> ops -> is _ active ) ▁{ ▁if ▁(! se -> ops -> is _ active ( se -> op aque )) ▁{ ▁continue ; ▁} ▁} ▁tra

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mv p _ init ▁( CP UM IP S State ▁* env , ▁const ▁m ips _ def _ t ▁* def ) ▁{ ▁env -> m vp ▁= ▁g _ m alloc 0( size of ( CP UM IP SM VP Context )); ▁/* ▁M VP Conf 1 ▁implemented , ▁TL B ▁sh ar able , ▁no ▁g ating ▁storage ▁support , ▁programm able ▁cache ▁partition ing ▁implemented , ▁number ▁of ▁alloc atable ▁and ▁sh ar able ▁TL B ▁entries , ▁M VP ▁has ▁alloc atable ▁TC s , ▁2 ▁V PE s ▁implemented , ▁5 ▁TC s ▁implemented . ▁*/ ▁env -> m vp -> CP 0_ M VP Conf 0 ▁= ▁(1 ▁<< ▁CP 0 M V PC 0_ M ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ band ( I VI 45 Dec Context ▁* ctx , ▁int ▁plane _ num , ▁I VI Band Desc ▁* band , ▁AV Codec Context ▁* av ctx ) ▁{ ▁int ▁result , ▁i , ▁t , ▁idx 1, ▁idx 2, ▁pos ; ▁IV IT ile ▁* tile ; ▁band -> buf ▁= ▁band -> buf s [ ctx -> dst _ buf ]; ▁if ▁(! band -> buf ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Band ▁buffer ▁points ▁to ▁no ▁data ! \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁band -> ref _ buf ▁= ▁band -> buf s [ ctx -> ref _ buf ]; ▁band -> data _ ptr ▁= ▁ctx -> fram

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁s 39 0_ virt io _ device _ init ( V irt IOS 390 Device ▁* dev , ▁V irt IO Device ▁* v dev ) ▁{ ▁V irt IOS 390 Bus ▁* bus ; ▁int ▁dev _ len ; ▁bus ▁= ▁DO _ UP CAST ( V irt IOS 390 Bus , ▁bus , ▁dev -> q dev . parent _ bus ); ▁dev -> v dev ▁= ▁v dev ; ▁dev -> dev _ off s ▁= ▁bus -> dev _ off s ; ▁dev -> feat _ len ▁= ▁sizeof ( uint 32_ t ); ▁/* ▁always ▁keep ▁32 ▁bits ▁features ▁*/ ▁dev _ len ▁= ▁VI RT IO _ DEV _ OFF S _ CONFIG ; ▁dev _ len ▁+= ▁s 39 0_ virt io _ device _ num _ v q ( dev ) ▁* 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁RAM Block ▁* q emu _ ram _ alloc _ internal ( ram _ addr _ t ▁size , ▁ram _ addr _ t ▁max _ size , ▁void ▁(* res ized )( const ▁char *, ▁uint 64_ t ▁length , ▁void ▁* host ), ▁void ▁* host , ▁bool ▁resize able , ▁Memory Region ▁* mr , ▁Error ▁** err p ) ▁{ ▁RAM Block ▁* new _ block ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁size ▁= ▁HOST _ PAGE _ ALIGN ( size ); ▁max _ size ▁= ▁HOST _ PAGE _ ALIGN ( max _ size ); ▁new _ block ▁= ▁g _ m alloc 0( size of (* new _ block )); ▁new _ block -> mr ▁= ▁mr ; ▁new _ block

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁tc g _ out _ mov i ( TC G Context ▁* s , ▁TC G Type ▁type , ▁int ▁ret , ▁tc g _ target _ long ▁arg ) ▁{ ▁# if ▁defined (__ s par c _ v 9 __) ▁&& ▁! defined (__ s par c _ v 8 plus __) ▁if ▁( arg ▁!= ▁( arg ▁& ▁0 xffffffff )) ▁f printf ( stderr , ▁" un implemented ▁% s ▁with ▁constant ▁% ld \ n ", ▁__ func __, ▁arg ); ▁# end if ▁if ▁( arg ▁== ▁( arg ▁& ▁0 xff f )) ▁tc g _ out 32 ( s , ▁AR ITH _ OR ▁| ▁IN SN _ RD ( ret ) ▁| ▁IN SN _ RS 1( TC G _ REG _ G 0) ▁| ▁IN SN _ IM M 13 ( arg ));

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁q crypto _ block _ lu ks _ create ( Q Crypto Block ▁* block , ▁Q Crypto Block Create Options ▁* options , ▁Q Crypto Block Init Func ▁init func , ▁Q Crypto Block Write Func ▁writ ef unc , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁Q Crypto Block LU KS ▁* lu ks ; ▁Q Crypto Block Create Options LU KS ▁lu ks _ opts ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁uint 8_ t ▁* master key ▁= ▁NULL ; ▁uint 8_ t ▁* slot key ▁= ▁NULL ; ▁uint 8_ t ▁* split key ▁= ▁NULL ; ▁size _ t ▁split key len ▁= ▁0; ▁size _ t ▁i ; ▁Q Crypto 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁swf _ write _ trail er ( AV Format Context ▁* s ) ▁{ ▁SW F Context ▁* sw f ▁= ▁s -> priv _ data ; ▁Byte IO Context ▁* pb ▁= ▁& s -> pb ; ▁AV Codec Context ▁* enc , ▁* video _ enc ; ▁int ▁file _ size , ▁i ; ▁video _ enc ▁= ▁NULL ; ▁for ( i =0; i < s -> nb _ streams ; i ++) ▁{ ▁enc ▁= ▁& s -> streams [ i ] -> codec ; ▁if ▁( enc -> codec _ type ▁== ▁CODE C _ TYPE _ VI DEO ) ▁video _ enc ▁= ▁enc ; ▁} ▁put _ sw f _ tag ( s , ▁TAG _ END ); ▁put _ sw f _ end _ tag ( s ); ▁put _ flush _ packet ( & s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁x pm _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁X PM Dec Context ▁* x ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* p = data ; ▁const ▁uint 8_ t ▁* end , ▁* ptr ▁= ▁av pk t -> data ; ▁int ▁n colors , ▁cpp , ▁ret , ▁i , ▁j ; ▁int 64_ t ▁size ; ▁uint 32_ t ▁* dst ; ▁av ctx -> pix _ fmt ▁= ▁AV _ PI X _ F MT _ B GRA ; ▁end ▁= ▁av pk t -> data ▁+ ▁av pk t -> size ; ▁while ▁( mem cmp ( ptr , ▁"/ * ▁X PM ▁*/ \ n ", ▁10) ▁&& ▁ptr ▁< ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ri pem d 16 0_ transform ( uint 32_ t ▁* state , ▁const ▁uint 8_ t ▁buffer [ 64 ], ▁int ▁ext ) ▁{ ▁uint 32_ t ▁a , ▁b , ▁c , ▁d , ▁e , ▁f , ▁g , ▁h , ▁i , ▁j ; ▁uint 32_ t ▁block [ 16 ]; ▁int ▁n ; ▁if ▁( ext ) ▁{ ▁a ▁= ▁state [0]; ▁b ▁= ▁state [1]; ▁c ▁= ▁state [2 ]; ▁d ▁= ▁state [3 ]; ▁e ▁= ▁state [4 ]; ▁f ▁= ▁state [5 ]; ▁g ▁= ▁state [6 ]; ▁h ▁= ▁state [ 7 ]; ▁i ▁= ▁state [ 8 ]; ▁j ▁= ▁state [ 9 ]; ▁} ▁else ▁{ ▁a ▁= ▁f ▁= ▁state [0]; ▁b ▁= ▁g ▁= ▁state [1]; ▁c ▁= ▁h ▁= ▁state [2 ]; ▁d ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁opt _ frame _ size ( const ▁char ▁* arg ) ▁{ ▁if ▁( av _ parse _ video _ frame _ size ( & frame _ width , ▁& frame _ height , ▁arg ) ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" In correct ▁frame ▁size \ n "); ▁av _ exit (1); ▁} ▁if ▁(( frame _ width ▁% ▁2) ▁!= ▁0 ▁|| ▁( frame _ height ▁% ▁2) ▁!= ▁0) ▁{ ▁f printf ( stderr , ▁" Frame ▁size ▁must ▁be ▁a ▁multiple ▁of ▁2 \ n "); ▁av _ exit (1); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sd l _ write _ trail er ( AV Format Context ▁* s ) ▁{ ▁SDL Context ▁* sdl ▁= ▁s -> priv _ data ; ▁sd l -> quit ▁= ▁1; ▁if ▁( sdl -> overlay ) ▁SDL _ Free Y UV Overlay ( sdl -> overlay ); ▁if ▁( sdl -> event _ thread ) ▁SDL _ Wait Thread ( sdl -> event _ thread , ▁NULL ); ▁if ▁( sdl -> mut ex ) ▁SDL _ Destroy Mut ex ( sdl -> mut ex ); ▁if ▁( sdl -> init _ cond ) ▁SDL _ Destroy Cond ( sdl -> init _ cond ); ▁if ▁(! sdl -> sdl _ was _ already _ init ed ) ▁SDL _ Quit (); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁MP V _ decode _ mb ( M peg Enc Context ▁* s , ▁D CT E LE M ▁block [6 ][ 64 ]) ▁{ ▁int ▁mb _ x , ▁mb _ y ; ▁int ▁dct _ lines ize , ▁dct _ offset ; ▁op _ pixels _ func ▁* op _ pix ; ▁qp el _ mc _ func ▁* op _ qp ix ; ▁mb _ x ▁= ▁s -> mb _ x ; ▁mb _ y ▁= ▁s -> mb _ y ; ▁# if def ▁FF _ POST PROCESS ▁quant _ store [ mb _ y ][ mb _ x ]= s -> q scale ; ▁// printf ("[ % 02 d ][ % 02 d ] ▁% d \ n ", mb _ x , mb _ y , s -> q scale ); ▁# end if ▁/* ▁update ▁DC ▁predict ors ▁for ▁P ▁macro blocks ▁*/ ▁if ▁(! s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ hw po ison _ page _ add ( ram _ addr _ t ▁ram _ addr ) ▁{ ▁H WP o ison Page ▁* page ; ▁Q LIST _ FORE A CH ( page , ▁& hw po ison _ page _ list , ▁list ) ▁{ ▁if ▁( page -> ram _ addr ▁== ▁ram _ addr ) ▁{ ▁return ; ▁} ▁} ▁page ▁= ▁g _ m alloc ( size of ( H WP o ison Page )); ▁page -> ram _ addr ▁= ▁ram _ addr ; ▁Q LIST _ INSERT _ HEAD ( & hw po ison _ page _ list , ▁page , ▁list ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ i _ picture _ primary _ header ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁int ▁pq index ; ▁/* ▁Pro log ▁common ▁to ▁all ▁fram etypes ▁should ▁be ▁done ▁in ▁caller ▁*/ ▁// BF ▁= ▁Buffer ▁Full ness ▁if ▁( v -> profile ▁<= ▁PROFILE _ MAIN ▁&& ▁get _ bits ( gb , ▁7 )) ▁{ ▁av _ log ( v -> s . av ctx , ▁AV _ LOG _ DEBUG , ▁" I ▁Buffer Full ness ▁not ▁0 \ n "); ▁} ▁/* ▁Quant izer ▁stuff ▁*/ ▁pq index ▁= ▁get _ bits ( gb , ▁5 ); ▁if ▁( v -> quant izer _ mode ▁== ▁Q

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc ie _ mm cfg _ data _ write ( PC I Bus ▁* s , ▁uint 32_ t ▁mm cfg _ addr , ▁uint 32_ t ▁val , ▁int ▁len ) ▁{ ▁PC ID evice ▁* pc i _ dev ▁= ▁pc ie _ dev _ find _ by _ mm cfg _ addr ( s , ▁mm cfg _ addr ); ▁if ▁(! pc i _ dev ) ▁{ ▁return ; ▁} ▁pci _ host _ config _ write _ common ( pc i _ dev , ▁P CI E _ MM CF G _ CON FO FF SET ( mm cfg _ addr ), ▁pci _ config _ size ( pc i _ dev ), ▁val , ▁len ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ bits ( J peg 2000 Decoder Context ▁* s , ▁int ▁n ) ▁{ ▁int ▁res ▁= ▁0; ▁if ▁( s -> buf _ end ▁- ▁s -> buf ▁< ▁(( n ▁- ▁s -> bit _ index ) ▁>> ▁8 )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁while ▁( -- n ▁>= ▁0) ▁{ ▁res ▁<<= ▁1; ▁if ▁( s -> bit _ index ▁== ▁0) ▁{ ▁s -> bit _ index ▁= ▁7 ▁+ ▁(* s -> buf ▁!= ▁0 xff ); ▁s -> buf ++; ▁} ▁s -> bit _ index --; ▁res ▁|= ▁(* s -> buf ▁>> ▁s -> bit _ index ) ▁& ▁1; ▁} ▁return ▁res ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ ud ta _ string ( MO V Context ▁* c , ▁Byte IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁char ▁* str ▁= ▁NULL ; ▁int ▁size ; ▁uint 16_ t ▁str _ size ; ▁if ▁( c -> it unes _ metadata ) ▁{ ▁int ▁data _ size ▁= ▁get _ be 32 ( pb ); ▁int ▁tag ▁= ▁get _ le 32 ( pb ); ▁if ▁( tag ▁== ▁M K TAG (' d ',' a ',' t ',' a ')) ▁{ ▁get _ be 32 ( pb ); ▁// ▁type ▁get _ be 32 ( pb ); ▁// ▁unknown ▁str _ size ▁= ▁data _ size ▁- ▁16 ; ▁} ▁else ▁return ▁0; ▁} ▁else ▁{ ▁str _ size ▁= ▁get _ be 16 ( pb );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁aio _ context _ setup ( A io Context ▁* ctx , ▁Error ▁** err p ) ▁{ ▁# if def ▁CONFIG _ EP OLL ▁assert (! ctx -> ep oll fd ); ▁ctx -> ep oll fd ▁= ▁e poll _ create 1( EP OLL _ CLO EXEC ); ▁if ▁( ctx -> ep oll fd ▁== ▁-1) ▁{ ▁ctx -> ep oll _ available ▁= ▁false ; ▁} ▁else ▁{ ▁ctx -> ep oll _ available ▁= ▁true ; ▁} ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dv b sub _ display _ end _ segment ( AV Codec Context ▁* av ctx , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁AV Sub title ▁* sub ) ▁{ ▁D VB Sub Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁D VB Sub Display Definition ▁* display _ def ▁= ▁ctx -> display _ definition ; ▁D VB Sub Region ▁* region ; ▁D VB Sub Region Display ▁* display ; ▁AV Sub title Rect ▁* rect ; ▁D VB Sub CL UT ▁* cl ut ; ▁uint 32_ t ▁* cl ut _ table ; ▁int ▁i ; ▁int ▁offset _ x =0, ▁offset _ y =0; ▁sub -> rect s ▁= ▁NULL 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁QU ANT _ FN ( pv q _ encode _ band ) ▁{ ▁return ▁quant _ band _ template ( pv q , ▁f , ▁rc , ▁band , ▁X , ▁Y , ▁N , ▁b , ▁blocks , ▁low band , ▁duration , ▁low band _ out , ▁level , ▁gain , ▁low band _ scr atch , ▁fill , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ set _ ph ys _ mem ( target _ ph ys _ addr _ t ▁start _ addr , ▁ram _ addr _ t ▁size , ▁ram _ addr _ t ▁phys _ offset ) ▁{ ▁K VM State ▁* s ▁= ▁k vm _ state ; ▁ram _ addr _ t ▁flags ▁= ▁phys _ offset ▁& ▁~ TARGET _ PAGE _ MASK ; ▁KV MS lot ▁* mem , ▁old ; ▁int ▁err ; ▁/* ▁k vm ▁works ▁in ▁page ▁size ▁chunks , ▁but ▁the ▁function ▁may ▁be ▁called ▁with ▁sub - page ▁size ▁and ▁un aligned ▁start ▁address . ▁*/ ▁size ▁= ▁TARGET _ PAGE _ ALIGN ( size ); ▁start _ addr ▁= ▁TARGET _ PAGE _ AL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁master _ abort _ mem _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁av codec _ align _ dimensions ( AV Codec Context ▁* s , ▁int ▁* width , ▁int ▁* height ){ ▁int ▁w _ align = ▁1; ▁int ▁h _ align = ▁1; ▁switch ( s -> pix _ fmt ){ ▁case ▁PI X _ F MT _ Y UV 4 20 P : ▁case ▁PI X _ F MT _ Y U Y V 4 22 : ▁case ▁PI X _ F MT _ U Y V Y 4 22 : ▁case ▁PI X _ F MT _ Y UV 4 22 P : ▁case ▁PI X _ F MT _ Y UV 444 P : ▁case ▁PI X _ F MT _ GRAY 8: ▁case ▁PI X _ F MT _ GRAY 16 BE : ▁case ▁PI X _ F MT _ GRAY 16 LE : ▁case ▁PI X _ F MT _ Y UV J 4 20 P : ▁case ▁PI X _ F MT _ Y UV J 4 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ init _ c ab ac _ decoder ( C AB AC Context ▁* c , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ){ ▁c -> by test ream _ start = ▁c -> by test ream = ▁buf ; ▁c -> by test ream _ end = ▁buf ▁+ ▁buf _ size ; ▁# if ▁C AB AC _ BITS ▁== ▁16 ▁c -> low ▁= ▁(* c -> by test ream ++) << 18 ; ▁c -> low += ▁(* c -> by test ream ++) << 10 ; ▁# else ▁c -> low ▁= ▁(* c -> by test ream ++) << 10 ; ▁# end if ▁c -> low += ▁(( * c -> by test ream ++) << 2) ▁+ ▁2; ▁c -> range = ▁0 x 1 FE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h ls _ read _ header ( AV Format Context ▁* s ) ▁{ ▁void ▁* u ▁= ▁( s -> flags ▁& ▁AV F MT _ FLAG _ CUSTOM _ IO ) ▁? ▁NULL ▁: ▁s -> pb ; ▁H LS Context ▁* c ▁= ▁s -> priv _ data ; ▁int ▁ret ▁= ▁0, ▁i ; ▁int ▁highest _ cur _ seq _ no ▁= ▁0; ▁c -> ctx ▁= ▁s ; ▁c -> interrupt _ callback ▁= ▁& s -> interrupt _ callback ; ▁c -> strict _ std _ compl iance ▁= ▁s -> strict _ std _ compl iance ; ▁c -> first _ packet ▁= ▁1; ▁c -> first _ timestamp ▁= ▁AV _ NO PT S _ VALUE ; ▁c -> cur _ timestamp ▁= ▁AV

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV Bit Stream Filter Context ▁* av _ bit stream _ filter _ init ( const ▁char ▁* name ) ▁{ ▁AV Bit Stream Filter ▁* bs f ▁= ▁first _ bit stream _ filter ; ▁while ▁( bs f ) ▁{ ▁if ▁(! str cmp ( name , ▁bs f -> name )) ▁{ ▁AV Bit Stream Filter Context ▁* bs fc ▁= ▁av _ m alloc z ( size of ( AV Bit Stream Filter Context )); ▁bs fc -> filter ▁= ▁bs f ; ▁bs fc -> priv _ data ▁= ▁bs f -> priv _ data _ size ▁? ▁av _ m alloc z ( bs f -> priv _ data _ size ) ▁: ▁NULL ; ▁return ▁bs fc ; ▁} ▁bs f ▁= ▁bs f -> next ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( div w ) ▁{ ▁if ▁(( Ts 0 ▁== ▁INT 32_ MIN ▁&& ▁T s 1 ▁== ▁-1) ▁|| ▁T s 1 ▁== ▁0) ▁{ ▁T 0 ▁= ▁( int 32_ t ) (( -1) ▁* ▁( T 0 ▁>> ▁3 1) ); ▁} ▁else ▁{ ▁T 0 ▁= ▁( Ts 0 ▁/ ▁T s 1); ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Interface Error Action ▁drive _ get _ on error ( Block Driver State ▁* b dr v ) ▁{ ▁int ▁index ; ▁for ▁( index ▁= ▁0; ▁index ▁< ▁nb _ d rives ; ▁index ++) ▁if ▁( d rives _ table [ index ]. b dr v ▁== ▁b dr v ) ▁return ▁d rives _ table [ index ]. on error ; ▁return ▁BLOCK _ ERR _ REPORT ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁net filter _ final ize ( Object ▁* obj ) ▁{ ▁Net Filter State ▁* nf ▁= ▁NET FILTER ( obj ); ▁Net Filter Class ▁* n fc ▁= ▁NET FILTER _ GET _ CLASS ( obj ); ▁if ▁( n fc -> cleanup ) ▁{ ▁n fc -> cleanup ( nf ); ▁} ▁if ▁( nf -> net dev ▁&& ▁! Q TAIL Q _ EMPTY ( & nf -> net dev -> filters )) ▁{ ▁Q TAIL Q _ REMOVE ( & nf -> net dev -> filters , ▁nf , ▁next ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ compat _1 _4 ( Q EM UM achine Init Args ▁* args ) ▁{ ▁pc _ compat _1_ 5 ( args ); ▁has _ pv pan ic ▁= ▁false ; ▁x 86_ cpu _ compat _ set _ features (" n 270 ", ▁FE AT _1_ EC X , ▁0, ▁CP UID _ EXT _ MO V BE ); ▁x 86_ cpu _ compat _ set _ features (" W est m ere ", ▁FE AT _1_ EC X , ▁0, ▁CP UID _ EXT _ PC LM UL Q D Q ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁amd vi _ real ize ( Device State ▁* dev , ▁Error ▁** err ) ▁{ ▁int ▁ret ▁= ▁0; ▁AMD VI State ▁* s ▁= ▁AMD _ I OM MU _ DEVICE ( dev ); ▁X 86 I OM MU State ▁* x 86_ iom mu ▁= ▁X 86_ I OM MU _ DEVICE ( dev ); ▁P CI Bus ▁* bus ▁= ▁PC _ MA CHINE ( q dev _ get _ machine ()) -> bus ; ▁s -> iot lb ▁= ▁g _ hash _ table _ new _ full ( amd vi _ uint 64_ hash , ▁amd vi _ uint 64_ equal , ▁g _ free , ▁g _ free ); ▁/* ▁This ▁device ▁should ▁take ▁care ▁of ▁IO MM U ▁P CI ▁properties ▁*/ ▁x 86_ iom mu -> t

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av io _ close _ dyn _ buf ( AV IO Context ▁* s , ▁uint 8_ t ▁** p buffer ) ▁{ ▁Dyn Buffer ▁* d ▁= ▁s -> op aque ; ▁int ▁size ; ▁static ▁const ▁char ▁pad buf [ FF _ INPUT _ BUFFER _ P ADDING _ SIZE ] ▁= ▁{0 }; ▁int ▁padding ▁= ▁0; ▁if ▁(! s ) ▁{ ▁* p buffer ▁= ▁NULL ; ▁return ▁0; ▁} ▁/* ▁don ' t ▁attempt ▁to ▁pad ▁fixed - size ▁packet ▁buffers ▁*/ ▁if ▁(! s -> max _ packet _ size ) ▁{ ▁av io _ write ( s , ▁pad buf , ▁sizeof ( pad buf )); ▁padding ▁= ▁FF _ INPUT _ BUFFER _ P ADDING _ SIZE ; ▁} ▁av io 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ net _ queue _ append ( Net Queue ▁* queue , ▁Net Client State ▁* sender , ▁unsigned ▁flags , ▁const ▁uint 8_ t ▁* buf , ▁size _ t ▁size , ▁Net Packet Sent ▁* sent _ cb ) ▁{ ▁Net Packet ▁* packet ; ▁if ▁( queue -> n q _ count ▁>= ▁queue -> n q _ max len ▁&& ▁! sent _ cb ) ▁{ ▁return ; ▁/* ▁drop ▁if ▁queue ▁full ▁and ▁no ▁callback ▁*/ ▁} ▁packet ▁= ▁g _ m alloc ( size of ( Net Packet ) ▁+ ▁size ); ▁packet -> sender ▁= ▁sender ; ▁packet -> flags ▁= ▁flags ; ▁packet -> size ▁= ▁size ; ▁p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ sub frame _ l pc ( Short en Context ▁* s , ▁int ▁channel , ▁int ▁residual _ size , ▁int ▁pred _ order ) ▁{ ▁int ▁sum , ▁i , ▁j ; ▁int ▁coeffs [ pred _ order ]; ▁for ▁( i =0; ▁i < pred _ order ; ▁i ++) ▁coeffs [ i ] ▁= ▁get _ sr _ g ol omb _ short en ( & s -> gb , ▁L PC QU ANT ); ▁for ▁( i =0; ▁i ▁< ▁s -> block size ; ▁i ++) ▁{ ▁sum ▁= ▁s -> l pc q offset ; ▁for ▁( j =0; ▁j < pred _ order ; ▁j ++) ▁sum ▁+= ▁coeffs [ j ] ▁* ▁s -> decoded [ channel ][ i - j -1 ]; ▁s -> decoded [ chann

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁timer list _ expired ( Q EM UT imer List ▁* timer _ list ) ▁{ ▁int 64_ t ▁expire _ time ; ▁if ▁(! atomic _ read ( & timer _ list -> active _ tim ers )) ▁{ ▁return ▁false ; ▁} ▁qemu _ mut ex _ lock ( & timer _ list -> active _ tim ers _ lock ); ▁if ▁(! timer _ list -> active _ tim ers ) ▁{ ▁qemu _ mut ex _ un lock ( & timer _ list -> active _ tim ers _ lock ); ▁return ▁false ; ▁} ▁expire _ time ▁= ▁timer _ list -> active _ tim ers -> expire _ time ; ▁qemu _ mut ex _ un lock ( & timer _ list -> activ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁px r 24 _ un compress ( EX R Context ▁* s , ▁const ▁uint 8_ t ▁* src , ▁int ▁compressed _ size , ▁int ▁uncompressed _ size , ▁EX R Thread Data ▁* td ) ▁{ ▁unsigned ▁long ▁dest _ len , ▁expected _ len ▁= ▁0; ▁const ▁uint 8_ t ▁* in ▁= ▁td -> tmp ; ▁uint 8_ t ▁* out ; ▁int ▁c , ▁i , ▁j ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> nb _ channels ; ▁i ++) ▁{ ▁if ▁( s -> channels [ i ]. pixel _ type ▁== ▁EX R _ FLOAT ) ▁{ ▁expected _ len ▁+= ▁( td -> x size ▁* ▁td -> y size ▁* ▁3 ); /* ▁PR X ▁24 ▁store ▁float ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ default ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁int 64_ t ▁total _ size ▁= ▁0; ▁MO V Atom ▁a ; ▁int ▁i ; ▁if ▁( atom . size ▁< ▁0) ▁atom . size ▁= ▁INT 64_ MAX ; ▁while ▁( total _ size ▁+ ▁8 ▁<= ▁atom . size ▁&& ▁! av io _ fe of ( pb )) ▁{ ▁int ▁(* parse )( MO V Context *, ▁AV IO Context *, ▁MO V Atom ) ▁= ▁NULL ; ▁a . size ▁= ▁atom . size ; ▁a . type =0; ▁if ▁( atom . size ▁>= ▁8) ▁{ ▁a . size ▁= ▁av io _ rb 32 ( pb ); ▁a . type ▁= ▁av io _ rl 32 ( p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ah ci _ populate _ sg list ( A H C ID evice ▁* ad , ▁Q EM US G List ▁* sg list , ▁A H C IC md H dr ▁* cmd , ▁int 64_ t ▁limit , ▁int 32_ t ▁offset ) ▁{ ▁uint 16_ t ▁opts ▁= ▁le 16_ to _ cpu ( cmd -> opts ); ▁uint 16_ t ▁pr dt l ▁= ▁le 16_ to _ cpu ( cmd -> pr dt l ); ▁uint 64_ t ▁cf is _ addr ▁= ▁le 64_ to _ cpu ( cmd -> tbl _ addr ); ▁uint 64_ t ▁pr dt _ addr ▁= ▁cf is _ addr ▁+ ▁0 x 80 ; ▁d ma _ addr _ t ▁pr dt _ len ▁= ▁( pr dt l ▁* ▁sizeof ( A H CI _ S G )); ▁d ma _ addr _ t ▁real _ pr d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁d wt _ encode 97 _ int ( D WT Context ▁* s , ▁int ▁* t ) ▁{ ▁int ▁lev , ▁w ▁= ▁s -> lin elen [ s -> nd ec levels -1] [0]; ▁int ▁* line ▁= ▁s -> i _ line buf ; ▁line ▁+= ▁5; ▁for ▁( le v ▁= ▁s -> nd ec levels -1; ▁lev ▁>= ▁0; ▁lev -- ){ ▁int ▁lh ▁= ▁s -> lin elen [ le v ] [0], ▁lv ▁= ▁s -> lin elen [ le v ] [1], ▁mh ▁= ▁s -> mod [ le v ] [0], ▁mv ▁= ▁s -> mod [ le v ] [1], ▁lp ; ▁int ▁* l ; ▁// ▁VER _ SD ▁l ▁= ▁line ▁+ ▁mv ; ▁for ▁( lp ▁= ▁0; ▁lp ▁< ▁lh ; ▁lp ++) ▁{ ▁int ▁i , ▁j ▁= ▁0; ▁for 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ post init ( H 264 Context ▁* h ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁Picture ▁* out ▁= ▁s -> current _ picture _ ptr ; ▁Picture ▁* cur ▁= ▁s -> current _ picture _ ptr ; ▁int ▁i , ▁p ics , ▁out _ of _ order , ▁out _ idx ; ▁s -> current _ picture _ ptr -> q scale _ type = ▁FF _ Q SCALE _ TYPE _ H 264 ; ▁s -> current _ picture _ ptr -> p ict _ type = ▁s -> p ict _ type ; ▁if ▁( h -> next _ output _ pic ) ▁return ; ▁if ▁( cur -> field _ p oc [0] == INT _ MAX ▁|| ▁cur -> f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁error _ propag ate ( Error ▁** dst _ err p , ▁Error ▁* local _ err ) ▁{ ▁if ▁( local _ err ▁&& ▁dst _ err p ▁== ▁& error _ abort ) ▁{ ▁error _ report _ err ( local _ err ); ▁abort (); ▁} ▁else ▁if ▁( dst _ err p ▁&& ▁! * dst _ err p ) ▁{ ▁* dst _ err p ▁= ▁local _ err ; ▁} ▁else ▁if ▁( local _ err ) ▁{ ▁error _ free ( local _ err ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁gen _ m sub 32_ q ( TC G v ▁ret , ▁TC G v ▁arg 1, ▁TC G v ▁arg 2, ▁TC G v ▁arg 3, ▁uint 32_ t ▁n , ▁uint 32_ t ▁up _ shift , ▁C PUT ri Core State ▁* env ) ▁{ ▁TC G v ▁temp ▁= ▁tc g _ temp _ new (); ▁TC G v ▁temp 2 ▁= ▁tc g _ temp _ new (); ▁TC G v ▁temp 3 ▁= ▁tc g _ temp _ new (); ▁TC G v _ i 64 ▁t 1 ▁= ▁tc g _ temp _ new _ i 64 (); ▁TC G v _ i 64 ▁t 2 ▁= ▁tc g _ temp _ new _ i 64 (); ▁TC G v _ i 64 ▁t 3 ▁= ▁tc g _ temp _ new _ i 64 (); ▁TC G v _ i 64 ▁t 4 ▁= ▁tc g _ temp _ new _ i 64 (); ▁tc g _ gen _ e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int 32 ▁float 64_ to _ int 32_ round _ to _ zero ( ▁float 64 ▁a ▁STATUS _ PARAM ▁) ▁{ ▁flag ▁a Sign ; ▁int 16 ▁a Exp , ▁shift Count ; ▁uint 64_ t ▁a Sig , ▁saved AS ig ; ▁int 32 ▁z ; ▁a ▁= ▁float 64_ s qu ash _ input _ den ormal ( a ▁STATUS _ VAR ); ▁a Sig ▁= ▁extract Float 64 F rac ( ▁a ▁); ▁a Exp ▁= ▁extract Float 64 Exp ( ▁a ▁); ▁a Sign ▁= ▁extract Float 64 Sign ( ▁a ▁); ▁if ▁( ▁0 x 41 E ▁< ▁a Exp ▁) ▁{ ▁if ▁( ▁( ▁a Exp ▁== ▁0 x 7 FF ▁) ▁&& ▁a Sig ▁) ▁a Sign ▁= ▁0; ▁goto ▁invalid ; ▁} ▁else ▁if ▁( ▁a 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Re open Queue ▁* b dr v _ re open _ queue ( Block Re open Queue ▁* bs _ queue , ▁Block Driver State ▁* bs , ▁int ▁flags ) ▁{ ▁assert ( bs ▁!= ▁NULL ); ▁Block Re open Queue Entry ▁* bs _ entry ; ▁if ▁( bs _ queue ▁== ▁NULL ) ▁{ ▁bs _ queue ▁= ▁g _ new 0( Block Re open Queue , ▁1); ▁Q SI MPLE Q _ INIT ( bs _ queue ); ▁} ▁/* ▁b dr v _ open () ▁masks ▁this ▁flag ▁out ▁*/ ▁flags ▁&= ▁~ B DR V _ O _ PROTOCOL ; ▁if ▁( bs -> file ) ▁{ ▁b dr v _ re open _ queue ( bs _ queue , ▁bs -> file , ▁b dr v _ inherit

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁format _ line ( void ▁* ptr , ▁int ▁level , ▁const ▁char ▁* fmt , ▁va _ list ▁vl , ▁AV B Print ▁part [3 ], ▁int ▁* print _ prefix , ▁int ▁type [2]) ▁{ ▁AV Class * ▁av c ▁= ▁ptr ▁? ▁* ( AV Class ▁** ) ▁ptr ▁: ▁NULL ; ▁av _ b print _ init ( part + 0, ▁0, ▁1); ▁av _ b print _ init ( part +1, ▁0, ▁1); ▁av _ b print _ init ( part + 2, ▁0, ▁65536 ); ▁if ( type ) ▁type [0] ▁= ▁type [1] ▁= ▁AV _ CLASS _ CATEGORY _ NA ▁+ ▁16 ; ▁if ▁(* print _ prefix ▁&& ▁av c ) ▁{ ▁if ▁( av c -> parent _ log _ conte

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dn x hd _ init _ vlc ( DN X HD Context ▁* ctx , ▁uint 32_ t ▁cid ) ▁{ ▁if ▁( cid ▁!= ▁ctx -> cid ) ▁{ ▁int ▁index ; ▁if ▁(( index ▁= ▁ff _ dn x hd _ get _ cid _ table ( cid )) ▁< ▁0) ▁{ ▁av _ log ( ctx -> av ctx , ▁AV _ LOG _ ERROR , ▁" unsupported ▁cid ▁% d \ n ", ▁cid ); ▁return ▁A VER ROR ( EN OS Y S ); ▁} ▁if ▁( ff _ dn x hd _ cid _ table [ index ]. bit _ depth ▁!= ▁ctx -> bit _ depth ) ▁{ ▁av _ log ( ctx -> av ctx , ▁AV _ LOG _ ERROR , ▁" bit ▁depth ▁mis matches ▁% d ▁% d \ n ", ▁ff _ d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁check _ default _ settings ( AV Codec Context ▁* av ctx ) ▁{ ▁X 264 Context ▁* x 4 ▁= ▁av ctx -> priv _ data ; ▁int ▁score ▁= ▁0; ▁score ▁+= ▁x 4 -> params . analy se . i _ me _ range ▁== ▁0; ▁score ▁+= ▁x 4 -> params . rc . i _ qp _ step ▁== ▁3; ▁score ▁+= ▁x 4 -> params . i _ key int _ max ▁== ▁12 ; ▁score ▁+= ▁x 4 -> params . rc . i _ qp _ min ▁== ▁2; ▁score ▁+= ▁x 4 -> params . rc . i _ qp _ max ▁== ▁31 ; ▁score ▁+= ▁x 4 -> params . rc . f _ q compress ▁== ▁0.5 ; ▁score ▁+= ▁f abs ( x 4

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ set _ signal _ mask ( CPU State ▁* env , ▁const ▁sig set _ t ▁* sig set ) ▁{ ▁struct ▁k vm _ signal _ mask ▁* sig mask ; ▁int ▁r ; ▁if ▁(! sig set ) ▁return ▁k vm _ vc pu _ io ctl ( env , ▁K VM _ SET _ SIG NAL _ MASK , ▁NULL ); ▁sig mask ▁= ▁qemu _ m alloc ( size of (* sig mask ) ▁+ ▁sizeof (* sig set )); ▁sig mask -> len ▁= ▁8 ; ▁mem c py ( sig mask -> sig set , ▁sig set , ▁sizeof (* sig set )); ▁r ▁= ▁k vm _ vc pu _ io ctl ( env , ▁K VM _ SET _ SIG NAL _ MASK , ▁sig mask ); ▁free ( sig mask

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁unix _ close ( void ▁* op aque ) ▁{ ▁Q EM U File Socket ▁* s ▁= ▁opaque ; ▁close ( s -> fd ); ▁g _ free ( s ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁M peg 1 Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁M peg Enc Context ▁* s 2 ▁= ▁& s -> mpeg _ enc _ ctx ; ▁av _ d log ( av ctx , ▁" fill _ buffer \ n "); ▁if ▁( buf _ size ▁== ▁0 ▁|| ▁( buf _ size ▁== ▁4 ▁&& ▁AV _ RB 32 ( buf ) ▁== ▁SE Q _ END _ CODE )) ▁{ ▁/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fd _ chr _ read ( void ▁* op aque ) ▁{ ▁Char Driver State ▁* chr ▁= ▁opaque ; ▁F D Char Driver ▁* s ▁= ▁chr -> op aque ; ▁int ▁size , ▁len ; ▁uint 8_ t ▁buf [10 24 ]; ▁len ▁= ▁sizeof ( buf ); ▁if ▁( len ▁> ▁s -> max _ size ) ▁len ▁= ▁s -> max _ size ; ▁if ▁( len ▁== ▁0) ▁return ; ▁size ▁= ▁read ( s -> fd _ in , ▁buf , ▁len ); ▁if ▁( size ▁== ▁0) ▁{ ▁/* ▁F D ▁has ▁been ▁closed . ▁Remove ▁it ▁from ▁the ▁active ▁list . ▁*/ ▁qemu _ set _ fd _ handler 2( s -> fd _ in , ▁NULL , ▁NULL , ▁NULL , ▁N

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁smb ios _ build _ type _1_ fields ( Q emu Opts ▁* opts ) ▁{ ▁const ▁char ▁* val ; ▁val ▁= ▁qemu _ opt _ get ( opts , ▁" man ufacturer "); ▁if ▁( val ) ▁{ ▁smb ios _ add _ field (1, ▁offset of ( struct ▁smb ios _ type _1, ▁manufacturer _ str ), ▁val , ▁str len ( val ) ▁+ ▁1); ▁} ▁val ▁= ▁qemu _ opt _ get ( opts , ▁" product "); ▁if ▁( val ) ▁{ ▁smb ios _ add _ field (1, ▁offset of ( struct ▁smb ios _ type _1, ▁product _ name _ str ), ▁val , ▁str len ( val ) ▁+ ▁1); ▁} ▁val ▁= ▁qemu _ opt _ g

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vms v ga _ f ifo _ run ( struct ▁vms v ga _ state _ s ▁* s ) ▁{ ▁uint 32_ t ▁cmd , ▁colour ; ▁int ▁args , ▁len ; ▁int ▁x , ▁y , ▁dx , ▁dy , ▁width , ▁height ; ▁struct ▁vms v ga _ cursor _ definition _ s ▁cursor ; ▁uint 32_ t ▁cmd _ start ; ▁len ▁= ▁vms v ga _ f ifo _ length ( s ); ▁while ▁( len ▁> ▁0) ▁{ ▁/* ▁May ▁need ▁to ▁go ▁back ▁to ▁the ▁start ▁of ▁the ▁command ▁if ▁incomplete ▁*/ ▁cmd _ start ▁= ▁s -> cmd -> stop ; ▁switch ▁( cmd ▁= ▁vms v ga _ f ifo _ read ( s )) ▁{ ▁case ▁SVG A _ CM

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁h dev _ get _ max _ segments ( const ▁struct ▁stat ▁* st ) ▁{ ▁# if def ▁CONFIG _ LI NU X ▁char ▁buf [ 32 ]; ▁const ▁char ▁* end ; ▁char ▁* sys fs path ; ▁int ▁ret ; ▁int ▁fd ▁= ▁-1; ▁long ▁max _ segments ; ▁sys fs path ▁= ▁g _ str dup _ printf ("/ sys / dev / block /% u :% u / queue / max _ segments ", ▁major ( st -> st _ r dev ), ▁minor ( st -> st _ r dev )); ▁fd ▁= ▁open ( sys fs path , ▁O _ RD ONLY ); ▁if ▁( fd ▁== ▁-1) ▁{ ▁ret ▁= ▁- err no ; ▁goto ▁out ; ▁} ▁do ▁{ ▁ret ▁= ▁read ( fd , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ap ic _ update _ irq ( API C Common State ▁* s ) ▁{ ▁if ▁(! ( s -> sp ur ious _ vec ▁& ▁API C _ SV _ ENABLE )) ▁{ ▁return ; ▁} ▁if ▁( ap ic _ irq _ pending ( s ) ▁> ▁0) ▁{ ▁cpu _ interrupt ( s -> cpu _ env , ▁CPU _ INTER R UP T _ H ARD ); ▁} ▁else ▁if ▁( ap ic _ accept _ pic _ in tr ( & s -> bus dev . q dev ) ▁&& ▁pic _ get _ output ( isa _ pic )) ▁{ ▁ap ic _ del iver _ pic _ in tr ( & s -> bus dev . q dev , ▁1); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( ext sh ) ▁{ ▁T 0 ▁= ▁( int 32_ t ) (( int 16_ t )( Ts 0 )); ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nfs _ file _ open ( Block Driver State ▁* bs , ▁Q Dict ▁* options , ▁int ▁flags , ▁Error ▁** err p ) ▁{ ▁N FS Client ▁* client ▁= ▁bs -> op aque ; ▁int 64_ t ▁ret ; ▁client -> a io _ context ▁= ▁b dr v _ get _ a io _ context ( bs ); ▁ret ▁= ▁nfs _ client _ open ( client , ▁options , ▁( flags ▁& ▁B DR V _ O _ RD WR ) ▁? ▁O _ RD WR ▁: ▁O _ RD ONLY , ▁bs -> open _ flags , ▁err p ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁qemu _ mut ex _ init ( & client -> mut ex ); ▁bs -> total _ sect ors ▁= ▁r

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁p mac _ ide _ read b ▁( void ▁* op aque , target _ ph ys _ addr _ t ▁addr ) ▁{ ▁uint 8_ t ▁retval ; ▁MAC IO IDE State ▁* d ▁= ▁opaque ; ▁addr ▁= ▁( addr ▁& ▁0 xFF F ) ▁>> ▁4; ▁switch ▁( addr ) ▁{ ▁case ▁1 ▁... ▁7: ▁retval ▁= ▁ide _ i op ort _ read ( & d -> bus , ▁addr ); ▁break ; ▁case ▁8: ▁case ▁22: ▁retval ▁= ▁ide _ status _ read ( & d -> bus , ▁0); ▁break ; ▁default : ▁retval ▁= ▁0 xFF ; ▁break ; ▁} ▁return ▁retval ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ph ys _ addr _ t ▁boo ke 20 6_ tl b _ to _ page _ size ( CPU State ▁* env , ▁p pc mas _ tl b _ t ▁* tl b ) ▁{ ▁uint 32_ t ▁tl bn cfg ; ▁int ▁tl bn ▁= ▁boo ke 20 6_ tl bm _ to _ tl bn ( env , ▁tl b ); ▁int ▁tl bm _ size ; ▁tl bn cfg ▁= ▁env -> spr [ SP R _ BOOK E _ TL B 0 CF G ▁+ ▁tl bn ]; ▁if ▁( tl bn cfg ▁& ▁TL B n CF G _ AVA IL ) ▁{ ▁tl bm _ size ▁= ▁( tl b -> mas 1 ▁& ▁M AS 1_ T SIZE _ MASK ) ▁>> ▁M AS 1_ T SIZE _ SHIFT ; ▁} ▁else ▁{ ▁tl bm _ size ▁= ▁( tl bn cfg ▁& ▁TL B n CF G _ MIN SIZE ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁x h ci _ setup _ packet ( X H C IT rans fer ▁* x fer , ▁X H CI Port ▁* port , ▁int ▁ep ) ▁{ ▁usb _ packet _ setup ( & x fer -> packet , ▁x fer -> in _ x fer ▁? ▁USB _ TOKEN _ IN ▁: ▁USB _ TOKEN _ OUT , ▁x fer -> x h ci -> slots [ x fer -> slot id -1 ]. dev addr , ▁ep ▁& ▁0 x 7 f ); ▁usb _ packet _ add buf ( & x fer -> packet , ▁x fer -> data , ▁x fer -> data _ length ); ▁D PRI NT F (" x h ci : ▁setup ▁packet ▁pid ▁0 x % x ▁addr ▁% d ▁ep ▁% d \ n ", ▁x fer -> packet . pid , ▁x fer -> packet .

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁thread _ pool _ cancel ( Block A IO CB ▁* ac b ) ▁{ ▁ThreadPool Element ▁* elem ▁= ▁( ThreadPool Element ▁* ) ac b ; ▁ThreadPool ▁* pool ▁= ▁elem -> pool ; ▁trace _ thread _ pool _ cancel ( elem , ▁elem -> common . op aque ); ▁qemu _ mut ex _ lock ( & pool -> lock ); ▁if ▁( elem -> state ▁== ▁THREAD _ QUEUE D ▁&& ▁/* ▁No ▁thread ▁has ▁yet ▁started ▁working ▁on ▁elem . ▁we ▁can ▁try ▁to ▁" st e al " ▁* ▁the ▁item ▁from ▁the ▁worker ▁if ▁we ▁can ▁get ▁a ▁signal ▁from ▁the ▁* ▁semaphore . ▁Bec

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁monitor _ protocol _ event _ init ( void ) ▁{ ▁qemu _ mut ex _ init ( & monitor _ event _ state _ lock ); ▁/* ▁Limit ▁R TC ▁& ▁B AL LO ON ▁events ▁to ▁1 ▁per ▁second ▁*/ ▁monitor _ protocol _ event _ th rottle ( Q EVENT _ RTC _ CHANGE , ▁1000); ▁monitor _ protocol _ event _ th rottle ( Q EVENT _ B AL LO ON _ CHANGE , ▁1000); ▁monitor _ protocol _ event _ th rottle ( Q EVENT _ W ATCH D OG , ▁1000); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁seek _ test ( const ▁char ▁* input _ filename , ▁const ▁char ▁* start , ▁const ▁char ▁* end ) ▁{ ▁AV Codec ▁* codec ▁= ▁NULL ; ▁AV Codec Context ▁* ctx = ▁NULL ; ▁AV Codec Parameters ▁* origin _ par ▁= ▁NULL ; ▁AV Frame ▁* fr ▁= ▁NULL ; ▁AV Format Context ▁* fmt _ ctx ▁= ▁NULL ; ▁int ▁video _ stream ; ▁int ▁result ; ▁int ▁i , ▁j ; ▁long ▁int ▁start _ ts , ▁end _ ts ; ▁size _ of _ array ▁= ▁0; ▁number _ of _ elements ▁= ▁0; ▁crc _ array ▁= ▁pts _ array ▁= ▁NULL ; ▁result ▁= ▁av format _ open 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AU X Reply ▁aux _ request ( AU X Bus ▁* bus , ▁AU X Command ▁cmd , ▁uint 32_ t ▁address , ▁uint 8_ t ▁len , ▁uint 8_ t ▁* data ) ▁{ ▁AU X Reply ▁ret ▁= ▁AU X _ N ACK ; ▁I 2 C Bus ▁* i 2 c _ bus ▁= ▁aux _ get _ i 2 c _ bus ( bus ); ▁size _ t ▁i ; ▁bool ▁is _ write ▁= ▁false ; ▁D PRI NT F (" request ▁at ▁address ▁0 x %" ▁PRI X 32 ▁", ▁command ▁% u , ▁len ▁% u \ n ", ▁address , ▁cmd , ▁len ); ▁switch ▁( cmd ) ▁{ ▁/* ▁* ▁Forward ▁the ▁request ▁on ▁the ▁AU X ▁bus .. ▁*/ ▁case ▁WRITE _ AU X : ▁case ▁READ _ AU 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 2 y uv X _ ar )( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* l um Filter , ▁const ▁int 16_ t ▁** l um Src , ▁int ▁l um Filter Size , ▁const ▁int 16_ t ▁* chr Filter , ▁const ▁int 16_ t ▁** chr US rc , ▁const ▁int 16_ t ▁** chr V Src , ▁int ▁chr Filter Size , ▁const ▁int 16_ t ▁** al p Src , ▁uint 8_ t ▁* dest , ▁uint 8_ t ▁* u Dest , ▁uint 8_ t ▁* v Dest , ▁uint 8_ t ▁* a Dest , ▁long ▁dst W , ▁long ▁chr Dst W ) ▁{ ▁if ▁( u Dest ) ▁{ ▁Y SCALE Y UV 2 Y V 12 X _ AC CUR ATE

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Migration Info ▁* q mp _ query _ migrate ( Error ▁** err p ) ▁{ ▁Migration Info ▁* info ▁= ▁g _ m alloc 0( size of (* info )); ▁Migration State ▁* s ▁= ▁migrate _ get _ current (); ▁switch ▁( s -> state ) ▁{ ▁case ▁M IG _ STATE _ NONE : ▁/* ▁no ▁migration ▁has ▁happened ▁ever ▁*/ ▁break ; ▁case ▁M IG _ STATE _ SET UP : ▁info -> has _ status ▁= ▁true ; ▁info -> status ▁= ▁g _ str dup (" setup "); ▁info -> has _ total _ time ▁= ▁false ; ▁break ; ▁case ▁M IG _ STATE _ ACTIVE : ▁case ▁M IG _ STATE _ CANCEL L

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁cow _ set _ bit ( Block Driver State ▁* bs , ▁int 64_ t ▁bit num ) ▁{ ▁uint 64_ t ▁offset ▁= ▁sizeof ( struct ▁cow _ header _ v 2) ▁+ ▁bit num ▁/ ▁8 ; ▁uint 8_ t ▁bitmap ; ▁if ▁( b dr v _ p read ( bs -> file , ▁offset , ▁& bitmap , ▁sizeof ( bitmap )) ▁!= ▁sizeof ( bitmap )) ▁{ ▁return ▁- err no ; ▁} ▁bitmap ▁|= ▁(1 ▁<< ▁( bit num ▁% ▁8 )); ▁if ▁( b dr v _ p write ( bs -> file , ▁offset , ▁& bitmap , ▁sizeof ( bitmap )) ▁!= ▁sizeof ( bitmap )) ▁{ ▁return ▁- err no ; ▁} ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( cm pl ) ▁{ ▁if ▁( T 0 ▁< ▁T 1) ▁{ ▁T 0 ▁= ▁0 x 08 ; ▁} ▁else ▁if ▁( T 0 ▁> ▁T 1) ▁{ ▁T 0 ▁= ▁0 x 04 ; ▁} ▁else ▁{ ▁T 0 ▁= ▁0 x 02 ; ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v oc _ pro be ( AV Probe Data ▁* p ) ▁{ ▁int ▁version , ▁check ; ▁if ▁( p -> buf _ size ▁< ▁26 ) ▁return ▁0; ▁if ▁( mem cmp ( p -> buf , ▁v oc _ magic , ▁sizeof ( v oc _ magic ) ▁- ▁1)) ▁return ▁0; ▁version ▁= ▁p -> buf [ 22 ] ▁| ▁( p -> buf [ 23 ] ▁<< ▁8 ); ▁check ▁= ▁p -> buf [ 24 ] ▁| ▁( p -> buf [ 25 ] ▁<< ▁8 ); ▁if ▁(~ version ▁+ ▁0 x 1234 ▁!= ▁check ) ▁return ▁10; ▁return ▁AV PRO BE _ S CORE _ MAX ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ram _ load ( Q EM U File ▁* f , ▁void ▁* op aque , ▁int ▁version _ id ) ▁{ ▁ram _ addr _ t ▁addr ; ▁int ▁flags ; ▁if ▁( version _ id ▁< ▁3 ▁|| ▁version _ id ▁> ▁4) ▁{ ▁return ▁- E IN VAL ; ▁} ▁do ▁{ ▁addr ▁= ▁qemu _ get _ be 64 ( f ); ▁flags ▁= ▁addr ▁& ▁~ TARGET _ PAGE _ MASK ; ▁addr ▁&= ▁TARGET _ PAGE _ MASK ; ▁if ▁( flags ▁& ▁RAM _ SA VE _ FLAG _ ME M _ SIZE ) ▁{ ▁if ▁( version _ id ▁== ▁3) ▁{ ▁if ▁( addr ▁!= ▁ram _ bytes _ total ()) ▁{ ▁return ▁- E IN VAL ; ▁} ▁} ▁else ▁{ ▁/* ▁Synchron ize ▁RAM 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁drive _ backup _ prepare ( Bl k Action State ▁* common , ▁Error ▁** err p ) ▁{ ▁Drive Backup State ▁* state ▁= ▁DO _ UP CAST ( Drive Backup State , ▁common , ▁common ); ▁Block Driver State ▁* bs ; ▁Drive Backup ▁* backup ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁assert ( common -> action -> type ▁== ▁TRANSACTION _ ACTION _ K IND _ D RI VE _ BACK UP ); ▁backup ▁= ▁common -> action -> u . drive _ backup . data ; ▁bs ▁= ▁q mp _ get _ root _ bs ( backup -> device , ▁err p ); ▁if ▁(! bs ) ▁{ ▁return ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RET _ STOP ▁( Dis as Context ▁* ctx ) ▁{ ▁gen _ op _ update _ n ip (( ctx ) -> n ip ); ▁ctx -> exception ▁= ▁EX CP _ MT MS R ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁term _ exit ( void ) ▁{ ▁# if nd ef ▁__ M ING W 32 __ ▁tc setattr ▁(0, ▁T CS AN OW , ▁& old tty ); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ segment 64 ( CP UP PC State ▁* env , ▁struct ▁mm u _ ctx _ hash 64 ▁* ctx , ▁target _ ulong ▁e addr , ▁int ▁rw , ▁int ▁type ) ▁{ ▁hw addr ▁hash ; ▁target _ ulong ▁vs id ; ▁int ▁pr , ▁target _ page _ bits ; ▁int ▁ret , ▁ret 2; ▁pr ▁= ▁ms r _ pr ; ▁ctx -> ead dr ▁= ▁e addr ; ▁p pc _ sl b _ t ▁* sl b ; ▁target _ ulong ▁page addr ; ▁int ▁segment _ bits ; ▁LOG _ MM U (" Check ▁S LB s \ n "); ▁sl b ▁= ▁sl b _ lookup ( env , ▁e addr ); ▁if ▁(! sl b ) ▁{ ▁return ▁- 5; ▁} ▁if ▁( sl b -> vs id ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 9 fs _ rece iv ef d ( int ▁sock fd , ▁int ▁* status ) ▁{ ▁struct ▁i ove c ▁i ov ; ▁struct ▁msg hdr ▁msg ; ▁struct ▁c msg hdr ▁* c msg ; ▁int ▁retval , ▁data , ▁fd ; ▁union ▁Msg Control ▁msg _ control ; ▁i ov . io v _ base ▁= ▁& data ; ▁i ov . io v _ len ▁= ▁sizeof ( data ); ▁mem set ( & msg , ▁0, ▁sizeof ( msg )); ▁msg . msg _ io v ▁= ▁& io v ; ▁msg . msg _ io v len ▁= ▁1; ▁msg . msg _ control ▁= ▁& msg _ control ; ▁msg . msg _ cont roll en ▁= ▁sizeof ( msg _ control ); ▁do ▁{ ▁retval ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ inject _ x 86_ m ce _ on ( CPU State ▁* env , ▁struct ▁k vm _ x 86_ m ce ▁* m ce , ▁int ▁flag ) ▁{ ▁struct ▁k vm _ x 86_ m ce _ data ▁data ▁= ▁{ ▁. env ▁= ▁env , ▁. m ce ▁= ▁m ce , ▁. abort _ on _ error ▁= ▁( flag ▁& ▁AB ORT _ ON _ ERROR ), ▁}; ▁if ▁(! env -> mc g _ cap ) ▁{ ▁f printf ( stderr , ▁" MCE ▁support ▁is ▁not ▁enabled ! \ n "); ▁return ; ▁} ▁run _ on _ cpu ( env , ▁k vm _ do _ inject _ x 86_ m ce , ▁& data ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁A io Handler ▁* find _ a io _ handler ( A io Context ▁* ctx , ▁int ▁fd ) ▁{ ▁A io Handler ▁* node ; ▁Q LIST _ FORE A CH ( node , ▁& ctx -> a io _ handlers , ▁node ) ▁{ ▁if ▁( node -> p fd . fd ▁== ▁fd ) ▁if ▁(! node -> deleted ) ▁return ▁node ; ▁} ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dis as _ xt ens a _ ins n ( CPU X t ens a State ▁* env , ▁Dis as Context ▁* dc ) ▁{ ▁# define ▁HAS _ OPTION _ BITS ( opt ) ▁do ▁{ ▁\ ▁if ▁(! option _ bits _ enabled ( dc , ▁opt )) ▁{ ▁\ ▁qemu _ log (" Option ▁is ▁not ▁enabled ▁% s :% d \ n ", ▁\ ▁__ FILE __, ▁__ LINE __ ); ▁\ ▁goto ▁invalid _ op code ; ▁\ ▁} ▁\ ▁} ▁while ▁( 0) ▁# define ▁HAS _ OPTION ( opt ) ▁HAS _ OPTION _ BITS ( X TE NS A _ OPTION _ BIT ( opt )) ▁# define ▁T BD () ▁qemu _ log (" T BD ( pc ▁= ▁% 08 x ): ▁% s :% d \ n ", ▁d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁end _ frame ( AV Filter Link ▁* in link ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁in link -> dst ; ▁F PS Context ▁* s ▁= ▁ctx -> priv ; ▁AV Filter Link ▁* out link ▁= ▁ctx -> outputs [0]; ▁AV Filter Buffer Ref ▁* buf ▁= ▁in link -> cur _ buf ; ▁int 64_ t ▁delta ; ▁int ▁i , ▁ret ; ▁in link -> cur _ buf ▁= ▁NULL ; ▁s -> frames _ in ++; ▁/* ▁discard ▁frames ▁until ▁we ▁get ▁the ▁first ▁timestamp ▁*/ ▁if ▁( s -> pts ▁== ▁AV _ NO PT S _ VALUE ) ▁{ ▁if ▁( buf -> pts ▁!= ▁AV _ NO PT S _ VALUE ) ▁{ ▁write 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ro q _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁R o q Dem ux Context ▁* ro q ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁ret ▁= ▁0; ▁unsigned ▁int ▁chunk _ size ; ▁unsigned ▁int ▁chunk _ type ; ▁unsigned ▁int ▁code book _ size ; ▁unsigned ▁char ▁pre amble [ Ro Q _ CHUNK _ PRE A MB LE _ SIZE ]; ▁int ▁packet _ read ▁= ▁0; ▁int 64_ t ▁code book _ offset ; ▁while ▁(! packet _ read ) ▁{ ▁if ▁( av io _ fe of ( s -> pb )) ▁return ▁A VER ROR ( E IO ); ▁/*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( h Scale )( int 16_ t ▁* dst , ▁int ▁dst W , ▁uint 8_ t ▁* src , ▁int ▁src W , ▁int ▁x Inc , ▁int 16_ t ▁* filter , ▁int 16_ t ▁* filter Pos , ▁int ▁filter Size ) ▁{ ▁# if def ▁HAVE _ MM X ▁assert ( filter Size ▁% ▁4 ▁== ▁0 ▁&& ▁filter Size > 0); ▁if ( filter Size == 4) ▁// ▁all ways ▁true ▁for ▁up scaling , ▁sometimes ▁for ▁down ▁too ▁{ ▁long ▁counter = ▁-2 * dst W ; ▁filter - = ▁counter * 2; ▁filter Pos - = ▁counter /2 ; ▁dst - = ▁counter /2 ; ▁asm ▁volatile ( ▁" px or ▁%

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ file _ set _ error ( Q EM U File ▁* f , ▁int ▁ret ) ▁{ ▁if ▁( f -> last _ error ▁== ▁0) ▁{ ▁f -> last _ error ▁= ▁ret ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ picture _ loss less ( AV Codec Context ▁* av ctx , ▁unsigned ▁char ▁* buf , ▁int ▁buf _ size , ▁void ▁* data ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁av ctx -> priv _ data ; ▁M J peg Context ▁* ▁const ▁m ▁= ▁s -> m jpeg _ ctx ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁const ▁int ▁width = ▁s -> width ; ▁const ▁int ▁height = ▁s -> height ; ▁AV Frame ▁* ▁const ▁p = ▁( AV Frame *) & s -> current _ picture ; ▁const ▁int ▁predict or = ▁av ctx -> prediction _ method +1 ; ▁init _ put _ bits ( & s -> pb

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁opt _ input _ file ( Options Context ▁* o , ▁const ▁char ▁* opt , ▁const ▁char ▁* filename ) ▁{ ▁AV Format Context ▁* ic ; ▁AV InputFormat ▁* file _ iform at ▁= ▁NULL ; ▁int ▁err , ▁i , ▁ret ; ▁int 64_ t ▁timestamp ; ▁uint 8_ t ▁buf [ 128 ]; ▁AV Dictionary ▁** opts ; ▁int ▁orig _ nb _ streams ; ▁// ▁number ▁of ▁streams ▁before ▁av format _ find _ stream _ info ▁if ▁( o -> format ) ▁{ ▁if ▁(! ( file _ iform at ▁= ▁av _ find _ input _ format ( o -> format ))) ▁{ ▁av _ log ( NULL , ▁AV _ LOG _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ ef d ct uid z ▁( uint 64_ t ▁val ) ▁{ ▁CPU _ Double U ▁u ; ▁u . ll ▁= ▁val ; ▁/* ▁NaN ▁are ▁not ▁treated ▁the ▁same ▁way ▁IE EE ▁7 54 ▁does ▁*/ ▁if ▁( un likely ( float 64_ is _ nan ( u . d ))) ▁return ▁0; ▁return ▁float 64_ to _ uint 64_ round _ to _ zero ( u . d , ▁& env -> vec _ status ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b ios _ link er _ loader _ add _ checksum ( B IOS Linker ▁* link er , ▁const ▁char ▁* file _ name , ▁void ▁* start , ▁unsigned ▁size , ▁uint 8_ t ▁* checksum ) ▁{ ▁B ios Linker Loader Entry ▁entry ; ▁const ▁B ios Linker File Entry ▁* file ▁= ▁b ios _ link er _ find _ file ( link er , ▁file _ name ); ▁ptr diff _ t ▁checksum _ offset ▁= ▁( g char ▁* ) checksum ▁- ▁file -> blob -> data ; ▁ptr diff _ t ▁start _ offset ▁= ▁( g char ▁* ) start ▁- ▁file -> blob -> data ; ▁assert ( checksum _ offset ▁>= ▁0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ thread _ release _ buffer ( AV Codec Context ▁* av ctx , ▁Thread Frame ▁* f ) ▁{ ▁Per Thread Context ▁* p ▁= ▁av ctx -> internal -> thread _ ctx ; ▁Frame Thread Context ▁* f ctx ; ▁AV Frame ▁* dst , ▁* tmp ; ▁FF _ DIS ABLE _ DE PRE CATION _ WARNING S ▁int ▁can _ direct _ free ▁= ▁! ( av ctx -> active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ) ▁|| ▁av ctx -> thread _ safe _ callbacks ▁|| ▁( ▁# if ▁FF _ API _ GET _ BUFFER ▁! av ctx -> get _ buffer ▁&& ▁# end if ▁av ctx -> get _ buffer 2 ▁== ▁av c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ sch ro _ queue _ free ( FF Sch ro Queue ▁* queue , ▁void ▁(* free _ func )( void ▁* )) ▁{ ▁while ▁( queue -> p _ head ) ▁free _ func ( ff _ sch ro _ queue _ pop ( queue )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ mut ex _ lock _ i oth read ( void ) ▁{ ▁if ▁(! tc g _ enabled ()) ▁{ ▁qemu _ mut ex _ lock ( & q emu _ global _ mut ex ); ▁} ▁else ▁{ ▁i oth read _ request ing _ mut ex ▁= ▁true ; ▁if ▁( q emu _ mut ex _ try lock ( & q emu _ global _ mut ex )) ▁{ ▁qemu _ cpu _ k ick _ thread ( first _ cpu ); ▁qemu _ mut ex _ lock ( & q emu _ global _ mut ex ); ▁} ▁i oth read _ request ing _ mut ex ▁= ▁false ; ▁qemu _ cond _ broadcast ( & q emu _ io _ pro ceed ed _ cond ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ add l _ ES P _ im ( int 32_ t ▁val ) ▁{ ▁tc g _ gen _ ld _ tl ( cpu _ tmp 0, ▁cpu _ env , ▁offset of ( CPU State , ▁regs [ R _ ES P ])); ▁tc g _ gen _ add i _ tl ( cpu _ tmp 0, ▁cpu _ tmp 0, ▁val ); ▁# if def ▁TARGET _ X 86_64 ▁tc g _ gen _ and i _ tl ( cpu _ tmp 0, ▁cpu _ tmp 0, ▁0 xffffffff ); ▁# end if ▁tc g _ gen _ st _ tl ( cpu _ tmp 0, ▁cpu _ env , ▁offset of ( CPU State , ▁regs [ R _ ES P ])); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁dec _ mov u _ r ( Dis as Context ▁* dc ) ▁{ ▁TC G v ▁t 0; ▁int ▁size ▁= ▁mem size _ z ( dc ); ▁DIS ( f printf ▁( log file , ▁" mov u . % c ▁$ r % u , ▁$ r % u \ n ", ▁mem size _ char ( size ), ▁dc -> op 1, ▁dc -> op 2 )); ▁cr is _ cc _ mask ( dc , ▁CC _ MASK _ N Z ); ▁t 0 ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ TL ); ▁dec _ prep _ move _ r ( dc , ▁dc -> op 1, ▁dc -> op 2, ▁size , ▁0, ▁t 0); ▁cr is _ al u ( dc , ▁CC _ OP _ MOVE , ▁cpu _ R [ dc -> op 2], ▁cpu _ R [ dc -> op 2], ▁t 0, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV InputFormat ▁* av _ find _ input _ format ( const ▁char ▁* short _ name ) ▁{ ▁AV InputFormat ▁* fmt ▁= ▁NULL ; ▁while ▁(( fmt ▁= ▁av _ iform at _ next ( fmt ))) ▁if ▁( match _ format ( short _ name , ▁fmt -> name )) ▁return ▁fmt ; ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁ds put il _ init _ s se 2( DS P Context ▁* c , ▁AV Codec Context ▁* av ctx , ▁int ▁mm _ flags ) ▁{ ▁# if ▁HAVE _ SS E 2_ IN LINE ▁const ▁int ▁high _ bit _ depth ▁= ▁av ctx -> bits _ per _ raw _ sample ▁> ▁8 ; ▁if ▁(! high _ bit _ depth ▁&& ▁av ctx -> id ct _ al go ▁== ▁FF _ ID CT _ X V ID MM X ) ▁{ ▁c -> id ct _ put ▁= ▁ff _ id ct _ x vid _ s se 2_ put ; ▁c -> id ct _ add ▁= ▁ff _ id ct _ x vid _ s se 2_ add ; ▁c -> id ct ▁= ▁ff _ id ct _ x vid _ s se 2; ▁c -> id ct _ perm utati

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁au _ pro be ( AV Probe Data ▁* p ) ▁{ ▁/* ▁check ▁file ▁header ▁*/ ▁if ▁( p -> buf _ size ▁<= ▁24 ) ▁return ▁0; ▁if ▁( p -> buf [0] ▁== ▁'.' ▁&& ▁p -> buf [1] ▁== ▁' s ' ▁&& ▁p -> buf [2] ▁== ▁' n ' ▁&& ▁p -> buf [3] ▁== ▁' d ') ▁return ▁AV PRO BE _ S CORE _ MAX ; ▁else ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ fw _ add _ pf lash _ dr v ( void ) ▁{ ▁Q emu Opts ▁* opts ; ▁Q EM UM achine ▁* machine ; ▁char ▁* filename ; ▁if ▁( b ios _ name ▁== ▁NULL ) ▁{ ▁b ios _ name ▁= ▁B IOS _ FILENAME ; ▁} ▁filename ▁= ▁qemu _ find _ file ( Q EM U _ FILE _ TYPE _ B IOS , ▁b ios _ name ); ▁opts ▁= ▁drive _ add ( IF _ P FL ASH , ▁-1, ▁filename , ▁" readonly = on "); ▁g _ free ( filename ); ▁if ▁( opts ▁== ▁NULL ) ▁{ ▁return ; ▁} ▁machine ▁= ▁find _ default _ machine (); ▁if ▁( machine ▁== ▁NULL ) ▁{ ▁return ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ af _ queue _ remove ( Audio Frame Queue ▁* af q , ▁int ▁nb _ samples , ▁int 64_ t ▁* pts , ▁int ▁* duration ) ▁{ ▁int 64_ t ▁out _ pts ▁= ▁AV _ NO PT S _ VALUE ; ▁int ▁removed _ samples ▁= ▁0; ▁# if def ▁DEBUG ▁ff _ af _ queue _ log _ state ( af q ); ▁# end if ▁/* ▁get ▁output ▁pts ▁from ▁the ▁next ▁frame ▁or ▁generated ▁pts ▁*/ ▁if ▁( af q -> frame _ queue ) ▁{ ▁if ▁( af q -> frame _ queue -> pts ▁!= ▁AV _ NO PT S _ VALUE ) ▁out _ pts ▁= ▁af q -> frame _ queue -> pts ▁- ▁af q -> remaining _ d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁stream _ start ( Block Driver State ▁* bs , ▁Block Driver State ▁* base , ▁const ▁char ▁* base _ id , ▁int 64_ t ▁speed , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque , ▁Error ▁** err p ) ▁{ ▁Stream Block Job ▁* s ; ▁Cor outine ▁* co ; ▁s ▁= ▁block _ job _ create ( & stream _ job _ type , ▁bs , ▁speed , ▁cb , ▁opaque , ▁err p ); ▁if ▁(! s ) ▁{ ▁return ; ▁} ▁s -> base ▁= ▁base ; ▁if ▁( base _ id ) ▁{ ▁p str c py ( s -> back ing _ file _ id , ▁sizeof ( s -> back ing _ file _ id ), ▁base _ i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁double ▁get _ diff _ limited _ q ( M peg Enc Context ▁* s , ▁Rate Control Entry ▁* r ce , ▁double ▁q ){ ▁Rate Control Context ▁* rc c = ▁& s -> rc _ context ; ▁AV Codec Context ▁* a = ▁s -> av ctx ; ▁const ▁int ▁p ict _ type = ▁r ce -> new _ p ict _ type ; ▁const ▁double ▁last _ p _ q ▁= ▁r cc -> last _ q scale _ for [ P _ TYPE ]; ▁const ▁double ▁last _ non _ b _ q = ▁r cc -> last _ q scale _ for [ rc c -> last _ non _ b _ p ict _ type ]; ▁if ▁( p ict _ type == I _ TYPE ▁&& ▁( a -> i _ quant _ fa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ write _ h dl r _ tag ( AV IO Context ▁* pb , ▁MO V Track ▁* track ) ▁{ ▁const ▁char ▁* h dl r , ▁* descr ▁= ▁NULL , ▁* h dl r _ type ▁= ▁NULL ; ▁int 64_ t ▁pos ▁= ▁av io _ t ell ( pb ); ▁if ▁(! track ) ▁{ ▁/* ▁no ▁media ▁--> ▁data ▁handler ▁*/ ▁h dl r ▁= ▁" dh lr "; ▁h dl r _ type ▁= ▁" url ▁"; ▁descr ▁= ▁" Data Handler "; ▁} ▁else ▁{ ▁h dl r ▁= ▁( track -> mode ▁== ▁MODE _ MO V ) ▁? ▁" m h lr " ▁: ▁"\ 0\ 0\ 0\ 0 "; ▁if ▁( track -> enc -> codec _ type ▁== ▁AV MEDIA _ TYPE _ VI DEO ) ▁{

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁P PC _ OP ( s raw i ) ▁{ ▁T 1 ▁= ▁T 0; ▁T 0 ▁= ▁( Ts 0 ▁>> ▁PARAM (1) ); ▁if ▁( Ts 1 ▁< ▁0 ▁&& ▁( Ts 1 ▁& ▁PARAM (2 )) ▁!= ▁0) ▁{ ▁x er _ ca ▁= ▁1; ▁} ▁else ▁{ ▁x er _ ca ▁= ▁0; ▁} ▁RETURN (); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁trace _ init _ file ( const ▁char ▁* file ) ▁{ ▁# if def ▁CONFIG _ TRA CE _ SI MPLE ▁st _ set _ trace _ file ( file ); ▁# el if ▁defined ▁CONFIG _ TRA CE _ LOG ▁/* ▁If ▁both ▁the ▁simple ▁and ▁the ▁log ▁backends ▁are ▁enabled , ▁"- trace ▁file " ▁* ▁only ▁applies ▁to ▁the ▁simple ▁backend ; ▁use ▁"- D " ▁for ▁the ▁log ▁backend . ▁*/ ▁if ▁( file ) ▁{ ▁qemu _ set _ log _ filename ( file ); ▁} ▁# else ▁if ▁( file ) ▁{ ▁f printf ( stderr , ▁" error : ▁- trace ▁file = ... : ▁" ▁" option ▁not ▁supported 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁srt _ pro be ( AV Probe Data ▁* p ) ▁{ ▁const ▁unsigned ▁char ▁* ptr ▁= ▁p -> buf ; ▁int ▁i , ▁v , ▁num ▁= ▁0; ▁if ▁( AV _ RB 24 ( ptr ) ▁== ▁0 x EF BB BF ) ▁ptr ▁+= ▁3; ▁/* ▁skip ▁UTF -8 ▁BOM ▁*/ ▁while ▁(* ptr ▁== ▁'\ r ' ▁|| ▁* ptr ▁== ▁'\ n ') ▁ptr ++; ▁for ▁( i =0; ▁i < 2; ▁i ++) ▁{ ▁if ▁(( num ▁== ▁i ▁|| ▁num ▁+ ▁1 ▁== ▁i ) ▁&& ▁s scan f ( ptr , ▁"% * d :% * 2 d :% * 2 d % * 1[ , . ] % * 3 d ▁--> ▁% * d :% * 2 d :% * 2 d % * 1[ , . ] %3 d ", ▁& v ) ▁== ▁1) ▁return ▁AV PRO BE _ S CORE _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pi ix 4_ update _ hot plug ( PI IX 4 PM State ▁* s ) ▁{ ▁PC ID evice ▁* dev ▁= ▁& s -> dev ; ▁Bus State ▁* bus ▁= ▁q dev _ get _ parent _ bus ( & dev -> q dev ); ▁Device State ▁* q dev , ▁* next ; ▁s -> pc i 0_ hot plug _ enable ▁= ▁~ 0; ▁Q TAIL Q _ FORE A CH _ SAFE ( q dev , ▁& bus -> children , ▁sibling , ▁next ) ▁{ ▁PC ID evice ▁* pd ev ▁= ▁P CI _ DEVICE ( q dev ); ▁PC ID evice Class ▁* pc ▁= ▁P CI _ DEVICE _ GET _ CLASS ( pd ev ); ▁int ▁slot ▁= ▁P CI _ SL OT ( pd ev -> dev fn ); ▁if ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁stream _ set _ speed ( Block Job ▁* job , ▁int 64_ t ▁speed , ▁Error ▁** err p ) ▁{ ▁Stream Block Job ▁* s ▁= ▁container _ of ( job , ▁Stream Block Job , ▁common ); ▁if ▁( speed ▁< ▁0) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER , ▁" speed "); ▁return ; ▁} ▁rat el imit _ set _ speed ( & s -> limit , ▁speed ▁/ ▁B DR V _ SE CTOR _ SIZE , ▁S LI CE _ TIME ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁dn x hd _ decode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁DN X HD Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁ff _ free _ vlc ( & ctx -> ac _ vlc ); ▁ff _ free _ vlc ( & ctx -> dc _ vlc ); ▁ff _ free _ vlc ( & ctx -> run _ vlc ); ▁av _ fre ep ( & ctx -> mb _ scan _ index ); ▁av _ fre ep ( & ctx -> rows ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁unix _ start _ incoming _ migration ( const ▁char ▁* path ) ▁{ ▁struct ▁sock addr _ un ▁un ; ▁int ▁sock ; ▁d printf (" Attempt ing ▁to ▁start ▁an ▁incoming ▁migration \ n "); ▁sock ▁= ▁socket ( PF _ UN IX , ▁SOCK _ STREAM , ▁0); ▁if ▁( sock ▁< ▁0) ▁{ ▁f printf ( stderr , ▁" Could ▁not ▁open ▁unix ▁socket : ▁% s \ n ", ▁strerror ( err no )); ▁return ▁- E IN VAL ; ▁} ▁mem set ( & un , ▁0, ▁sizeof ( un )); ▁un . sun _ family ▁= ▁AF _ UN IX ; ▁sn printf ( un . sun _ path , ▁sizeof ( un . sun _ path ), ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ refresh _ limits ( Block Driver State ▁* bs , ▁Error ▁** err p ) ▁{ ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁mem set ( & bs -> bl , ▁0, ▁sizeof ( bs -> bl )); ▁if ▁(! dr v ) ▁{ ▁return ; ▁} ▁/* ▁Default ▁alignment ▁based ▁on ▁whether ▁driver ▁has ▁byte ▁interface ▁*/ ▁bs -> request _ alignment ▁= ▁drv -> b dr v _ co _ p read v ▁? ▁1 ▁: ▁512 ; ▁/* ▁Take ▁some ▁limits ▁from ▁the ▁children ▁as ▁a ▁default ▁*/ ▁if ▁( bs -> file ) ▁{ ▁b dr v _ refresh _ limits ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁check _ ref blocks ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁B dr v Check Mode ▁fix , ▁bool ▁* rebuild , ▁void ▁** refcount _ table , ▁int 64_ t ▁* nb _ clusters ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁i , ▁size ; ▁int ▁ret ; ▁for ( i ▁= ▁0; ▁i ▁< ▁s -> refcount _ table _ size ; ▁i ++) ▁{ ▁uint 64_ t ▁offset , ▁cluster ; ▁offset ▁= ▁s -> refcount _ table [ i ]; ▁cluster ▁= ▁offset ▁>> ▁s -> cluster _ bits ; ▁/* ▁Ref count ▁blocks ▁are ▁cluster ▁alig

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Drive Info ▁* drive _ init ( Q emu Opts ▁* opts , ▁Block Interface Type ▁block _ default _ type ) ▁{ ▁const ▁char ▁* buf ; ▁const ▁char ▁* file ▁= ▁NULL ; ▁const ▁char ▁* serial ; ▁const ▁char ▁* media str ▁= ▁""; ▁Block Interface Type ▁type ; ▁enum ▁{ ▁MEDIA _ DIS K , ▁MEDIA _ CD ROM ▁} ▁media ; ▁int ▁bus _ id , ▁unit _ id ; ▁int ▁cy ls , ▁heads , ▁secs , ▁translation ; ▁Block Driver ▁* dr v ▁= ▁NULL ; ▁int ▁max _ dev s ; ▁int ▁index ; ▁int ▁ro ▁= ▁0; ▁int ▁b dr v _ flags ▁= ▁0; ▁int ▁on _ read _ error 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁char ▁* key val _ parse _ one ( Q Dict ▁* q dict , ▁const ▁char ▁* params , ▁const ▁char ▁* impl ied _ key , ▁Error ▁** err p ) ▁{ ▁const ▁char ▁* key , ▁* key _ end , ▁* s ; ▁size _ t ▁len ; ▁char ▁key _ in _ cur [ 128 ]; ▁Q Dict ▁* cur ; ▁int ▁ret ; ▁Q Object ▁* next ; ▁Q String ▁* val ; ▁key ▁= ▁params ; ▁len ▁= ▁str c sp n ( params , ▁" = , "); ▁if ▁( impl ied _ key ▁&& ▁len ▁&& ▁key [ len ] ▁!= ▁' = ') ▁{ ▁/* ▁Des ug ar ▁implied ▁key ▁*/ ▁key ▁= ▁implied _ key ; ▁len ▁= ▁str len ( imp

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁md ct _ test ( AC 3 MD CT Context ▁* md ct , ▁AV LF G ▁* l fg ) ▁{ ▁int 16_ t ▁input [ MD CT _ SA MP LES ]; ▁int 32_ t ▁output [ AC 3_ MAX _ CO E FS ]; ▁float ▁input 1[ MD CT _ SA MP LES ]; ▁float ▁output 1[ AC 3_ MAX _ CO E FS ]; ▁float ▁s , ▁a , ▁err , ▁e , ▁em ax ; ▁int ▁i , ▁k , ▁n ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁MD CT _ SA MP LES ; ▁i ++) ▁{ ▁input [ i ] ▁= ▁( av _ l fg _ get ( l fg ) ▁% ▁65535 ▁- ▁327 67 ) ▁* ▁9 ▁/ ▁10; ▁input 1[ i ] ▁= ▁input [ i ]; ▁} ▁md ct 512 ( md ct , ▁output , ▁input

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁AV R ational ▁update _ sar ( int ▁old _ w , ▁int ▁old _ h , ▁AV R ational ▁s ar , ▁int ▁new _ w , ▁int ▁new _ h ) ▁{ ▁// ▁attempt ▁to ▁keep ▁aspect ▁during ▁typical ▁resolution ▁switches ▁if ▁(! sar . num ) ▁s ar ▁= ▁( AV R ational ){ 1, ▁1 }; ▁s ar ▁= ▁av _ mul _ q ( sar , ▁( AV R ational ){ new _ h ▁* ▁old _ w , ▁new _ w ▁* ▁old _ h }); ▁return ▁s ar ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁q pc i _ pc _ config _ read l ( Q PC I Bus ▁* bus , ▁int ▁dev fn , ▁uint 8_ t ▁offset ) ▁{ ▁out l (0 x cf 8, ▁(1 ▁<< ▁3 1) ▁| ▁( dev fn ▁<< ▁8) ▁| ▁offset ); ▁return ▁in l (0 x cf c ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ block ( B ink Audio Context ▁* s , ▁float ▁** out , ▁int ▁use _ d ct ) ▁{ ▁int ▁ch , ▁i , ▁j , ▁k ; ▁float ▁q , ▁quant [ 25 ]; ▁int ▁width , ▁coeff ; ▁Get Bit Context ▁* gb ▁= ▁& s -> gb ; ▁if ▁( use _ d ct ) ▁skip _ bits ( gb , ▁2); ▁for ▁( ch ▁= ▁0; ▁ch ▁< ▁s -> channels ; ▁ch ++) ▁{ ▁FFT Sample ▁* coeff s ▁= ▁out [ ch ]; ▁if ▁( s -> version _ b ) ▁{ ▁if ▁( get _ bits _ left ( gb ) ▁< ▁64 ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁coeffs [0] ▁= ▁av _ int 2 float ( get _ bits _ long

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁load _ normal _ reset ( S 390 CPU ▁* cpu ) ▁{ ▁S 390 CPU Class ▁* sc c ▁= ▁S 39 0_ CPU _ GET _ CLASS ( cpu ); ▁pause _ all _ v cpus (); ▁cpu _ synchron ize _ all _ states (); ▁cpu _ reset _ all (); ▁io _ sub system _ reset (); ▁sc c -> initial _ cpu _ reset ( CPU ( cpu )); ▁sc c -> load _ normal ( CPU ( cpu )); ▁cpu _ synchron ize _ all _ post _ reset (); ▁resume _ all _ v cpus (); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v 9 fs _ post _ l create ( V 9 fs State ▁* s , ▁V 9 fs L create State ▁* vs , ▁int ▁err ) ▁{ ▁if ▁( err ▁== ▁0) ▁{ ▁v 9 fs _ string _ copy ( & vs -> f id p -> path , ▁& vs -> fullname ); ▁stat _ to _ q id ( & vs -> st buf , ▁& vs -> q id ); ▁vs -> offset ▁+= ▁pdu _ marshal ( vs -> pd u , ▁vs -> offset , ▁" Q d ", ▁& vs -> q id , ▁& vs -> i oun it ); ▁err ▁= ▁vs -> offset ; ▁} ▁else ▁{ ▁vs -> f id p -> f id _ type ▁= ▁P 9_ F ID _ NONE ; ▁close ( vs -> f id p -> fs . fd ); ▁err ▁= ▁- err no ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁get _ xb z r le _ cache _ stats ( Migration Info ▁* info ) ▁{ ▁if ▁( migrate _ use _ xb z r le ()) ▁{ ▁info -> has _ xb z r le _ cache ▁= ▁true ; ▁info -> xb z r le _ cache ▁= ▁g _ m alloc 0( size of (* info -> xb z r le _ cache )); ▁info -> xb z r le _ cache -> cache _ size ▁= ▁migrate _ xb z r le _ cache _ size (); ▁info -> xb z r le _ cache -> bytes ▁= ▁x bz r le _ mig _ bytes _ transfer red (); ▁info -> xb z r le _ cache -> pages ▁= ▁x bz r le _ mig _ pages _ transfer red (); ▁info -> x

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Power PC CPU ▁* pp c 4 40 _ init _ x il inx ( ram _ addr _ t ▁* ram _ size , ▁int ▁do _ init , ▁const ▁char ▁* cpu _ model , ▁uint 32_ t ▁sys cl k ) ▁{ ▁Power PC CPU ▁* cpu ; ▁CP UP PC State ▁* env ; ▁qemu _ irq ▁* ir qs ; ▁cpu ▁= ▁PO WER PC _ CPU ( cpu _ generic _ init ( TYPE _ PO WER PC _ CPU , ▁cpu _ model )); ▁if ▁( cpu ▁== ▁NULL ) ▁{ ▁f printf ( stderr , ▁" Unable ▁to ▁initialize ▁CPU ! \ n "); ▁exit (1); ▁} ▁env ▁= ▁& cpu -> env ; ▁p pc _ b oo ke _ tim ers _ init ( cpu , ▁sys cl k , ▁0 /* ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁create _ default _ q tables ( uint 8_ t ▁* q tables , ▁uint 8_ t ▁q ) ▁{ ▁int ▁factor ▁= ▁q ; ▁int ▁i ; ▁factor ▁= ▁av _ clip ( q , ▁1, ▁99 ); ▁if ▁( q ▁< ▁50 ) ▁q ▁= ▁5000 ▁/ ▁factor ; ▁else ▁q ▁= ▁200 ▁- ▁factor ▁* ▁2; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁128 ; ▁i ++) ▁{ ▁int ▁val ▁= ▁( default _ quant izers [ i ] ▁* ▁q ▁+ ▁50 ) ▁/ ▁100; ▁/* ▁Limit ▁the ▁quant izers ▁to ▁1 ▁<= ▁q ▁<= ▁255 . ▁*/ ▁val ▁= ▁av _ clip ( val , ▁1, ▁255 ); ▁q tables [ i ] ▁= ▁val ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ af _ queue _ close ( Audio Frame Queue ▁* af q ) ▁{ ▁/* ▁remove / free ▁any ▁remaining ▁frames ▁*/ ▁while ▁( af q -> frame _ queue ) ▁delete _ next _ frame ( af q ); ▁mem set ( af q , ▁0, ▁sizeof (* af q )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁l um Range To J peg 16_ c ( int 16_ t ▁* _ dst , ▁int ▁width ) ▁{ ▁int ▁i ; ▁int 32_ t ▁* dst ▁= ▁( int 32_ t ▁* ) ▁_ dst ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁width ; ▁i ++) ▁dst [ i ] ▁= ▁( FF MIN ( dst [ i ], 301 89 << 4) * 190 77 ▁- ▁( 390 57 36 1 << 4 )) >> 14 ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁fill _ coding _ method _ array ( sb _ int 8_ array ▁t one _ level _ idx , ▁sb _ int 8_ array ▁t one _ level _ idx _ temp , ▁sb _ int 8_ array ▁coding _ method , ▁int ▁nb _ channels , ▁int ▁c , ▁int ▁super block type _2_ 3, ▁int ▁cm _ table _ select ) ▁{ ▁int ▁ch , ▁sb , ▁j ; ▁int ▁tmp , ▁acc , ▁es p _4 0, ▁comp ; ▁int ▁add 1, ▁add 2, ▁add 3, ▁add 4; ▁int 64_ t ▁mult res ; ▁if ▁(! super block type _2_ 3) ▁{ ▁/* ▁This ▁case ▁is ▁unt ested , ▁no ▁samples ▁available ▁*/ ▁S AMP LES _ NE EDED ▁fo

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁find _ m otion ( Des h ake Context ▁* des h ake , ▁uint 8_ t ▁* src 1, ▁uint 8_ t ▁* src 2, ▁int ▁width , ▁int ▁height , ▁int ▁stride , ▁Transform ▁* t ) ▁{ ▁int ▁x , ▁y ; ▁Int Motion Vector ▁mv ▁= ▁{ 0, ▁0 }; ▁int ▁counts [ 128 ][ 128 ]; ▁int ▁count _ max _ value ▁= ▁0; ▁int ▁contrast ; ▁int ▁pos ; ▁double ▁* angles ▁= ▁av _ m alloc ( size of (* angles ) ▁* ▁width ▁* ▁height ▁/ ▁( 16 ▁* ▁des h ake -> block size )); ▁int ▁center _ x ▁= ▁0, ▁center _ y ▁= ▁0; ▁double ▁p _ x , ▁p _ y ; ▁// ▁R

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁di rac _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* pk t ) ▁{ ▁D ira c Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁uint 8_ t ▁* buf ▁= ▁pkt -> data ; ▁int ▁buf _ size ▁= ▁pkt -> size ; ▁int ▁i , ▁data _ unit _ size , ▁buf _ idx ▁= ▁0; ▁int ▁ret ; ▁/* ▁release ▁unused ▁frames ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁MAX _ FRAME S ; ▁i ++) ▁if ▁( s -> all _ frames [ i ]. av frame -> data [0] ▁&& ▁! s -> all _ frames [ i ].

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁TC G v ▁gen _ ea ( CP UM 68 K State ▁* env , ▁Dis as Context ▁* s , ▁uint 16_ t ▁insn , ▁int ▁op size , ▁TC G v ▁val , ▁TC G v ▁* addr p , ▁ea _ what ▁what ) ▁{ ▁TC G v ▁reg ; ▁TC G v ▁result ; ▁uint 32_ t ▁offset ; ▁switch ▁(( ins n ▁>> ▁3) ▁& ▁7) ▁{ ▁case ▁0: ▁/* ▁Data ▁register ▁direct . ▁*/ ▁reg ▁= ▁D REG ( ins n , ▁0); ▁if ▁( what ▁== ▁E A _ STORE ) ▁{ ▁gen _ part set _ reg ( op size , ▁reg , ▁val ); ▁return ▁store _ dummy ; ▁} ▁else ▁{ ▁return ▁gen _ extend ( reg , ▁op size , ▁what ▁== ▁E A

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁void ▁nv enc _ setup _ rate _ control ( AV Codec Context ▁* av ctx ) ▁{ ▁N v enc Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> bit _ rate ▁> ▁0) ▁{ ▁ctx -> encode _ config . rc Params . average Bit Rate ▁= ▁av ctx -> bit _ rate ; ▁} ▁else ▁if ▁( ctx -> encode _ config . rc Params . average Bit Rate ▁> ▁0) ▁{ ▁ctx -> encode _ config . rc Params . max Bit Rate ▁= ▁ctx -> encode _ config . rc Params . average Bit Rate ; ▁} ▁if ▁( av ctx -> rc _ max _ rate ▁> ▁0) ▁ctx -> enc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁vp 3_ decode _ end ( AV Codec Context ▁* av ctx ) ▁{ ▁V p 3 Decode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁if ▁( av ctx -> is _ copy ▁&& ▁! s -> current _ frame . data [0]) ▁return ▁0; ▁av _ free ( s -> super block _ coding ); ▁av _ free ( s -> all _ fragments ); ▁av _ free ( s -> coded _ fragment _ list [0]); ▁av _ free ( s -> d ct _ tokens _ base ); ▁av _ free ( s -> super block _ fragments ); ▁av _ free ( s -> macro block _ coding ); ▁av _ free ( s -> m otion _ val

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ disconnect _ finish ( V nc State ▁* vs ) ▁{ ▁v nc _ q mp _ event ( vs , ▁Q EVENT _ V NC _ DIS CONNECTED ); ▁buffer _ free ( & vs -> input ); ▁buffer _ free ( & vs -> output ); ▁q object _ dec ref ( vs -> info ); ▁# if def ▁CONFIG _ V NC _ TLS ▁v nc _ tls _ client _ cleanup ( vs ); ▁# end if ▁/* ▁CONFIG _ V NC _ TLS ▁*/ ▁# if def ▁CONFIG _ V NC _ S AS L ▁v nc _ s asl _ client _ cleanup ( vs ); ▁# end if ▁/* ▁CONFIG _ V NC _ S AS L ▁*/ ▁audio _ del ( vs ); ▁Q TAIL Q _ REMOVE ( & vs -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ opts _ print ( Q emu Opts ▁* opts ) ▁{ ▁Q emu Opt ▁* opt ; ▁Q emu Opt Desc ▁* desc ▁= ▁opts -> list -> desc ; ▁if ▁( desc [0]. name ▁== ▁NULL ) ▁{ ▁Q TAIL Q _ FORE A CH ( opt , ▁& opts -> head , ▁next ) ▁{ ▁printf ("% s =\" % s \" ▁", ▁opt -> name , ▁opt -> str ); ▁} ▁return ; ▁} ▁for ▁( ; ▁desc ▁&& ▁desc -> name ; ▁desc ++) ▁{ ▁const ▁char ▁* value ; ▁Q emu Opt ▁* opt ▁= ▁qemu _ opt _ find ( opts , ▁desc -> name ); ▁value ▁= ▁opt ▁? ▁opt -> str ▁: ▁desc -> def _ value _ str ; ▁if ▁(! value 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁nv ic _ read l ( nv ic _ state ▁* s , ▁uint 32_ t ▁offset ) ▁{ ▁ARM CPU ▁* cpu ; ▁uint 32_ t ▁val ; ▁int ▁irq ; ▁switch ▁( offset ) ▁{ ▁case ▁4: ▁/* ▁Inter rupt ▁Control ▁Type . ▁*/ ▁return ▁( s -> num _ irq ▁/ ▁3 2) ▁- ▁1; ▁case ▁0 x 10 : ▁/* ▁Sys Tick ▁Control ▁and ▁Status . ▁*/ ▁val ▁= ▁s -> s ystick . control ; ▁s -> s ystick . control ▁&= ▁~ SY ST ICK _ COUNT FLAG ; ▁return ▁val ; ▁case ▁0 x 14 : ▁/* ▁Sys Tick ▁Reload ▁Value . ▁*/ ▁return ▁s -> s ystick . reload ; ▁case ▁0 x 18 :

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁g xf _ write _ header ( AV Format Context ▁* s ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁G XF Context ▁* g xf ▁= ▁s -> priv _ data ; ▁G XF Stream Context ▁* v sc ▁= ▁NULL ; ▁uint 8_ t ▁tracks [ 255 ] ▁= ▁{0 }; ▁int ▁i , ▁media _ info ▁= ▁0; ▁if ▁(! pb -> seek able ) ▁{ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" g xf ▁mux er ▁does ▁not ▁support ▁stream ed ▁output , ▁patch ▁welcome "); ▁return ▁-1; ▁} ▁g xf -> flags ▁|= ▁0 x 000 8 0000 ; ▁/* ▁material ▁is ▁simple ▁clip ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q xl _ render _ update _ area _ un locked ( PC I Q X L Device ▁* q xl ) ▁{ ▁V GA Common State ▁* v ga ▁= ▁& q xl -> v ga ; ▁int ▁i ; ▁if ▁( q xl -> guest _ primary . res ized ) ▁{ ▁q xl -> guest _ primary . res ized ▁= ▁0; ▁q xl -> guest _ primary . data ▁= ▁memory _ region _ get _ ram _ ptr ( & q xl -> v ga . v ram ); ▁q xl _ set _ rect _ to _ surface ( q xl , ▁& q xl -> dirty [0]); ▁q xl -> num _ dirty _ rect s ▁= ▁1; ▁trace _ q xl _ render _ guest _ primary _ res ized ( ▁q xl -> guest _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁page _ init ( void ) ▁{ ▁/* ▁NOTE : ▁we ▁can ▁always ▁suppose ▁that ▁qemu _ host _ page _ size ▁>= ▁TARGET _ PAGE _ SIZE ▁*/ ▁# if def ▁_ W IN 32 ▁{ ▁SYSTEM _ INFO ▁system _ info ; ▁Get System Info ( & system _ info ); ▁qemu _ real _ host _ page _ size ▁= ▁system _ info . dw Page Size ; ▁} ▁# else ▁qemu _ real _ host _ page _ size ▁= ▁get pages ize (); ▁# end if ▁if ▁( q emu _ host _ page _ size ▁== ▁0) ▁{ ▁qemu _ host _ page _ size ▁= ▁qemu _ real _ host _ page _ size ; ▁} ▁if ▁( q emu _ h

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁SocketAddress ▁* tcp _ build _ address ( const ▁char ▁* host _ port , ▁Error ▁** err p ) ▁{ ▁Inet SocketAddress ▁* i addr ▁= ▁g _ new ( Inet SocketAddress , ▁1); ▁SocketAddress ▁* s addr ; ▁if ▁( inet _ parse ( i addr , ▁host _ port , ▁err p )) ▁{ ▁q api _ free _ Inet SocketAddress ( i addr ); ▁return ▁NULL ; ▁} ▁s addr ▁= ▁g _ new 0( SocketAddress , ▁1); ▁s addr -> type ▁= ▁SO CKET _ ADDRESS _ K IND _ INET ; ▁s addr -> u . inet . data ▁= ▁i addr ; ▁return ▁s addr ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nb d _ close ( Block Driver State ▁* bs ) ▁{ ▁B DR V N BD State ▁* s ▁= ▁bs -> op aque ; ▁qemu _ opts _ del ( s -> socket _ opts ); ▁nb d _ client _ session _ close ( & s -> client ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁reset ( Device State ▁* d ) ▁{ ▁s P AP R DR Connector ▁* d rc ▁= ▁SP AP R _ DR _ CONNECT OR ( d ); ▁s P AP R DR Connector Class ▁* dr ck ▁= ▁SP AP R _ DR _ CONNECT OR _ GET _ CLASS ( d rc ); ▁trace _ sp ap r _ d rc _ reset ( sp ap r _ d rc _ index ( d rc )); ▁g _ free ( d rc -> cc s ); ▁d rc -> cc s ▁= ▁NULL ; ▁/* ▁immediately ▁upon ▁reset ▁we ▁can ▁safely ▁assume ▁D RC s ▁whose ▁devices ▁* ▁are ▁pending ▁removal ▁can ▁be ▁safely ▁removed , ▁and ▁that ▁they ▁will ▁* ▁subsequ ently ▁be ▁left

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ remove _ break point ( CPU State ▁* current _ env , ▁target _ ulong ▁addr , ▁target _ ulong ▁len , ▁int ▁type ) ▁{ ▁struct ▁k vm _ sw _ break point ▁* bp ; ▁CPU State ▁* env ; ▁int ▁err ; ▁if ▁( type ▁== ▁G DB _ B REAK POINT _ SW ) ▁{ ▁bp ▁= ▁k vm _ find _ sw _ break point ( current _ env , ▁addr ); ▁if ▁(! bp ) ▁return ▁- EN O ENT ; ▁if ▁( bp -> use _ count ▁> ▁1) ▁{ ▁bp -> use _ count --; ▁return ▁0; ▁} ▁err ▁= ▁k vm _ arch _ remove _ sw _ break point ( current _ env , ▁bp ); ▁if ▁( err ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ fc mp _ gt _ DT ( CP USH 4 State ▁* env , ▁float 64 ▁t 0, ▁float 64 ▁t 1) ▁{ ▁int ▁relation ; ▁set _ float _ exception _ flags (0, ▁& env -> fp _ status ); ▁relation ▁= ▁float 64_ compare ( t 0, ▁t 1, ▁& env -> fp _ status ); ▁if ▁( un likely ( relation ▁== ▁float _ relation _ un ordered )) ▁{ ▁update _ f ps cr ( env , ▁GET PC ()); ▁} ▁else ▁{ ▁env -> sr _ t ▁= ▁( relation ▁== ▁float _ relation _ greater ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁img _ info ( int ▁arg c , ▁char ▁** argv ) ▁{ ▁int ▁c ; ▁Output Format ▁output _ format ▁= ▁O FORMAT _ H UM AN ; ▁const ▁char ▁* filename , ▁* fmt , ▁* output ; ▁Block Driver State ▁* bs ; ▁Image Info ▁* info ; ▁fmt ▁= ▁NULL ; ▁output ▁= ▁NULL ; ▁for ( ; ;) ▁{ ▁int ▁option _ index ▁= ▁0; ▁static ▁const ▁struct ▁option ▁long _ options [] ▁= ▁{ ▁{" help ", ▁no _ argument , ▁0, ▁' h '}, ▁{" format ", ▁required _ argument , ▁0, ▁' f '}, ▁{" output ", ▁required _ argument , ▁0, ▁OPTION _ OUTPUT }

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁q io _ dns _ resolver _ lookup _ sync ( Q IOD NS Resolver ▁* resolver , ▁SocketAddress Legacy ▁* addr , ▁size _ t ▁* n addrs , ▁SocketAddress Legacy ▁*** addrs , ▁Error ▁** err p ) ▁{ ▁switch ▁( addr -> type ) ▁{ ▁case ▁SO CKET _ ADDRESS _ LEG ACY _ K IND _ INET : ▁return ▁q io _ dns _ resolver _ lookup _ sync _ inet ( resolver , ▁addr , ▁n addrs , ▁addrs , ▁err p ); ▁case ▁SO CKET _ ADDRESS _ LEG ACY _ K IND _ UN IX : ▁case ▁SO CKET _ ADDRESS _ LEG ACY _ K IND _ V SO CK : ▁case ▁SO CKET _ ADDRESS _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁coroutine _ fn ▁int ▁qc ow _ co _ read v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁index _ in _ cluster ; ▁int ▁ret ▁= ▁0, ▁n ; ▁uint 64_ t ▁cluster _ offset ; ▁struct ▁i ove c ▁hd _ io v ; ▁Q EM UI O Vector ▁hd _ q io v ; ▁uint 8_ t ▁* buf ; ▁void ▁* orig _ buf ; ▁Error ▁* err ▁= ▁NULL ; ▁if ▁( q io v -> nio v ▁> ▁1) ▁{ ▁buf ▁= ▁orig _ buf ▁= ▁qemu _ try _ block align ( bs , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg 4_ decode _ g op _ header ( M peg Enc Context ▁* s , ▁Get Bit Context ▁* gb ) ▁{ ▁int ▁hours , ▁minutes , ▁seconds ; ▁if ▁(! show _ bits ( gb , ▁23 )) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ WARNING , ▁" G OP ▁header ▁invalid \ n "); ▁return ▁-1; ▁} ▁hours ▁= ▁get _ bits ( gb , ▁5 ); ▁minutes ▁= ▁get _ bits ( gb , ▁6 ); ▁skip _ bits 1( gb ); ▁seconds ▁= ▁get _ bits ( gb , ▁6 ); ▁s -> time _ base ▁= ▁seconds ▁+ ▁60 *( minutes ▁+ ▁60 * hours ); ▁skip _ bits 1( gb ); ▁skip _ bits 1( gb )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ftp _ restart ( FTP Context ▁* s , ▁int 64_ t ▁pos ) ▁{ ▁char ▁command [ CONTROL _ BUFFER _ SIZE ]; ▁const ▁int ▁rest _ codes [] ▁= ▁{ 35 0, ▁0 }; ▁sn printf ( command , ▁sizeof ( command ), ▁" REST ▁% " PR Id 64" \ r \ n ", ▁pos ); ▁if ▁(! ftp _ send _ command ( s , ▁command , ▁rest _ codes , ▁NULL )) ▁return ▁A VER ROR ( E IO ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁b dr v _ co _ do _ copy _ on _ read v ( B dr v Child ▁* child , ▁int 64_ t ▁offset , ▁unsigned ▁int ▁bytes , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁Block Driver State ▁* bs ▁= ▁child -> bs ; ▁/* ▁Perform ▁I / O ▁through ▁a ▁temporary ▁buffer ▁so ▁that ▁users ▁who ▁s cri b ble ▁over ▁* ▁their ▁read ▁buffer ▁while ▁the ▁operation ▁is ▁in ▁progress ▁do ▁not ▁end ▁up ▁* ▁modifying ▁the ▁image ▁file . ▁This ▁is ▁critical ▁for ▁zero - copy ▁guest ▁I / O ▁* ▁where ▁anything ▁might ▁happe

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ io ctl ( K VM State ▁* s , ▁int ▁type , ▁...) ▁{ ▁int ▁ret ; ▁void ▁* arg ; ▁va _ list ▁ap ; ▁va _ start ( ap , ▁type ); ▁arg ▁= ▁va _ arg ( ap , ▁void ▁* ); ▁va _ end ( ap ); ▁ret ▁= ▁io ctl ( s -> fd , ▁type , ▁arg ); ▁if ▁( ret ▁== ▁-1) ▁ret ▁= ▁- err no ; ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁ex yn os 42 10_ m ct _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁offset , ▁unsigned ▁size ) ▁{ ▁Ex yn os 42 10 M CT State ▁* s ▁= ▁( Ex yn os 42 10 M CT State ▁* ) op aque ; ▁int ▁index ; ▁int ▁shift ; ▁uint 64_ t ▁count ; ▁uint 32_ t ▁value ; ▁int ▁lt _ i ; ▁switch ▁( offset ) ▁{ ▁case ▁M CT _ CF G : ▁value ▁= ▁s -> reg _ m ct _ cfg ; ▁break ; ▁case ▁G _ C NT _ L : ▁case ▁G _ C NT _ U : ▁shift ▁= ▁8 ▁* ▁( offset ▁& ▁0 x 4 ); ▁count ▁= ▁ex yn os 42 10_ g f rc _ get _ count 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁the ora _ g pt opts ( AV Format Context ▁* ctx , ▁int ▁idx , ▁uint 64_ t ▁gp , ▁int 64_ t ▁* d ts ) ▁{ ▁struct ▁o gg ▁* og g ▁= ▁ctx -> priv _ data ; ▁struct ▁o gg _ stream ▁* os ▁= ▁o gg -> streams ▁+ ▁idx ; ▁struct ▁the ora _ params ▁* th p ▁= ▁os -> private ; ▁uint 64_ t ▁iframe ▁= ▁gp ▁>> ▁th p -> gp shift ; ▁uint 64_ t ▁p frame ▁= ▁gp ▁& ▁th p -> gp mask ; ▁if ▁( th p -> version ▁< ▁0 x 0 30 201 ) ▁iframe ++; ▁if (! p frame ) ▁os -> p flags ▁|= ▁AV _ PK T _ FLAG _ KEY ; ▁if ▁( d ts ) ▁* d ts ▁= ▁ifr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av _ build _ index _ raw ( AV Format Context ▁* s ) ▁{ ▁AV Packet ▁pkt 1, ▁* pk t ▁= ▁& pk t 1; ▁int ▁ret ; ▁AV Stream ▁* st ; ▁st ▁= ▁s -> streams [0]; ▁av _ read _ frame _ flush ( s ); ▁url _ f seek ( & s -> pb , ▁s -> data _ offset , ▁SE EK _ SET ); ▁for ( ; ;) ▁{ ▁ret ▁= ▁av _ read _ frame ( s , ▁pkt ); ▁if ▁( ret ▁< ▁0) ▁break ; ▁if ▁( pk t -> stream _ index ▁== ▁0 ▁&& ▁st -> parser ▁&& ▁( pk t -> flags ▁& ▁PK T _ FLAG _ KEY )) ▁{ ▁add _ index _ entry ( st , ▁st -> parser -> frame _ of

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁F W Cfg State ▁* bo ch s _ b ios _ init ( void ) ▁{ ▁F W Cfg State ▁* fw _ cfg ; ▁uint 8_ t ▁* s mb ios _ tables , ▁* s mb ios _ anchor ; ▁size _ t ▁smb ios _ tables _ len , ▁smb ios _ anchor _ len ; ▁uint 64_ t ▁* num a _ fw _ cfg ; ▁int ▁i , ▁j ; ▁unsigned ▁int ▁ap ic _ id _ limit ▁= ▁pc _ ap ic _ id _ limit ( max _ cpus ); ▁fw _ cfg ▁= ▁fw _ cfg _ init _ io ( B IOS _ CF G _ IO PORT ); ▁/* ▁F W _ CF G _ MAX _ CP US ▁is ▁a ▁bit ▁confusing / problem atic ▁on ▁x 86 : ▁* ▁* ▁Se a B IOS ▁needs ▁F W 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁mm u _ translate ( CP US 390 X State ▁* env , ▁target _ ulong ▁v addr , ▁int ▁rw , ▁uint 64_ t ▁asc , ▁target _ ulong ▁* r addr , ▁int ▁* flags ) ▁{ ▁int ▁r ▁= ▁-1; ▁uint 8_ t ▁* sk ; ▁* flags ▁= ▁PAGE _ READ ▁| ▁PAGE _ WRITE ▁| ▁PAGE _ EXEC ; ▁v addr ▁&= ▁TARGET _ PAGE _ MASK ; ▁if ▁(! ( env -> p sw . mask ▁& ▁PS W _ MASK _ DAT )) ▁{ ▁* r addr ▁= ▁v addr ; ▁r ▁= ▁0; ▁goto ▁out ; ▁} ▁switch ▁( asc ) ▁{ ▁case ▁PS W _ ASC _ PRI MARY : ▁case ▁PS W _ ASC _ HOME : ▁r ▁= ▁mm u _ translate _ asc ( env , ▁v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁decode _ ac _ coeff s ( Get Bit Context ▁* gb , ▁int 16_ t ▁* out , ▁int ▁blocks _ per _ slice , ▁int ▁plane _ size _ factor , ▁const ▁uint 8_ t ▁* scan ) ▁{ ▁int ▁pos , ▁block _ mask , ▁run , ▁level , ▁sign , ▁run _ cb _ index , ▁lev _ cb _ index ; ▁int ▁max _ coeff s , ▁bits _ left ; ▁/* ▁set ▁initial ▁prediction ▁values ▁*/ ▁run ▁= ▁4; ▁level ▁= ▁2; ▁max _ coeff s ▁= ▁blocks _ per _ slice ▁<< ▁6 ; ▁block _ mask ▁= ▁blocks _ per _ slice ▁- ▁1; ▁for ▁( pos ▁= ▁blocks _ per _ slice ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁local _ op end ir ( Fs Context ▁* ctx , ▁V 9 fs Path ▁* fs _ path , ▁V 9 fs F id Open State ▁* fs ) ▁{ ▁int ▁dir fd ; ▁DIR ▁* stream ; ▁dir fd ▁= ▁local _ op end ir _ n of ollow ( ctx , ▁fs _ path -> data ); ▁if ▁( dir fd ▁== ▁-1) ▁{ ▁return ▁-1; ▁} ▁stream ▁= ▁fd op end ir ( dir fd ); ▁if ▁(! stream ) ▁{ ▁return ▁-1; ▁} ▁fs -> dir . stream ▁= ▁stream ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁m peg _ m ux _ init ( AV Format Context ▁* ctx ) ▁{ ▁M peg M ux Context ▁* s ▁= ▁ctx -> priv _ data ; ▁int ▁bitrate , ▁i , ▁m pa _ id , ▁m pv _ id , ▁ac 3_ id ; ▁AV Stream ▁* st ; ▁Stream Info ▁* stream ; ▁s -> packet _ number ▁= ▁0; ▁s -> is _ v cd ▁= ▁( ctx -> o format ▁== ▁& mpeg 1 v cd _ m ux ); ▁s -> is _ mpeg 2 ▁= ▁( ctx -> o format ▁== ▁& mpeg 2 v ob _ m ux ); ▁if ▁( s -> is _ v cd ) ▁s -> packet _ size ▁= ▁2 32 4; ▁/* ▁V CD ▁packet ▁size ▁*/ ▁else ▁s -> packet _ size ▁= ▁2048 ; ▁/* ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ read _ header ( AV Format Context ▁* s ) ▁{ ▁M XF Context ▁* mx f ▁= ▁s -> priv _ data ; ▁K LV Packet ▁k lv ; ▁int 64_ t ▁ess ence _ offset ▁= ▁0; ▁int ▁ret ; ▁mx f -> last _ forward _ t ell ▁= ▁INT 64_ MAX ; ▁mx f -> edit _ units _ per _ packet ▁= ▁1; ▁if ▁(! mx f _ read _ sync ( s -> pb , ▁mx f _ header _ partition _ pack _ key , ▁14 )) ▁{ ▁av _ log ( s , ▁AV _ LOG _ ERROR , ▁" could ▁not ▁find ▁header ▁partition ▁pack ▁key \ n "); ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁} ▁av io _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁get _ net _ error _ message ( g int ▁error ) ▁{ ▁H MODULE ▁module ▁= ▁NULL ; ▁g char ▁* ret val ▁= ▁NULL ; ▁w char _ t ▁* msg ▁= ▁NULL ; ▁int ▁flags ; ▁size _ t ▁n chars ; ▁flags ▁= ▁FORMAT _ MESSAGE _ AL LOC ATE _ BUFFER ▁| ▁FORMAT _ MESSAGE _ IGNO RE _ INSERT S ▁| ▁FORMAT _ MESSAGE _ FROM _ SYSTEM ; ▁if ▁( error ▁>= ▁ NER R _ BASE ▁&& ▁error ▁<= ▁MAX _ NER R ) ▁{ ▁module ▁= ▁Load Library Ex W ( L " net msg . dll ", ▁NULL , ▁LOAD _ LIBRARY _ AS _ DATA FILE ); ▁if ▁( module ▁!= ▁NULL ) ▁{ ▁flags ▁|= ▁FOR

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k q emu _ record _ flush ( void ) ▁{ ▁PC Record ▁* r , ▁* r _ next ; ▁int ▁h ; ▁for ( h ▁= ▁0; ▁h ▁< ▁PC _ REC _ HASH _ SIZE ; ▁h ++) ▁{ ▁for ( r ▁= ▁pc _ rec _ hash [ h ]; ▁r ▁!= ▁NULL ; ▁r ▁= ▁r _ next ) ▁{ ▁r _ next ▁= ▁r -> next ; ▁free ( r ); ▁} ▁pc _ rec _ hash [ h ] ▁= ▁NULL ; ▁} ▁nb _ pc _ records ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁iscsi _ allocation map _ set ( I sc si L un ▁* is cs il un , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors ) ▁{ ▁int 64_ t ▁cluster _ num , ▁nb _ clusters ; ▁if ▁( is cs il un -> allocation map ▁== ▁NULL ) ▁{ ▁return ; ▁} ▁cluster _ num ▁= ▁sector _ num ▁/ ▁is cs il un -> cluster _ sect ors ; ▁nb _ clusters ▁= ▁DIV _ ROUND _ UP ( sect or _ num ▁+ ▁nb _ sect ors , ▁is cs il un -> cluster _ sect ors ) ▁- ▁cluster _ num ; ▁bitmap _ set ( is cs il un -> allocation map , ▁cluster _ num , ▁nb _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ exec ( CPU Arch State ▁* env ) ▁{ ▁CPU State ▁* cpu ▁= ▁ENV _ GET _ CPU ( env ); ▁CPU Class ▁* cc ▁= ▁CPU _ GET _ CLASS ( cpu ); ▁# if def ▁TARGET _ I 386 ▁X 86 CPU ▁* x 86_ cpu ▁= ▁X 86_ CPU ( cpu ); ▁# end if ▁int ▁ret , ▁interrupt _ request ; ▁Translation Block ▁* tb ; ▁uint 8_ t ▁* tc _ ptr ; ▁uint ptr _ t ▁next _ tb ; ▁Sync Clock s ▁sc ; ▁/* ▁This ▁must ▁be ▁volatile ▁so ▁it ▁is ▁not ▁trash ed ▁by ▁long j mp () ▁*/ ▁volatile ▁bool ▁have _ tb _ lock ▁= ▁false ; ▁if ▁( cpu -> hal ted ) ▁{ ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ q emu _ str tos z _ metric ( void ) ▁{ ▁const ▁char ▁* str ▁= ▁"1234 5 k "; ▁char ▁* end ptr ▁= ▁NULL ; ▁int 64_ t ▁res ; ▁res ▁= ▁qemu _ str tos z _ metric ( str , ▁& end ptr ); ▁g _ assert _ cmp int ( res , ▁== , ▁12345 000); ▁g _ assert ( end ptr ▁== ▁str ▁+ ▁6 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁RE NAME ( y uv 4 22 pto y uy 2) ( const ▁uint 8_ t ▁* ys rc , ▁const ▁uint 8_ t ▁* us rc , ▁const ▁uint 8_ t ▁* v src , ▁uint 8_ t ▁* dst , ▁long ▁width , ▁long ▁height , ▁long ▁l um Stride , ▁long ▁chrom Stride , ▁long ▁dst Stride ) ▁{ ▁RE NAME ( y uv Plan art oy uy 2) ( ys rc , ▁us rc , ▁v src , ▁dst , ▁width , ▁height , ▁l um Stride , ▁chrom Stride , ▁dst Stride , ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 26 3_ decode _ mb ( M peg Enc Context ▁* s , ▁int 16_ t ▁block [6 ][ 64 ]) ▁{ ▁int ▁cb pc , ▁cb py , ▁i , ▁cb p , ▁pred _ x , ▁pred _ y , ▁mx , ▁my , ▁d quant ; ▁int 16_ t ▁* m ot _ val ; ▁const ▁int ▁xy = ▁s -> mb _ x ▁+ ▁s -> mb _ y ▁* ▁s -> mb _ stride ; ▁int ▁cb pb ▁= ▁0, ▁pb _ mv _ count ▁= ▁0; ▁av _ assert 2 (! s -> h 26 3_ pred ); ▁if ▁( s -> p ict _ type ▁== ▁AV _ PI CT URE _ TYPE _ P ) ▁{ ▁do { ▁if ▁( get _ bits 1( & s -> gb )) ▁{ ▁/* ▁skip ▁mb ▁*/ ▁s -> mb _ in tra ▁= ▁0; ▁for ( i =

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁DEF ( put , ▁pixels 16_ x 2) ( uint 8_ t ▁* block , ▁const ▁uint 8_ t ▁* pixels , ▁ptr diff _ t ▁line _ size , ▁int ▁h ) ▁{ ▁MO V Q _ B FE ( mm 6 ); ▁__ asm __ ▁volatile ( ▁" le a ▁( % 3, ▁% 3), ▁% %" REG _ a " ▁\ n \ t " ▁". p 2 align ▁3 ▁\ n \ t " ▁" 1: ▁\ n \ t " ▁" mov q ▁( % 1), ▁%% mm 0 ▁\ n \ t " ▁" mov q ▁1 ( % 1), ▁%% mm 1 ▁\ n \ t " ▁" mov q ▁( % 1, ▁% 3), ▁%% mm 2 ▁\ n \ t " ▁" mov q ▁1 ( % 1, ▁% 3), ▁%% mm 3 ▁\ n \ t " ▁P AV GB P ( % % mm 0, ▁%% mm 1, ▁%% mm 4, ▁%% mm 2, ▁%% mm 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁register _ save vm ( const ▁char ▁* id str , ▁int ▁instance _ id , ▁int ▁version _ id , ▁Save State Handler ▁* save _ state , ▁Load State Handler ▁* load _ state , ▁void ▁* op aque ) ▁{ ▁Save State Entry ▁* se , ▁** p se ; ▁se ▁= ▁qemu _ m alloc ( size of ( Save State Entry )); ▁if ▁(! se ) ▁return ▁-1; ▁p str c py ( se -> id str , ▁sizeof ( se -> id str ), ▁id str ); ▁se -> instance _ id ▁= ▁( instance _ id ▁== ▁-1) ▁? ▁0 ▁: ▁instance _ id ; ▁se -> version _ id ▁= ▁version _ id ; ▁se -> save _ stat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁arm _ m pt imer _ class _ init ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( k lass ); ▁dc -> real ize ▁= ▁arm _ m pt imer _ real ize ; ▁dc -> v ms d ▁= ▁& vm state _ arm _ m pt imer ; ▁dc -> reset ▁= ▁arm _ m pt imer _ reset ; ▁dc -> no _ user ▁= ▁1; ▁dc -> props ▁= ▁arm _ m pt imer _ properties ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ mb _ c av lc ( H 264 Context ▁* h ){ ▁M peg Enc Context ▁* ▁const ▁s ▁= ▁& h -> s ; ▁const ▁int ▁mb _ xy = ▁s -> mb _ x ▁+ ▁s -> mb _ y * s -> mb _ stride ; ▁int ▁partition _ count ; ▁unsigned ▁int ▁mb _ type , ▁cb p ; ▁int ▁dct 8 x 8_ allowed = ▁h -> pp s . transform _8 x 8_ mode ; ▁s -> d sp . clear _ blocks ( h -> mb ); ▁// FIX ME ▁avoid ▁if ▁already ▁clear ▁( move ▁after ▁skip ▁handl ong ? ▁t printf ( s -> av ctx , ▁" pic :% d ▁mb :% d /% d \ n ", ▁h -> frame _ num , ▁s -> mb _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pci _ default _ write _ config ( PC ID evice ▁* d , ▁uint 32_ t ▁address , ▁uint 32_ t ▁val , ▁int ▁len ) ▁{ ▁int ▁can _ write , ▁i ; ▁uint 32_ t ▁end , ▁addr ; ▁if ▁( len ▁== ▁4 ▁&& ▁(( address ▁>= ▁0 x 10 ▁&& ▁address ▁< ▁0 x 10 ▁+ ▁4 ▁* ▁6) ▁|| ▁( address ▁>= ▁0 x 30 ▁&& ▁address ▁< ▁0 x 34 ))) ▁{ ▁P CI I OR eg ion ▁* r ; ▁int ▁reg ; ▁if ▁( ▁address ▁>= ▁0 x 30 ▁) ▁{ ▁reg ▁= ▁P CI _ ROM _ SL OT ; ▁} else { ▁reg ▁= ▁( address ▁- ▁0 x 10) ▁>> ▁2; ▁} ▁r ▁= ▁& d -> io _ regions [ reg ]; ▁if ▁( r -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ tr ns _ chunk ( AV Codec Context ▁* av ctx , ▁PNG Dec Context ▁* s , ▁uint 32_ t ▁length ) ▁{ ▁int ▁v , ▁i ; ▁if ▁( s -> color _ type ▁== ▁PNG _ COLOR _ TYPE _ PA LET TE ) ▁{ ▁if ▁( length ▁> ▁256 ▁|| ▁! ( s -> state ▁& ▁PNG _ PL TE )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁length ; ▁i ++) ▁{ ▁v ▁= ▁by test ream 2_ get _ byte ( & s -> gb ); ▁s -> palette [ i ] ▁= ▁( s -> palette [ i ] ▁& ▁0 x 00 ffffff ) ▁| ▁( v ▁<< ▁24 ); ▁} ▁} ▁else ▁if ▁( s -> color _ type

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁w v _ get _ value _ integer ( W av pack Frame Context ▁* s , ▁uint 32_ t ▁* crc , ▁int ▁S ) ▁{ ▁unsigned ▁bit ; ▁if ▁( s -> extra _ bits ) ▁{ ▁S ▁<<= ▁s -> extra _ bits ; ▁if ▁( s -> got _ extra _ bits ▁&& ▁get _ bits _ left ( & s -> gb _ extra _ bits ) ▁>= ▁s -> extra _ bits ) ▁{ ▁S ▁|= ▁get _ bits _ long ( & s -> gb _ extra _ bits , ▁s -> extra _ bits ); ▁* crc ▁= ▁* crc ▁* ▁9 ▁+ ▁( S ▁& ▁0 xffff ) ▁* ▁3 ▁+ ▁(( un signed ) S ▁>> ▁16 ); ▁} ▁} ▁bit ▁= ▁( S ▁& ▁s -> and ) ▁| ▁s -> or 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁helper _ ld l ( CP UM IP S State ▁* env , ▁target _ ulong ▁arg 1, ▁target _ ulong ▁arg 2, ▁int ▁mem _ idx ) ▁{ ▁uint 64_ t ▁tmp ; ▁tmp ▁= ▁do _ l bu ( env , ▁arg 2, ▁mem _ idx ); ▁arg 1 ▁= ▁( arg 1 ▁& ▁0 x 00 FFFF FFFF FFFFFF ULL ) ▁| ▁( tmp ▁<< ▁56 ); ▁if ▁( GET _ L MASK 64 ( arg 2) ▁<= ▁6) ▁{ ▁tmp ▁= ▁do _ l bu ( env , ▁GET _ OFFSET ( arg 2, ▁1), ▁mem _ idx ); ▁arg 1 ▁= ▁( arg 1 ▁& ▁0 xFF 00 FFFF FFFF FFFF ULL ) ▁| ▁( tmp ▁<< ▁48 ); ▁} ▁if ▁( GET _ L MASK 64 ( arg 2) ▁<= ▁5) ▁{ ▁tmp ▁= 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁load _ matrix ( M peg Enc Context ▁* s , ▁uint 16_ t ▁matrix 0 [ 64 ], ▁uint 16_ t ▁matrix 1[ 64 ], ▁int ▁in tra ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁64 ; ▁i ++) ▁{ ▁int ▁j ▁= ▁s -> d sp . id ct _ perm utation [ ff _ z ig z ag _ direct [ i ] ]; ▁int ▁v ▁= ▁get _ bits ( & s -> gb , ▁8 ); ▁if ▁( v ▁== ▁0) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" matrix ▁dam aged \ n "); ▁return ▁-1; ▁} ▁if ▁( in tra ▁&& ▁i ▁== ▁0 ▁&& ▁v ▁!= ▁8) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁child _ handler ( int ▁sig ) ▁{ ▁int ▁status ; ▁while ▁( wait pid (-1, ▁& status , ▁W NO H ANG ) ▁> ▁0) ▁/* ▁NOT H ING ▁*/ ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁copy _ from ( Ipv ideo Context ▁* s , ▁AV Frame ▁* src , ▁AV Frame ▁* dst , ▁int ▁delta _ x , ▁int ▁delta _ y ) ▁{ ▁int ▁current _ offset ▁= ▁s -> pixel _ ptr ▁- ▁dst -> data [0]; ▁int ▁motion _ offset ▁= ▁current _ offset ▁+ ▁delta _ y ▁* ▁dst -> lines ize [0] ▁+ ▁delta _ x ▁* ▁(1 ▁+ ▁s -> is _16 b pp ); ▁if ▁( m otion _ offset ▁< ▁0) ▁{ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" ▁Inter play ▁video : ▁motion ▁offset ▁< ▁0 ▁( % d )\ n ", ▁motion _ offset ); ▁return ▁A VER ROR _ IN V AL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁im x _ ep it _ reset ( Device State ▁* dev ) ▁{ ▁IM X EP IT State ▁* s ▁= ▁IM X _ EP IT ( dev ); ▁/* ▁* ▁Soft ▁reset ▁doesn ' t ▁touch ▁some ▁bits ; ▁hard ▁reset ▁clears ▁them ▁*/ ▁s -> cr ▁&= ▁( CR _ EN | CR _ EN MOD | CR _ ST OPEN | CR _ DO Z EN | CR _ WAIT EN | CR _ DB GEN ); ▁s -> sr ▁= ▁0; ▁s -> lr ▁= ▁T IMER _ MAX ; ▁s -> cmp ▁= ▁0; ▁s -> cnt ▁= ▁0; ▁/* ▁stop ▁both ▁timers ▁*/ ▁p timer _ stop ( s -> timer _ cmp ); ▁p timer _ stop ( s -> timer _ reload ); ▁/* ▁compute ▁new ▁frequency ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁quit _ tim ers ( void ) ▁{ ▁alarm _ timer -> stop ( alarm _ timer ); ▁alarm _ timer ▁= ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁b dr v _ aligned _ p write v ( B dr v Child ▁* child , ▁B dr v Track ed Request ▁* req , ▁int 64_ t ▁offset , ▁unsigned ▁int ▁bytes , ▁int 64_ t ▁align , ▁Q EM UI O Vector ▁* q io v , ▁int ▁flags ) ▁{ ▁Block Driver State ▁* bs ▁= ▁child -> bs ; ▁Block Driver ▁* dr v ▁= ▁bs -> dr v ; ▁bool ▁wait ed ; ▁int ▁ret ; ▁int 64_ t ▁end _ sect or ▁= ▁DIV _ ROUND _ UP ( offset ▁+ ▁bytes , ▁B DR V _ SE CTOR _ SIZE ); ▁uint 64_ t ▁bytes _ remaining ▁= ▁bytes ; ▁int ▁max _ transfer ; ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Block Driver A IO CB ▁* raw _ a io _ read ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors , ▁Block Driver Completion Func ▁* cb , ▁void ▁* op aque ) ▁{ ▁Raw A IO CB ▁* ac b ; ▁/* ▁* ▁If ▁O _ DIRECT ▁is ▁used ▁and ▁the ▁buffer ▁is ▁not ▁aligned ▁fall ▁back ▁* ▁to ▁synchronous ▁IO . ▁*/ ▁B DR V Raw State ▁* s ▁= ▁bs -> op aque ; ▁if ▁( un likely ( s -> aligned _ buf ▁!= ▁NULL ▁&& ▁(( uint ptr _ t ) ▁buf ▁% ▁512 ))) ▁{ ▁Q EM UB H ▁* b h ; ▁ac b ▁= ▁qem

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁coroutine _ fn ▁b dr v _ co _ do _ read v ( B dr v Child ▁* child , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁Q EM UI O Vector ▁* q io v , ▁B dr v Request Flags ▁flags ) ▁{ ▁if ▁( nb _ sect ors ▁< ▁0 ▁|| ▁nb _ sect ors ▁> ▁B DR V _ REQUEST _ MAX _ SE CT ORS ) ▁{ ▁return ▁- E IN VAL ; ▁} ▁return ▁b dr v _ co _ p read v ( child -> bs , ▁sector _ num ▁<< ▁B DR V _ SE CTOR _ BITS , ▁nb _ sect ors ▁<< ▁B DR V _ SE CTOR _ BITS , ▁q io v , ▁flags ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sig ch ld _ handler ( int ▁signal ) ▁{ ▁qemu _ b h _ schedule ( sig ch ld _ b h ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁P ES Context ▁* add _ p es _ stream ( M peg TS Context ▁* ts , ▁int ▁pid , ▁int ▁p cr _ pid , ▁int ▁stream _ type ) ▁{ ▁M peg TS Filter ▁* t ss ; ▁P ES Context ▁* p es ; ▁/* ▁if ▁no ▁pid ▁found , ▁then ▁add ▁a ▁pid ▁context ▁*/ ▁p es ▁= ▁av _ m alloc z ( size of ( PE S Context )); ▁if ▁(! p es ) ▁return ▁0; ▁p es -> ts ▁= ▁ts ; ▁p es -> stream ▁= ▁ts -> stream ; ▁p es -> pid ▁= ▁pid ; ▁p es -> pc r _ pid ▁= ▁p cr _ pid ; ▁p es -> stream _ type ▁= ▁stream _ type ; ▁p es -> state ▁= ▁M PEG TS _ SK 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁m peg _ m otion _ internal ( M peg Enc Context ▁* s , ▁uint 8_ t ▁* dest _ y , ▁uint 8_ t ▁* dest _ cb , ▁uint 8_ t ▁* dest _ cr , ▁int ▁field _ based , ▁int ▁bottom _ field , ▁int ▁field _ select , ▁uint 8_ t ▁** ref _ picture , ▁op _ pixels _ func ▁(* pix _ op ) [4 ], ▁int ▁motion _ x , ▁int ▁motion _ y , ▁int ▁h , ▁int ▁is _ mpeg 12, ▁int ▁mb _ y ) ▁{ ▁uint 8_ t ▁* ptr _ y , ▁* ptr _ cb , ▁* ptr _ cr ; ▁int ▁d xy , ▁uv d xy , ▁mx , ▁my , ▁src _ x , ▁src _ y , ▁uv src _ x , ▁uv src _ y , ▁v _ edg

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁s 39 0_ virt io _ irq ( S 390 CPU ▁* cpu , ▁int ▁config _ change , ▁uint 64_ t ▁token ) ▁{ ▁if ▁( k vm _ enabled ()) ▁{ ▁k vm _ s 39 0_ virt io _ irq ( cpu , ▁config _ change , ▁token ); ▁} ▁else ▁{ ▁cpu _ inject _ ext ( cpu , ▁VI RT IO _ EXT _ CODE , ▁config _ change , ▁token ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v ble _ unpack ( V BLE Context ▁* ctx , ▁Get Bit Context ▁* gb ) ▁{ ▁int ▁i ; ▁static ▁const ▁uint 8_ t ▁L UT [ 256 ] ▁= ▁{ ▁8, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, 4, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, ▁5, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, 4, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, ▁6, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, 4, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, ▁5, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, 4, 0,1, 0, 2, 0,1, 0, 3, 0,1, 0, 2, 0,1, 0, ▁7, 0,1, 0, 2, 0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff url _ alloc ( URL Context ▁** pu c , ▁const ▁char ▁* filename , ▁int ▁flags , ▁const ▁AV IO Interrupt CB ▁* int _ cb ) ▁{ ▁URL Protocol ▁* up ▁= ▁NULL ; ▁char ▁proto _ str [ 128 ], ▁proto _ nested [ 128 ], ▁* ptr ; ▁size _ t ▁proto _ len ▁= ▁str sp n ( filename , ▁URL _ SCHEME _ CHARS ); ▁if ▁( filename [ proto _ len ] ▁!= ▁' :' ▁|| ▁is _ dos _ path ( filename )) ▁str c py ( proto _ str , ▁" file "); ▁else ▁av _ str lc py ( proto _ str , ▁filename , ▁FF MIN ( proto _ len ▁+ ▁1, ▁sizeof ( proto _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Block Driver State ▁* b dr v _ next ( Block Driver State ▁* bs ) ▁{ ▁if ▁(! bs ) ▁{ ▁return ▁Q TAIL Q _ FIRST ( & b dr v _ states ); ▁} ▁return ▁Q TAIL Q _ NEXT ( bs , ▁device _ list ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁m cf _ u art _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁m cf _ u art _ state ▁* s ▁= ▁( m cf _ u art _ state ▁* ) op aque ; ▁switch ▁( addr ▁& ▁0 x 3 f ) ▁{ ▁case ▁0 x 00 : ▁s -> mr [ s -> current _ mr ] ▁= ▁val ; ▁s -> current _ mr ▁= ▁1; ▁break ; ▁case ▁0 x 04 : ▁/* ▁CS R ▁is ▁ignored . ▁*/ ▁break ; ▁case ▁0 x 08 : ▁/* ▁Command ▁Register . ▁*/ ▁m cf _ do _ command ( s , ▁val ); ▁break ; ▁case ▁0 x 0 c : ▁/* ▁Trans mit ▁Buffer . ▁*/ ▁s -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Mem Tx Attrs ▁k vm _ arch _ post _ run ( CPU State ▁* cs , ▁struct ▁k vm _ run ▁* run ) ▁{ ▁ARM CPU ▁* cpu ; ▁uint 32_ t ▁switched _ level ; ▁if ▁( k vm _ irq ch ip _ in _ kernel ()) ▁{ ▁/* ▁* ▁We ▁only ▁need ▁to ▁sync ▁timer ▁states ▁with ▁user - space ▁interrupt ▁* ▁controllers , ▁so ▁return ▁early ▁and ▁save ▁cycles ▁if ▁we ▁don ' t . ▁*/ ▁return ▁ME MT X ATTR S _ UN SPE CIFIED ; ▁} ▁cpu ▁= ▁ARM _ CPU ( cs ); ▁/* ▁Synchron ize ▁our ▁shadow ed ▁in - kernel ▁device ▁irq ▁lines ▁with ▁the ▁k vm ▁ones ▁*/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁av i _ write _ trail er ( AV Format Context ▁* s ) ▁{ ▁A VI Context ▁* avi ▁= ▁s -> priv _ data ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁int ▁res ▁= ▁0; ▁int ▁i , ▁j , ▁n , ▁nb _ frames ; ▁int 64_ t ▁file _ size ; ▁if ▁( pb -> seek able ) ▁{ ▁if ▁( avi -> ri ff _ id ▁== ▁1) ▁{ ▁ff _ end _ tag ( pb , ▁av i -> mov i _ list ); ▁res ▁= ▁av i _ write _ idx 1( s ); ▁ff _ end _ tag ( pb , ▁av i -> ri ff _ start ); ▁} ▁else ▁{ ▁av i _ write _ ix ( s ); ▁ff _ end _ tag ( pb , ▁av i -> mov i _ list ); ▁f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 64_ t ▁o map _ mp ui _ io _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁size ) ▁{ ▁if ▁( size ▁!= ▁2) ▁{ ▁return ▁o map _ bad width _ read 16 ( op aque , ▁addr ); ▁} ▁if ▁( addr ▁== ▁O MAP _ MP UI _ BASE ) ▁/* ▁C MR ▁*/ ▁return ▁0 x fe 4 d ; ▁O MAP _ BAD _ REG ( addr ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nam _ write b ▁( void ▁* op aque , ▁uint 32_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁P CI AC 97 Link State ▁* d ▁= ▁opaque ; ▁AC 97 Link State ▁* s ▁= ▁& d -> ac 97 ; ▁d olog ▁(" U ▁nam ▁write b ▁% # x ▁<- ▁% # x \ n ", ▁addr , ▁val ); ▁s -> cas ▁= ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁s 39 0_ f lic _ common _ real ize ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁S 390 F LIC State ▁* fs ▁= ▁S 39 0_ F LIC _ COM MON ( dev ); ▁uint 32_ t ▁max _ batch ▁= ▁fs -> adapter _ routes _ max _ batch ; ▁if ▁( max _ batch ▁> ▁AD AP TER _ RO UTES _ MAX _ G SI ) ▁{ ▁error _ set g ( err p , ▁" f lic ▁property ▁adapter _ routes _ max _ batch ▁too ▁big " ▁" ▁( % d ▁> ▁% d )", ▁max _ batch , ▁AD AP TER _ RO UTES _ MAX _ G SI ); ▁} ▁fs -> a is _ supported ▁= ▁true ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dx va 2_ get _ buffer ( AV Codec Context ▁* s , ▁AV Frame ▁* frame , ▁int ▁flags ) ▁{ ▁InputStream ▁* ist ▁= ▁s -> op aque ; ▁D X VA 2 Context ▁* ctx ▁= ▁ist -> hw accel _ ctx ; ▁return ▁av _ hw frame _ get _ buffer ( ctx -> hw _ frames _ ctx , ▁frame , ▁0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ id ct 8_ add _ c ( uint 8_ t ▁* dst , ▁D CT E LE M ▁* block , ▁int ▁stride ){ ▁int ▁i ; ▁uint 8_ t ▁* cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NE G _ C ROP ; ▁block [0] ▁+= ▁32 ; ▁for ( ▁i ▁= ▁0; ▁i ▁< ▁8 ; ▁i ++ ▁) ▁{ ▁const ▁int ▁a 0 ▁= ▁block [0 + i * 8] ▁+ ▁block [4 + i * 8 ]; ▁const ▁int ▁a 2 ▁= ▁block [0 + i * 8] ▁- ▁block [4 + i * 8 ]; ▁const ▁int ▁a 4 ▁= ▁( block [2 + i * 8] >> 1) ▁- ▁block [6 + i * 8 ]; ▁const ▁int ▁a 6 ▁= ▁( block [6 + i * 8] >> 1) ▁+ ▁block [2 + i * 8 ]; ▁const ▁int ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁do _ load _ d cr ▁( void ) ▁{ ▁target _ ulong ▁val ; ▁if ▁( un likely ( env -> d cr _ env ▁== ▁NULL )) ▁{ ▁if ▁( log level ▁!= ▁0) ▁{ ▁f printf ( log file , ▁" No ▁D CR ▁environment \ n "); ▁} ▁do _ raise _ exception _ err ( EX CP _ PRO GRAM , ▁EX CP _ IN VAL ▁| ▁EX CP _ IN VAL _ IN VAL ); ▁} ▁else ▁if ▁( un likely ( pp c _ d cr _ read ( env -> d cr _ env , ▁T 0, ▁& val ) ▁!= ▁0 )) ▁{ ▁if ▁( log level ▁!= ▁0) ▁{ ▁f printf ( log file , ▁" DC R ▁read ▁error ▁% d ▁% 03 x \ n ", ▁( int ) T 0, ▁( int ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tl b _ set _ page ( CPU Arch State ▁* env , ▁target _ ulong ▁v addr , ▁target _ ph ys _ addr _ t ▁p addr , ▁int ▁prot , ▁int ▁mm u _ idx , ▁target _ ulong ▁size ) ▁{ ▁Memory Region Section ▁* section ; ▁unsigned ▁int ▁index ; ▁target _ ulong ▁address ; ▁target _ ulong ▁code _ address ; ▁uint ptr _ t ▁add end ; ▁C PUT LB Entry ▁* te ; ▁target _ ph ys _ addr _ t ▁i ot lb ; ▁assert ( size ▁>= ▁TARGET _ PAGE _ SIZE ); ▁if ▁( size ▁!= ▁TARGET _ PAGE _ SIZE ) ▁{ ▁tl b _ add _ large _ page ( env , ▁v addr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt l 81 39 _ io _ write b ( void ▁* op aque , ▁uint 8_ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁R TL 81 39 State ▁* s ▁= ▁opaque ; ▁addr ▁&= ▁0 xff ; ▁switch ▁( addr ) ▁{ ▁case ▁MAC 0 ▁... ▁MAC 0 + 5: ▁s -> ph ys [ addr ▁- ▁MAC 0] ▁= ▁val ; ▁break ; ▁case ▁MAC 0 + 6 ▁... ▁MAC 0 + 7: ▁/* ▁reserved ▁*/ ▁break ; ▁case ▁MAR 0 ▁... ▁MAR 0 + 7: ▁s -> mult [ addr ▁- ▁MAR 0] ▁= ▁val ; ▁break ; ▁case ▁Ch ip Cmd : ▁rt l 81 39 _ Ch ip Cmd _ write ( s , ▁val ); ▁break ; ▁case ▁C fg 9 34 6: ▁rt l 81 39 _ Cfg 9 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rv 40 _ h _ weak _ loop _ filter ( uint 8_ t ▁* src , ▁const ▁int ▁stride , ▁const ▁int ▁filter _ p 1, ▁const ▁int ▁filter _ q 1, ▁const ▁int ▁alpha , ▁const ▁int ▁beta , ▁const ▁int ▁lim _ p 0 q 0, ▁const ▁int ▁lim _ q 1, ▁const ▁int ▁lim _ p 1) ▁{ ▁rv 40 _ weak _ loop _ filter ( src , ▁stride , ▁1, ▁filter _ p 1, ▁filter _ q 1, ▁alpha , ▁beta , ▁lim _ p 0 q 0, ▁lim _ q 1, ▁lim _ p 1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ sub frame ( W mall Decode Ctx ▁* s ) ▁{ ▁int ▁offset ▁= ▁s -> samples _ per _ frame ; ▁int ▁sub frame _ len ▁= ▁s -> samples _ per _ frame ; ▁int ▁total _ samples ▁= ▁s -> samples _ per _ frame ▁* ▁s -> num _ channels ; ▁int ▁i , ▁j , ▁raw pc m _ tile , ▁padding _ zero es , ▁res ; ▁s -> sub frame _ offset ▁= ▁get _ bits _ count ( & s -> gb ); ▁/* ▁reset ▁channel ▁context ▁and ▁find ▁the ▁next ▁block ▁offset ▁and ▁size ▁== ▁the ▁next ▁block ▁of ▁the ▁channel ▁with ▁the ▁smallest ▁num

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁RE NAME ( y uv 2 rgb 565 _1 )( Sw s Context ▁* c , ▁const ▁int 16_ t ▁* buf 0, ▁const ▁int 16_ t ▁* ub uf [2], ▁const ▁int 16_ t ▁* bg uf [2], ▁const ▁int 16_ t ▁* ab uf 0, ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁u val pha , ▁int ▁y ) ▁{ ▁const ▁int 16_ t ▁* ub uf 0 ▁= ▁u buf [0], ▁* ub uf 1 ▁= ▁u buf [1]; ▁const ▁int 16_ t ▁* buf 1= ▁buf 0; ▁// FIX ME ▁needed ▁for ▁RGB 1/ B GR 1 ▁if ▁( u val pha ▁< ▁2048 ) ▁{ ▁// ▁note ▁this ▁is ▁not ▁correct ▁( shift s ▁chrom in ance ▁by ▁0.5 ▁pixels ) ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h mp _ mem char _ write ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁uint 32_ t ▁size ; ▁const ▁char ▁* ch ard ev ▁= ▁q dict _ get _ str ( q dict , ▁" device "); ▁const ▁char ▁* data ▁= ▁q dict _ get _ str ( q dict , ▁" data "); ▁Error ▁* err p ▁= ▁NULL ; ▁size ▁= ▁str len ( data ); ▁q mp _ mem char _ write ( ch ard ev , ▁size , ▁data , ▁false , ▁0, ▁& err p ); ▁h mp _ handle _ error ( mon , ▁& err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁do _ bit _ allocation ( AC 3 Decode Context ▁* ctx , ▁int ▁flags ) ▁{ ▁ac 3_ audio _ block ▁* ab ▁= ▁& ctx -> audio _ block ; ▁int ▁i , ▁sn ro ff st ▁= ▁0; ▁if ▁(! flags ) ▁/* ▁bit ▁allocation ▁is ▁not ▁required ▁*/ ▁return ▁0; ▁if ▁( ab -> flags ▁& ▁AC 3_ AB _ SN RO FF ST E ) ▁{ ▁/* ▁check ▁whether ▁sn ro ff st s ▁are ▁zero ▁*/ ▁sn ro ff st ▁+= ▁ab -> cs n ro ff st ; ▁if ▁( ab -> flags ▁& ▁AC 3_ AB _ CP LI NU ) ▁sn ro ff st ▁+= ▁ab -> c pl fs n ro ff st ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ctx -> b si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ drive _ backup ( const ▁char ▁* device , ▁const ▁char ▁* target , ▁bool ▁has _ format , ▁const ▁char ▁* format , ▁enum ▁M irror Sync Mode ▁sync , ▁bool ▁has _ mode , ▁enum ▁New Image Mode ▁mode , ▁bool ▁has _ speed , ▁int 64_ t ▁speed , ▁bool ▁has _ on _ source _ error , ▁Block dev OnError ▁on _ source _ error , ▁bool ▁has _ on _ target _ error , ▁Block dev OnError ▁on _ target _ error , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁Block Driver State ▁* target _ bs ; ▁Block Driver Stat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁m al ta _ f pg a _ write ( void ▁* op aque , ▁hw addr ▁addr , ▁uint 64_ t ▁val , ▁unsigned ▁size ) ▁{ ▁Mal ta F PG A State ▁* s ▁= ▁opaque ; ▁uint 32_ t ▁s addr ; ▁s addr ▁= ▁( addr ▁& ▁0 xff fff ); ▁switch ▁( s addr ) ▁{ ▁/* ▁SW ITCH ▁Register ▁*/ ▁case ▁0 x 00 200 : ▁break ; ▁/* ▁J MP RS ▁Register ▁*/ ▁case ▁0 x 00 210 : ▁break ; ▁/* ▁L ED BAR ▁Register ▁*/ ▁case ▁0 x 00 40 8: ▁s -> led s ▁= ▁val ▁& ▁0 xff ; ▁m al ta _ f pg a _ update _ display ( s ); ▁break ; ▁/* ▁ASCII WORD ▁Register ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁revert _ channel _ c orrelation ( AL S Dec Context ▁* ctx , ▁A LS Block Data ▁* bd , ▁A LS Channel Data ▁** cd , ▁int ▁* re vert ed , ▁unsigned ▁int ▁offset , ▁int ▁c ) ▁{ ▁A LS Channel Data ▁* ch ▁= ▁cd [ c ]; ▁unsigned ▁int ▁dep ▁= ▁0; ▁unsigned ▁int ▁channels ▁= ▁ctx -> av ctx -> channels ; ▁if ▁( re vert ed [ c ]) ▁return ▁0; ▁revert ed [ c ] ▁= ▁1; ▁while ▁( dep ▁< ▁channels ▁&& ▁! ch [ dep ]. stop _ flag ) ▁{ ▁revert _ channel _ c orrelation ( ctx , ▁bd , ▁cd , ▁revert ed , ▁offset , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ hp et ( G Array ▁* table _ data , ▁G Array ▁* link er ) ▁{ ▁Ac pi 20 H pet ▁* hp et ; ▁hp et ▁= ▁ac pi _ data _ push ( table _ data , ▁sizeof (* hp et )); ▁/* ▁Note ▁timer _ block _ id ▁value ▁must ▁be ▁kept ▁in ▁sync ▁with ▁value ▁advert ised ▁by ▁* ▁em ulated ▁hp et ▁*/ ▁hp et -> timer _ block _ id ▁= ▁cpu _ to _ le 32 (0 x 80 86 a 201 ); ▁hp et -> addr . address ▁= ▁cpu _ to _ le 64 ( H PE T _ BASE ); ▁build _ header ( link er , ▁table _ data , ▁( void ▁* ) hp et , ▁" H PE T ", ▁sizeof (* hp e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁down mix _3 f _1 r _ to _ mon o ( float ▁* samples ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁256 ; ▁i ++) ▁{ ▁samples [ i ] ▁+= ▁( samples [ i ▁+ ▁256 ] ▁+ ▁samples [ i ▁+ ▁512 ] ▁+ ▁samples [ i ▁+ ▁768 ]); ▁samples [ i ▁+ ▁256 ] ▁= ▁samples [ i ▁+ ▁512 ] ▁= ▁samples [ i ▁+ ▁768 ] ▁= ▁0; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q sv _ decode _ init ( AV Codec Context ▁* av ctx , ▁Q SV Context ▁* q ) ▁{ ▁const ▁AV Pix F mt Descriptor ▁* desc ; ▁m fx Session ▁session ▁= ▁NULL ; ▁int ▁i op attern ▁= ▁0; ▁m fx Video Param ▁param ▁= ▁{ ▁{ ▁0 ▁} ▁}; ▁int ▁frame _ width ▁= ▁av ctx -> coded _ width ; ▁int ▁frame _ height ▁= ▁av ctx -> coded _ height ; ▁int ▁ret ; ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> sw _ pix _ fmt ); ▁if ▁(! desc ) ▁return ▁A VER ROR _ BUG ; ▁if ▁(! q -> async _ f ifo ) ▁{ ▁q -> async _ f ifo 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁virt io _ pc i _ mod ern _ region _ map ( V irt IO PC I Proxy ▁* proxy , ▁V irt IO PC I Region ▁* region , ▁struct ▁virt io _ pc i _ cap ▁* cap ) ▁{ ▁memory _ region _ add _ sub region ( & proxy -> mod ern _ bar , ▁region -> offset , ▁& region -> mr ); ▁cap -> cfg _ type ▁= ▁region -> type ; ▁cap -> offset ▁= ▁cpu _ to _ le 32 ( region -> offset ); ▁cap -> length ▁= ▁cpu _ to _ le 32 ( memory _ region _ size ( & region -> mr )); ▁virt io _ pc i _ add _ mem _ cap ( proxy , ▁cap ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mix er _ reset ▁( AC 97 Link State ▁* s ) ▁{ ▁uint 8_ t ▁active [ LAST _ INDEX ]; ▁d olog ▁(" mix er _ reset \ n "); ▁mem set ▁( s -> mix er _ data , ▁0, ▁sizeof ▁( s -> mix er _ data )); ▁mem set ▁( active , ▁0, ▁sizeof ▁( active )); ▁mix er _ store ▁( s , ▁AC 97 _ Reset ▁, ▁0 x 0000 ); ▁/* ▁69 40 ▁*/ ▁mix er _ store ▁( s , ▁AC 97 _ Master _ Volume _ Mon o _ M ute ▁, ▁0 x 8 000); ▁mix er _ store ▁( s , ▁AC 97 _ PC _ BE EP _ Volume _ M ute ▁, ▁0 x 0000 ); ▁mix er _ store ▁( s , ▁AC 97 _ Pho

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁b dr v _ pd is card ( Block Driver State ▁* bs , ▁int 64_ t ▁offset , ▁int ▁count ) ▁{ ▁Cor outine ▁* co ; ▁Dis card Co ▁rw co ▁= ▁{ ▁. bs ▁= ▁bs , ▁. offset ▁= ▁offset , ▁. count ▁= ▁count , ▁. ret ▁= ▁NOT _ DONE , ▁}; ▁if ▁( q emu _ in _ cor outine ()) ▁{ ▁/* ▁Fast - path ▁if ▁already ▁in ▁coroutine ▁context ▁*/ ▁b dr v _ pd is card _ co _ entry ( & rw co ); ▁} ▁else ▁{ ▁A io Context ▁* a io _ context ▁= ▁b dr v _ get _ a io _ context ( bs ); ▁co ▁= ▁qemu _ cor outine _ create ( b dr v _ pd is car

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁HEL PER ( st by _ b )( CPU HP PA State ▁* env , ▁target _ ulong ▁addr , ▁target _ ulong ▁val ) ▁{ ▁uint ptr _ t ▁ra ▁= ▁GET PC (); ▁switch ▁( addr ▁& ▁3) ▁{ ▁case ▁3: ▁cpu _ st b _ data _ ra ( env , ▁addr , ▁val , ▁ra ); ▁break ; ▁case ▁2: ▁cpu _ st w _ data _ ra ( env , ▁addr , ▁val , ▁ra ); ▁break ; ▁case ▁1: ▁/* ▁The ▁3 ▁byte ▁store ▁must ▁appear ▁atomic . ▁*/ ▁if ▁( parallel _ cpus ) ▁{ ▁atomic _ store _3 ( env , ▁addr , ▁val , ▁0 x 00 ffffff u , ▁ra ); ▁} ▁else ▁{ ▁cpu _ st b _ data _ ra ( env

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ image _ check _ sar ( un signed ▁int ▁w , ▁unsigned ▁int ▁h , ▁AV R ational ▁s ar ) ▁{ ▁int 64_ t ▁scaled _ dim ; ▁if ▁(! sar . den ) ▁return ▁A VER ROR ( E IN VAL ); ▁if ▁(! sar . num ▁|| ▁s ar . num ▁== ▁s ar . den ) ▁return ▁0; ▁if ▁( sar . num ▁< ▁s ar . den ) ▁scaled _ dim ▁= ▁av _ res cale _ r nd ( w , ▁s ar . num , ▁s ar . den , ▁AV _ ROUND _ ZERO ); ▁else ▁scaled _ dim ▁= ▁av _ res cale _ r nd ( h , ▁s ar . den , ▁s ar . num , ▁AV _ ROUND _ ZERO ); ▁if ▁( scaled _ dim ▁> ▁0) ▁return ▁0;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ gray _ bit stream ( HY uv Context ▁* s , ▁int ▁count ) ▁{ ▁int ▁i ; ▁OPEN _ RE ADER ( re , ▁& s -> gb ); ▁count ▁/= ▁2; ▁if ▁( count ▁>= ▁( get _ bits _ left ( & s -> gb )) ▁/ ▁( 32 ▁* ▁2 )) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁count ▁&& ▁get _ bits _ left ( & s -> gb ) ▁> ▁0; ▁i ++) ▁{ ▁READ _2 PI X ( s -> temp [0] [2 ▁* ▁i ], ▁s -> temp [0] [2 ▁* ▁i ▁+ ▁1], ▁0); ▁} ▁} ▁else ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁count ; ▁i ++) ▁{ ▁READ _2 PI X ( s -> temp [0] [2 ▁* ▁i ], ▁s -> temp [0] [2 ▁* ▁i ▁+ ▁1]

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁memory _ region _ des truct or _ alias ( Memory Region ▁* mr ) ▁{ ▁memory _ region _ un ref ( mr -> alias ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁p pc _ hash 64_ handle _ mm u _ fault ( Power PC CPU ▁* cpu , ▁target _ ulong ▁e addr , ▁int ▁r wx , ▁int ▁mm u _ idx ) ▁{ ▁CPU State ▁* cs ▁= ▁CPU ( cpu ); ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁p pc _ sl b _ t ▁* sl b ; ▁hw addr ▁p te _ offset ; ▁p pc _ hash _ pt e 64_ t ▁p te ; ▁int ▁pp _ prot , ▁am r _ prot , ▁prot ; ▁uint 64_ t ▁new _ pt e 1; ▁const ▁int ▁need _ prot [] ▁= ▁{ PAGE _ READ , ▁PAGE _ WRITE , ▁PAGE _ EXEC }; ▁hw addr ▁r addr ; ▁assert (( r wx ▁== ▁0) ▁|| ▁( r wx ▁== ▁1) ▁|| ▁( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pc x _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁PC X Context ▁* ▁const ▁s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁AV Frame ▁* ▁const ▁p ▁= ▁& s -> picture ; ▁int ▁compressed , ▁xmin , ▁ymin , ▁xmax , ▁ymax ; ▁unsigned ▁int ▁w , ▁h , ▁bits _ per _ pixel , ▁bytes _ per _ line , ▁n plan es , ▁stride , ▁y , ▁x , ▁bytes _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q emu Opts ▁* q emu _ opts _ from _ q dict ( Q emu Opts List ▁* list , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁Q emu Opts ▁* opts ; ▁opts ▁= ▁qemu _ opts _ create ( list , ▁q dict _ get _ try _ str ( q dict , ▁" id "), ▁1); ▁if ▁( opts ▁== ▁NULL ) ▁return ▁NULL ; ▁q dict _ iter ( q dict , ▁qemu _ opts _ from _ q dict _1, ▁opts ); ▁return ▁opts ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁conditional _ branch ( DB D MA _ channel ▁* ch ) ▁{ ▁db d ma _ cmd ▁* current ▁= ▁& ch -> current ; ▁uint 16_ t ▁br ; ▁uint 16_ t ▁sel _ mask , ▁sel _ value ; ▁uint 32_ t ▁status ; ▁int ▁cond ; ▁DB D MA _ DP RI NT F (" conditional _ branch \ n "); ▁/* ▁check ▁if ▁we ▁must ▁branch ▁*/ ▁br ▁= ▁le 16_ to _ cpu ( current -> command ) ▁& ▁BR _ MASK ; ▁switch ( br ) ▁{ ▁case ▁BR _ NE VER : ▁/* ▁don ' t ▁branch ▁*/ ▁next ( ch ); ▁return ; ▁case ▁BR _ AL WAYS : ▁/* ▁always ▁branch ▁*/ ▁branch ( ch 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁de quant ization _ int ( int ▁x , ▁int ▁y , ▁J peg 2000 C blk ▁* c blk , ▁J peg 2000 Component ▁* comp , ▁J peg 2000 T 1 Context ▁* t 1, ▁J peg 2000 Band ▁* band ) ▁{ ▁int ▁i , ▁j ; ▁int ▁w ▁= ▁c blk -> coord [0] [1] ▁- ▁c blk -> coord [0] [0]; ▁for ▁( j ▁= ▁0; ▁j ▁< ▁( c blk -> coord [1] [1] ▁- ▁c blk -> coord [1] [0]); ▁++ j ) ▁{ ▁int 32_ t ▁* data p ▁= ▁& comp -> i _ data [( comp -> coord [0] [1] ▁- ▁comp -> coord [0] [0]) ▁* ▁( y ▁+ ▁j ) ▁+ ▁x ]; ▁int ▁* src ▁= ▁t 1 -> data [ j ]; ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gdb _ accept ( void ) ▁{ ▁G DB State ▁* s ; ▁struct ▁sock addr _ in ▁sock addr ; ▁sock len _ t ▁len ; ▁int ▁fd ; ▁for ( ; ;) ▁{ ▁len ▁= ▁sizeof ( sock addr ); ▁fd ▁= ▁accept ( g db server _ fd , ▁( struct ▁sock addr ▁* ) & sock addr , ▁& len ); ▁if ▁( fd ▁< ▁0 ▁&& ▁errno ▁!= ▁E INT R ) ▁{ ▁per ror (" accept "); ▁return ; ▁} ▁else ▁if ▁( fd ▁>= ▁0) ▁{ ▁# if nd ef ▁_ W IN 32 ▁fcntl ( fd , ▁F _ SET FD , ▁F D _ CLO EXEC ); ▁# end if ▁break ; ▁} ▁} ▁/* ▁set ▁short ▁latency ▁*/ ▁socket _ set _ n 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁va api _ encode _ h 26 5_ init _ sequence _ params ( AV Codec Context ▁* av ctx ) ▁{ ▁V A API Encode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁V A Enc Sequence Parameter Buffer HE VC ▁* v seq ▁= ▁ctx -> codec _ sequence _ params ; ▁V A Enc Picture Parameter Buffer HE VC ▁* v pic ▁= ▁ctx -> codec _ picture _ params ; ▁V A API Encode H 265 Context ▁* priv ▁= ▁ctx -> priv _ data ; ▁V A API Encode H 265 M isc Sequence Params ▁* m seq ▁= ▁& priv -> misc _ sequence _ params ; ▁int ▁i ; ▁{ ▁// ▁g

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rd ft _ calc _ c ( R DF T Context ▁* s , ▁FFT Sample ▁* data ) ▁{ ▁int ▁i , ▁i 1, ▁i 2; ▁FFT Complex ▁ev , ▁od ; ▁const ▁int ▁n ▁= ▁1 ▁<< ▁s -> nb its ; ▁const ▁float ▁k 1 ▁= ▁0.5 ; ▁const ▁float ▁k 2 ▁= ▁0.5 ▁- ▁s -> inverse ; ▁const ▁FFT Sample ▁* tc os ▁= ▁s -> tc os ; ▁const ▁FFT Sample ▁* ts in ▁= ▁s -> ts in ; ▁if ▁(! s -> inverse ) ▁{ ▁s -> fft . fft _ perm ute ( & s -> fft , ▁( FF T Complex *) data ); ▁s -> fft . fft _ calc ( & s -> fft , ▁( FF T Complex *) data ); ▁} ▁/* ▁i =0 ▁is 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁g 7 26 _ init ( AV Codec Context ▁* ▁av ctx ) ▁{ ▁AV G 7 26 Context * ▁c ▁= ▁( AV G 7 26 Context *) av ctx -> priv _ data ; ▁unsigned ▁int ▁index = ▁( av ctx -> bit _ rate ▁+ ▁av ctx -> sample _ rate / 2) ▁/ ▁av ctx -> sample _ rate ▁- ▁2; ▁if ▁( ▁( av ctx -> bit _ rate ▁!= ▁16 000 ▁&& ▁av ctx -> bit _ rate ▁!= ▁24 000 ▁&& ▁av ctx -> bit _ rate ▁!= ▁32 000 ▁&& ▁av ctx -> bit _ rate ▁!= ▁4 0000 )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" G 7 26 : ▁unsupported ▁audio ▁format 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁unsigned ▁long ▁find _ next _ zero _ bit ( const ▁unsigned ▁long ▁* addr , ▁unsigned ▁long ▁size , ▁unsigned ▁long ▁offset ) ▁{ ▁const ▁unsigned ▁long ▁* p ▁= ▁addr ▁+ ▁BIT OP _ WORD ( offset ); ▁unsigned ▁long ▁result ▁= ▁offset ▁& ▁~ ( BITS _ PER _ LONG -1 ); ▁unsigned ▁long ▁tmp ; ▁if ▁( offset ▁>= ▁size ) ▁{ ▁return ▁size ; ▁} ▁size ▁-= ▁result ; ▁offset ▁% = ▁B ITS _ PER _ LONG ; ▁if ▁( offset ) ▁{ ▁tmp ▁= ▁* ( p ++ ); ▁tmp ▁|= ▁~ 0 UL ▁>> ▁( BITS _ PER _ LONG ▁- ▁offset ); ▁if ▁( size ▁< ▁B ITS _ P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁visit _ end _ implicit _ struct ( Visitor ▁* v , ▁Error ▁** err p ) ▁{ ▁assert (! error _ is _ set ( err p )); ▁if ▁( v -> end _ implicit _ struct ) ▁{ ▁v -> end _ implicit _ struct ( v , ▁err p ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ reject _ length ( N BD Client ▁* client , ▁bool ▁fatal , ▁Error ▁** err p ) ▁{ ▁int ▁ret ; ▁assert ( client -> opt len ); ▁if ▁( nb d _ drop ( client -> i oc , ▁client -> opt len , ▁err p ) ▁< ▁0) ▁{ ▁return ▁- E IO ; ▁} ▁ret ▁= ▁nb d _ neg ot iate _ send _ rep _ err ( client , ▁N BD _ REP _ ERR _ INVALID , ▁err p , ▁" option ▁'% s ' ▁should ▁have ▁zero ▁length ", ▁nb d _ opt _ lookup ( client -> opt )); ▁if ▁( f atal ▁&& ▁! ret ) ▁{ ▁error _ set g ( err p , ▁" option ▁'% s ' ▁should 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm pp c _ read _ host _ property ( const ▁char ▁* node _ path , ▁const ▁char ▁* prop , ▁void ▁* val , ▁size _ t ▁len ) ▁{ ▁char ▁* path ; ▁FILE ▁* f ; ▁int ▁ret ; ▁int ▁path len ; ▁path len ▁= ▁sn printf ( NULL , ▁0, ▁"% s /% s /% s ", ▁PRO C _ DE VT REE _ PATH , ▁node _ path , ▁prop ) ▁+ ▁1; ▁path ▁= ▁qemu _ m alloc ( path len ); ▁if ▁( path ▁== ▁NULL ) ▁{ ▁ret ▁= ▁- EN O ME M ; ▁goto ▁out ; ▁} ▁sn printf ( path , ▁path len , ▁"% s /% s /% s ", ▁PRO C _ DE VT REE _ PATH , ▁node _ path , ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ q emu _ ld ( TC G Context ▁* s , ▁TC G Reg ▁data , ▁TC G Reg ▁addr , ▁TC G Mem Op Idx ▁o i , ▁bool ▁is _64 ) ▁{ ▁TC G Mem Op ▁mem op ▁= ▁get _ mem op ( oi ); ▁# if def ▁CONFIG _ SO FT MM U ▁unsigned ▁mem i ▁= ▁get _ mm uid x ( oi ); ▁TC G Reg ▁addr z , ▁param ; ▁tc g _ ins n _ unit ▁* func ; ▁tc g _ ins n _ unit ▁* label _ ptr ; ▁addr z ▁= ▁tc g _ out _ tl b _ load ( s , ▁addr , ▁mem i , ▁mem op , ▁offset of ( CP UT LB Entry , ▁addr _ read )); ▁/* ▁The ▁fast ▁path ▁is ▁exactly 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁opts _ visitor _ cleanup ( Opts Visitor ▁* ov ) ▁{ ▁if ▁( ov -> un processed _ opts ▁!= ▁NULL ) ▁{ ▁g _ hash _ table _ destroy ( ov -> un processed _ opts ); ▁} ▁g _ free ( ov -> fake _ id _ opt ); ▁mem set ( ov , ▁'\ 0', ▁sizeof ▁* ov ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ host _ open ( US B Host Device ▁* s , ▁lib usb _ device ▁* dev ) ▁{ ▁USB Device ▁* ud ev ▁= ▁USB _ DEVICE ( s ); ▁int ▁bus _ num ▁= ▁lib usb _ get _ bus _ number ( dev ); ▁int ▁addr ▁= ▁lib usb _ get _ device _ address ( dev ); ▁int ▁rc ; ▁trace _ usb _ host _ open _ started ( bus _ num , ▁addr ); ▁if ▁( s -> dh ▁!= ▁NULL ) ▁{ ▁goto ▁fail ; ▁} ▁rc ▁= ▁lib usb _ open ( dev , ▁& s -> dh ); ▁if ▁( rc ▁!= ▁0) ▁{ ▁goto ▁fail ; ▁} ▁s -> dev ▁= ▁dev ; ▁s -> bus _ num ▁= ▁bus _ num ; ▁s -> add

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int 64_ t ▁x bz r le _ cache _ resize ( int 64_ t ▁new _ size , ▁Error ▁** err p ) ▁{ ▁Page Cache ▁* new _ cache ; ▁int 64_ t ▁ret ; ▁/* ▁Check ▁for ▁trunc ation ▁*/ ▁if ▁( new _ size ▁!= ▁( size _ t ) new _ size ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER _ VALUE , ▁" cache ▁size ", ▁" ex ceed ing ▁address ▁space "); ▁return ▁-1; ▁} ▁/* ▁Cache ▁should ▁not ▁be ▁larger ▁than ▁guest ▁ram ▁size ▁*/ ▁if ▁( new _ size ▁> ▁ram _ bytes _ total ()) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ P

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁setup _ rt _ frame ( int ▁sig , ▁struct ▁target _ sig action ▁* ka , ▁target _ sig info _ t ▁* info , ▁target _ sig set _ t ▁* set , ▁CPU Alpha State ▁* env ) ▁{ ▁abi _ ulong ▁frame _ addr , ▁r 26 ; ▁struct ▁target _ rt _ sig frame ▁* frame ; ▁int ▁i , ▁err ▁= ▁0; ▁frame _ addr ▁= ▁get _ sig frame ( ka , ▁env , ▁sizeof (* frame )); ▁if ▁(! lock _ user _ struct ( VER IFY _ WRITE , ▁frame , ▁frame _ addr , ▁0 )) ▁{ ▁goto ▁give _ sig seg v ; ▁} ▁err ▁|= ▁copy _ sig info _ to _ user ( & frame -

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁im x _ g pt _ reset ( Device State ▁* dev ) ▁{ ▁IM X G PT State ▁* s ▁= ▁IM X _ G PT ( dev ); ▁/* ▁stop ▁timer ▁*/ ▁p timer _ stop ( s -> timer ); ▁/* ▁* ▁Soft ▁reset ▁doesn ' t ▁touch ▁some ▁bits ; ▁hard ▁reset ▁clears ▁them ▁*/ ▁s -> cr ▁&= ▁~ ( G PT _ CR _ EN | G PT _ CR _ EN MOD | G PT _ CR _ ST OPEN | G PT _ CR _ DO Z EN | ▁G PT _ CR _ WAIT EN | G PT _ CR _ DB GEN ); ▁s -> sr ▁= ▁0; ▁s -> pr ▁= ▁0; ▁s -> ir ▁= ▁0; ▁s -> cnt ▁= ▁0; ▁s -> oc r 1 ▁= ▁T IMER _ MAX ; ▁s -> oc r 2 ▁= ▁T IMER

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dy nt icks _ start _ timer ( struct ▁qemu _ alarm _ timer ▁* t ) ▁{ ▁struct ▁sig event ▁ev ; ▁timer _ t ▁host _ timer ; ▁struct ▁sig action ▁act ; ▁sig fill set ( & act . sa _ mask ); ▁act . sa _ flags ▁= ▁0; ▁act . sa _ handler ▁= ▁host _ alarm _ handler ; ▁sig action ( SIG AL RM , ▁& act , ▁NULL ); ▁ev . sig ev _ value . s ival _ int ▁= ▁0; ▁ev . sig ev _ notify ▁= ▁SIG E V _ SIG NAL ; ▁ev . sig ev _ sign o ▁= ▁SIG AL RM ; ▁if ▁( timer _ create ( C LOCK _ RE AL TIME , ▁& ev , ▁& host _ tim

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁s 39 0_ pc i _ generate _ event ( uint 8_ t ▁cc , ▁uint 16_ t ▁p ec , ▁uint 32_ t ▁fh , ▁uint 32_ t ▁fid , ▁uint 64_ t ▁f addr , ▁uint 32_ t ▁e ) ▁{ ▁Se i Container ▁* se i _ cont ▁= ▁g _ m alloc 0( size of ( Se i Container )); ▁S 390 pc i State ▁* s ▁= ▁S 39 0_ PC I _ HOST _ BR ID GE ( ▁object _ resolve _ path ( TYPE _ S 39 0_ PC I _ HOST _ BR ID GE , ▁NULL )); ▁if ▁(! s ) ▁{ ▁return ; ▁} ▁se i _ cont -> fh ▁= ▁fh ; ▁se i _ cont -> f id ▁= ▁fid ; ▁se i _ cont -> cc ▁= ▁cc ; ▁se i _ cont ->

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁c ps r _ write ( CPU ARM State ▁* env , ▁uint 32_ t ▁val , ▁uint 32_ t ▁mask , ▁C PS R Write Type ▁write _ type ) ▁{ ▁uint 32_ t ▁changed _ da if ; ▁if ▁( mask ▁& ▁C PS R _ N Z CV ) ▁{ ▁env -> Z F ▁= ▁(~ val ) ▁& ▁C PS R _ Z ; ▁env -> NF ▁= ▁val ; ▁env -> CF ▁= ▁( val ▁>> ▁29 ) ▁& ▁1; ▁env -> V F ▁= ▁( val ▁<< ▁3) ▁& ▁0 x 8 0000000 ; ▁} ▁if ▁( mask ▁& ▁C PS R _ Q ) ▁env -> Q F ▁= ▁(( val ▁& ▁C PS R _ Q ) ▁!= ▁0); ▁if ▁( mask ▁& ▁C PS R _ T ) ▁env -> thumb ▁= ▁(( val ▁& ▁C PS R _ T ) ▁!= ▁0); ▁if ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ pro be _ n vid ia _ bar 0_ quir k ( V FI OP C ID evice ▁* v dev , ▁int ▁nr ) ▁{ ▁V FI O Qu ir k ▁* quir k ; ▁V FI O Config Mirror Qu ir k ▁* mirror ; ▁if ▁(! vf io _ pc i _ is ( v dev , ▁P CI _ VE ND OR _ ID _ NV ID IA , ▁P CI _ ANY _ ID ) ▁|| ▁! vf io _ is _ v ga ( v dev ) ▁|| ▁nr ▁!= ▁0) ▁{ ▁return ; ▁} ▁quir k ▁= ▁g _ m alloc 0( size of (* quir k )); ▁mirror ▁= ▁quir k -> data ▁= ▁g _ m alloc 0( size of (* mirror )); ▁mirror -> mem ▁= ▁quir k -> mem ▁= ▁g _ m alloc 0( size of ( M

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ ar ith _ compute _ ov ( Dis as Context ▁* ctx , ▁TC G v ▁arg 0, ▁TC G v ▁arg 1, ▁TC G v ▁arg 2, ▁int ▁sub ) ▁{ ▁TC G v ▁t 0 ▁= ▁tc g _ temp _ new (); ▁tc g _ gen _ xor _ tl ( cpu _ ov , ▁arg 0, ▁arg 1); ▁tc g _ gen _ xor _ tl ( t 0, ▁arg 1, ▁arg 2); ▁if ▁( sub ) ▁{ ▁tc g _ gen _ and _ tl ( cpu _ ov , ▁cpu _ ov , ▁t 0); ▁} ▁else ▁{ ▁tc g _ gen _ and c _ tl ( cpu _ ov , ▁cpu _ ov , ▁t 0); ▁} ▁tc g _ temp _ free ( t 0); ▁if ▁( N AR ROW _ MODE ( ctx )) ▁{ ▁tc g _ gen _ ext 32

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁uint 8_ t ▁* buf , ▁int ▁buf _ size ) ▁{ ▁H 264 Context ▁* h ▁= ▁av ctx -> priv _ data ; ▁M peg Enc Context ▁* s ▁= ▁& h -> s ; ▁AV Frame ▁* p ict ▁= ▁data ; ▁int ▁buf _ index ; ▁s -> flags = ▁av ctx -> flags ; ▁s -> flags 2= ▁av ctx -> flags 2; ▁/* ▁no ▁supp lement ary ▁picture ▁*/ ▁if ▁( buf _ size ▁== ▁0) ▁{ ▁return ▁0; ▁} ▁if ( s -> flags & CODE C _ FLAG _ TR UNC ATED ){ ▁int ▁next = ▁find _ frame _ end 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ common _ reset ( CPU State ▁* cpu ) ▁{ ▁CPU Class ▁* cc ▁= ▁CPU _ GET _ CLASS ( cpu ); ▁if ▁( q emu _ log level _ mask ( CPU _ LOG _ RE SET )) ▁{ ▁qemu _ log (" CPU ▁Reset ▁( CPU ▁% d )\ n ", ▁cpu -> cpu _ index ); ▁log _ cpu _ state ( cpu , ▁cc -> reset _ dump _ flags ); ▁} ▁cpu -> interrupt _ request ▁= ▁0; ▁cpu -> hal ted ▁= ▁0; ▁cpu -> mem _ io _ pc ▁= ▁0; ▁cpu -> mem _ io _ v addr ▁= ▁0; ▁cpu -> ic ount _ extra ▁= ▁0; ▁cpu -> ic ount _ dec r . u 32 ▁= ▁0; ▁cpu -> can _ do _ io ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ opts _ foreach ( Q emu Opts List ▁* list , ▁qemu _ opts _ loop func ▁func , ▁void ▁* op aque , ▁int ▁abort _ on _ failure ) ▁{ ▁Q emu Opts ▁* opts ; ▁int ▁rc ▁= ▁0; ▁TA IL Q _ FORE A CH ( opts , ▁& list -> head , ▁next ) ▁{ ▁rc ▁= ▁func ( opts , ▁opaque ); ▁if ▁( abort _ on _ failure ▁&& ▁rc ▁!= ▁0) ▁break ; ▁} ▁return ▁rc ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sub page _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 64_ t ▁value , ▁unsigned ▁len ) ▁{ ▁sub page _ t ▁* mm io ▁= ▁opaque ; ▁unsigned ▁int ▁idx ▁= ▁SUB PAGE _ ID X ( addr ); ▁Memory Region Section ▁* section ; ▁# if ▁defined ( DEBUG _ SUB PAGE ) ▁printf ("% s : ▁sub page ▁% p ▁len ▁% d ▁addr ▁" ▁TARGET _ F MT _ pl x ▁" ▁idx ▁% d ▁value ▁% " PRI x 64" \ n ", ▁__ func __, ▁mm io , ▁len , ▁addr , ▁idx , ▁value ); ▁# end if ▁section ▁= ▁& ph ys _ sections [ mm io -> sub

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nv enc _ find _ free _ reg _ resource ( AV Codec Context ▁* av ctx ) ▁{ ▁N v enc Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁N v enc D yn Load Functions ▁* dl _ fn ▁= ▁& ctx -> nv enc _ d load _ funcs ; ▁NV _ EN CODE _ API _ FUNCTION _ LIST ▁* p _ nv enc ▁= ▁& dl _ fn -> nv enc _ funcs ; ▁int ▁i ; ▁if ▁( ctx -> nb _ registered _ frames ▁== ▁FF _ ARRAY _ E LE MS ( ctx -> registered _ frames )) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ctx -> nb _ registered _ frames ; ▁i ++) ▁{ ▁if ▁(! ctx -> registered _ f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁tb _ flush _ j mp _ cache ( CPU State ▁* cpu , ▁target _ ulong ▁addr ) ▁{ ▁unsigned ▁int ▁i ; ▁/* ▁Dis card ▁jump ▁cache ▁entries ▁for ▁any ▁tb ▁which ▁might ▁potentially ▁overlap ▁the ▁flushed ▁page . ▁*/ ▁i ▁= ▁tb _ j mp _ cache _ hash _ page ( addr ▁- ▁TARGET _ PAGE _ SIZE ); ▁mem set ( & cpu -> tb _ j mp _ cache [ i ], ▁0, ▁TB _ J MP _ PAGE _ SIZE ▁* ▁sizeof ( Translation Block ▁* )); ▁i ▁= ▁tb _ j mp _ cache _ hash _ page ( addr ); ▁mem set ( & cpu -> tb _ j mp _ cache [ i ], ▁0, ▁TB _ J MP _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Device State ▁* b dr v _ get _ attached ( Block Driver State ▁* bs ) ▁{ ▁return ▁bs -> peer ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q api _ de alloc _ push ( Q api De alloc Visitor ▁* q ov , ▁void ▁* value ) ▁{ ▁Stack Entry ▁* e ▁= ▁g _ m alloc 0( size of (* e )); ▁e -> value ▁= ▁value ; ▁/* ▁see ▁if ▁we ' re ▁just ▁pushing ▁a ▁list ▁head ▁tracker ▁*/ ▁if ▁( value ▁== ▁NULL ) ▁{ ▁e -> is _ list _ head ▁= ▁true ; ▁} ▁Q TAIL Q _ INSERT _ HEAD ( & q ov -> stack , ▁e , ▁node ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* vn c _ z lib _ z alloc ( void ▁* x , ▁unsigned ▁items , ▁unsigned ▁size ) ▁{ ▁void ▁* p ; ▁size ▁*= ▁items ; ▁size ▁= ▁( size ▁+ ▁Z AL LOC _ ALIGN MENT ▁- ▁1) ▁& ▁~ ( Z AL LOC _ ALIGN MENT ▁- ▁1); ▁p ▁= ▁qemu _ m alloc z ( size ); ▁return ▁( p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁send _ png _ rect ( V nc State ▁* vs , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h , ▁V nc Palette ▁* palette ) ▁{ ▁png _ byte ▁color _ type ; ▁png _ struct p ▁png _ ptr ; ▁png _ inf op ▁info _ ptr ; ▁png _ color p ▁png _ palette ▁= ▁NULL ; ▁pix man _ image _ t ▁* line buf ; ▁int ▁level ▁= ▁tight _ png _ conf [ vs -> t ight . compression ]. png _ z lib _ level ; ▁int ▁filters ▁= ▁tight _ png _ conf [ vs -> t ight . compression ]. png _ filters ; ▁uint 8_ t ▁* buf ; ▁int ▁dy ; ▁png _ ptr ▁= ▁png _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁nv dim m _ init _ ac pi _ state ( Ac pi NV DI MM State ▁* state , ▁Memory Region ▁* io , ▁F W Cfg State ▁* fw _ cfg , ▁Object ▁* owner ) ▁{ ▁memory _ region _ init _ io ( & state -> io _ mr , ▁owner , ▁& nv dim m _ ds m _ ops , ▁state , ▁" nv dim m - ac pi - io ", ▁NV DI MM _ AC PI _ IO _ LEN ); ▁memory _ region _ add _ sub region ( io , ▁NV DI MM _ AC PI _ IO _ BASE , ▁& state -> io _ mr ); ▁state -> ds m _ mem ▁= ▁g _ array _ new ( false , ▁true ▁/* ▁clear ▁*/ , ▁1); ▁ac pi _ data _ push ( state 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁calculate _ ref counts ( Block Driver State ▁* bs , ▁B dr v Check Result ▁* res , ▁B dr v Check Mode ▁fix , ▁bool ▁* rebuild , ▁void ▁** refcount _ table , ▁int 64_ t ▁* nb _ clusters ) ▁{ ▁B DR V Q c ow 2 State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁i ; ▁Q C ow Snapshot ▁* sn ; ▁int ▁ret ; ▁if ▁(! * refcount _ table ) ▁{ ▁int 64_ t ▁old _ size ▁= ▁0; ▁ret ▁= ▁real loc _ refcount _ array ( s , ▁ref count _ table , ▁& old _ size , ▁* nb _ clusters ); ▁if ▁( ret ▁< ▁0) ▁{ ▁res -> check _ errors 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁eh ci _ trace _ q td ( E H CI Queue ▁* q , ▁target _ ph ys _ addr _ t ▁addr , ▁E H CI q td ▁* q td ) ▁{ ▁trace _ usb _ eh ci _ q td ( q , ▁addr , ▁q td -> next , ▁q td -> al tn ext , ▁get _ field ( q td -> token , ▁Q TD _ TOKEN _ T BYTES ), ▁get _ field ( q td -> token , ▁Q TD _ TOKEN _ CP AGE ), ▁get _ field ( q td -> token , ▁Q TD _ TOKEN _ C ERR ), ▁get _ field ( q td -> token , ▁Q TD _ TOKEN _ PID ), ▁( bool )( q td -> token ▁& ▁Q TD _ TOKEN _ IO C ), ▁( bool )( q td -> token ▁& ▁Q TD _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁meg as as _ sc si _ un init ( PC ID evice ▁* d ) ▁{ ▁M eg as as State ▁* s ▁= ▁ME G AS AS ( d ); ▁if ▁( m eg as as _ use _ ms ix ( s )) ▁{ ▁ms ix _ un init ( d , ▁& s -> mm io _ io , ▁& s -> mm io _ io ); ▁} ▁if ▁( m eg as as _ use _ m si ( s )) ▁{ ▁m si _ un init ( d ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁jpeg 2000 _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁J peg 2000 Decoder Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁Thread Frame ▁frame ▁= ▁{ ▁. f ▁= ▁data ▁}; ▁AV Frame ▁* picture ▁= ▁data ; ▁int ▁t il eno , ▁ret ; ▁s -> av ctx ▁= ▁av ctx ; ▁s -> buf ▁= ▁s -> buf _ start ▁= ▁av pk t -> data ; ▁s -> buf _ end ▁= ▁s -> buf _ start ▁+ ▁av pk t -> size ; ▁s -> cur til eno ▁= ▁0; ▁// ▁TODO : ▁only ▁one ▁tile ▁in ▁D CI ▁JP 2 K .

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vf io _ platform _ eo i ( V FI O Device ▁* v based ev ) ▁{ ▁V FI O INT p ▁* int p ; ▁V FI OP latform Device ▁* v dev ▁= ▁container _ of ( v based ev , ▁V FI OP latform Device , ▁v based ev ); ▁qemu _ mut ex _ lock ( & v dev -> int p _ mut ex ); ▁Q LIST _ FORE A CH ( int p , ▁& v dev -> int p _ list , ▁next ) ▁{ ▁if ▁( int p -> state ▁== ▁V FI O _ IR Q _ ACTIVE ) ▁{ ▁trace _ vf io _ platform _ eo i ( int p -> pin , ▁event _ notifier _ get _ fd ( & int p -> interrupt )); ▁intp -> state ▁= ▁V 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ store q _ reg ( Dis as Context ▁* s , ▁int ▁r low , ▁int ▁r high , ▁TC G v ▁val ) ▁{ ▁TC G v ▁tmp ; ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ trunc _ i 64_ i 32 ( tmp , ▁val ); ▁store _ reg ( s , ▁r low , ▁tmp ); ▁tmp ▁= ▁new _ tmp (); ▁tc g _ gen _ sh ri _ i 64 ( val , ▁val , ▁32 ); ▁tc g _ gen _ trunc _ i 64_ i 32 ( tmp , ▁val ); ▁store _ reg ( s , ▁r high , ▁tmp ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁var arg _ number ( void ) ▁{ ▁Q Object ▁* obj ; ▁Q Int ▁* q int ; ▁Q Float ▁* q float ; ▁int ▁value ▁= ▁0 x 234 2; ▁int 64_ t ▁value 64 ▁= ▁0 x 234 234 234 3 LL ; ▁double ▁value f ▁= ▁2. 32 34 234 23 ; ▁obj ▁= ▁q object _ from _ json f ("% d ", ▁value ); ▁g _ assert ( obj ▁!= ▁NULL ); ▁g _ assert ( q object _ type ( obj ) ▁== ▁Q TYPE _ Q INT ); ▁q int ▁= ▁q object _ to _ q int ( obj ); ▁g _ assert ( q int _ get _ int ( q int ) ▁== ▁value ); ▁Q DE CRE F ( q int ); ▁obj ▁= ▁q object _ from _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁oh ci _ service _ ed _ list ( O H CI State ▁* oh ci , ▁uint 32_ t ▁head , ▁int ▁completion ) ▁{ ▁struct ▁oh ci _ ed ▁ed ; ▁uint 32_ t ▁next _ ed ; ▁uint 32_ t ▁cur ; ▁int ▁active ; ▁active ▁= ▁0; ▁if ▁( head ▁== ▁0) ▁return ▁0; ▁for ▁( cur ▁= ▁head ; ▁cur ; ▁cur ▁= ▁next _ ed ) ▁{ ▁if ▁( oh ci _ read _ ed ( oh ci , ▁cur , ▁& ed )) ▁{ ▁trace _ usb _ oh ci _ ed _ read _ error ( cur ); ▁oh ci _ d ie ( oh ci ); ▁return ▁0; ▁} ▁next _ ed ▁= ▁ed . next ▁& ▁O H CI _ D PT R _ MASK ; ▁if ▁(( ed . hea

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁s 39 0_ pc i _ iom mu _ disable ( S 390 PC I Bus Device ▁* pb dev ) ▁{ ▁memory _ region _ del _ sub region ( & pb dev -> mr , ▁& pb dev -> iom mu _ mr ); ▁object _ un parent ( OBJECT ( & pb dev -> iom mu _ mr )); ▁pb dev -> iom mu _ enabled ▁= ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff url _ connect ( URL Context ▁* uc , ▁AV Dictionary ▁** options ) ▁{ ▁int ▁err ▁= ▁uc -> prot -> url _ open 2 ▁? ▁uc -> prot -> url _ open 2( uc , ▁uc -> filename , ▁uc -> flags , ▁options ) ▁: ▁uc -> prot -> url _ open ( uc , ▁uc -> filename , ▁uc -> flags ); ▁if ▁( err ) ▁return ▁err ; ▁uc -> is _ connected ▁= ▁1; ▁/* ▁We ▁must ▁be ▁careful ▁here ▁as ▁ff url _ seek () ▁could ▁be ▁slow , ▁* ▁for ▁example ▁for ▁http ▁*/ ▁if ▁(( uc -> flags ▁& ▁AV IO _ FLAG _ WRITE ) ▁|| ▁! str cmp ( uc -> prot -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 8_ t ▁sd _ read _ data ( SD State ▁* sd ) ▁{ ▁/* ▁TODO : ▁Append ▁CRC s ▁*/ ▁uint 8_ t ▁ret ; ▁int ▁io _ len ; ▁if ▁(! sd -> b dr v ▁|| ▁! b dr v _ is _ insert ed ( sd -> b dr v ) ▁|| ▁! sd -> enable ) ▁return ▁0 x 00 ; ▁if ▁( sd -> state ▁!= ▁sd _ s ending data _ state ) ▁{ ▁f printf ( stderr , ▁" sd _ read _ data : ▁not ▁in ▁Sending - Data ▁state \ n "); ▁return ▁0 x 00 ; ▁} ▁if ▁( sd -> card _ status ▁& ▁( ADDRESS _ ERROR ▁| ▁W P _ VI OL ATION )) ▁return ▁0 x 00 ; ▁io _ len ▁= ▁( sd -> oc r ▁& ▁(

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ visitor _ out _ int ( Test Output Visitor Data ▁* data , ▁const ▁void ▁* unused ) ▁{ ▁int 64_ t ▁value ▁= ▁- 42 ; ▁Q Object ▁* obj ; ▁visit _ type _ int ( data -> ov , ▁NULL , ▁& value , ▁& error _ abort ); ▁obj ▁= ▁visitor _ get ( data ); ▁g _ assert ( q object _ type ( obj ) ▁== ▁Q TYPE _ Q INT ); ▁g _ assert _ cmp int ( q int _ get _ int ( q object _ to _ q int ( obj )), ▁== , ▁value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁net _ sl ir p _ host f wd _ remove ( Monitor ▁* mon , ▁const ▁char ▁* src _ str ) ▁{ ▁struct ▁in _ addr ▁host _ addr ▁= ▁{ ▁. s _ addr ▁= ▁IN ADDR _ ANY ▁}; ▁int ▁host _ port ; ▁char ▁buf [ 256 ] ▁= ▁""; ▁const ▁char ▁* p ▁= ▁src _ str ; ▁int ▁is _ ud p ▁= ▁0; ▁int ▁n ; ▁if ▁(! sl ir p _ init ed ) ▁{ ▁monitor _ printf ( mon , ▁" user ▁mode ▁network ▁stack ▁not ▁in ▁use \ n "); ▁return ; ▁} ▁if ▁(! src _ str ▁|| ▁! src _ str [0]) ▁goto ▁fail _ syntax ; ▁get _ str _ sep ( buf , ▁sizeof ( buf ), ▁& p 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ co _ read v ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁remaining _ sect ors , ▁Q EM UI O Vector ▁* q io v ) ▁{ ▁B DR V Q c ow State ▁* s ▁= ▁bs -> op aque ; ▁int ▁index _ in _ cluster , ▁n 1; ▁int ▁ret ; ▁int ▁cur _ nr _ sect ors ; ▁/* ▁number ▁of ▁sector s ▁in ▁current ▁iteration ▁*/ ▁uint 64_ t ▁cluster _ offset ▁= ▁0; ▁uint 64_ t ▁bytes _ done ▁= ▁0; ▁Q EM UI O Vector ▁hd _ q io v ; ▁uint 8_ t ▁* cluster _ data ▁= ▁NULL ; ▁qemu _ i ove c _ init ( & hd _ q io v 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ k uk i _ chunk ( AV Format Context ▁* s , ▁int 64_ t ▁size ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ▁= ▁s -> streams [0]; ▁if ▁( size ▁< ▁0 ▁|| ▁size ▁> ▁INT _ MAX ▁- ▁FF _ INPUT _ BUFFER _ P ADDING _ SIZE ) ▁return ▁-1; ▁if ▁( st -> codec -> codec _ id ▁== ▁AV _ CODE C _ ID _ A AC ) ▁{ ▁/* ▁The ▁magic ▁cookie ▁format ▁for ▁A AC ▁is ▁an ▁mp 4 ▁es ds ▁atom . ▁The ▁l av c ▁A AC ▁decoder ▁requires ▁the ▁data ▁from ▁the ▁codec ▁specific ▁description ▁as ▁extr ad ata ▁input

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* q emu _ f open _ rd ma ( RD MA Context ▁* rd ma , ▁const ▁char ▁* mode ) ▁{ ▁Q EM U File RD MA ▁* r ▁= ▁g _ m alloc 0( size of ( Q EM U File RD MA )); ▁if ▁( q emu _ file _ mode _ is _ not _ valid ( mode )) ▁{ ▁return ▁NULL ; ▁} ▁r -> rd ma ▁= ▁rd ma ; ▁if ▁( mode [0] ▁== ▁' w ') ▁{ ▁r -> file ▁= ▁qemu _ f open _ ops ( r , ▁& rd ma _ write _ ops ); ▁} ▁else ▁{ ▁r -> file ▁= ▁qemu _ f open _ ops ( r , ▁& rd ma _ read _ ops ); ▁} ▁return ▁r -> file ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ cod est ream ( J 2 k Decoder Context ▁* s ) ▁{ ▁J 2 k Coding Style ▁* cod st y ▁= ▁s -> cod st y ; ▁J 2 k Quant Style ▁* q nt st y ▁= ▁s -> q nt st y ; ▁uint 8_ t ▁* properties ▁= ▁s -> properties ; ▁for ▁( ; ; ){ ▁int ▁marker , ▁len , ▁ret ▁= ▁0; ▁const ▁uint 8_ t ▁* ol db uf ; ▁if ▁( s -> buf _ end ▁- ▁s -> buf ▁< ▁2 ){ ▁av _ log ( s -> av ctx , ▁AV _ LOG _ ERROR , ▁" Missing ▁E OC \ n "); ▁break ; ▁} ▁marker ▁= ▁by test ream _ get _ be 16 ( & s -> buf ); ▁if ( s -> av ctx -> debu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ass _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁av ctx -> sub title _ header ▁= ▁av _ m alloc ( av ctx -> ex tr ad ata _ size ); ▁if ▁(! av ctx -> ex tr ad ata ) ▁return ▁A VER ROR ( EN O ME M ); ▁mem c py ( av ctx -> sub title _ header , ▁av ctx -> ex tr ad ata , ▁av ctx -> ex tr ad ata _ size ); ▁av ctx -> sub title _ header _ size ▁= ▁av ctx -> ex tr ad ata _ size ; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v 9 fs _ device _ real ize _ common ( V 9 fs State ▁* s , ▁Error ▁** err p ) ▁{ ▁int ▁i , ▁len ; ▁struct ▁stat ▁stat ; ▁Fs Driver Entry ▁* f se ; ▁V 9 fs Path ▁path ; ▁int ▁rc ▁= ▁1; ▁/* ▁initialize ▁pdu ▁allocator ▁*/ ▁Q LIST _ INIT ( & s -> free _ list ); ▁Q LIST _ INIT ( & s -> active _ list ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁( MAX _ REQ ▁- ▁1); ▁i ++) ▁{ ▁Q LIST _ INSERT _ HEAD ( & s -> free _ list , ▁& s -> pd us [ i ], ▁next ); ▁s -> pd us [ i ]. s ▁= ▁s ; ▁s -> pd us [ i ]. idx ▁= ▁i ; ▁} ▁v 9 fs _ p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁w sd _ read _ header ( AV Format Context ▁* s ) ▁{ ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁AV Stream ▁* st ; ▁int ▁version ; ▁uint 32_ t ▁text _ offset , ▁data _ offset , ▁channel _ assign ; ▁char ▁playback _ time [ AV _ TIME CODE _ STR _ SIZE ]; ▁st ▁= ▁av format _ new _ stream ( s , ▁NULL ); ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁av io _ skip ( pb , ▁8 ); ▁version ▁= ▁av io _ r 8 ( pb ); ▁av _ log ( s , ▁AV _ LOG _ DEBUG , ▁" version : ▁% i . % i \ n ", ▁version ▁>> ▁4, ▁version ▁& ▁0

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁x 11 grab _ read _ header ( AV Format Context ▁* s 1) ▁{ ▁struct ▁x 11 grab ▁* x 11 grab ▁= ▁s 1 -> priv _ data ; ▁Display ▁* d py ; ▁AV Stream ▁* st ▁= ▁NULL ; ▁enum ▁AV Pixel Format ▁input _ pix fmt ; ▁X Image ▁* image ; ▁int ▁x _ off ▁= ▁0; ▁int ▁y _ off ▁= ▁0; ▁int ▁screen ; ▁int ▁use _ sh m ; ▁char ▁* d py name , ▁* offset ; ▁int ▁ret ▁= ▁0; ▁Col ormap ▁color _ map ; ▁X Color ▁color [ 256 ]; ▁int ▁i ; ▁d py name ▁= ▁av _ str dup ( s 1 -> filename ); ▁if ▁(! d py name ) ▁goto ▁out ; ▁offset ▁= ▁str c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vp 8_ h _ loop _ filter _ simple _ c ( uint 8_ t ▁* dst , ▁ptr diff _ t ▁stride , ▁int ▁fl im ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁16 ; ▁i ++) ▁if ▁( simple _ limit ( dst + i * stride , ▁1, ▁fl im )) ▁filter _ common ( dst + i * stride , ▁1, ▁1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁b dr v _ d rain ( Block Driver State ▁* bs ) ▁{ ▁bool ▁busy ▁= ▁true ; ▁b dr v _ d rain _ rec urse ( bs ); ▁while ▁( bus y ) ▁{ ▁/* ▁Keep ▁iterating ▁*/ ▁b dr v _ flush _ io _ queue ( bs ); ▁busy ▁= ▁b dr v _ requests _ pending ( bs ); ▁busy ▁|= ▁aio _ poll ( b dr v _ get _ a io _ context ( bs ), ▁busy );

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁main _ loop ( void ) ▁{ ▁bool ▁non blocking ; ▁int ▁last _ io ▁__ attribute __ ▁(( unused )) ▁= ▁0; ▁# if def ▁CONFIG _ PRO FIL ER ▁int 64_ t ▁ti ; ▁# end if ▁int ▁r ; ▁qemu _ main _ loop _ start (); ▁for ▁( ; ;) ▁{ ▁# if def ▁CONFIG _ I OTH READ ▁non blocking ▁= ▁! k vm _ enabled () ▁&& ▁last _ io ▁> ▁0; ▁# else ▁non blocking ▁= ▁cpu _ exec _ all (); ▁if ▁( vm _ request _ pending ()) ▁{ ▁non blocking ▁= ▁true ; ▁} ▁# end if ▁# if def ▁CONFIG _ PRO FIL ER ▁ti ▁= ▁profile _ get clock (); ▁# 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁boot p _ reply ( const ▁struct ▁boot p _ t ▁* bp ) ▁{ ▁BO OT P Client ▁* bc ▁= ▁NULL ; ▁struct ▁m buf ▁* m ; ▁struct ▁boot p _ t ▁* rb p ; ▁struct ▁sock addr _ in ▁s addr , ▁d addr ; ▁struct ▁in _ addr ▁dns _ addr ; ▁const ▁struct ▁in _ addr ▁* pre q _ addr ; ▁int ▁dhcp _ msg _ type , ▁val ; ▁uint 8_ t ▁* q ; ▁/* ▁extract ▁exact ▁D HCP ▁msg ▁type ▁*/ ▁dhcp _ decode ( bp , ▁& dhcp _ msg _ type , ▁& pre q _ addr ); ▁d printf (" boot p ▁packet ▁op =% d ▁msg type =% d ", ▁bp -> bp _ op , ▁dhcp 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁print _ features ( FILE ▁* f , ▁int ▁(* cpu _ f printf )( FILE ▁* f , ▁const ▁char ▁* fmt , ▁... ), ▁uint 32_ t ▁features , ▁const ▁char ▁* prefix ) ▁{ ▁unsigned ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ARRAY _ SIZE ( feature _ name ); ▁i ++) ▁if ▁( feature _ name [ i ] ▁&& ▁( features ▁& ▁(1 ▁<< ▁i ))) ▁{ ▁if ▁( prefix ) ▁(* cpu _ f printf )( f , ▁"% s ", ▁prefix ); ▁(* cpu _ f printf )( f , ▁"% s ▁", ▁feature _ name [ i ]); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁cpu _ x 86_ gen _ code ( uint 8_ t ▁* gen _ code _ buf , ▁int ▁max _ code _ size , ▁int ▁* gen _ code _ size _ ptr , ▁uint 8_ t ▁* pc _ start , ▁int ▁flags ) ▁{ ▁Dis as Context ▁dc 1, ▁* dc ▁= ▁& dc 1; ▁uint 8_ t ▁* gen _ code _ end , ▁* pc _ ptr ; ▁long ▁ret ; ▁# if def ▁DEBUG _ DIS AS ▁struct ▁dis as semble _ info ▁dis asm _ info ; ▁# end if ▁dc -> code 32 ▁= ▁( flags ▁>> ▁G EN _ FLAG _ CODE 32_ SHIFT ) ▁& ▁1; ▁dc -> add seg ▁= ▁( flags ▁>> ▁G EN _ FLAG _ ADD SE G _ SHIFT ) ▁& ▁1; ▁dc -> f _ st ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁char ▁* q object _ input _ get _ key val ( Q Object Input Visitor ▁* q iv , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Q Object ▁* q obj ; ▁Q String ▁* q str ; ▁q obj ▁= ▁q object _ input _ get _ object ( q iv , ▁name , ▁true , ▁err p ); ▁if ▁(! q obj ) ▁{ ▁return ▁NULL ; ▁} ▁q str ▁= ▁q object _ to _ q string ( q obj ); ▁if ▁(! q str ) ▁{ ▁error _ set g ( err p , ▁Q ERR _ INVALID _ PARAMETER _ TYPE , ▁full _ name ( q iv , ▁name ), ▁" string "); ▁return ▁NULL ; ▁} ▁return ▁q string _ ge

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q io _ channel _ socket _ final ize ( Object ▁* obj ) ▁{ ▁Q IO Channel Socket ▁* i oc ▁= ▁Q IO _ CHANNEL _ SOCKET ( obj ); ▁if ▁( i oc -> fd ▁!= ▁-1) ▁{ ▁# if def ▁WIN 32 ▁W SA Event Select ( i oc -> fd , ▁NULL , ▁0); ▁# end if ▁closes ocket ( i oc -> fd ); ▁i oc -> fd ▁= ▁-1;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁f trace _ init ( void ) ▁{ ▁char ▁mount _ point [ PATH _ MAX ]; ▁char ▁path [ PATH _ MAX ]; ▁int ▁debug fs _ found ; ▁int ▁trace _ fd ▁= ▁-1; ▁debug fs _ found ▁= ▁find _ mount ( mount _ point , ▁" debug fs "); ▁if ▁( debug fs _ found ) ▁{ ▁sn printf ( path , ▁PATH _ MAX , ▁"% s / tr acing / tr acing _ on ", ▁mount _ point ); ▁trace _ fd ▁= ▁open ( path , ▁O _ WR ONLY ); ▁if ▁( trace _ fd ▁< ▁0) ▁{ ▁if ▁( err no ▁== ▁E AC CES ) ▁{ ▁trace _ marker _ fd ▁= ▁open ("/ dev / null ", ▁O _ WR ONLY ); ▁if 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 rgba 64 _1_ c _ template ( Sw s Context ▁* c , ▁const ▁int 32_ t ▁* buf 0, ▁const ▁int 32_ t ▁* ub uf [2], ▁const ▁int 32_ t ▁* v buf [2], ▁const ▁int 32_ t ▁* ab uf 0, ▁uint 16_ t ▁* dest , ▁int ▁dst W , ▁int ▁u val pha , ▁int ▁y , ▁enum ▁AV Pixel Format ▁target , ▁int ▁has Alpha , ▁int ▁eight bytes ) ▁{ ▁const ▁int 32_ t ▁* ub uf 0 ▁= ▁u buf [0], ▁* v buf 0 ▁= ▁v buf [0]; ▁int ▁i ; ▁int ▁A 1 ▁= ▁0 xffff << 14, ▁A 2= ▁0 xffff << 14 ; ▁if ▁( u val pha ▁< ▁2048 ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁(( dst W

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁visit _ type _ int ( Visitor ▁* v , ▁int 64_ t ▁* obj , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁if ▁(! error _ is _ set ( err p )) ▁{ ▁v -> type _ int ( v , ▁obj , ▁name , ▁err p ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁av c _ l um a _ mid _8 w _ ms a ( const ▁uint 8_ t ▁* src , ▁int 32_ t ▁src _ stride , ▁uint 8_ t ▁* dst , ▁int 32_ t ▁dst _ stride , ▁int 32_ t ▁height ) ▁{ ▁uint 32_ t ▁loop _ cnt ; ▁v 16 i 8 ▁src 0, ▁src 1, ▁src 2, ▁src 3, ▁src 4; ▁v 16 i 8 ▁mask 0, ▁mask 1, ▁mask 2; ▁v 8 i 16 ▁h z _ out 0, ▁h z _ out 1, ▁h z _ out 2, ▁h z _ out 3; ▁v 8 i 16 ▁h z _ out 4, ▁h z _ out 5, ▁h z _ out 6, ▁h z _ out 7, ▁h z _ out 8 ; ▁v 8 i 16 ▁dst 0, ▁dst 1, ▁dst 2, ▁dst 3; ▁v 16 u 8 ▁out 0, ▁out 1; ▁LD _ SB 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁p am _ encode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁av _ frame _ free ( & av ctx -> coded _ frame ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁o gg vor b is _ init _ encoder ( vor b is _ info ▁* vi , ▁AV Codec Context ▁* av c context ) ▁{ ▁O gg V orb is Context ▁* context ▁= ▁av c context -> priv _ data ; ▁double ▁cf req ; ▁if ▁( av c context -> flags ▁& ▁CODE C _ FLAG _ Q SCALE ) ▁{ ▁/* ▁variable ▁bitrate ▁*/ ▁if ▁( vor b is _ encode _ setup _ v br ( vi , ▁av c context -> channels , ▁av c context -> sample _ rate , ▁av c context -> global _ quality ▁/ ▁( float ) FF _ Q P 2 LA MB DA ▁/ ▁10.0 )) ▁return ▁-1; ▁} ▁else ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁encode _ frame ( AV Codec Context ▁* av ctx , ▁AV Packet ▁* av pk t , ▁const ▁AV Frame ▁* frame , ▁int ▁* got _ packet _ ptr ) ▁{ ▁N elly M oser Encode Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁ret ; ▁if ▁( s -> last _ frame ) ▁return ▁0; ▁mem c py ( s -> buf , ▁s -> buf ▁+ ▁NE LL Y _ SA MP LES , ▁NE LL Y _ BU F _ LEN ▁* ▁sizeof (* s -> buf )); ▁if ▁( frame ) ▁{ ▁mem c py ( s -> buf ▁+ ▁NE LL Y _ BU F _ LEN , ▁frame -> data [0], ▁frame -> nb _ samples ▁* ▁sizeof (* s -> buf )); ▁if ▁( f

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁im d ct _ and _ window ing ( A AC Context ▁* ac , ▁Single Channel Element ▁* s ce , ▁float ▁bias ) ▁{ ▁Individual Channel Stream ▁* ics ▁= ▁& s ce -> ics ; ▁float ▁* in ▁= ▁s ce -> coeff s ; ▁float ▁* out ▁= ▁s ce -> ret ; ▁float ▁* saved ▁= ▁s ce -> saved ; ▁const ▁float ▁* sw indow ▁= ▁ics -> use _ kb _ window [0] ▁? ▁ff _ a ac _ k bd _ short _ 128 ▁: ▁ff _ s ine _ 128 ; ▁const ▁float ▁* l window _ prev ▁= ▁ics -> use _ kb _ window [1] ▁? ▁ff _ a ac _ k bd _ long _10 24 ▁: ▁ff _ s ine _10

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ ds put il _ init _ alpha ( DS P Context * ▁c , ▁AV Codec Context ▁* av ctx ) ▁{ ▁const ▁int ▁high _ bit _ depth ▁= ▁av ctx -> bits _ per _ raw _ sample ▁> ▁8 ; ▁if ▁(! high _ bit _ depth ) ▁{ ▁c -> put _ pixels _ tab [0][0] ▁= ▁put _ pixels 16_ ax p _ asm ; ▁c -> put _ pixels _ tab [0] [1] ▁= ▁put _ pixels 16_ x 2_ ax p ; ▁c -> put _ pixels _ tab [0] [2] ▁= ▁put _ pixels 16_ y 2_ ax p ; ▁c -> put _ pixels _ tab [0] [3] ▁= ▁put _ pixels 16_ xy 2_ ax p ; ▁c -> put _ no _ r nd _ pixels _ tab [0][

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁char ▁* check _ nan _ suffix ( char ▁* s ) ▁{ ▁char ▁* start ▁= ▁s ; ▁if ▁(* s ++ ▁!= ▁' (' ) ▁return ▁start ; ▁while ▁(( * s ▁>= ▁' a ' ▁&& ▁* s ▁<= ▁' z ') ▁|| ▁(* s ▁>= ▁' A ' ▁&& ▁* s ▁<= ▁' Z ') ▁|| ▁(* s ▁>= ▁'0' ▁&& ▁* s ▁<= ▁'9 ') ▁|| ▁* s ▁== ▁'_ ') ▁s ++; ▁return ▁* s ▁== ▁') ' ▁? ▁s ▁+ ▁1 ▁: ▁start ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁diff _ bytes _ c ( uint 8_ t ▁* dst , ▁uint 8_ t ▁* src 1, ▁uint 8_ t ▁* src 2, ▁int ▁w ){ ▁long ▁i ; ▁# if ▁! HA VE _ FA ST _ UN ALI G NED ▁if (( long ) src 2 ▁& ▁( size of ( long ) -1 )){ ▁for ( i =0; ▁i + 7 < w ; ▁i += 8 ){ ▁dst [ i + 0] ▁= ▁src 1[ i + 0] - src 2[ i +0 ]; ▁dst [ i +1] ▁= ▁src 1[ i +1] - src 2[ i +1 ]; ▁dst [ i + 2] ▁= ▁src 1[ i + 2] - src 2[ i +2 ]; ▁dst [ i + 3] ▁= ▁src 1[ i + 3] - src 2[ i + 3 ]; ▁dst [ i + 4] ▁= ▁src 1[ i + 4] - src 2[ i + 4 ]; ▁dst [ i + 5] ▁= ▁src 1

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁D P X Context ▁* const ▁s ▁= ▁av ctx -> priv _ data ; ▁AV Frame ▁* picture ▁= ▁data ; ▁AV Frame ▁* const ▁p ▁= ▁& s -> picture ; ▁uint 8_ t ▁* ptr [ AV _ NUM _ DATA _ PO INTER S ]; ▁unsigned ▁int ▁offset ; ▁int ▁magic _ num , ▁endian ; ▁int ▁x , ▁y , ▁i , ▁ret ; ▁int ▁w , ▁h , ▁bits _ per _ color 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁gen _ pool 16 c _ ins n ( Dis as Context ▁* ctx , ▁int ▁* is _ branch ) ▁{ ▁int ▁rd ▁= ▁mm reg (( ctx -> op code ▁>> ▁3) ▁& ▁0 x 7 ); ▁int ▁rs ▁= ▁mm reg ( ctx -> op code ▁& ▁0 x 7 ); ▁int ▁op c ; ▁switch ▁( (( ctx -> op code ) ▁>> ▁4) ▁& ▁0 x 3 f ) ▁{ ▁case ▁NOT 16 ▁+ ▁0: ▁case ▁NOT 16 ▁+ ▁1: ▁case ▁NOT 16 ▁+ ▁2: ▁case ▁NOT 16 ▁+ ▁3: ▁gen _ logic ( ctx , ▁O PC _ N OR , ▁rd , ▁rs , ▁0); ▁break ; ▁case ▁XOR 16 ▁+ ▁0: ▁case ▁XOR 16 ▁+ ▁1: ▁case ▁XOR 16 ▁+ ▁2: ▁case ▁XOR 16 ▁+ ▁3: ▁gen _ logic

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ filter _ frame ( AV Filter Link ▁* link , ▁AV Frame ▁* frame ) ▁{ ▁int ▁(* filter _ frame )( AV Filter Link ▁* , ▁AV Frame ▁* ); ▁AV Filter Pad ▁* dst ▁= ▁link -> dst pad ; ▁AV Frame ▁* out ; ▁FF _ DP RI NT F _ START ( NULL , ▁filter _ frame ); ▁ff _ d log _ link ( NULL , ▁link , ▁1); ▁if ▁(! ( filter _ frame ▁= ▁dst -> filter _ frame )) ▁filter _ frame ▁= ▁default _ filter _ frame ; ▁/* ▁copy ▁the ▁frame ▁if ▁needed ▁*/ ▁if ▁( dst -> needs _ writable ▁&& ▁! av _ frame _ is _ writable ( frame )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁s size _ t ▁v nc _ tls _ push ( gn ut ls _ transport _ ptr _ t ▁transport , ▁const ▁void ▁* data , ▁size _ t ▁len ) ▁{ ▁V nc State ▁* vs ▁= ▁( V nc State ▁* ) transport ; ▁int ▁ret ; ▁retry : ▁ret ▁= ▁send ( vs -> cs ock , ▁data , ▁len , ▁0); ▁if ▁( ret ▁< ▁0) ▁{ ▁if ▁( err no ▁== ▁E INT R ) ▁goto ▁retry ; ▁return ▁-1; ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁property _ set _ enum ( Object ▁* obj , ▁Visitor ▁* v , ▁void ▁* op aque , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁Enum Property ▁* prop ▁= ▁opaque ; ▁int ▁value ; ▁visit _ type _ enum ( v , ▁& value , ▁prop -> strings , ▁NULL , ▁name , ▁err p ); ▁prop -> set ( obj , ▁value , ▁err p ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ h 2 64_ filter _ mb _ fast ( const ▁H 264 Context ▁* h , ▁H 264 Slice Context ▁* sl , ▁int ▁mb _ x , ▁int ▁mb _ y , ▁uint 8_ t ▁* img _ y , ▁uint 8_ t ▁* img _ cb , ▁uint 8_ t ▁* img _ cr , ▁unsigned ▁int ▁lines ize , ▁unsigned ▁int ▁uv lines ize ) ▁{ ▁assert (! FRAME _ MB A FF ( h )); ▁if (! h -> h 264 d sp . h 2 64_ loop _ filter _ strength ▁|| ▁h -> pp s . chrom a _ qp _ diff ) ▁{ ▁ff _ h 2 64_ filter _ mb ( h , ▁sl , ▁mb _ x , ▁mb _ y , ▁img _ y , ▁img _ cb , ▁img _ cr , ▁lines ize , ▁uv l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ e ject ( const ▁char ▁* device , ▁bool ▁has _ force , ▁bool ▁force , ▁Error ▁** err p ) ▁{ ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁rc ; ▁if ▁(! has _ force ) ▁{ ▁force ▁= ▁false ; ▁} ▁rc ▁= ▁do _ open _ tr ay ( device , ▁force , ▁& local _ err ); ▁if ▁( local _ err ) ▁{ ▁error _ propag ate ( err p , ▁local _ err ); ▁return ; ▁} ▁if ▁( rc ▁== ▁E IN PROGRESS ) ▁{ ▁error _ set g ( err p , ▁" Device ▁'% s ' ▁is ▁locked ▁and ▁force ▁was ▁not ▁specified , ▁" ▁" wait ▁for ▁t ray ▁to ▁open ▁and ▁try 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁check _ prot ( int ▁prot , ▁int ▁rw , ▁int ▁access _ type ) ▁{ ▁int ▁ret ; ▁if ▁( access _ type ▁== ▁ACCESS _ CODE ) ▁{ ▁if ▁( prot ▁& ▁PAGE _ EXEC ) ▁{ ▁ret ▁= ▁0; ▁} ▁else ▁{ ▁ret ▁= ▁- 2; ▁} ▁} ▁else ▁if ▁( rw ) ▁{ ▁if ▁( prot ▁& ▁PAGE _ WRITE ) ▁{ ▁ret ▁= ▁0; ▁} ▁else ▁{ ▁ret ▁= ▁- 2; ▁} ▁} ▁else ▁{ ▁if ▁( prot ▁& ▁PAGE _ READ ) ▁{ ▁ret ▁= ▁0; ▁} ▁else ▁{ ▁ret ▁= ▁- 2; ▁} ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v mdk _ write _ extent ( V mdk Extent ▁* extent , ▁int 64_ t ▁cluster _ offset , ▁int 64_ t ▁offset _ in _ cluster , ▁Q EM UI O Vector ▁* q io v , ▁uint 64_ t ▁q io v _ offset , ▁uint 64_ t ▁n _ bytes , ▁uint 64_ t ▁offset ) ▁{ ▁int ▁ret ; ▁V mdk G rain Marker ▁* data ▁= ▁NULL ; ▁u Long f ▁buf _ len ; ▁Q EM UI O Vector ▁local _ q io v ; ▁struct ▁i ove c ▁i ov ; ▁int 64_ t ▁write _ offset ; ▁int 64_ t ▁write _ end _ sect or ; ▁if ▁( extent -> compressed ) ▁{ ▁void ▁* compressed _ data ; ▁if ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁http _ server ( void ) ▁{ ▁int ▁server _ fd , ▁ret , ▁rt sp _ server _ fd , ▁delay , ▁delay 1; ▁struct ▁poll fd ▁poll _ table [ HTTP _ MAX _ CONNECTION S ▁+ ▁2], ▁* poll _ entry ; ▁HTTP Context ▁* c , ▁* c _ next ; ▁server _ fd ▁= ▁socket _ open _ listen ( & my _ http _ addr ); ▁if ▁( server _ fd ▁< ▁0) ▁return ▁-1; ▁rt sp _ server _ fd ▁= ▁socket _ open _ listen ( & my _ rt sp _ addr ); ▁if ▁( rt sp _ server _ fd ▁< ▁0) ▁return ▁-1; ▁http _ log (" ff server ▁started .\ n "); ▁start _ childr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dn x hd _ decode _ header ( DN X HD Context ▁* ctx , ▁AV Frame ▁* frame , ▁const ▁uint 8_ t ▁* buf , ▁int ▁buf _ size , ▁int ▁first _ field ) ▁{ ▁static ▁const ▁uint 8_ t ▁header _ prefix [] ▁= ▁{ ▁0 x 00, ▁0 x 00, ▁0 x 0 2, ▁0 x 8 0, ▁0 x 01 ▁}; ▁static ▁const ▁uint 8_ t ▁header _ prefix 444 [] ▁= ▁{ ▁0 x 00, ▁0 x 00, ▁0 x 0 2, ▁0 x 8 0, ▁0 x 02 ▁}; ▁int ▁i , ▁cid , ▁ret ; ▁if ▁( buf _ size ▁< ▁0 x 2 80) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( mem cmp ( buf , ▁header _ prefix , ▁5) ▁&

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ monitor _ def ( target _ long ▁* p val , ▁const ▁char ▁* name ) ▁{ ▁const ▁Monitor Def ▁* md ; ▁void ▁* ptr ; ▁for ( md ▁= ▁monitor _ defs ; ▁md -> name ▁!= ▁NULL ; ▁md ++) ▁{ ▁if ▁( compare _ cmd ( name , ▁md -> name )) ▁{ ▁if ▁( md -> get _ value ) ▁{ ▁* p val ▁= ▁md -> get _ value ( md , ▁md -> offset ); ▁} ▁else ▁{ ▁CPU State ▁* env ▁= ▁mon _ get _ cpu (); ▁if ▁(! env ) ▁return ▁- 2; ▁ptr ▁= ▁( uint 8_ t ▁* ) env ▁+ ▁md -> offset ; ▁switch ( md -> type ) ▁{ ▁case ▁MD _ I 32 : ▁* p 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁do _ sig frame _ return _ v 2( CPU State ▁* env , ▁target _ ulong ▁frame _ addr , ▁struct ▁target _ u context _ v 2 ▁* uc ) ▁{ ▁sig set _ t ▁host _ set ; ▁abi _ ulong ▁* re gs pace ; ▁target _ to _ host _ sig set ( & host _ set , ▁& uc -> t uc _ sig mask ); ▁sig proc mask ( SIG _ SET MASK , ▁& host _ set , ▁NULL ); ▁if ▁( restore _ sig context ( env , ▁& uc -> t uc _ m context )) ▁if ▁( do _ sig alt stack ( frame _ addr ▁+ ▁offset of ( struct ▁target _ u context _ v 2, ▁t uc _ stack ), ▁0, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁F W Cfg State ▁* pc _ memory _ init ( Memory Region ▁* system _ memory , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁ram _ addr _ t ▁below _4 g _ mem _ size , ▁ram _ addr _ t ▁above _4 g _ mem _ size , ▁Memory Region ▁* rom _ memory , ▁Memory Region ▁** ram _ memory , ▁P c Guest Info ▁* guest _ info ) ▁{ ▁int ▁linux _ boot , ▁i ; ▁Memory Region ▁* ram , ▁* option _ rom _ mr ; ▁Memory Region ▁* ram _ below _4 g , ▁* ram _ above _4 g ; ▁F W C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁press _ key ( V nc State ▁* vs , ▁int ▁keys ym ) ▁{ ▁int ▁keycode ▁= ▁keys ym 2 scan code ( vs -> vd -> k bd _ layout , ▁keys ym ) ▁& ▁SC AN CODE _ KEY MASK ; ▁qemu _ input _ event _ send _ key _ number ( vs -> vd -> d cl . con , ▁keycode , ▁true ); ▁qemu _ input _ event _ send _ key _ delay (0); ▁qemu _ input _ event _ send _ key _ number ( vs -> vd -> d cl . con , ▁keycode , ▁false ); ▁qemu _ input _ event _ send _ key _ delay (0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁s 39 0_ virt io _ device _ sync ( V irt IOS 390 Device ▁* dev ) ▁{ ▁V irt IOS 390 Bus ▁* bus ▁= ▁DO _ UP CAST ( V irt IOS 390 Bus , ▁bus , ▁dev -> q dev . parent _ bus ); ▁ram _ addr _ t ▁cur _ off s ; ▁uint 8_ t ▁num _ v q ; ▁int ▁i ; ▁virt io _ reset ( dev -> v dev ); ▁/* ▁Sync ▁dev ▁space ▁*/ ▁st b _ ph ys ( dev -> dev _ off s ▁+ ▁VI RT IO _ DEV _ OFF S _ TYPE , ▁dev -> v dev -> device _ id ); ▁st b _ ph ys ( dev -> dev _ off s ▁+ ▁VI RT IO _ DEV _ OFF S _ NUM _ V Q , ▁s 39 0_ virt io _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁F UN CC ( pred 8 x 8_ left _ dc )( uint 8_ t ▁* _ src , ▁int ▁stride ){ ▁int ▁i ; ▁int ▁dc 0, ▁dc 2; ▁pixel 4 ▁dc 0 s plat , ▁dc 2 s plat ; ▁pixel ▁* src ▁= ▁( pixel *) _ src ; ▁stride ▁/= ▁sizeof ( pixel ); ▁dc 0 = dc 2 =0; ▁for ( i =0; i < 4; ▁i ++){ ▁dc 0 += ▁src [-1 + i * stride ]; ▁dc 2 += ▁src [-1 +( i + 4) * stride ]; ▁} ▁dc 0 s plat ▁= ▁PI X EL _ SP L AT _ X 4 (( dc 0 ▁+ ▁2) >> 2); ▁dc 2 s plat ▁= ▁PI X EL _ SP L AT _ X 4 (( dc 2 ▁+ ▁2) >> 2); ▁for ( i =0; ▁i < 4; ▁i ++){ ▁(( pixel 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁alloc _ and _ copy ( uint 8_ t ▁** p out buf , ▁int ▁* p out buf _ size , ▁const ▁uint 8_ t ▁* sp s _ pp s , ▁uint 32_ t ▁sp s _ pp s _ size , ▁const ▁uint 8_ t ▁* in , ▁uint 32_ t ▁in _ size ) ▁{ ▁uint 32_ t ▁offset ▁= ▁* p out buf _ size ; ▁uint 8_ t ▁n al _ header _ size ▁= ▁offset ▁? ▁3 ▁: ▁4; ▁* p out buf _ size ▁+= ▁sp s _ pp s _ size + in _ size + nal _ header _ size ; ▁* p out buf ▁= ▁av _ real loc (* p out buf , ▁* p out buf _ size ); ▁if ▁( sp s _ pp s ) ▁mem c py (* p out buf + o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁aio _ set _ event _ notifier ( A io Context ▁* ctx , ▁Event Notifier ▁* e , ▁Event Notifier Handler ▁* io _ notify , ▁A io Flush Event Notifier Handler ▁* io _ flush ) ▁{ ▁A io Handler ▁* node ; ▁Q LIST _ FORE A CH ( node , ▁& ctx -> a io _ handlers , ▁node ) ▁{ ▁if ▁( node -> e ▁== ▁e ▁&& ▁! node -> deleted ) ▁{ ▁break ; ▁} ▁} ▁/* ▁Are ▁we ▁deleting ▁the ▁fd ▁handler ? ▁*/ ▁if ▁(! io _ notify ) ▁{ ▁if ▁( node ) ▁{ ▁g _ source _ remove _ poll ( & ctx -> source , ▁& node -> p fd ); ▁/* ▁If ▁the ▁loc

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁float _ near _ ulp ( float ▁a , ▁float ▁b , ▁unsigned ▁max _ ulp ) ▁{ ▁union ▁av _ int float 32 ▁x , ▁y ; ▁x . f ▁= ▁a ; ▁y . f ▁= ▁b ; ▁if ▁( is _ negative ( x ) ▁!= ▁is _ negative ( y )) ▁{ ▁// ▁handle ▁-0.0 ▁== ▁+ 0.0 ▁return ▁a ▁== ▁b ; ▁} ▁if ▁( abs ( x . i ▁- ▁y . i ) ▁<= ▁max _ ulp ) ▁return ▁1; ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ro q _ d pc m _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁RO Q D PC M Context ▁* context ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> channels ▁> ▁2) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Audio ▁must ▁be ▁mon o ▁or ▁st ere o \ n "); ▁return ▁-1; ▁} ▁if ▁( av ctx -> sample _ rate ▁!= ▁220 50) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Audio ▁must ▁be ▁220 50 ▁H z \ n "); ▁return ▁-1; ▁} ▁if ▁( av ctx -> sample _ fmt ▁!= ▁AV _ SA MPLE _ F MT _ S 16) ▁{ ▁av _ log

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sp ap r _ populate _ cpu _ dt ( CPU State ▁* cs , ▁void ▁* fd t , ▁int ▁offset , ▁s P AP R Machine State ▁* sp ap r ) ▁{ ▁Power PC CPU ▁* cpu ▁= ▁PO WER PC _ CPU ( cs ); ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ GET _ CLASS ( cs ); ▁int ▁index ▁= ▁p pc _ get _ vc pu _ dt _ id ( cpu ); ▁uint 32_ t ▁se gs [] ▁= ▁{ cpu _ to _ be 32 ( 28 ), ▁cpu _ to _ be 32 ( 40 ), ▁0 xffffffff , ▁0 xffffffff }; ▁uint 32_ t ▁tb freq ▁= ▁k vm _ enabled () ▁? ▁k 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ function ( const ▁Test Struct ▁test _ sample ) ▁{ ▁int ▁ret , ▁i ; ▁void ▁** output _ data ▁= ▁NULL ; ▁AV Audio F ifo ▁* af ifo ▁= ▁av _ audio _ f ifo _ alloc ( test _ sample . format , ▁test _ sample . nb _ ch , ▁test _ sample . nb _ samples _ p ch ); ▁if ▁(! af ifo ) ▁{ ▁ERROR (" ERROR : ▁av _ audio _ f ifo _ alloc ▁returned ▁NULL !"); ▁} ▁ret ▁= ▁write _ samples _ to _ audio _ f ifo ( af ifo , ▁test _ sample , ▁test _ sample . nb _ samples _ p ch , ▁0); ▁if ▁( ret ▁< ▁0){ ▁ERROR (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ff _ w mv 2_ id ct _ put _ c ( uint 8_ t ▁* dest , ▁int ▁line _ size , ▁D CT E LE M ▁* block ) ▁{ ▁ff _ w mv 2_ id ct _ c ( block ); ▁put _ pixels _ cl amp ed _ c ( block , ▁dest , ▁line _ size ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ inter frame _ v 4 ( AV Codec Context ▁* av ctx , ▁uint 8_ t ▁* src , ▁uint 32_ t ▁size ) ▁{ ▁H nm 4 Video Context ▁* hn m ▁= ▁av ctx -> priv _ data ; ▁Get Byte Context ▁gb ; ▁uint 32_ t ▁write offset ▁= ▁0, ▁count , ▁left , ▁offset ; ▁uint 8_ t ▁tag , ▁previous , ▁back line , ▁backward , ▁swap ; ▁by test ream 2_ init ( & gb , ▁src , ▁size ); ▁while ▁( by test ream 2_ t ell ( & gb ) ▁< ▁size ) ▁{ ▁count ▁= ▁by test ream 2_ pe ek _ byte ( & gb ) ▁& ▁0 x 1 F ; ▁if ▁( count ▁== ▁0) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁setup _ frame ( int ▁sig , ▁struct ▁em ulated _ sig action ▁* ka , ▁target _ sig set _ t ▁* set , ▁CPU X 86 State ▁* env ) ▁{ ▁struct ▁sig frame ▁* frame ; ▁int ▁err ▁= ▁0; ▁frame ▁= ▁get _ sig frame ( ka , ▁env , ▁sizeof (* frame )); ▁# if ▁0 ▁if ▁(! access _ ok ( VER IFY _ WRITE , ▁frame , ▁sizeof (* frame ))) ▁goto ▁give _ sig seg v ; ▁# end if ▁err ▁|= ▁__ put _ user (( /* current -> exec _ domain ▁&& ▁current -> exec _ domain -> signal _ inv map ▁&& ▁sig ▁< ▁32 ▁? ▁current -> exec _ do

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁write _ target _ close ( Block Driver State ▁* bs ) ▁{ ▁B DR V V V F AT State * ▁s ▁= ▁* (( B DR V V V F AT State ** ) ▁bs -> op aque ); ▁b dr v _ delete ( s -> q c ow ); ▁free ( s -> q c ow _ filename ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a iff _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁AV Stream ▁* st ▁= ▁s -> streams [0]; ▁AI FF Input Context ▁* a iff ▁= ▁s -> priv _ data ; ▁int 64_ t ▁max _ size ; ▁int ▁res , ▁size ; ▁/* ▁calculate ▁size ▁of ▁remaining ▁data ▁*/ ▁max _ size ▁= ▁a iff -> data _ end ▁- ▁av io _ t ell ( s -> pb ); ▁if ▁( max _ size ▁<= ▁0) ▁return ▁A VER ROR _ EOF ; ▁/* ▁Now ▁for ▁that ▁packet ▁*/ ▁switch ▁( st -> codec par -> codec _ id ) ▁{ ▁case ▁AV _ CODE C _ ID _ AD PC M _ I MA _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ fn m sub ▁( uint 64_ t ▁arg 1, ▁uint 64_ t ▁arg 2, ▁uint 64_ t ▁arg 3) ▁{ ▁CPU _ Double U ▁f arg 1, ▁f arg 2, ▁f arg 3; ▁f arg 1. ll ▁= ▁arg 1; ▁f arg 2. ll ▁= ▁arg 2; ▁f arg 3. ll ▁= ▁arg 3; ▁if ▁( un likely ( float 64_ is _ signal ing _ nan ( f arg 1. d ) ▁|| ▁float 64_ is _ signal ing _ nan ( f arg 2. d ) ▁|| ▁float 64_ is _ signal ing _ nan ( f arg 3. d ))) ▁{ ▁/* ▁s NaN ▁operation ▁*/ ▁f arg 1. ll ▁= ▁f load _ invalid _ op _ ex cp ( PO WER PC _ EX CP _ FP _ V X SN AN ); ▁} ▁else

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dec _ mod u ( Dis as Context ▁* dc ) ▁{ ▁int ▁l 1; ▁LOG _ DIS (" mod u ▁r % d , ▁r % d , ▁% d \ n ", ▁dc -> r 2, ▁dc -> r 0, ▁dc -> r 1); ▁if ▁(! ( dc -> features ▁& ▁L M 32_ FEATURE _ DI VI DE )) ▁{ ▁qemu _ log _ mask ( LOG _ G UE ST _ ERROR , ▁" h ardware ▁divider ▁is ▁not ▁available \ n "); ▁t _ gen _ il legal _ ins n ( dc ); ▁return ; ▁} ▁l 1 ▁= ▁gen _ new _ label (); ▁tc g _ gen _ br con di _ tl ( TC G _ COND _ NE , ▁cpu _ R [ dc -> r 1], ▁0, ▁l 1); ▁tc g _ gen _ mov i _ tl ( cpu _ pc 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁o map _ l 4_ io _ write b ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁value ) ▁{ ▁unsigned ▁int ▁i ▁= ▁( addr ▁- ▁O MAP 2_ L 4_ BASE ) ▁>> ▁TARGET _ PAGE _ BITS ; ▁return ▁o map _ l 4_ io _ write b _ fn [ i ]( om ap _ l 4_ io _ op aque [ i ], ▁addr , ▁value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v 9 fs _ create _ post _ l stat ( V 9 fs State ▁* s , ▁V 9 fs Create State ▁* vs , ▁int ▁err ) ▁{ ▁if ▁( err ▁== ▁0 ▁|| ▁errno ▁!= ▁ENOENT ) ▁{ ▁err ▁= ▁- err no ; ▁goto ▁out ; ▁} ▁if ▁( vs -> perm ▁& ▁P 9_ STAT _ MODE _ DIR ) ▁{ ▁err ▁= ▁v 9 fs _ do _ mkdir ( s , ▁vs ); ▁v 9 fs _ create _ post _ mkdir ( s , ▁vs , ▁err ); ▁} ▁else ▁if ▁( vs -> perm ▁& ▁P 9_ STAT _ MODE _ SY M LINK ) ▁{ ▁err ▁= ▁v 9 fs _ do _ symlink ( s , ▁vs ); ▁v 9 fs _ create _ post _ perms ( s , ▁vs , ▁err ); ▁} ▁else ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁pal _ init ▁( CPU State ▁* env ) ▁{ ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁target _ ulong ▁sp ap r _ rt as _ call ( s P AP R Environment ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁if ▁(( token ▁>= ▁TOKEN _ BASE ) ▁&& ▁(( token ▁- ▁TOKEN _ BASE ) ▁< ▁TOKEN _ MAX )) ▁{ ▁struct ▁rt as _ call ▁* call ▁= ▁rt as _ table ▁+ ▁( token ▁- ▁TOKEN _ BASE ); ▁if ▁( call -> fn ) ▁{ ▁call -> fn ( sp ap r , ▁token , ▁nargs , ▁args , ▁n ret , ▁ret s ); ▁return ▁H _ SUCCESS ; ▁} ▁} ▁/* ▁H ACK : ▁Some ▁Linux ▁ea

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁apply _ t ns _ filter ( float ▁* out , ▁float ▁* in , ▁int ▁order , ▁int ▁direction , ▁float ▁* t ns _ co efs , ▁int ▁l tp _ used , ▁int ▁w , ▁int ▁filt , ▁int ▁start _ i , ▁int ▁len ) ▁{ ▁int ▁i , ▁j , ▁inc , ▁start ▁= ▁start _ i ; ▁float ▁tmp [ T NS _ MAX _ ORDER +1 ]; ▁if ▁( direction ) ▁{ ▁inc ▁= ▁-1; ▁start ▁= ▁( start ▁+ ▁len ) ▁- ▁1; ▁} ▁else ▁{ ▁inc ▁= ▁1; ▁} ▁if ▁(! l tp _ used ) ▁{ ▁/* ▁AR ▁filter ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁len ; ▁i ++, ▁start ▁+= ▁inc ) ▁out [ i ] ▁= ▁in [ start

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mk v _ write _ ass _ blocks ( AV Format Context ▁* s , ▁AV IO Context ▁* pb , ▁AV Packet ▁* pk t ) ▁{ ▁Mat ro sk a M ux Context ▁* mk v ▁= ▁s -> priv _ data ; ▁int ▁i , ▁layer ▁= ▁0, ▁max _ duration ▁= ▁0, ▁size , ▁line _ size , ▁data _ size ▁= ▁pkt -> size ; ▁uint 8_ t ▁* start , ▁* end , ▁* data ▁= ▁pkt -> data ; ▁eb ml _ master ▁block group ; ▁char ▁buffer [ 20 48 ]; ▁while ▁( data _ size ) ▁{ ▁int ▁duration ▁= ▁ass _ get _ duration ( data ); ▁max _ duration ▁= ▁FF MAX ( duration , ▁max _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ram _ block _ enable _ notify ( const ▁char ▁* block _ name , ▁void ▁* host _ addr , ▁ram _ addr _ t ▁offset , ▁ram _ addr _ t ▁length , ▁void ▁* op aque ) ▁{ ▁Migration Incoming State ▁* mis ▁= ▁opaque ; ▁struct ▁u ff d io _ register ▁reg _ struct ; ▁reg _ struct . range . start ▁= ▁( uint ptr _ t ) host _ addr ; ▁reg _ struct . range . len ▁= ▁length ; ▁reg _ struct . mode ▁= ▁U FF DIO _ REGI STER _ MODE _ MISS ING ; ▁/* ▁Now ▁tell ▁our ▁user fault _ fd ▁that ▁it ' s ▁responsible ▁for ▁thi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁draw _ bar _ y uv ( AV Frame ▁* out , ▁const ▁float ▁* h , ▁const ▁float ▁* rc p _ h , ▁const ▁Color Float ▁* c , ▁int ▁bar _ h ) ▁{ ▁int ▁x , ▁y , ▁y h , ▁w ▁= ▁out -> width ; ▁float ▁mul , ▁ht , ▁r cp _ bar _ h ▁= ▁1.0 f ▁/ ▁bar _ h ; ▁uint 8_ t ▁* vy ▁= ▁out -> data [0], ▁* v u ▁= ▁out -> data [1], ▁* vv ▁= ▁out -> data [2 ]; ▁uint 8_ t ▁* l py , ▁* l pu , ▁* l pv ; ▁int ▁ls y ▁= ▁out -> lines ize [0], ▁l su ▁= ▁out -> lines ize [1], ▁l sv ▁= ▁out -> lines ize [2 ]; ▁int ▁fmt ▁= ▁out -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ chr _ open _ win _ file _ out ( Q emu Opts ▁* opts , ▁Char Driver State ▁** _ chr ) ▁{ ▁const ▁char ▁* file _ out ▁= ▁qemu _ opt _ get ( opts , ▁" path "); ▁HAND LE ▁fd _ out ; ▁fd _ out ▁= ▁Create File ( file _ out , ▁GENERIC _ WRITE , ▁FILE _ SHA RE _ READ , ▁NULL , ▁OPEN _ AL WAYS , ▁FILE _ ATTRIBUTE _ NORMAL , ▁NULL ); ▁if ▁( fd _ out ▁== ▁INVALID _ HANDLE _ VALUE ) ▁{ ▁return ▁- E IO ; ▁} ▁return ▁qemu _ chr _ open _ win _ file ( fd _ out , ▁_ chr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ fill _ default _ ref _ list ( H 264 Context ▁* h , ▁H 264 Slice Context ▁* sl ) ▁{ ▁int ▁i , ▁len ; ▁if ▁( sl -> slice _ type _ nos ▁== ▁AV _ PI CT URE _ TYPE _ B ) ▁{ ▁H 264 Picture ▁* sorted [ 32 ]; ▁int ▁cur _ p oc , ▁list ; ▁int ▁len s [2 ]; ▁if ▁( FIELD _ PI CT URE ( h )) ▁cur _ p oc ▁= ▁h -> cur _ pic _ ptr -> field _ p oc [ h -> picture _ structure ▁== ▁PI CT _ B OTTOM _ FIELD ]; ▁else ▁cur _ p oc ▁= ▁h -> cur _ pic _ ptr -> p oc ; ▁for ▁( list ▁= ▁0; ▁list ▁< ▁2; ▁list ++) ▁{ ▁l

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v td _ init ( Int el I OM MU State ▁* s ) ▁{ ▁X 86 I OM MU State ▁* x 86_ iom mu ▁= ▁X 86_ I OM MU _ DEVICE ( s ); ▁mem set ( s -> csr , ▁0, ▁DM AR _ REG _ SIZE ); ▁mem set ( s -> w mask , ▁0, ▁DM AR _ REG _ SIZE ); ▁mem set ( s -> w 1 c mask , ▁0, ▁DM AR _ REG _ SIZE ); ▁mem set ( s -> w om ask , ▁0, ▁DM AR _ REG _ SIZE ); ▁s -> iom mu _ ops . translate ▁= ▁v td _ iom mu _ translate ; ▁s -> iom mu _ ops . notify _ started ▁= ▁v td _ iom mu _ notify _ started ; ▁s -> root ▁= ▁0; ▁s -> root 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁const ▁uint 8_ t ▁* ff _ h 26 3_ find _ res ync _ marker ( const ▁uint 8_ t ▁* av _ restrict ▁p , ▁const ▁uint 8_ t ▁* av _ restrict ▁end ) ▁{ ▁av _ assert 2( p ▁< ▁end ); ▁end - = 2; ▁p ++; ▁for ( ; p < end ; ▁p + =2 ){ ▁if (! * p ){ ▁if ▁(! p [-1] ▁&& ▁p [1]) ▁return ▁p ▁- ▁1; ▁else ▁if (! p [ ▁1] ▁&& ▁p [2]) ▁return ▁p ; ▁} ▁} ▁return ▁end + 2; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ ct c 1( CP UM IP S State ▁* env , ▁target _ ulong ▁arg 1, ▁uint 32_ t ▁reg ) ▁{ ▁switch ( reg ) ▁{ ▁case ▁25 : ▁if ▁( arg 1 ▁& ▁0 xff ffff 00) ▁return ; ▁env -> active _ f pu . f cr 31 ▁= ▁( env -> active _ f pu . f cr 31 ▁& ▁0 x 017 ffff f ) ▁| ▁(( arg 1 ▁& ▁0 x fe ) ▁<< ▁24 ) ▁| ▁(( arg 1 ▁& ▁0 x 1) ▁<< ▁23 ); ▁break ; ▁case ▁26 : ▁if ▁( arg 1 ▁& ▁0 x 007 c 0000 ) ▁return ; ▁env -> active _ f pu . f cr 31 ▁= ▁( env -> active _ f pu . f cr 31 ▁& ▁0 xff fc 0 f 8 3) ▁| ▁( arg 1 ▁& ▁0 x 000 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cpu _ set _ irq ( void ▁* op aque , ▁int ▁irq , ▁int ▁level ) ▁{ ▁CPU State ▁* env ▁= ▁opaque ; ▁if ▁( level ) ▁{ ▁CP UI R Q _ DP RI NT F (" Raise ▁CPU ▁IR Q ▁% d \ n ", ▁irq ); ▁env -> hal ted ▁= ▁0; ▁env -> p il _ in ▁|= ▁1 ▁<< ▁irq ; ▁cpu _ check _ ir qs ( env ); ▁} ▁else ▁{ ▁CP UI R Q _ DP RI NT F (" Lower ▁CPU ▁IR Q ▁% d \ n ", ▁irq ); ▁env -> p il _ in ▁&= ▁~ (1 ▁<< ▁irq ); ▁cpu _ check _ ir qs ( env ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁get _ stream _ block size ( Block Driver State ▁* b dr v ) ▁{ ▁uint 8_ t ▁cmd [6 ]; ▁uint 8_ t ▁buf [ 12 ]; ▁uint 8_ t ▁sense buf [ 8 ]; ▁sg _ io _ hdr _ t ▁io _ header ; ▁int ▁ret ; ▁mem set ( cmd , ▁0, ▁sizeof ( cmd )); ▁mem set ( buf , ▁0, ▁sizeof ( buf )); ▁cmd [0] ▁= ▁MODE _ SE NSE ; ▁cmd [4] ▁= ▁sizeof ( buf ); ▁mem set ( & io _ header , ▁0, ▁sizeof ( io _ header )); ▁io _ header . interface _ id ▁= ▁' S '; ▁io _ header . dx fer _ direction ▁= ▁S G _ D X FER _ FROM _ DEV ; ▁io _ header

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qc ow 2_ pre _ write _ overlap _ check ( Block Driver State ▁* bs , ▁int ▁ign , ▁int 64_ t ▁offset , ▁int 64_ t ▁size ) ▁{ ▁int ▁ret ▁= ▁qc ow 2_ check _ metadata _ overlap ( bs , ▁ign , ▁offset , ▁size ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁else ▁if ▁( ret ▁> ▁0) ▁{ ▁int ▁metadata _ ol _ bit nr ▁= ▁f fs ( ret ) ▁- ▁1; ▁assert ( metadata _ ol _ bit nr ▁< ▁Q CO W 2_ OL _ MAX _ BIT N R ); ▁qc ow 2_ signal _ cor ruption ( bs , ▁true , ▁offset , ▁size , ▁" Pre vent ing ▁invalid ▁" ▁" write ▁on ▁meta

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ MP V _ frame _ start ( M peg Enc Context ▁* s , ▁AV Codec Context ▁* av ctx ) ▁{ ▁int ▁i , ▁ret ; ▁Picture ▁* pic ; ▁s -> mb _ skipped ▁= ▁0; ▁if ▁(! ff _ thread _ can _ start _ frame ( av ctx )) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Attempt ▁to ▁start ▁a ▁frame ▁outside ▁SET UP ▁state \ n "); ▁return ▁-1; ▁} ▁/* ▁mark ▁& ▁release ▁old ▁frames ▁*/ ▁if ▁( s -> p ict _ type ▁!= ▁AV _ PI CT URE _ TYPE _ B ▁&& ▁s -> last _ picture _ ptr ▁&& ▁s -> last _ picture _ ptr ▁!= ▁s -> next _ pictu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁co _ write _ request ( void ▁* op aque ) ▁{ ▁B DR V Sh eep dog State ▁* s ▁= ▁opaque ; ▁qemu _ cor outine _ enter ( s -> co _ send , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ frame _ il bm ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁If f Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> size ▁>= ▁2 ▁? ▁av pk t -> data ▁+ ▁AV _ RB 16 ( av pk t -> data ) ▁: ▁NULL ; ▁const ▁int ▁buf _ size ▁= ▁av pk t -> size ▁>= ▁2 ▁? ▁av pk t -> size ▁- ▁AV _ RB 16 ( av pk t -> data ) ▁: ▁0; ▁const ▁uint 8_ t ▁* buf _ end ▁= ▁buf + buf _ size ; ▁int ▁y , ▁plane , ▁res ; ▁if ▁(( res ▁= ▁ext

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁udp _ listen ( Sl ir p ▁* sl ir p , ▁u _ int 32_ t ▁h addr , ▁u _ int ▁h port , ▁u _ int 32_ t ▁l addr , ▁u _ int ▁l port , ▁int ▁flags ) ▁{ ▁struct ▁sock addr _ in ▁addr ; ▁struct ▁socket ▁* so ; ▁sock len _ t ▁add rl en ▁= ▁sizeof ( struct ▁sock addr _ in ), ▁opt ▁= ▁1; ▁so ▁= ▁s oc reate ( sl ir p ); ▁if ▁(! so ) ▁{ ▁return ▁NULL ; ▁} ▁so -> s ▁= ▁socket ( AF _ INET , SO CK _ D GRAM , 0); ▁so -> so _ expire ▁= ▁cur time ▁+ ▁SO _ EXPI RE ; ▁ins que ( so , ▁& sl ir p -> ud b ); ▁addr . sin _ family ▁= ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁gr lib _ irq mp _ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁IR Q MP ▁* irq mp ▁= ▁opaque ; ▁IR Q MP State ▁* state ; ▁assert ( irq mp ▁!= ▁NULL ); ▁state ▁= ▁irq mp -> state ; ▁assert ( state ▁!= ▁NULL ); ▁addr ▁&= ▁0 xff ; ▁/* ▁global ▁registers ▁*/ ▁switch ▁( addr ) ▁{ ▁case ▁LEVEL _ OFFSET : ▁return ▁state -> level ; ▁case ▁PENDING _ OFFSET : ▁return ▁state -> pending ; ▁case ▁FOR CE 0_ OFFSET : ▁/* ▁This ▁register ▁is ▁an ▁" alias " ▁for ▁the ▁force ▁regist

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁qemu _ sg list _ destroy ( Q EM US G List ▁* q sg ) ▁{ ▁g _ free ( q sg -> sg ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _9 p _ device _ init ( V irt IO Device ▁* v dev ) ▁{ ▁V 9 fs State ▁* s ▁= ▁VI RT IO _9 P ( v dev ); ▁int ▁i , ▁len ; ▁struct ▁stat ▁stat ; ▁Fs Driver Entry ▁* f se ; ▁V 9 fs Path ▁path ; ▁virt io _ init ( VI RT IO _ DEVICE ( s ), ▁" virt io -9 p ", ▁VI RT IO _ ID _9 P , ▁sizeof ( struct ▁virt io _9 p _ config ) ▁+ ▁MAX _ TAG _ LEN ); ▁/* ▁initialize ▁pdu ▁allocator ▁*/ ▁Q LIST _ INIT ( & s -> free _ list ); ▁Q LIST _ INIT ( & s -> active _ list ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁( MAX _ REQ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 9 fs _ request ( V 9 fs Proxy ▁* proxy , ▁int ▁type , ▁void ▁* response , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁dev _ t ▁r dev ; ▁va _ list ▁ap ; ▁int ▁size ▁= ▁0; ▁int ▁retval ▁= ▁0; ▁uint 64_ t ▁offset ; ▁Proxy Header ▁header ▁= ▁{ ▁0, ▁0 }; ▁struct ▁times pec ▁spec [2 ]; ▁int ▁flags , ▁mode , ▁uid , ▁gid ; ▁V 9 fs String ▁* name , ▁* value ; ▁V 9 fs String ▁* path , ▁* old path ; ▁struct ▁i ove c ▁* i ove c ▁= ▁NULL , ▁* reply ▁= ▁NULL ; ▁qemu _ mut ex _ lock ( & proxy -> mut ex ); ▁if ▁( pro

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc si _ req _ set _ status ( SC S ID isk Req ▁* r , ▁int ▁status , ▁int ▁sense _ code ) ▁{ ▁S CS ID isk State ▁* s ▁= ▁DO _ UP CAST ( SC S ID isk State , ▁q dev , ▁r -> req . dev ); ▁r -> req . status ▁= ▁status ; ▁sc si _ disk _ set _ s ense ( s , ▁sense _ code ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁sd h ci _ blk gap _ write ( SD H CI State ▁* s , ▁uint 8_ t ▁value ) ▁{ ▁if ▁(( value ▁& ▁SD H C _ STOP _ AT _ G AP _ REQ ) ▁&& ▁( s -> blk gap ▁& ▁SD H C _ STOP _ AT _ G AP _ REQ )) ▁{ ▁return ; ▁} ▁s -> blk gap ▁= ▁value ▁& ▁SD H C _ STOP _ AT _ G AP _ REQ ; ▁if ▁(( value ▁& ▁SD H C _ CONT INUE _ REQ ) ▁&& ▁s -> stopped _ state ▁&& ▁( s -> blk gap ▁& ▁SD H C _ STOP _ AT _ G AP _ REQ ) ▁== ▁0) ▁{ ▁if ▁( s -> stopped _ state ▁== ▁sd hc _ gap _ read ) ▁{ ▁s -> pr n st s ▁|= ▁SD H C _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ chr _ parse _ vc ( Q emu Opts ▁* opts , ▁Ch ard ev Backend ▁* backend , ▁Error ▁** err p ) ▁{ ▁int ▁val ; ▁backend -> vc ▁= ▁g _ new 0( Ch ard ev VC , ▁1); ▁val ▁= ▁qemu _ opt _ get _ number ( opts , ▁" width ", ▁0); ▁if ▁( val ▁!= ▁0) ▁{ ▁backend -> vc -> has _ width ▁= ▁true ; ▁backend -> vc -> width ▁= ▁val ; ▁} ▁val ▁= ▁qemu _ opt _ get _ number ( opts , ▁" height ", ▁0); ▁if ▁( val ▁!= ▁0) ▁{ ▁backend -> vc -> has _ height ▁= ▁true ; ▁backend -> vc -> height ▁= ▁val ; ▁} ▁val ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁int ▁find _ best ( struct ▁vf _ instance ▁* vf ){ ▁int ▁is _ format _ ok ay ▁= ▁vf -> next -> query _ format ( vf -> next , ▁IM GF MT _ Y V 12 ); ▁if ▁(( is _ format _ ok ay ▁& ▁V FC AP _ C SP _ SUPPORTED _ BY _ H W ) ▁|| ▁( is _ format _ ok ay ▁& ▁V FC AP _ C SP _ SUPPORTED )) ▁return ▁IM GF MT _ Y V 12 ; ▁else ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _ id iv l _ E AX _ T 0( void ) ▁{ ▁int ▁den , ▁q , ▁r ; ▁int 64_ t ▁num ; ▁num ▁= ▁(( uint 32_ t ) E AX ) ▁| ▁(( uint 64_ t ) (( uint 32_ t ) ED X ) ▁<< ▁32 ); ▁den ▁= ▁T 0; ▁if ▁( den ▁== ▁0) ▁{ ▁raise _ exception ( EX CP 00_ DIV Z ); ▁} ▁# if def ▁BU GG Y _ GCC _ DIV 64 ▁r ▁= ▁id iv 32 ( & q , ▁num , ▁den ); ▁# else ▁q ▁= ▁( num ▁/ ▁den ); ▁r ▁= ▁( num ▁% ▁den ); ▁# end if ▁E AX ▁= ▁( uint 32_ t ) q ; ▁ED X ▁= ▁( uint 32_ t ) r ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁id ct _ col ( int 16_ t ▁* blk , ▁const ▁uint 8_ t ▁* quant ) ▁{ ▁int ▁t 0, ▁t 1, ▁t 2, ▁t 3, ▁t 4, ▁t 5, ▁t 6, ▁t 7, ▁t 8, ▁t 9, ▁t A , ▁t B , ▁t C , ▁t D , ▁t E , ▁t F ; ▁int ▁t 10, ▁t 11, ▁t 12, ▁t 13 ; ▁int ▁s 0, ▁s 1, ▁s 2, ▁s 3, ▁s 4, ▁s 5, ▁s 6, ▁s 7 ; ▁s 0 ▁= ▁( int ) ▁blk [0 ▁* ▁8 ] ▁* ▁quant [0 ▁* ▁8 ]; ▁s 1 ▁= ▁( int ) ▁blk [1 ▁* ▁8 ] ▁* ▁quant [1 ▁* ▁8 ]; ▁s 2 ▁= ▁( int ) ▁blk [2 ▁* ▁8 ] ▁* ▁quant [2 ▁* ▁8 ]; ▁s 3 ▁= ▁( int ) ▁blk [3 ▁* ▁8 ] ▁* ▁quant [3 ▁* ▁8 ]; ▁s 4 ▁=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁four xm _ pro be ( AV Probe Data ▁* p ) ▁{ ▁if ▁( p -> buf _ size ▁< ▁12 ) ▁return ▁0; ▁if ▁(( AV _ RL 32 ( & p -> buf [0]) ▁!= ▁RI FF _ TAG ) ▁|| ▁( AV _ RL 32 ( & p -> buf [ 8 ]) ▁!= ▁_ 4 X M V _ TAG )) ▁return ▁0; ▁return ▁AV PRO BE _ S CORE _ MAX ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁jpeg _ table _ header ( AV Codec Context ▁* av ctx , ▁Put Bit Context ▁* p , ▁Scan Table ▁* in tra _ sc ant able , ▁uint 16_ t ▁l um a _ in tra _ matrix [ 64 ], ▁uint 16_ t ▁chrom a _ in tra _ matrix [ 64 ], ▁int ▁h sample [3 ]) ▁{ ▁int ▁i , ▁j , ▁size ; ▁uint 8_ t ▁* ptr ; ▁M peg Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> codec _ id ▁!= ▁AV _ CODE C _ ID _ L J PEG ) ▁{ ▁int ▁matrix _ count ▁= ▁1 ▁+ ▁!! mem cmp ( l um a _ in tra _ matrix , ▁chrom a _ in tra _ matrix , ▁si

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ sp ap r _ init ( Machine State ▁* machine ) ▁{ ▁s P AP R Machine State ▁* sp ap r ▁= ▁SP AP R _ MA CHINE ( machine ); ▁s P AP R Machine Class ▁* sm c ▁= ▁SP AP R _ MA CHINE _ GET _ CLASS ( machine ); ▁const ▁char ▁* kernel _ filename ▁= ▁machine -> kernel _ filename ; ▁const ▁char ▁* kernel _ cmdline ▁= ▁machine -> kernel _ cmdline ; ▁const ▁char ▁* init rd _ filename ▁= ▁machine -> init rd _ filename ; ▁Power PC CPU ▁* cpu ; ▁P CI Host State ▁* ph b ; ▁int ▁i ; ▁Memory Region ▁* sys

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁n 8 x 0_ n and _ setup ( struct ▁n 800 _ s ▁* s ) ▁{ ▁char ▁* ot p _ region ; ▁Drive Info ▁* d info ; ▁s -> n and ▁= ▁q dev _ create ( NULL , ▁" on en and "); ▁q dev _ prop _ set _ uint 16 ( s -> n and , ▁" man ufacturer _ id ", ▁N AND _ M FR _ SA MS UN G ); ▁/* ▁Either ▁0 x 40 ▁or ▁0 x 48 ▁are ▁OK ▁for ▁the ▁device ▁ID ▁*/ ▁q dev _ prop _ set _ uint 16 ( s -> n and , ▁" device _ id ", ▁0 x 48 ); ▁q dev _ prop _ set _ uint 16 ( s -> n and , ▁" version _ id ", ▁0); ▁q dev _ prop _ set _ int 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁cpu _ dump _ state ▁( CPU State ▁* env , ▁FILE ▁* f , ▁int ▁(* cpu _ f printf )( FILE ▁* f , ▁const ▁char ▁* fmt , ▁... ), ▁int ▁flags ) ▁{ ▁uint 32_ t ▁c 0_ status ; ▁int ▁i ; ▁cpu _ f printf ( f , ▁" pc =0 x " ▁TARGET _ F MT _ l x ▁" ▁HI =0 x " ▁TARGET _ F MT _ l x ▁" ▁LO =0 x " ▁TARGET _ F MT _ l x ▁" ▁ds ▁% 04 x ▁" ▁TARGET _ F MT _ l x ▁" ▁% d \ n ", ▁env -> PC , ▁env -> HI , ▁env -> LO , ▁env -> h flags , ▁env -> b target , ▁env -> b cond ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁32 ; ▁i ++) ▁{ ▁if ▁(( i ▁& 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a ac _ sync ( uint 64_ t ▁state , ▁A AC AC 3 Parse Context ▁* hdr _ info , ▁int ▁* need _ next _ header , ▁int ▁* new _ frame _ start ) ▁{ ▁Get Bit Context ▁bits ; ▁A AC AD TS Header Info ▁hdr ; ▁int ▁size ; ▁union ▁{ ▁uint 64_ t ▁u 64 ; ▁uint 8_ t ▁u 8 [ 8 ]; ▁} ▁tmp ; ▁tmp . u 64 ▁= ▁av _ be 2 ne 64 ( state ); ▁init _ get _ bits ( & bits , ▁tmp . u 8 + 8- A AC _ AD TS _ HEADER _ SIZE , ▁A AC _ AD TS _ HEADER _ SIZE ▁* ▁8 ); ▁if ▁(( size ▁= ▁av priv _ a ac _ parse _ header ( & bits , ▁& hdr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 64_ t ▁helper _ ld _ as i ( CP US PAR C State ▁* env , ▁target _ ulong ▁addr , ▁int ▁as i , ▁int ▁size , ▁int ▁sign ) ▁{ ▁uint 64_ t ▁ret ▁= ▁0; ▁# if ▁defined ( DEBUG _ A SI ) ▁target _ ulong ▁last _ addr ▁= ▁addr ; ▁# end if ▁if ▁( as i ▁< ▁0 x 80) ▁{ ▁helper _ raise _ exception ( env , ▁TT _ PRI V _ ACT ); ▁} ▁helper _ check _ align ( env , ▁addr , ▁size ▁- ▁1); ▁addr ▁= ▁as i _ address _ mask ( env , ▁as i , ▁addr ); ▁switch ▁( as i ) ▁{ ▁case ▁0 x 8 2: ▁/* ▁Primary ▁no - fault ▁*/ ▁case ▁0 x 8 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁vc 2_ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁Pl ane ▁* p ; ▁Sub Band ▁* b ; ▁int ▁i , ▁j , ▁level , ▁o , ▁shift , ▁ret ; ▁const ▁AV Pix F mt Descriptor ▁* fmt ▁= ▁av _ pix _ fmt _ desc _ get ( av ctx -> pix _ fmt ); ▁const ▁int ▁depth ▁= ▁fmt -> comp [0]. depth ; ▁VC 2 Enc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> picture _ number ▁= ▁0; ▁/* ▁Total ▁allowed ▁quant ization ▁range ▁*/ ▁s -> q _ ceil ▁= ▁DI RA C _ MAX _ QU ANT _ INDEX ; ▁s -> ver . major ▁= ▁2; ▁s -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁rv 40 _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁R V 34 Dec Context ▁* r ▁= ▁av ctx -> priv _ data ; ▁r -> rv 30 ▁= ▁0; ▁ff _ rv 34 _ decode _ init ( av ctx ); ▁if (! a ic _ top _ vlc . bits ) ▁rv 40 _ init _ tables (); ▁r -> parse _ slice _ header ▁= ▁rv 40 _ parse _ slice _ header ; ▁r -> decode _ in tra _ types ▁= ▁rv 40 _ decode _ in tra _ types ; ▁r -> decode _ mb _ info ▁= ▁rv 40 _ decode _ mb _ info ; ▁r -> loop _ filter ▁= ▁rv 40 _ loop _ filter ; ▁r -> l um a _ d

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spr _ write _ db at u _ h ▁( void ▁* op aque , ▁int ▁spr n ) ▁{ ▁Dis as Context ▁* ctx ▁= ▁opaque ; ▁gen _ op _ store _ db at u (( sp rn ▁- ▁SP R _ DB AT 4 U ) ▁/ ▁2); ▁RET _ STOP ( ctx ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁sp rint f _ len ( char ▁* string , ▁const ▁char ▁* format , ▁...) ▁# else ▁sp rint f _ len ( va _ alist ) ▁va _ d cl ▁# end if ▁{ ▁va _ list ▁args ; ▁# if def ▁__ ST DC __ ▁va _ start ( args , ▁format ); ▁# else ▁char ▁* string ; ▁char ▁* format ; ▁va _ start ( args ); ▁string ▁= ▁va _ arg ( args , ▁char ▁* ); ▁format ▁= ▁va _ arg ( args , ▁char ▁* ); ▁# end if ▁v sp rint f ( string , ▁format , ▁args ); ▁return ▁str len ( string ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁extract _ ex tr ad ata _ h 264 5 ( AV BS F Context ▁* ctx , ▁AV Packet ▁* pk t , ▁uint 8_ t ▁** data , ▁int ▁* size ) ▁{ ▁static ▁const ▁int ▁extr ad ata _ nal _ types _ h ev c [] ▁= ▁{ ▁HE VC _ NAL _ V PS , ▁HE VC _ NAL _ SP S , ▁HE VC _ NAL _ P PS , ▁}; ▁static ▁const ▁int ▁extr ad ata _ nal _ types _ h 264 [] ▁= ▁{ ▁H 2 64_ NAL _ SP S , ▁H 2 64_ NAL _ P PS , ▁}; ▁Extract Ex tr ad ata Context ▁* s ▁= ▁ctx -> priv _ data ; ▁H 264 5 Packet ▁h 264 5_ pk t ▁= ▁{ ▁0 ▁}; ▁int ▁extr ad ata _ size

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁F UNC ( put _ h ev c _ ep el _ bi _ w _ h )( uint 8_ t ▁* _ dst , ▁ptr diff _ t ▁_ dst stride , ▁uint 8_ t ▁* _ src , ▁ptr diff _ t ▁_ src stride , ▁int 16_ t ▁* src 2, ▁int ▁height , ▁int ▁denom , ▁int ▁wx 0, ▁int ▁wx 1, ▁int ▁o x 0, ▁int ▁o x 1, ▁int ptr _ t ▁mx , ▁int ptr _ t ▁my , ▁int ▁width ) ▁{ ▁int ▁x , ▁y ; ▁pixel ▁* src ▁= ▁( pixel ▁* ) _ src ; ▁ptr diff _ t ▁src stride ▁= ▁_ src stride ▁/ ▁sizeof ( pixel ); ▁pixel ▁* dst ▁= ▁( pixel ▁* ) _ dst ; ▁ptr diff _ t ▁dst stride ▁= ▁_ ds

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sd l 2_ gl _ scan out ( Display ChangeListener ▁* d cl , ▁uint 32_ t ▁backing _ id , ▁bool ▁backing _ y _0_ top , ▁uint 32_ t ▁x , ▁uint 32_ t ▁y , ▁uint 32_ t ▁w , ▁uint 32_ t ▁h ) ▁{ ▁struct ▁sd l 2_ console ▁* s con ▁= ▁container _ of ( d cl , ▁struct ▁sd l 2_ console , ▁d cl ); ▁assert ( s con -> open gl ); ▁s con -> x ▁= ▁x ; ▁s con -> y ▁= ▁y ; ▁s con -> w ▁= ▁w ; ▁s con -> h ▁= ▁h ; ▁s con -> tex _ id ▁= ▁backing _ id ; ▁s con -> y 0_ top ▁= ▁backing _ y _0_ top ; ▁SDL _ GL _ Make Current ( 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁mm _ stop _ timer ( struct ▁qemu _ alarm _ timer ▁* t ) ▁{ ▁time Kill Event ( mm _ timer ); ▁time End Period ( mm _ period ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tc g _ out _ q emu _ st ( TC G Context ▁* s , ▁TC G Reg ▁data , ▁TC G Reg ▁addr , ▁TC G Mem Op Idx ▁o i ) ▁{ ▁TC G Mem Op ▁mem op ▁= ▁get _ mem op ( oi ); ▁# if def ▁CONFIG _ SO FT MM U ▁unsigned ▁mem i ▁= ▁get _ mm uid x ( oi ); ▁TC G Reg ▁addr z , ▁param ; ▁tc g _ ins n _ unit ▁* func ; ▁tc g _ ins n _ unit ▁* label _ ptr ; ▁addr z ▁= ▁tc g _ out _ tl b _ load ( s , ▁addr , ▁mem i , ▁mem op , ▁offset of ( CP UT LB Entry , ▁addr _ write )); ▁/* ▁The ▁fast ▁path ▁is ▁exactly ▁one ▁insn . ▁T

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Q EM U File ▁* q emu _ f open _ fd ( int ▁fd ) ▁{ ▁Q EM U File FD ▁* s ▁= ▁qemu _ m alloc z ( size of ( Q EM U File FD )); ▁if ▁( s ▁== ▁NULL ) ▁return ▁NULL ; ▁s -> fd ▁= ▁fd ; ▁s -> file ▁= ▁qemu _ f open _ ops ( s , ▁fd _ put _ buffer , ▁fd _ get _ buffer , ▁fd _ close , ▁NULL ); ▁return ▁s -> file ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pred _ spatial _ direct _ m otion ( const ▁H 264 Context ▁* const ▁h , ▁H 264 Slice Context ▁* sl , ▁int ▁* mb _ type ) ▁{ ▁int ▁b 8_ stride ▁= ▁2; ▁int ▁b 4_ stride ▁= ▁h -> b _ stride ; ▁int ▁mb _ xy ▁= ▁sl -> mb _ xy , ▁mb _ y ▁= ▁sl -> mb _ y ; ▁int ▁mb _ type _ col [2 ]; ▁const ▁int 16_ t ▁(* l 1 mv 0) [2], ▁(* l 1 mv 1) [2 ]; ▁const ▁int 8_ t ▁* l 1 ref 0, ▁* l 1 ref 1; ▁const ▁int ▁is _ b 8 x 8 ▁= ▁IS _8 X 8 (* mb _ type ); ▁unsigned ▁int ▁sub _ mb _ type ▁= ▁MB _ TYPE _ L 0 L 1; ▁in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b oston _ l cd _ event ( void ▁* op aque , ▁int ▁event ) ▁{ ▁B oston State ▁* s ▁= ▁opaque ; ▁if ▁( event ▁== ▁CH R _ EVENT _ O PE NED ▁&& ▁! s -> l cd _ init ed ) ▁{ ▁qemu _ chr _ fe _ printf ( & s -> l cd _ display , ▁" ▁"); ▁s -> l cd _ init ed ▁= ▁true ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁add _ command ( const ▁cmd info _ t ▁* ci ) ▁{ ▁cmd tab ▁= ▁real loc (( void ▁* ) cmd tab , ▁++ n cmds ▁* ▁sizeof (* cmd tab )); ▁cmd tab [ n cmds ▁- ▁1] ▁= ▁* ci ; ▁q sort ( cmd tab , ▁n cmds , ▁sizeof (* cmd tab ), ▁compare ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁open pic _ update _ irq ( Open PIC State ▁* o pp , ▁int ▁n _ IR Q ) ▁{ ▁IR Q _ src _ t ▁* src ; ▁int ▁i ; ▁src ▁= ▁& o pp -> src [ n _ IR Q ]; ▁if ▁(! src -> pending ) ▁{ ▁/* ▁no ▁irq ▁pending ▁*/ ▁D PRI NT F ("% s : ▁IR Q ▁% d ▁is ▁not ▁pending \ n ", ▁__ func __, ▁n _ IR Q ); ▁return ; ▁} ▁if ▁( src -> ipv p ▁& ▁IP VP _ MASK _ MASK ) ▁{ ▁/* ▁Inter rupt ▁source ▁is ▁disabled ▁*/ ▁D PRI NT F ("% s : ▁IR Q ▁% d ▁is ▁disabled \ n ", ▁__ func __, ▁n _ IR Q ); ▁return ; ▁} ▁if ▁( IP VP _ PRIORI

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁usb _ bt _ f ifo _ out _ enqueue ( struct ▁US BB t State ▁* s , ▁struct ▁usb _ h ci _ out _ f ifo _ s ▁* f ifo , ▁void ▁(* send )( struct ▁H CI Info ▁* , ▁const ▁uint 8_ t ▁* , ▁int ), ▁int ▁(* complete )( const ▁uint 8_ t ▁* , ▁int ), ▁const ▁uint 8_ t ▁* data , ▁int ▁len ) ▁{ ▁if ▁( f ifo -> len ) ▁{ ▁mem c py ( f ifo -> data ▁+ ▁fif o -> len , ▁data , ▁len ); ▁fif o -> len ▁+= ▁len ; ▁if ▁( complete ( f ifo -> data , ▁fif o -> len )) ▁{ ▁send ( s -> h ci , ▁fif o -> data , ▁fif o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ status ( HTTP Context ▁* c ) ▁{ ▁HTTP Context ▁* c 1; ▁FF Stream ▁* stream ; ▁char ▁* p ; ▁time _ t ▁ti ; ▁int ▁i , ▁len ; ▁AV IO Context ▁* pb ; ▁if ▁( av io _ open _ dyn _ buf ( & pb ) ▁< ▁0) ▁{ ▁/* ▁XXX : ▁return ▁an ▁error ▁? ▁*/ ▁c -> buffer _ ptr ▁= ▁c -> buffer ; ▁c -> buffer _ end ▁= ▁c -> buffer ; ▁return ; ▁} ▁av io _ printf ( pb , ▁" HTTP / 1.0 ▁200 ▁OK \ r \ n "); ▁av io _ printf ( pb , ▁" Content - type : ▁% s \ r \ n ", ▁" text / html "); ▁av io _ printf ( pb , ▁" P 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ram _ save _ compressed _ page ( Q EM U File ▁* f , ▁Page Search Status ▁* p ss , ▁bool ▁last _ stage , ▁uint 64_ t ▁* bytes _ transfer red ) ▁{ ▁int ▁pages ▁= ▁-1; ▁uint 64_ t ▁bytes _ xmit ; ▁uint 8_ t ▁* p ; ▁int ▁ret ; ▁RAM Block ▁* block ▁= ▁p ss -> block ; ▁ram _ addr _ t ▁offset ▁= ▁p ss -> offset ; ▁p ▁= ▁block -> host ▁+ ▁offset ; ▁bytes _ xmit ▁= ▁0; ▁ret ▁= ▁ram _ control _ save _ page ( f , ▁block -> offset , ▁offset , ▁TARGET _ PAGE _ SIZE , ▁& bytes _ xmit ); ▁if ▁( bytes _ xmi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ block _ stream ( bool ▁has _ job _ id , ▁const ▁char ▁* job _ id , ▁const ▁char ▁* device , ▁bool ▁has _ base , ▁const ▁char ▁* base , ▁bool ▁has _ back ing _ file , ▁const ▁char ▁* back ing _ file , ▁bool ▁has _ speed , ▁int 64_ t ▁speed , ▁bool ▁has _ on _ error , ▁Block dev OnError ▁on _ error , ▁Error ▁** err p ) ▁{ ▁Block Driver State ▁* bs ; ▁Block Driver State ▁* base _ bs ▁= ▁NULL ; ▁A io Context ▁* a io _ context ; ▁Error ▁* local _ err ▁= ▁NULL ; ▁const ▁char ▁* base _ name ▁= ▁NUL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ dx va 2_ commit _ buffer ( AV Codec Context ▁* av ctx , ▁AV D X VA Context ▁* ctx , ▁DE CO DER _ BUFFER _ DESC ▁* d sc , ▁unsigned ▁type , ▁const ▁void ▁* data , ▁unsigned ▁size , ▁unsigned ▁mb _ count ) ▁{ ▁void ▁* dx va _ data ; ▁unsigned ▁dx va _ size ; ▁int ▁result ; ▁H RESULT ▁hr ; ▁# if ▁CONFIG _ D 3 D 11 VA ▁if ▁( av ctx -> pix _ fmt ▁== ▁AV _ PI X _ F MT _ D 3 D 11 VA _ V LD ) ▁hr ▁= ▁ID 3 D 11 Video Context _ Get Decoder Buffer ( D 3 D 11 VA _ CONTEXT ( ctx ) -> video _ context , ▁D 3 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁inet _ listen _ s addr ( Inet SocketAddress ▁* s addr , ▁int ▁port _ offset , ▁bool ▁update _ addr , ▁Error ▁** err p ) ▁{ ▁struct ▁addr info ▁ai , * res , * e ; ▁char ▁port [ 33 ]; ▁char ▁u addr [ INET 6_ ADDR STR LEN +1 ]; ▁char ▁u port [ 33 ]; ▁int ▁s listen , ▁rc , ▁port _ min , ▁port _ max , ▁p ; ▁Error ▁* err ▁= ▁NULL ; ▁mem set ( & ai , 0, ▁sizeof ( ai )); ▁ai . ai _ flags ▁= ▁AI _ PASS IVE ; ▁if ▁( s addr -> has _ numeric ▁&& ▁s addr -> numeric ) ▁{ ▁ai . ai _ flags ▁|= ▁AI _ NUM ER 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ are s ( MO V Context ▁* c , ▁AV IO Context ▁* pb , ▁MO V Atom ▁atom ) ▁{ ▁AV Codec Context ▁* codec ▁= ▁c -> fc -> streams [ c -> fc -> nb _ streams -1] -> codec ; ▁if ▁( codec -> codec _ tag ▁== ▁M K TAG (' A ', ▁' V ', ▁' i ', ▁' n ') ▁&& ▁codec -> codec _ id ▁== ▁AV _ CODE C _ ID _ H 264 ▁&& ▁atom . size ▁> ▁11 ) ▁{ ▁av io _ skip ( pb , ▁10); ▁/* ▁For ▁AV ID ▁AV CI 50, ▁force ▁width ▁of ▁14 40 ▁to ▁be ▁able ▁to ▁select ▁the ▁correct ▁S PS ▁and ▁P PS ▁*/ ▁if ▁( av io _ rb 16 (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁vm state _ un register ( const ▁VM State Description ▁* v ms d , ▁void ▁* op aque ) ▁{ ▁Save State Entry ▁* se , ▁* new _ se ; ▁TA IL Q _ FORE A CH _ SAFE ( se , ▁& save vm _ handlers , ▁entry , ▁new _ se ) ▁{ ▁if ▁( se -> v ms d ▁== ▁vms d ▁&& ▁se -> op aque ▁== ▁opaque ) ▁{ ▁TA IL Q _ REMOVE ( & save vm _ handlers , ▁se , ▁entry ); ▁qemu _ free ( se ); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁virt io _ net _ handle _ mac ( V irt ION et ▁* n , ▁uint 8_ t ▁cmd , ▁struct ▁i ove c ▁* io v , ▁unsigned ▁int ▁i ov _ cnt ) ▁{ ▁struct ▁virt io _ net _ ctrl _ mac ▁mac _ data ; ▁size _ t ▁s ; ▁Net Client State ▁* nc ▁= ▁qemu _ get _ queue ( n -> nic ); ▁if ▁( cmd ▁== ▁VI RT IO _ NET _ CT RL _ MAC _ ADDR _ SET ) ▁{ ▁if ▁( io v _ size ( io v , ▁i ov _ cnt ) ▁!= ▁sizeof ( n -> mac )) ▁{ ▁return ▁VI RT IO _ NET _ ERR ; ▁} ▁s ▁= ▁i ov _ to _ buf ( io v , ▁i ov _ cnt , ▁0, ▁& n -> mac , ▁sizeof (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ff mm al _ init _ decoder ( AV Codec Context ▁* av ctx ) ▁{ ▁MM AL Decode Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁MM AL _ STATUS _ T ▁status ; ▁MM AL _ ES _ FORMAT _ T ▁* format _ in ; ▁MM AL _ COMPONENT _ T ▁* decoder ; ▁char ▁tmp [ 32 ]; ▁int ▁ret ▁= ▁0; ▁bc m _ host _ init (); ▁if ▁( mm al _ vc _ init ()) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Cannot ▁initialize ▁MM AL ▁VC ▁driver ! \ n "); ▁return ▁A VER ROR ( EN OS Y S ); ▁if ▁(( ret ▁= ▁ff _ get _ format ( av ct

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁o gg _ get _ length ( AV Format Context ▁* s ) ▁{ ▁struct ▁o gg ▁* og g ▁= ▁s -> priv _ data ; ▁int ▁i ; ▁int 64_ t ▁size , ▁end ; ▁int ▁streams _ left =0; ▁if (! s -> pb -> seek able ) ▁return ▁0; ▁// ▁already ▁set ▁if ▁( s -> duration ▁!= ▁AV _ NO PT S _ VALUE ) ▁return ▁0; ▁size ▁= ▁av io _ size ( s -> pb ); ▁if ( size ▁< ▁0) ▁return ▁0; ▁end ▁= ▁size ▁> ▁MAX _ PAGE _ SIZE ? ▁size ▁- ▁MAX _ PAGE _ SIZE : ▁0; ▁o gg _ save ▁( s ); ▁av io _ seek ▁( s -> pb , ▁end , ▁SE EK _ SET ); ▁while ▁(!

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mimic _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁M im ic Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁Get Byte Context ▁gb ; ▁int ▁is _ p frame ; ▁int ▁width , ▁height ; ▁int ▁quality , ▁num _ coeff s ; ▁int ▁swap _ buf _ size ▁= ▁buf _ size ▁- ▁M IM IC _ HEADER _ SIZE ; ▁if ▁( buf _ size ▁<= ▁M IM IC _ HEADER _ SIZE ) ▁{ ▁av _ log ( av c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ip video _ decode _ block _ op code _0 x 8 ( Ipv ideo Context ▁* s ) ▁{ ▁int ▁x , ▁y ; ▁unsigned ▁char ▁P [2 ]; ▁unsigned ▁int ▁flags ▁= ▁0; ▁/* ▁2- color ▁encoding ▁for ▁each ▁4 x 4 ▁quad rant , ▁or ▁2- color ▁encoding ▁on ▁* ▁either ▁top ▁and ▁bottom ▁or ▁left ▁and ▁right ▁hal ves ▁*/ ▁CHECK _ STREAM _ PT R (2); ▁P [0] ▁= ▁* s -> stream _ ptr ++; ▁P [1] ▁= ▁* s -> stream _ ptr ++; ▁if ▁( P [0] ▁<= ▁P [1]) ▁{ ▁CHECK _ STREAM _ PT R ( 14 ); ▁s -> stream _ ptr ▁-= ▁2; ▁for ▁( y ▁= ▁0; ▁y ▁< ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gdb _ set _ av r _ reg ( CPU State ▁* env , ▁uint 8_ t ▁* mem _ buf , ▁int ▁n ) ▁{ ▁if ▁( n ▁< ▁3 2) ▁{ ▁# if def ▁WOR DS _ B IG ENDIAN ▁env -> av r [ n ]. u 64 [0] ▁= ▁ld q _ p ( mem _ buf ); ▁env -> av r [ n ]. u 64 [1] ▁= ▁ld q _ p ( mem _ buf + 8 ); ▁# else ▁env -> av r [ n ]. u 64 [1] ▁= ▁ld q _ p ( mem _ buf ); ▁env -> av r [ n ]. u 64 [0] ▁= ▁ld q _ p ( mem _ buf + 8 ); ▁# end if ▁return ▁16 ; ▁} ▁if ▁( n ▁== ▁3 3) ▁{ ▁env -> v scr ▁= ▁ld l _ p ( mem _ buf ); ▁return ▁4; ▁} ▁if ▁( n ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v ga _ draw _ text ( V GA Common State ▁* s , ▁int ▁full _ update ) ▁{ ▁Display Surface ▁* surface ▁= ▁qemu _ console _ surface ( s -> con ); ▁int ▁cx , ▁cy , ▁ch eight , ▁cw , ▁ch , ▁c attr , ▁height , ▁width , ▁ch _ attr ; ▁int ▁cx _ min , ▁cx _ max , ▁lines ize , ▁x _ inc r , ▁line , ▁line 1; ▁uint 32_ t ▁offset , ▁fg col , ▁bg col , ▁v , ▁cursor _ offset ; ▁uint 8_ t ▁* d 1, ▁* d , ▁* src , ▁* dest , ▁* cursor _ ptr ; ▁const ▁uint 8_ t ▁* font _ ptr , ▁* font _ base [2 ]; ▁int ▁dup 9, ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int 64_ t ▁qemu _ ft ell ( Q EM U File ▁* f ) ▁{ ▁qemu _ ff lush ( f ); ▁return ▁f -> pos ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁lib qu vi _ read _ packet ( AV Format Context ▁* s , ▁AV Packet ▁* pk t ) ▁{ ▁Lib Qu vi Context ▁* q c ▁= ▁s -> priv _ data ; ▁return ▁av _ read _ frame ( q c -> fmt ctx , ▁pkt ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁PC ID evice ▁* q emu _ pc i _ hot _ add _ storage ( Monitor ▁* mon , ▁const ▁char ▁* dev addr , ▁const ▁char ▁* opts ) ▁{ ▁PC ID evice ▁* dev ; ▁Drive Info ▁* d info ▁= ▁NULL ; ▁int ▁type ▁= ▁-1; ▁char ▁buf [ 128 ]; ▁P CI Bus ▁* bus ; ▁int ▁dev fn ; ▁if ▁( get _ param _ value ( buf , ▁sizeof ( buf ), ▁" if ", ▁opts )) ▁{ ▁if ▁(! str cmp ( buf , ▁" sc si ")) ▁type ▁= ▁IF _ SC SI ; ▁else ▁if ▁(! str cmp ( buf , ▁" virt io ")) ▁{ ▁type ▁= ▁IF _ VI RT IO ; ▁} ▁else ▁{ ▁monitor _ printf ( mon , ▁" typ

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 16_ t ▁e ep rom 93 xx _ read ( eep rom _ t ▁* eep rom ) ▁{ ▁/* ▁Return ▁status ▁of ▁pin ▁DO ▁(0 ▁or ▁1). ▁*/ ▁logout (" CS =% u ▁DO =% u \ n ", ▁e ep rom -> e ec s , ▁e ep rom -> eed o ); ▁return ▁( eep rom -> eed o ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sys ctl _ write ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁value ) ▁{ ▁M il k ym ist Sys ctl State ▁* s ▁= ▁opaque ; ▁trace _ m il k ym ist _ sys ctl _ memory _ write ( addr , ▁value ); ▁addr ▁>>= ▁2; ▁switch ▁( addr ) ▁{ ▁case ▁R _ G PIO _ OUT : ▁case ▁R _ G PIO _ INT EN : ▁case ▁R _ T IMER 0_ COUNT ER : ▁if ▁( value ▁> ▁s -> re gs [ R _ T IMER 0_ COUNT ER ]) ▁{ ▁value ▁= ▁s -> re gs [ R _ T IMER 0_ COUNT ER ]; ▁error _ report (" m il k ym ist _ sys ctl : ▁timer 0:

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁AV Frame ▁* av codec _ alloc _ frame ( void ) ▁{ ▁AV Frame ▁* frame ▁= ▁av _ m alloc z ( size of ( AV Frame )); ▁if ▁( frame ▁== ▁NULL ) ▁return ▁NULL ; ▁FF _ DIS ABLE _ DE PRE CATION _ WARNING S ▁av codec _ get _ frame _ defaults ( frame ); ▁FF _ ENABLE _ DE PRE CATION _ WARNING S ▁return ▁frame ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁add _ h fy u _ left _ prediction _ int 16_ c ( uint 16_ t ▁* dst , ▁const ▁uint 16_ t ▁* src , ▁unsigned ▁mask , ▁int ▁w , ▁int ▁acc ){ ▁int ▁i ; ▁for ( i =0; ▁i < w -1; ▁i ++){ ▁acc += ▁src [ i ]; ▁dst [ i ]= ▁acc ▁& ▁mask ; ▁i ++; ▁acc += ▁src [ i ]; ▁dst [ i ]= ▁acc ▁& ▁mask ; ▁} ▁for ( ; ▁i < w ; ▁i ++){ ▁acc += ▁src [ i ]; ▁dst [ i ]= ▁acc ▁& ▁mask ; ▁} ▁return ▁acc ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁qemu _ irq ▁* px a 2 xx _ pic _ init ( target _ ph ys _ addr _ t ▁base , ▁CPU State ▁* env ) ▁{ ▁P XA 2 xx PIC State ▁* s ; ▁int ▁i om em type ; ▁qemu _ irq ▁* q i ; ▁s ▁= ▁( P XA 2 xx PIC State ▁* ) ▁qemu _ m alloc z ( size of ( P XA 2 xx PIC State )); ▁if ▁(! s ) ▁return ▁NULL ; ▁s -> cpu _ env ▁= ▁env ; ▁s -> int _ pending [0] ▁= ▁0; ▁s -> int _ pending [1] ▁= ▁0; ▁s -> int _ enabled [0] ▁= ▁0; ▁s -> int _ enabled [1] ▁= ▁0; ▁s -> is _ f iq [0] ▁= ▁0; ▁s -> is _ f iq [1] ▁= ▁0; ▁q i ▁= ▁qemu _ allocat

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁net _ init _ v de ( Q emu Opts ▁* opts , ▁const ▁Net Client Options ▁* new _ opts , ▁const ▁char ▁* name , ▁V LAN State ▁* vlan ) ▁{ ▁const ▁char ▁* sock ; ▁const ▁char ▁* group ; ▁int ▁port , ▁mode ; ▁sock ▁= ▁qemu _ opt _ get ( opts , ▁" sock "); ▁group ▁= ▁qemu _ opt _ get ( opts , ▁" group "); ▁port ▁= ▁qemu _ opt _ get _ number ( opts , ▁" port ", ▁0); ▁mode ▁= ▁qemu _ opt _ get _ number ( opts , ▁" mode ", ▁07 00 ); ▁if ▁( net _ v de _ init ( vlan , ▁" v de ", ▁name , ▁sock , ▁port , ▁group , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁ID 3 v 2 EM Func ▁* get _ extra _ meta _ func ( const ▁char ▁* tag , ▁int ▁is v 34 ) ▁{ ▁int ▁i ▁= ▁0; ▁while ▁( ff _ id 3 v 2_ extra _ meta _ funcs [ i ]. tag 3) ▁{ ▁if ▁(! mem cmp ( tag , ▁( is v 34 ▁? ▁ff _ id 3 v 2_ extra _ meta _ funcs [ i ]. tag 4 ▁: ▁ff _ id 3 v 2_ extra _ meta _ funcs [ i ]. tag 3), ▁( is v 34 ▁? ▁4 ▁: ▁3 ))) ▁return ▁& ff _ id 3 v 2_ extra _ meta _ funcs [ i ]; ▁i ++; ▁} ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁av _ buffers rc _ add _ ref ( AV Filter Context ▁* buffer _ filter , ▁AV Filter Buffer Ref ▁* pic ref , ▁int ▁flags ) ▁{ ▁Buffer Source Context ▁* c ▁= ▁buffer _ filter -> priv ; ▁AV Filter Buffer Ref ▁* buf ; ▁int ▁ret ; ▁if ▁(! pic ref ) ▁{ ▁c -> eof ▁= ▁1; ▁return ▁0; ▁} ▁else ▁if ▁( c -> eof ) ▁return ▁A VER ROR ( E IN VAL ); ▁if ▁(! av _ f ifo _ space ( c -> f ifo ) ▁&& ▁( ret ▁= ▁av _ f ifo _ real loc 2( c -> f ifo , ▁av _ f ifo _ size ( c -> f ifo ) ▁+ ▁sizeof ( buf ))) ▁< ▁0) ▁return ▁ret ; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q string _ destroy _ obj ( Q Object ▁* obj ) ▁{ ▁Q String ▁* qs ; ▁assert ( obj ▁!= ▁NULL ); ▁qs ▁= ▁q object _ to _ q string ( obj ); ▁g _ free ( qs -> string ); ▁g _ free ( qs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁bool ▁aio _ pending ( A io Context ▁* ctx ) ▁{ ▁A io Handler ▁* node ; ▁bool ▁result ▁= ▁false ; ▁/* ▁* ▁We ▁have ▁to ▁walk ▁very ▁carefully ▁in ▁case ▁aio _ set _ fd _ handler ▁is ▁* ▁called ▁while ▁we ' re ▁walk ing . ▁*/ ▁qemu _ lock cnt _ inc ( & ctx -> list _ lock ); ▁Q LIST _ FORE A CH _ RC U ( node , ▁& ctx -> a io _ handlers , ▁node ) ▁{ ▁if ▁( node -> p fd . re vent s ▁&& ▁node -> io _ notify ) ▁{ ▁result ▁= ▁true ; ▁break ; ▁} ▁if ▁(( node -> p fd . re vent s ▁& ▁G _ IO _ IN ) ▁&& ▁node -> io _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁size _ t ▁get _ request _ size ( V irt Queue ▁* v q ) ▁{ ▁unsigned ▁int ▁in , ▁out ; ▁virt queue _ get _ avail _ bytes ( v q , ▁& in , ▁& out ); ▁return ▁in ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ quit ( int ▁arg c , ▁const ▁char ▁** argv ) ▁{ ▁exit (0); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pc _ init 1( ram _ addr _ t ▁ram _ size , ▁const ▁char ▁* boot _ device , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model , ▁int ▁pci _ enabled , ▁int ▁k vm clock _ enabled ) ▁{ ▁int ▁i ; ▁ram _ addr _ t ▁below _4 g _ mem _ size , ▁above _4 g _ mem _ size ; ▁P CI Bus ▁* pc i _ bus ; ▁P CI I 4 40 FX State ▁* i 4 40 fx _ state ; ▁int ▁pi ix 3_ dev fn ▁= ▁-1; ▁qemu _ irq ▁* cpu _ irq ; ▁qemu _ irq ▁* isa _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁ro q _ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁R o q Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> av ctx ▁= ▁av ctx ; ▁if ▁( av ctx -> width ▁% ▁16 ▁|| ▁av ctx -> height ▁% ▁16 ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Dimensions ▁must ▁be ▁a ▁multiple ▁of ▁16 \ n "); ▁return ▁A VER ROR _ P ATCH W EL CO ME ; ▁} ▁s -> width ▁= ▁av ctx -> width ; ▁s -> height ▁= ▁av ctx -> height ; ▁s -> last _ frame ▁= ▁av _ frame _ alloc (); ▁s -> current _ frame ▁= ▁av _ frame 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ bt _ handle _ data ( US B Device ▁* dev , ▁USB Packet ▁* p ) ▁{ ▁struct ▁US BB t State ▁* s ▁= ▁( struct ▁US BB t State ▁* ) ▁dev -> op aque ; ▁int ▁ret ▁= ▁0; ▁if ▁(! s -> config ) ▁goto ▁fail ; ▁switch ▁( p -> pid ) ▁{ ▁case ▁USB _ TOKEN _ IN : ▁switch ▁( p -> de ve p ▁& ▁0 xf ) ▁{ ▁case ▁USB _ E VT _ EP : ▁ret ▁= ▁usb _ bt _ f ifo _ de queue ( & s -> evt , ▁p ); ▁break ; ▁case ▁USB _ ACL _ EP : ▁ret ▁= ▁usb _ bt _ f ifo _ de queue ( & s -> acl , ▁p ); ▁break ; ▁case ▁USB _ S CO _ EP

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt as _ ibm _ read _ slot _ reset _ state 2( Power PC CPU ▁* cpu , ▁s P AP R Environment ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁s P AP R PH B State ▁* s ph b ; ▁s P AP R PH B Class ▁* sp c ; ▁uint 64_ t ▁b uid ; ▁int ▁state , ▁ret ; ▁if ▁(( n args ▁!= ▁3) ▁|| ▁( n ret ▁!= ▁4 ▁&& ▁n ret ▁!= ▁5 )) ▁{ ▁goto ▁param _ error _ exit ; ▁} ▁b uid ▁= ▁(( uint 64_ t ) rt as _ ld ( args , ▁1) ▁<< ▁3 2) ▁| ▁rt as _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ migrate _ set _ cache _ size ( int 64_ t ▁value , ▁Error ▁** err p ) ▁{ ▁Migration State ▁* s ▁= ▁migrate _ get _ current (); ▁/* ▁Check ▁for ▁trunc ation ▁*/ ▁if ▁( value ▁!= ▁( size _ t ) value ) ▁{ ▁error _ set ( err p , ▁Q ERR _ INVALID _ PARAMETER _ VALUE , ▁" cache ▁size ", ▁" ex ceed ing ▁address ▁space "); ▁return ; ▁} ▁s -> xb z r le _ cache _ size ▁= ▁x bz r le _ cache _ resize ( value ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁path _ is _ absolute ( const ▁char ▁* path ) ▁{ ▁const ▁char ▁* p ; ▁# if def ▁_ W IN 32 ▁/* ▁specific ▁case ▁for ▁names ▁like : ▁"\\ .\ d :" ▁*/ ▁if ▁(* path ▁== ▁'/' ▁|| ▁* path ▁== ▁' \\ ') ▁return ▁1; ▁# end if ▁p ▁= ▁str chr ( path , ▁': '); ▁if ▁( p ) ▁p ++; ▁else ▁p ▁= ▁path ; ▁# if def ▁_ W IN 32 ▁return ▁(* p ▁== ▁'/' ▁|| ▁* p ▁== ▁' \\ '); ▁# else ▁return ▁(* p ▁== ▁'/ '); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁opts _ end _ struct ( Visitor ▁* v , ▁Error ▁** err p ) ▁{ ▁Opt s Visitor ▁* ov ▁= ▁to _ ov ( v ); ▁G Hash Table Iter ▁iter ; ▁G Queue ▁* any ; ▁if ▁( -- ov -> depth ▁> ▁0) ▁{ ▁return ; ▁} ▁/* ▁we ▁should ▁have ▁processed ▁all ▁( distinct ) ▁Q emu Opt ▁instances ▁*/ ▁g _ hash _ table _ iter _ init ( & iter , ▁o v -> un processed _ opts ); ▁if ▁( g _ hash _ table _ iter _ next ( & iter , ▁NULL , ▁( void ▁** ) & any )) ▁{ ▁const ▁Q emu Opt ▁* first ; ▁first ▁= ▁g _ queue _ pe ek _ head ( any ); ▁error _ se

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁shorten _ decode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁Short en Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁s -> channels ; ▁i ++) ▁{ ▁s -> decoded [ i ] ▁-= ▁s -> n wrap ; ▁av _ fre ep ( & s -> decoded [ i ]); ▁av _ fre ep ( & s -> offset [ i ]); ▁} ▁av _ fre ep ( & s -> bit stream ); ▁av _ fre ep ( & s -> coeff s ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ avg _ h 2 64_ qp el 4_ mc 13 _ ms a ( uint 8_ t ▁* dst , ▁const ▁uint 8_ t ▁* src , ▁ptr diff _ t ▁stride ) ▁{ ▁av c _ l um a _ h v _ q rt _ and _ aver _ dst _4 x 4_ ms a ( src ▁+ ▁stride ▁- ▁2, ▁src ▁- ▁( stride ▁* ▁2), ▁stride , ▁dst , ▁stride ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁ap ic _ mem _ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁Device State ▁* d ; ▁API C Common State ▁* s ; ▁uint 32_ t ▁val ; ▁int ▁index ; ▁d ▁= ▁cpu _ get _ current _ ap ic (); ▁if ▁(! d ) ▁{ ▁return ▁0; ▁} ▁s ▁= ▁DO _ UP CAST ( API C Common State , ▁bus dev . q dev , ▁d ); ▁index ▁= ▁( addr ▁>> ▁4) ▁& ▁0 xff ; ▁switch ( index ) ▁{ ▁case ▁0 x 0 2: ▁/* ▁id ▁*/ ▁val ▁= ▁s -> id ▁<< ▁24 ; ▁break ; ▁case ▁0 x 0 3: ▁/* ▁version ▁*/ ▁val ▁= ▁0 x 11 ▁| ▁(( API C _ L VT 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁SocketAddress Legacy ▁* tcp _ build _ address ( const ▁char ▁* host _ port , ▁Error ▁** err p ) ▁{ ▁Inet SocketAddress ▁* i addr ▁= ▁g _ new ( Inet SocketAddress , ▁1); ▁SocketAddress Legacy ▁* s addr ; ▁if ▁( inet _ parse ( i addr , ▁host _ port , ▁err p )) ▁{ ▁q api _ free _ Inet SocketAddress ( i addr ); ▁return ▁NULL ; ▁} ▁s addr ▁= ▁g _ new 0( SocketAddress Legacy , ▁1); ▁s addr -> type ▁= ▁SO CKET _ ADDRESS _ LEG ACY _ K IND _ INET ; ▁s addr -> u . inet . data ▁= ▁i addr ; ▁return ▁s addr ;

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁render _ line ( int ▁x 0, ▁uint 8_ t ▁y 0, ▁int ▁x 1, ▁int ▁y 1, ▁float ▁* buf ) ▁{ ▁int ▁dy ▁= ▁y 1 ▁- ▁y 0; ▁int ▁ad x ▁= ▁x 1 ▁- ▁x 0; ▁int ▁ad y ▁= ▁FF AB S ( dy ); ▁int ▁sy ▁= ▁dy ▁< ▁0 ▁? ▁-1 ▁: ▁1; ▁buf [ x 0] ▁= ▁ff _ vor b is _ floor 1_ inverse _ db _ table [ y 0 ]; ▁if ▁( ady * 2 ▁<= ▁ad x ) ▁{ ▁// ▁optimized ▁common ▁case ▁render _ line _ un rolled ( x 0, ▁y 0, ▁x 1, ▁sy , ▁ad y , ▁ad x , ▁buf ); ▁} ▁else ▁{ ▁int ▁base ▁= ▁dy ▁/ ▁ad x ; ▁int ▁x ▁= ▁x 0; ▁uint 8_ t ▁y ▁= ▁y 0; ▁in

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁const ▁Q Object ▁* q mp _ input _ get _ object ( Q mp Input Visitor ▁* q iv , ▁const ▁char ▁* name ) ▁{ ▁const ▁Q Object ▁* q obj ; ▁if ▁( q iv -> nb _ stack ▁== ▁0) ▁{ ▁q obj ▁= ▁q iv -> obj ; ▁} ▁else ▁{ ▁q obj ▁= ▁q iv -> stack [ q iv -> nb _ stack ▁- ▁1 ]. obj ; ▁} ▁if ▁( name ▁&& ▁q object _ type ( q obj ) ▁== ▁Q TYPE _ Q DICT ) ▁{ ▁return ▁q dict _ get ( q object _ to _ q dict ( q obj ), ▁name ); ▁} ▁else ▁if ▁( q iv -> nb _ stack ▁> ▁0 ▁&& ▁q object _ type ( q obj ) ▁== ▁Q TYPE _ Q LIST ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Buffer Pool Entry ▁* get _ pool ( AV Buffer Pool ▁* pool ) ▁{ ▁Buffer Pool Entry ▁* cur ▁= ▁NULL , ▁* last ▁= ▁NULL ; ▁do ▁{ ▁F FS W AP ( Buffer Pool Entry *, ▁cur , ▁last ); ▁cur ▁= ▁av priv _ atomic _ ptr _ cas (( void ▁* ▁volatile ▁* ) & pool -> pool , ▁last , ▁NULL ); ▁if ▁(! cur ) ▁return ▁NULL ; ▁} ▁while ▁( cur ▁!= ▁last ); ▁return ▁cur ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁switch _ buffer ( MP AD ecode Context ▁* s , ▁int ▁* pos , ▁int ▁* end _ pos , ▁int ▁* end _ pos 2) ▁{ ▁if ▁( s -> in _ gb . buffer ▁&& ▁* pos ▁>= ▁s -> gb . size _ in _ bits ) ▁{ ▁s -> gb ▁= ▁s -> in _ gb ; ▁s -> in _ gb . buffer ▁= ▁NULL ; ▁assert (( get _ bits _ count ( & s -> gb ) ▁& ▁7) ▁== ▁0); ▁skip _ bits _ long ( & s -> gb , ▁* pos ▁- ▁* end _ pos ); ▁* end _ pos 2 ▁= ▁* end _ pos ▁= ▁* end _ pos 2 ▁+ ▁get _ bits _ count ( & s -> gb ) ▁- ▁* pos ; ▁* pos ▁= ▁get _ bits _ count ( & s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vpc _ write ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁const ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors ) ▁{ ▁B DR V V PC State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁offset ; ▁int 64_ t ▁sector s , ▁sector s _ per _ block ; ▁int ▁ret ; ▁V H DF ooter ▁* footer ▁= ▁( V H DF ooter ▁* ) ▁s -> footer _ buf ; ▁if ▁( cpu _ to _ be 32 ( footer -> type ) ▁== ▁V HD _ FIX ED ) ▁{ ▁return ▁b dr v _ write ( bs -> file , ▁sector _ num , ▁buf , ▁nb _ sect ors ); ▁} ▁while ▁( nb _ sect ors ▁> ▁0) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁read _ old _ h uff man _ tables ( HY uv Context ▁* s ){ ▁# if ▁1 ▁Get Bit Context ▁gb ; ▁int ▁i ; ▁init _ get _ bits ( & gb , ▁classic _ shift _ l um a , ▁sizeof ( class ic _ shift _ l um a )* 8 ); ▁if ( read _ len _ table ( s -> len [0], ▁& gb ) < 0) ▁return ▁-1; ▁init _ get _ bits ( & gb , ▁classic _ shift _ chrom a , ▁sizeof ( class ic _ shift _ chrom a )* 8 ); ▁if ( read _ len _ table ( s -> len [1], ▁& gb ) < 0) ▁return ▁-1; ▁for ( i =0; ▁i < 256 ; ▁i ++) ▁s -> bits [0] [ i ] ▁= ▁classi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁ex yn os 4_ board s _ init _ common ( Machine State ▁* machine , ▁Ex yn os 4 Board Type ▁board _ type ) ▁{ ▁Ex yn os 4 Board State ▁* s ▁= ▁g _ new ( Ex yn os 4 Board State , ▁1); ▁Machine Class ▁* mc ▁= ▁MA CHINE _ GET _ CLASS ( machine ); ▁if ▁( s mp _ cpus ▁!= ▁EX Y NO S 42 10_ N CP US ▁&& ▁! q test _ enabled ()) ▁{ ▁error _ report ("% s ▁board ▁supports ▁only ▁% d ▁CPU ▁cores , ▁ignoring ▁s mp _ cpus " ▁" ▁value ", ▁mc -> name , ▁EX Y NO S 42 10_ N CP US ); ▁} ▁ex yn os 4_ board _ b info . ram _ size

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁json _ print _ section _ header ( Writer Context ▁* w ctx ) ▁{ ▁JSON Context ▁* json ▁= ▁w ctx -> priv ; ▁AV B Print ▁buf ; ▁const ▁struct ▁section ▁* section ▁= ▁w ctx -> section [ w ctx -> level ]; ▁const ▁struct ▁section ▁* parent _ section ▁= ▁w ctx -> level ▁? ▁w ctx -> section [ w ctx -> level -1] ▁: ▁NULL ; ▁if ▁( w ctx -> level ▁&& ▁w ctx -> nb _ item [ w ctx -> level -1 ]) ▁printf (", \ n "); ▁if ▁( section -> flags ▁& ▁SE CTION _ FLAG _ IS _ WRAP PER ) ▁{ ▁printf ("{ \ n "); ▁json

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁build _ m ad t ( G Array ▁* table _ data , ▁B IOS Linker ▁* link er , ▁V irt Guest Info ▁* guest _ info ) ▁{ ▁int ▁m ad t _ start ▁= ▁table _ data -> len ; ▁const ▁Mem Map Entry ▁* mem map ▁= ▁guest _ info -> mem map ; ▁const ▁int ▁* irq map ▁= ▁guest _ info -> irq map ; ▁Ac pi Multiple Ap ic Table ▁* m ad t ; ▁Ac pi M ad t Generic Dist rib utor ▁* g ic d ; ▁Ac pi M ad t Generic M si Frame ▁* g ic _ m si ; ▁int ▁i ; ▁m ad t ▁= ▁ac pi _ data _ push ( table _ data , ▁sizeof ▁* m ad t ); ▁g ic d ▁= ▁ac pi _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sl ir p _ can _ output ( void ) ▁{ ▁return ▁! sl ir p _ vc ▁|| ▁qemu _ can _ send _ packet ( sl ir p _ vc ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁usb _ tab let _ class _ init fn ( Object Class ▁* k lass , ▁void ▁* data ) ▁{ ▁USB Device Class ▁* uc ▁= ▁USB _ DEVICE _ CLASS ( k lass ); ▁uc -> init ▁= ▁usb _ tab let _ init fn ; ▁uc -> product _ desc ▁= ▁" Q EM U ▁USB ▁Tab let "; ▁uc -> usb _ desc ▁= ▁& desc _ tab let ; ▁uc -> handle _ packet ▁= ▁usb _ generic _ handle _ packet ; ▁uc -> handle _ reset ▁= ▁usb _ h id _ handle _ reset ; ▁uc -> handle _ control ▁= ▁usb _ h id _ handle _ control ; ▁uc -> handle _ data ▁= ▁usb _ h id _ handle

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁pix let _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* got _ frame , ▁AV Packet ▁* av pk t ) ▁{ ▁P ix let Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁int ▁i , ▁w , ▁h , ▁width , ▁height , ▁ret , ▁version ; ▁AV Frame ▁* p ▁= ▁data ; ▁Thread Frame ▁frame ▁= ▁{ ▁. f ▁= ▁data ▁}; ▁uint 32_ t ▁pkt size ; ▁by test ream 2_ init ( & ctx -> gb , ▁av pk t -> data , ▁av pk t -> size ); ▁pkt size ▁= ▁by test ream 2_ get _ be 32 ( & ctx -> gb ); ▁if ▁( pk t size ▁<= ▁44 ▁|| ▁pkt 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁cc w _ machine _2_ 9_ class _ options ( Machine Class ▁* mc ) ▁{ ▁S 390 C cw Machine Class ▁* s 390 mc ▁= ▁S 39 0_ MA CHINE _ CLASS ( mc ); ▁s 390 mc -> gs _ allowed ▁= ▁false ; ▁cc w _ machine _2_ 10_ class _ options ( mc ); ▁SET _ MA CHINE _ COMP AT ( mc , ▁CC W _ COMP AT _2_ 9 ); ▁s 390 mc -> css _ migration _ enabled ▁= ▁false ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mat ro sk a _ read _ header ( AV Format Context ▁* s ) ▁{ ▁Mat ro sk a Dem ux Context ▁* mat ro sk a ▁= ▁s -> priv _ data ; ▁E b ml List ▁* attach ements _ list ▁= ▁& mat ro sk a -> attachments ; ▁Mat ro sk a Attach ement ▁* attach ements ; ▁E b ml List ▁* ch apters _ list ▁= ▁& mat ro sk a -> ch apters ; ▁Mat ro sk a Ch apter ▁* ch apters ; ▁Mat ro sk a Track ▁* tracks ; ▁uint 64_ t ▁max _ start ▁= ▁0; ▁int 64_ t ▁pos ; ▁E b ml ▁eb ml ▁= ▁{ ▁0 ▁}; ▁AV Stream ▁* st ; ▁int ▁i , ▁j , ▁k , ▁res

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁filter _ frame ( AV Filter Link ▁* in link , ▁AV Frame ▁* pic ref ) ▁{ ▁AV Filter Context ▁* ctx ▁= ▁in link -> dst ; ▁Signature Context ▁* s ic ▁= ▁ctx -> priv ; ▁Stream Context ▁* sc ▁= ▁& ( s ic -> stream contexts [ FF _ IN LINK _ ID X ( in link ) ]); ▁F ine Signature * ▁fs ; ▁static ▁const ▁uint 8_ t ▁pot 3 [5] ▁= ▁{ ▁3 * 3 * 3 * 3, ▁3 * 3 * 3, ▁3 * 3, ▁3, ▁1 ▁}; ▁/* ▁indexes ▁of ▁words ▁: ▁2 10, 2 17, 2 19, 27 4, 3 34 ▁4 4, 17 5, 23 3, 27 0, 27 3 ▁5 7, 7 0, 10 3, 2 37, 269 ▁100, 28 5, 2

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ d ma _ fragment ed ( void ) ▁{ ▁A H CI Q State ▁* ah ci ; ▁A H CI Command ▁* cmd ; ▁uint 8_ t ▁px ; ▁size _ t ▁bufsize ▁= ▁4096 ; ▁unsigned ▁char ▁* tx ▁= ▁g _ m alloc ( buf size ); ▁unsigned ▁char ▁* rx ▁= ▁g _ m alloc 0( buf size ); ▁uint 64_ t ▁ptr ; ▁ah ci ▁= ▁ah ci _ boot _ and _ enable ( NULL ); ▁px ▁= ▁ah ci _ port _ select ( ah ci ); ▁ah ci _ port _ clear ( ah ci , ▁px ); ▁/* ▁create ▁pattern ▁*/ ▁generate _ pattern ( tx , ▁bufsize , ▁A H CI _ SE CTOR _ SIZE ); ▁/* ▁Create ▁a

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁pci hot plug _ read ( void ▁* op aque , ▁uint 32_ t ▁addr ) ▁{ ▁uint 32_ t ▁val ▁= ▁0; ▁struct ▁pci _ status ▁* g ▁= ▁opaque ; ▁switch ▁( addr ) ▁{ ▁case ▁P CI _ BASE : ▁val ▁= ▁g -> up ; ▁break ; ▁case ▁P CI _ BASE ▁+ ▁4: ▁val ▁= ▁g -> down ; ▁break ; ▁default : ▁break ; ▁} ▁PI IX 4_ DP RI NT F (" pc i hot plug ▁read ▁% x ▁== ▁% x \ n ", ▁addr , ▁val ); ▁return ▁val ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁w 64_ read _ header ( AV Format Context ▁* s , ▁AV Format Parameters ▁* ap ) ▁{ ▁int 64_ t ▁size ; ▁AV IO Context ▁* pb ▁= ▁s -> pb ; ▁W AV Context ▁* wav ▁= ▁s -> priv _ data ; ▁AV Stream ▁* st ; ▁uint 8_ t ▁guid [ 16 ]; ▁av io _ read ( pb , ▁guid , ▁16 ); ▁if ▁( mem cmp ( guid , ▁guid _ ri ff , ▁16 )) ▁return ▁-1; ▁if ▁( av io _ rl 64 ( pb ) ▁< ▁16 ▁+ ▁8 ▁+ ▁16 ▁+ ▁8 ▁+ ▁16 ▁+ ▁8) ▁/* ▁ri ff ▁+ ▁wave ▁+ ▁fmt ▁+ ▁sizes ▁*/ ▁return ▁-1; ▁av io _ read ( pb , ▁guid , ▁16 ); ▁if ▁( mem cmp ( gu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁rgb 15 to b gr 15 ( const ▁uint 8_ t ▁* src , ▁uint 8_ t ▁* dst , ▁long ▁src _ size ) ▁{ ▁long ▁i ; ▁long ▁num _ pixels ▁= ▁src _ size ▁>> ▁1; ▁for ( i =0; ▁i < num _ pixels ; ▁i ++) ▁{ ▁unsigned ▁b , g , r ; ▁register ▁uint 16_ t ▁rgb ; ▁rgb ▁= ▁src [2 * i ]; ▁r ▁= ▁rgb & 0 x 1 F ; ▁g ▁= ▁( rgb & 0 x 3 E 0) >> 5; ▁b ▁= ▁( rgb & 0 x 7 C 00) >> 10 ; ▁dst [2 * i ] ▁= ▁( b & 0 x 1 F ) ▁| ▁(( g & 0 x 1 F ) << 5) ▁| ▁(( r & 0 x 1 F ) << 10 ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v nc _ job _ add _ rect ( V nc Job ▁* job , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h ) ▁{ ▁V nc Rect Entry ▁* entry ▁= ▁g _ m alloc 0( size of ( V nc Rect Entry )); ▁entry -> rect . x ▁= ▁x ; ▁entry -> rect . y ▁= ▁y ; ▁entry -> rect . w ▁= ▁w ; ▁entry -> rect . h ▁= ▁h ; ▁v nc _ lock _ queue ( queue ); ▁Q LIST _ INSERT _ HEAD ( & job -> rect angles , ▁entry , ▁next ); ▁v nc _ un lock _ queue ( queue ); ▁return ▁1; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁u h ci _ async _ complete _ packet ( US B Packet ▁* ▁packet , ▁void ▁* op aque ) ▁{ ▁U H CI State ▁* s ▁= ▁opaque ; ▁U H CI _ Q H ▁q h ; ▁U H CI _ TD ▁td ; ▁uint 32_ t ▁link ; ▁uint 32_ t ▁old _ td _ ctrl ; ▁uint 32_ t ▁val ; ▁uint 32_ t ▁frame _ addr ; ▁int ▁ret ; ▁/* ▁Handle ▁async ▁is och ron ous ▁packet ▁completion ▁*/ ▁frame _ addr ▁= ▁s -> async _ frame _ addr ; ▁if ▁( frame _ addr ) ▁{ ▁cpu _ ph ysical _ memory _ read ( frame _ addr , ▁( uint 8_ t ▁* ) & link , ▁4 ); ▁le 32_ to _ cpu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁tracked _ request _ end ( B dr v Track ed Request ▁* req ) ▁{ ▁if ▁( req -> serial ising ) ▁{ ▁req -> bs -> serial ising _ in _ flight --; ▁} ▁Q LIST _ REMOVE ( req , ▁list ); ▁qemu _ co _ queue _ restart _ all ( & req -> wait _ queue ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁ad pc m _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁AD PC M Decode Context ▁* c ▁= ▁av ctx -> priv _ data ; ▁AD PC M Channel Status ▁* cs ; ▁int ▁n , ▁m , ▁channel , ▁i ; ▁int ▁block _ predict or [2 ]; ▁short ▁* samples ; ▁short ▁* samples _ end ; ▁const ▁uint 8_ t ▁* src ; ▁int ▁st ; ▁/* ▁st ere o ▁*/ ▁/* ▁D K 3 ▁AD PC M ▁accounting ▁var

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sm ack er _ decode _ header _ tree ( Sm ack V Context ▁* sm k , ▁Get Bit Context ▁* gb , ▁int ▁** re codes , ▁int ▁* last , ▁int ▁size ) ▁{ ▁int ▁res ; ▁H uff Context ▁h uff ; ▁H uff Context ▁tmp 1, ▁tmp 2; ▁V LC ▁vl c [2] ▁= ▁{ ▁{ ▁0 ▁} ▁}; ▁int ▁escapes [3 ]; ▁DB Ctx ▁ctx ; ▁int ▁err ▁= ▁0; ▁if ( size ▁>= ▁U INT _ MAX >> 4 ){ ▁// ▁( (( size ▁+ ▁3) ▁>> ▁2) ▁+ ▁3) ▁<< ▁2 ▁must ▁not ▁overflow ▁av _ log ( sm k -> av ctx , ▁AV _ LOG _ ERROR , ▁" size ▁too ▁large \ n "); ▁return ▁A VER ROR _ IN 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁standard _ decode _ picture _ primary _ header ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁int ▁status ▁= ▁0; ▁if ▁( v -> f interp flag ) ▁v -> interp frm ▁= ▁get _ bits ( gb , ▁1); ▁skip _ bits ( gb , ▁2); ▁// frame cnt ▁unused ▁if ▁( v -> r anger ed ) ▁v -> r anger ed frm ▁= ▁get _ bits ( gb , ▁1); ▁v -> s . p ict _ type ▁= ▁get _ bits ( gb , ▁1); ▁if ▁( v -> s . av ctx -> max _ b _ frames ) ▁{ ▁if ▁(! v -> s . p ict _ type ) ▁{ ▁if ▁( get _ bits ( gb , ▁1)) ▁v -> 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁FF Server IPAddress ACL * ▁parse _ dynamic _ acl ( FF Server Stream ▁* stream , ▁HTTP Context ▁* c ) ▁{ ▁FILE * ▁f ; ▁char ▁line [10 24 ]; ▁char ▁cmd [10 24 ]; ▁FF Server IPAddress ACL ▁* acl ▁= ▁NULL ; ▁int ▁line _ num ▁= ▁0; ▁const ▁char ▁* p ; ▁f ▁= ▁f open ( stream -> dynamic _ acl , ▁" r "); ▁if ▁(! f ) ▁{ ▁per ror ( stream -> dynamic _ acl ); ▁return ▁NULL ; ▁} ▁acl ▁= ▁av _ m alloc z ( size of ( FF Server IPAddress ACL )); ▁/* ▁Build ▁ACL ▁*/ ▁for ( ; ;) ▁{ ▁if ▁( f get s ( line , ▁sizeof 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁discard _ f ( Block Backend ▁* blk , ▁int ▁arg c , ▁char ▁** argv ) ▁{ ▁struct ▁time val ▁t 1, ▁t 2; ▁int ▁C flag ▁= ▁0, ▁q flag ▁= ▁0; ▁int ▁c , ▁ret ; ▁int 64_ t ▁offset , ▁count ; ▁while ▁(( c ▁= ▁getopt ( arg c , ▁argv , ▁" C q ")) ▁!= ▁-1) ▁{ ▁switch ▁( c ) ▁{ ▁case ▁' C ': ▁C flag ▁= ▁1; ▁break ; ▁case ▁' q ': ▁q flag ▁= ▁1; ▁break ; ▁default : ▁return ▁qemu io _ command _ usage ( & dis card _ cmd ); ▁} ▁} ▁if ▁( opt ind ▁!= ▁arg c ▁- ▁2) ▁{ ▁return ▁qemu io _ command _ usage ( & dis c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁memory _ region _ set _ dirty ( Memory Region ▁* mr , ▁hw addr ▁addr , ▁hw addr ▁size ) ▁{ ▁assert ( mr -> termin ates ); ▁cpu _ ph ysical _ memory _ set _ dirty _ range ( mr -> ram _ addr ▁+ ▁addr , ▁size , ▁memory _ region _ get _ dirty _ log _ mask ( mr )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ display _ print _ local _ addr ( V nc Display ▁* vd ) ▁{ ▁SocketAddress Legacy ▁* addr ; ▁Error ▁* err ▁= ▁NULL ; ▁if ▁(! vd -> n ls ock ) ▁{ ▁return ; ▁} ▁addr ▁= ▁q io _ channel _ socket _ get _ local _ address ( vd -> ls ock [0], ▁& err ); ▁if ▁(! addr ) ▁{ ▁return ; ▁} ▁if ▁( addr -> type ▁!= ▁SO CKET _ ADDRESS _ LEG ACY _ K IND _ INET ) ▁{ ▁q api _ free _ SocketAddress Legacy ( addr ); ▁return ; ▁} ▁error _ printf _ unless _ q mp (" V NC ▁server ▁running ▁on ▁% s :% s \ n ", ▁ad

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v 9 fs _ sy nth _ l stat ( Fs Context ▁* fs _ ctx , ▁V 9 fs Path ▁* fs _ path , ▁struct ▁stat ▁* st buf ) ▁{ ▁V 9 fs Sy nth Node ▁* node ▁= ▁* ( V 9 fs Sy nth Node ▁** ) fs _ path -> data ; ▁v 9 fs _ sy nth _ fill _ stat buf ( node , ▁st buf ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁q sv _ decode _ close ( AV Codec Context ▁* av ctx ) ▁{ ▁Q SV Other Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁ff _ q sv _ decode _ close ( & s -> q sv ); ▁q sv _ clear _ buffers ( s ); ▁av _ f ifo _ free ( s -> packet _ f ifo ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ ass _ split _ override _ codes ( const ▁ASS Codes Callbacks ▁* callbacks , ▁void ▁* priv , ▁const ▁char ▁* buf ) ▁{ ▁const ▁char ▁* text ▁= ▁NULL ; ▁char ▁new _ line [2 ]; ▁int ▁text _ len ▁= ▁0; ▁while ▁(* buf ) ▁{ ▁if ▁( text ▁&& ▁callbacks -> text ▁&& ▁( ss can f ( buf , ▁"\\ % 1[ n N ]", ▁new _ line ) ▁== ▁1 ▁|| ▁! str n cmp ( buf , ▁"{ \\ ", ▁2 ))) ▁{ ▁callbacks -> text ( priv , ▁text , ▁text _ len ); ▁text ▁= ▁NULL ; ▁} ▁if ▁( ss can f ( buf , ▁"\\ % 1[ n N ]", ▁new _ line ) ▁== ▁1) ▁{ ▁i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁compute _ scale _ factors ( un signed ▁char ▁scale _ code [ SB LIMIT ], ▁unsigned ▁char ▁scale _ factors [ SB LIMIT ][ 3], ▁int ▁sb _ samples [3 ][ 12 ][ SB LIMIT ], ▁int ▁sb limit ) ▁{ ▁int ▁* p , ▁vmax , ▁v , ▁n , ▁i , ▁j , ▁k , ▁code ; ▁int ▁index , ▁d 1, ▁d 2; ▁unsigned ▁char ▁* sf ▁= ▁& scale _ factors [0] [0]; ▁for ( j =0; j < s bl imit ; j ++) ▁{ ▁for ( i =0; i < 3; i ++) ▁{ ▁/* ▁find ▁the ▁max ▁absolute ▁value ▁*/ ▁p ▁= ▁& sb _ samples [ i ][0] [ j ]; ▁vmax ▁= ▁abs (* p ); ▁for ( k 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁arm v 7 m _ nv ic _ clear _ pending ( void ▁* op aque , ▁int ▁irq ) ▁{ ▁N VI C State ▁* s ▁= ▁( N VI C State ▁* ) op aque ; ▁Vec Info ▁* vec ; ▁assert ( irq ▁> ▁ARM V 7 M _ EX CP _ RE SET ▁&& ▁irq ▁< ▁s -> num _ irq ); ▁vec ▁= ▁& s -> vectors [ irq ]; ▁trace _ nv ic _ clear _ pending ( irq , ▁vec -> enabled , ▁vec -> p rio ); ▁if ▁( vec -> pending ) ▁{ ▁vec -> pending ▁= ▁0; ▁nv ic _ irq _ update ( s ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁var arg _ string ( void ) ▁{ ▁int ▁i ; ▁struct ▁{ ▁const ▁char ▁* decoded ; ▁} ▁test _ cases [] ▁= ▁{ ▁{ ▁" hello ▁world " ▁}, ▁{ ▁" the ▁quick ▁brown ▁fox ▁jump ed ▁over ▁the ▁f ence " ▁}, ▁{} ▁}; ▁for ▁( i ▁= ▁0; ▁test _ cases [ i ]. decoded ; ▁i ++) ▁{ ▁Q Object ▁* obj ; ▁Q String ▁* str ; ▁obj ▁= ▁q object _ from _ json f ("% s ", ▁test _ cases [ i ]. decoded ); ▁g _ assert ( obj ▁!= ▁NULL ); ▁g _ assert ( q object _ type ( obj ) ▁== ▁Q TYPE _ Q STRING ); ▁str ▁= ▁q object _ to _ q stri

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sc si _ q dev _ exit ( Device State ▁* q dev ) ▁{ ▁S CS ID evice ▁* dev ▁= ▁SC SI _ DEVICE ( q dev ); ▁if ▁( dev -> v ms entry ) ▁{ ▁qemu _ del _ vm _ change _ state _ handler ( dev -> v ms entry ); ▁} ▁sc si _ device _ destroy ( dev ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁gen _ sub _ bitmap ( T elet ext Context ▁* ctx , ▁AV Sub title Rect ▁* sub _ rect , ▁v bi _ page ▁* page , ▁int ▁ch op _ top ) ▁{ ▁int ▁res x ▁= ▁page -> columns ▁* ▁BIT MAP _ CHAR _ WIDTH ; ▁int ▁res y ▁= ▁( page -> rows ▁- ▁ch op _ top ) ▁* ▁BIT MAP _ CHAR _ HEIGHT ; ▁uint 8_ t ▁ci , ▁c max ▁= ▁0; ▁int ▁ret ; ▁v bi _ char ▁* vc ▁= ▁page -> text ▁+ ▁( ch op _ top ▁* ▁page -> columns ); ▁v bi _ char ▁* vc end ▁= ▁page -> text ▁+ ▁( page -> rows ▁* ▁page -> columns ); ▁for ▁( ; ▁vc ▁< ▁vc end

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁opt _ default ( const ▁char ▁* opt , ▁const ▁char ▁* arg ) ▁{ ▁const ▁AV Option ▁* oc , ▁* of , ▁* os , ▁* os wr ; ▁char ▁opt _ stri pped [ 128 ]; ▁const ▁char ▁* p ; ▁const ▁AV Class ▁* cc ▁= ▁av codec _ get _ class (), ▁* fc ▁= ▁av format _ get _ class (), ▁* sc , ▁* sw r _ class ; ▁if ▁(! ( p ▁= ▁str chr ( opt , ▁': ') )) ▁p ▁= ▁opt ▁+ ▁str len ( opt ); ▁av _ str lc py ( opt _ stri pped , ▁opt , ▁FF MIN ( size of ( opt _ stri pped ), ▁p ▁- ▁opt ▁+ ▁1 )); ▁if ▁(( oc ▁= ▁av _ opt _ find ( & cc , ▁o

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sla v io _ misc _ init ( target _ ph ys _ addr _ t ▁base , ▁target _ ph ys _ addr _ t ▁aux 1_ base , ▁target _ ph ys _ addr _ t ▁aux 2_ base , ▁qemu _ irq ▁irq , ▁qemu _ irq ▁fd c _ tc ) ▁{ ▁Device State ▁* dev ; ▁Sys Bus Device ▁* s ; ▁dev ▁= ▁q dev _ create ( NULL , ▁" s la v io _ misc "); ▁q dev _ init ( dev ); ▁s ▁= ▁sys bus _ from _ q dev ( dev ); ▁if ▁( base ) ▁{ ▁/* ▁8 ▁bit ▁registers ▁*/ ▁/* ▁S la v io ▁control ▁*/ ▁sys bus _ mm io _ map ( s , ▁0, ▁base ▁+ ▁MI SC _ CF G ); ▁/* ▁Diag

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁check _ tm _ pred 4 x 4_ mode ( int ▁mode , ▁int ▁mb _ x , ▁int ▁mb _ y ) ▁{ ▁if ▁(! mb _ x ) ▁{ ▁return ▁mb _ y ▁? ▁VER T _ VP 8_ PRE D ▁: ▁DC _12 9_ PRE D ; ▁} ▁else ▁{ ▁return ▁mb _ y ▁? ▁mode ▁: ▁H OR _ VP 8_ PRE D ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁struct ▁Res ample Context ▁* create ( struct ▁Res ample Context ▁* c , ▁int ▁out _ rate , ▁int ▁in _ rate , ▁int ▁filter _ size , ▁int ▁phase _ shift , ▁int ▁linear , ▁double ▁cutoff , ▁enum ▁AV Sample Format ▁format , ▁enum ▁Sw r Filter Type ▁filter _ type , ▁double ▁ka iser _ beta , ▁double ▁precision , ▁int ▁cheb y , ▁int ▁exact _ ration al ){ ▁so xr _ error _ t ▁error ; ▁so xr _ datatype _ t ▁type ▁= ▁format ▁== ▁AV _ SA MPLE _ F MT _ S 16 P ? ▁SO X R _ INT 16_ S ▁: ▁format ▁== ▁AV _ SA MPLE 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ put _ buffer ( void ▁* op aque , ▁const ▁uint 8_ t ▁* buf , ▁int 64_ t ▁pos , ▁int ▁size ) ▁{ ▁Q EM U File B dr v ▁* s ▁= ▁opaque ; ▁b dr v _ p write ( s -> bs , ▁s -> base _ offset ▁+ ▁pos , ▁buf , ▁size ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁qemu _ clock _ init ( Q EM UC lock Type ▁type ) ▁{ ▁Q EM UC lock ▁* clock ▁= ▁qemu _ clock _ ptr ( type ); ▁/* ▁Assert ▁that ▁the ▁clock ▁of ▁type ▁TYPE ▁has ▁not ▁been ▁initialized ▁yet . ▁*/ ▁assert ( main _ loop _ tl g . tl [ type ] ▁== ▁NULL ); ▁clock -> type ▁= ▁type ; ▁clock -> enabled ▁= ▁( type ▁== ▁Q EM U _ C LOCK _ VI RTUAL ▁? ▁false ▁: ▁true ); ▁clock -> last ▁= ▁INT 64_ MIN ; ▁Q LIST _ INIT ( & clock -> timer lists ); ▁notifier _ list _ init ( & clock -> reset _ not ifiers ); ▁m

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ pty ( Q emu Opts ▁* opts ) ▁{ ▁Char Driver State ▁* chr ; ▁P ty Char Driver ▁* s ; ▁struct ▁term ios ▁tty ; ▁int ▁master _ fd , ▁slave _ fd , ▁len ; ▁# if ▁defined (__ Open B SD __) ▁|| ▁defined (__ Drag on Fly __) ▁char ▁p ty _ name [ PATH _ MAX ]; ▁# define ▁q _ pts name ( x ) ▁p ty _ name ▁# else ▁char ▁* pty _ name ▁= ▁NULL ; ▁# define ▁q _ pts name ( x ) ▁pts name ( x ) ▁# end if ▁if ▁( open pty ( & master _ fd , ▁& slave _ fd , ▁p ty _ name , ▁NULL 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁HEL PER ( sig p )( CP US 390 X State ▁* env , ▁uint 64_ t ▁order _ code , ▁uint 32_ t ▁r 1, ▁uint 64_ t ▁cpu _ addr ) ▁{ ▁int ▁cc ▁= ▁SIG P _ CC _ ORDER _ CODE _ AC CE PTED ; ▁HEL PER _ LOG ("% s : ▁% 01 6" ▁PRI x 64 ▁" ▁% 08 x ▁% 01 6" ▁PRI x 64 ▁"\ n ", ▁__ func __, ▁order _ code , ▁r 1, ▁cpu _ addr ); ▁/* ▁Remember : ▁Use ▁" R 1 ▁or ▁R 1 ▁+ ▁1, ▁whichever ▁is ▁the ▁odd - number ed ▁register " ▁as ▁parameter ▁( input ). ▁Status ▁( output ) ▁is ▁always ▁R 1. ▁*/ ▁switch ▁( order _ code ) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁y uv 2 rgb _1_ c _ template ( Sw s Context ▁* c , ▁const ▁uint 16_ t ▁* buf 0, ▁const ▁uint 16_ t ▁* ub uf 0, ▁const ▁uint 16_ t ▁* ub uf 1, ▁const ▁uint 16_ t ▁* v buf 0, ▁const ▁uint 16_ t ▁* v buf 1, ▁const ▁uint 16_ t ▁* ab uf 0, ▁uint 8_ t ▁* dest , ▁int ▁dst W , ▁int ▁u val pha , ▁enum ▁Pixel Format ▁dst Format , ▁int ▁flags , ▁int ▁y , ▁enum ▁Pixel Format ▁target , ▁int ▁has Alpha ) ▁{ ▁int ▁i ; ▁if ▁( u val pha ▁< ▁2048 ) ▁{ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁( dst W ▁>> ▁1); ▁i ++) ▁{ ▁int ▁Y 1 ▁= ▁buf 0 [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁on en and _ prog _ main ( One N AND State ▁* s , ▁int ▁sec , ▁int ▁sec n , ▁void ▁* src ) ▁{ ▁int ▁result ▁= ▁0; ▁if ▁( sec n ▁> ▁0) ▁{ ▁uint 32_ t ▁size ▁= ▁( uint 32_ t ) sec n ▁* ▁512 ; ▁const ▁uint 8_ t ▁* sp ▁= ▁( const ▁uint 8_ t ▁* ) src ; ▁uint 8_ t ▁* dp ▁= ▁0; ▁if ▁( s -> b dr v _ cur ) ▁{ ▁dp ▁= ▁g _ m alloc ( size ); ▁if ▁(! dp ▁|| ▁b dr v _ read ( s -> b dr v _ cur , ▁sec , ▁dp , ▁sec n ) ▁< ▁0) ▁{ ▁result ▁= ▁1; ▁} ▁} ▁else ▁{ ▁if ▁( sec ▁+ ▁sec n ▁> ▁s -> secs _ cur ) 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁nb d _ receive _ list ( Q IO Channel ▁* i oc , ▁char ▁** name , ▁Error ▁** err p ) ▁{ ▁uint 64_ t ▁magic ; ▁uint 32_ t ▁opt ; ▁uint 32_ t ▁type ; ▁uint 32_ t ▁len ; ▁uint 32_ t ▁n amel en ; ▁int ▁error ; ▁* name ▁= ▁NULL ; ▁if ▁( read _ sync ( i oc , ▁& magic , ▁sizeof ( magic )) ▁!= ▁sizeof ( magic )) ▁{ ▁error _ set g ( err p , ▁" failed ▁to ▁read ▁list ▁option ▁magic "); ▁return ▁-1; ▁} ▁magic ▁= ▁be 64_ to _ cpu ( magic ); ▁if ▁( magic ▁!= ▁N BD _ REP _ M AGIC ) ▁{ ▁error _ set g ( err p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁hw upload _ query _ formats ( AV Filter Context ▁* av ctx ) ▁{ ▁H W Upload Context ▁* ctx ▁= ▁av ctx -> priv ; ▁AV H W Frames Constraints ▁* constraints ▁= ▁NULL ; ▁const ▁enum ▁AV Pixel Format ▁* input _ pix _ fmt s , ▁* output _ pix _ fmt s ; ▁AV Filter Formats ▁* input _ formats ▁= ▁NULL ; ▁int ▁err , ▁i ; ▁if ▁(! av ctx -> hw _ device _ ctx ) ▁{ ▁av _ log ( ctx , ▁AV _ LOG _ ERROR , ▁" A ▁hardware ▁device ▁reference ▁is ▁required ▁" ▁" to ▁upload ▁frames ▁to .\ n "); ▁return ▁A VER ROR (

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁error _ set g _ win 32 ( Error ▁** err p , ▁int ▁win 32_ err , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁va _ list ▁ap ; ▁char ▁* msg 1, ▁* msg 2; ▁if ▁( err p ▁== ▁NULL ) ▁{ ▁return ; ▁} ▁va _ start ( ap , ▁fmt ); ▁error _ set v ( err p , ▁ERROR _ CLASS _ GE NERIC _ ERROR , ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁if ▁( win 32_ err ▁!= ▁0) ▁{ ▁msg 1 ▁= ▁(* err p ) -> msg ; ▁msg 2 ▁= ▁g _ win 32_ error _ message ( win 32_ err ); ▁(* err p ) -> msg ▁= ▁g _ str dup _ printf ("% s : ▁% s ▁( error : ▁% x )", ▁msg 1, ▁ms

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ MP V _ frame _ end ( M peg Enc Context ▁* s ) ▁{ ▁int ▁i ; ▁/* ▁redraw ▁edges ▁for ▁the ▁frame ▁if ▁decoding ▁didn ' t ▁complete ▁*/ ▁// ▁just ▁to ▁make ▁sure ▁that ▁all ▁data ▁is ▁rendered . ▁if ▁( CONFIG _ M PEG _ X VM C _ DE CO DER ▁&& ▁s -> av ctx -> x vm c _ accel eration ) ▁{ ▁ff _ x vm c _ field _ end ( s ); ▁} ▁else ▁if (( s -> error _ count ▁|| ▁s -> encoding ▁|| ▁! ( s -> av ctx -> codec -> capabilities & CODE C _ CAP _ D RAW _ H ORIZ _ B AND )) ▁&& ▁! s -> av ctx -> hw accel ▁&& ▁! 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁qemu _ get _ buffer ( Q EM U File ▁* f , ▁uint 8_ t ▁* buf , ▁int ▁size 1) ▁{ ▁int ▁size , ▁l ; ▁if ▁( f -> is _ write ) ▁abort (); ▁size ▁= ▁size 1; ▁while ▁( size ▁> ▁0) ▁{ ▁l ▁= ▁f -> buf _ size ▁- ▁f -> buf _ index ; ▁if ▁( l ▁== ▁0) ▁{ ▁qemu _ fill _ buffer ( f ); ▁l ▁= ▁f -> buf _ size ▁- ▁f -> buf _ index ; ▁if ▁( l ▁== ▁0) ▁break ; ▁} ▁if ▁( l ▁> ▁size ) ▁l ▁= ▁size ; ▁mem c py ( buf , ▁f -> buf ▁+ ▁f -> buf _ index , ▁l ); ▁f -> buf _ index ▁+= ▁l ; ▁buf ▁+= ▁l ; ▁size ▁-= ▁l ; ▁} ▁return ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁* rom _ ptr ( target _ ph ys _ addr _ t ▁addr ) ▁{ ▁R om ▁* rom ; ▁rom ▁= ▁find _ rom ( addr ); ▁if ▁(! rom ▁|| ▁! rom -> data ) ▁return ▁NULL ; ▁return ▁rom -> data ▁+ ▁( addr ▁- ▁rom -> addr ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* do _ data _ dec ompress ( void ▁* op aque ) ▁{ ▁Dec ompress Param ▁* param ▁= ▁opaque ; ▁unsigned ▁long ▁pages ize ; ▁while ▁(! quit _ dec omp _ thread ) ▁{ ▁qemu _ mut ex _ lock ( & param -> mut ex ); ▁while ▁(! param -> start ▁&& ▁! quit _ dec omp _ thread ) ▁{ ▁qemu _ cond _ wait ( & param -> cond , ▁& param -> mut ex ); ▁} ▁if ▁(! quit _ dec omp _ thread ) ▁{ ▁pages ize ▁= ▁TARGET _ PAGE _ SIZE ; ▁/* ▁un compress () ▁will ▁return ▁failed ▁in ▁some ▁case , ▁especially ▁* ▁when ▁the ▁pa

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁long ▁do _ sig return ( CP USH 4 State ▁* re gs ) ▁{ ▁struct ▁target _ sig frame ▁* frame ; ▁abi _ ulong ▁frame _ addr ; ▁sig set _ t ▁blocked ; ▁target _ sig set _ t ▁target _ set ; ▁target _ ulong ▁r 0; ▁int ▁i ; ▁int ▁err ▁= ▁0; ▁# if ▁defined ( DEBUG _ SIG NAL ) ▁f printf ( stderr , ▁" do _ sig return \ n "); ▁# end if ▁frame _ addr ▁= ▁regs -> gre gs [ 15 ]; ▁if ▁(! lock _ user _ struct ( VER IFY _ READ , ▁frame , ▁frame _ addr , ▁1)) ▁goto ▁bad frame ; ▁__ get _ user ( target _ set . sig [0], ▁& fr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ap ic _ reset _ common ( Device State ▁* dev ) ▁{ ▁API C Common State ▁* s ▁= ▁API C _ COM MON ( dev ); ▁API C Common Class ▁* info ▁= ▁API C _ COM MON _ GET _ CLASS ( s ); ▁bool ▁b sp ; ▁b sp ▁= ▁cpu _ is _ b sp ( s -> cpu ); ▁s -> ap ic base ▁= ▁API C _ DEFAULT _ ADDRESS ▁| ▁( b sp ▁? ▁MS R _ IA 32_ API C BASE _ B SP ▁: ▁0) ▁| ▁MS R _ IA 32_ API C BASE _ ENABLE ; ▁s -> v ap ic _ p addr ▁= ▁0; ▁info -> v ap ic _ base _ update ( s ); ▁ap ic _ init _ reset ( dev ); ▁if ▁( b sp ) ▁{ ▁/* ▁* ▁L

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁o map _ p wt _ init ( target _ ph ys _ addr _ t ▁base , ▁struct ▁o map _ mp u _ state _ s ▁* s , ▁o map _ cl k ▁cl k ) ▁{ ▁int ▁i om em type ; ▁s -> p wt . base ▁= ▁base ; ▁s -> p wt . cl k ▁= ▁cl k ; ▁o map _ p wt _ reset ( s ); ▁i om em type ▁= ▁cpu _ register _ io _ memory (0, ▁o map _ p wt _ read fn , ▁o map _ p wt _ writ ef n , ▁s ); ▁cpu _ register _ ph ysical _ memory ( s -> p wt . base , ▁0 x 8 00, ▁i om em type ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁v nc _ h ext ile _ send _ frame buffer _ update ( V nc State ▁* vs , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h ) ▁{ ▁int ▁i , ▁j ; ▁int ▁has _ fg , ▁has _ bg ; ▁uint 8_ t ▁* last _ fg , ▁* last _ bg ; ▁V nc Display ▁* vd ▁= ▁vs -> vd ; ▁last _ fg ▁= ▁( uint 8_ t ▁* ) ▁qemu _ m alloc ( vd -> server -> pf . bytes _ per _ pixel ); ▁last _ bg ▁= ▁( uint 8_ t ▁* ) ▁qemu _ m alloc ( vd -> server -> pf . bytes _ per _ pixel ); ▁has _ fg ▁= ▁has _ bg ▁= ▁0; ▁for ▁( j ▁= ▁y ; ▁j ▁< ▁( y ▁+ ▁h ); ▁j ▁+= ▁16 ) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁b dr v _ read _ em ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁uint 8_ t ▁* buf , ▁int ▁nb _ sect ors ) ▁{ ▁int ▁async _ ret ; ▁Block Driver A IO CB ▁* ac b ; ▁struct ▁i ove c ▁i ov ; ▁Q EM UI O Vector ▁q io v ; ▁async _ ret ▁= ▁NOT _ DONE ; ▁i ov . io v _ base ▁= ▁( void ▁* ) buf ; ▁i ov . io v _ len ▁= ▁nb _ sect ors ▁* ▁B DR V _ SE CTOR _ SIZE ; ▁qemu _ i ove c _ init _ external ( & q io v , ▁& io v , ▁1); ▁ac b ▁= ▁bs -> dr v -> b dr v _ a io _ read v ( bs , ▁sector _ num , 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁k vm pp c _ get _ books _ s re gs ( Power PC CPU ▁* cpu ) ▁{ ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁struct ▁k vm _ s re gs ▁s re gs ; ▁int ▁ret ; ▁int ▁i ; ▁ret ▁= ▁k vm _ vc pu _ io ctl ( CPU ( cpu ), ▁K VM _ GET _ S REG S , ▁& s re gs ); ▁if ▁( ret ▁< ▁0) ▁{ ▁return ▁ret ; ▁} ▁if ▁(! env -> external _ ht ab ) ▁{ ▁p pc _ store _ sd r 1( env , ▁s re gs . u . s . sd r 1); ▁} ▁/* ▁Sync ▁S LB ▁*/ ▁# if def ▁TARGET _ P PC 64 ▁/* ▁* ▁The ▁packed ▁S LB ▁array ▁we ▁get ▁from ▁K VM _ GET _ S REG

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁integ rator cp _ init ( ram _ addr _ t ▁ram _ size , ▁int ▁v ga _ ram _ size , ▁const ▁char ▁* boot _ device , ▁Display State ▁* ds , ▁const ▁char ▁* kernel _ filename , ▁const ▁char ▁* kernel _ cmdline , ▁const ▁char ▁* init rd _ filename , ▁const ▁char ▁* cpu _ model ) ▁{ ▁CPU State ▁* env ; ▁uint 32_ t ▁ram _ offset ; ▁qemu _ irq ▁* pic ; ▁qemu _ irq ▁* cpu _ pic ; ▁int ▁sd ; ▁if ▁(! cpu _ model ) ▁cpu _ model ▁= ▁" arm 9 26 "; ▁env ▁= ▁cpu _ init ( cpu _ model ); ▁if ▁(! env ) ▁{ ▁f pri

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁h mp _ cont ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict ) ▁{ ▁Block InfoList ▁* b dev _ list , ▁* b dev ; ▁Error ▁* err ▁= ▁NULL ; ▁b dev _ list ▁= ▁q mp _ query _ block ( NULL ); ▁for ▁( b dev ▁= ▁b dev _ list ; ▁b dev ; ▁b dev ▁= ▁b dev -> next ) ▁{ ▁if ▁( key _ is _ missing ( b dev -> value )) ▁{ ▁monitor _ read _ block _ device _ key ( mon , ▁b dev -> value -> device , ▁h mp _ cont _ cb , ▁NULL ); ▁goto ▁out ; ▁} ▁} ▁q mp _ cont ( & err ); ▁h mp _ handle _ error ( mon , ▁& err ); ▁out : ▁q api 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _5 ( S AN M Video Context ▁* ctx ) ▁{ ▁# if ▁HAVE _ B IG ENDIAN ▁uint 16_ t ▁* frm ; ▁int ▁np ixel s ; ▁# end if ▁uint 8_ t ▁* dst ▁= ▁( uint 8_ t *) ctx -> frm 0; ▁if ▁( r le _ decode ( ctx , ▁dst , ▁ctx -> buf _ size )) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁# if ▁HAVE _ B IG ENDIAN ▁np ixel s ▁= ▁ctx -> np ixel s ; ▁frm ▁= ▁ctx -> frm 0; ▁while ▁( np ixel s --) ▁* frm ++ ▁= ▁av _ b swap 16 (* frm ); ▁# end if ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁aux _ bridge _ init ( Object ▁* obj ) ▁{ ▁AU X TO I 2 C State ▁* s ▁= ▁AU X TO I 2 C ( obj ); ▁s -> i 2 c _ bus ▁= ▁i 2 c _ init _ bus ( DEVICE ( obj ), ▁" aux - i 2 c "); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁b dr v _ co _ d rain _ b h _ cb ( void ▁* op aque ) ▁{ ▁B dr v Co D rain Data ▁* data ▁= ▁opaque ; ▁Cor outine ▁* co ▁= ▁data -> co ; ▁qemu _ b h _ delete ( data -> b h ); ▁b dr v _ d rain _ poll ( data -> bs ); ▁data -> done ▁= ▁true ; ▁qemu _ cor outine _ enter ( co , ▁NULL ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁add _ graphics _ client ( Monitor ▁* mon , ▁const ▁Q Dict ▁* q dict , ▁Q Object ▁** ret _ data ) ▁{ ▁const ▁char ▁* protocol ▁= ▁q dict _ get _ str ( q dict , ▁" protocol "); ▁const ▁char ▁* fd name ▁= ▁q dict _ get _ str ( q dict , ▁" fd name "); ▁Char Driver State ▁* s ; ▁if ▁( str cmp ( protocol , ▁" sp ice ") ▁== ▁0) ▁{ ▁int ▁fd ▁= ▁monitor _ get _ fd ( mon , ▁fd name , ▁NULL ); ▁int ▁skip auth ▁= ▁q dict _ get _ try _ bool ( q dict , ▁" skip auth ", ▁0); ▁int ▁tls ▁= ▁q dict _ get _ try

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁g boolean ▁q io _ channel _ tls _ handshake _ io ( Q IO Channel ▁* i oc , ▁G IO Condition ▁condition , ▁g pointer ▁user _ data ) ▁{ ▁Q IO Task ▁* task ▁= ▁user _ data ; ▁Q IO Channel TLS ▁* ti oc ▁= ▁Q IO _ CHANNEL _ TLS ( ▁q io _ task _ get _ source ( task )); ▁q io _ channel _ tls _ handshake _ task ( ▁ti oc , ▁task ); ▁object _ un ref ( OBJECT ( ti oc )); ▁return ▁FALSE ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pm _ update _ sc i ( VT 6 86 PM State ▁* s ) ▁{ ▁int ▁sc i _ level , ▁pm st s ; ▁pm st s ▁= ▁ac pi _ pm 1_ evt _ get _ st s ( & s -> ar , ▁s -> ar . tm r . overflow _ time ); ▁sc i _ level ▁= ▁( (( pm st s ▁& ▁s -> ar . pm 1. evt . en ) ▁& ▁( AC PI _ BIT MASK _ RT _ C LOCK _ ENABLE ▁| ▁AC PI _ BIT MASK _ PO WER _ BUTTON _ ENABLE ▁| ▁AC PI _ BIT MASK _ GLOBAL _ LOCK _ ENABLE ▁| ▁AC PI _ BIT MASK _ T IMER _ ENABLE )) ▁!= ▁0); ▁qemu _ set _ irq ( s -> dev . irq [0], ▁sc i _ level ); ▁/* ▁sched

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁flat _ print _ key _ prefix ( Writer Context ▁* w ctx ) ▁{ ▁Flat Context ▁* flat ▁= ▁w ctx -> priv ; ▁const ▁struct ▁section ▁* parent _ section ▁= ▁w ctx -> section [ w ctx -> level -1 ]; ▁printf ("% s ", ▁flat -> section _ header [ w ctx -> level ]. str ); ▁if ▁( parent _ section -> flags ▁& ▁SE CTION _ FLAG _ IS _ ARRAY ) ▁{ ▁int ▁n ▁= ▁parent _ section -> id ▁== ▁SE CTION _ ID _ PA CKET S _ AND _ FRAME S ▁? ▁w ctx -> nb _ section _ packet _ frame ▁: ▁w ctx -> nb _ item [ w ctx -> level 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁s dp _ parse _ fm tp _ config _ h 264 ( AV Stream ▁* stream , ▁Payload Context ▁* h 2 64_ data , ▁char ▁* attr , ▁char ▁* value ) ▁{ ▁AV Codec Context ▁* codec ▁= ▁stream -> codec ; ▁assert ( codec -> codec _ id ▁== ▁CODE C _ ID _ H 264 ); ▁assert ( h 2 64_ data ▁!= ▁NULL ); ▁if ▁(! str cmp ( attr , ▁" packet ization - mode ")) ▁{ ▁av _ log ( codec , ▁AV _ LOG _ DEBUG , ▁" R TP ▁Packet ization ▁Mode : ▁% d \ n ", ▁at oi ( value )); ▁h 2 64_ data -> packet ization _ mode ▁= ▁at oi ( value ); 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qc ow 2_ create 2( const ▁char ▁* filename , ▁int 64_ t ▁total _ size , ▁const ▁char ▁* back ing _ file , ▁const ▁char ▁* back ing _ format , ▁int ▁flags , ▁size _ t ▁cluster _ size , ▁int ▁pre alloc , ▁Q EM U Option Parameter ▁* options , ▁int ▁version , ▁Error ▁** err p ) ▁{ ▁/* ▁Calculate ▁cluster _ bits ▁*/ ▁int ▁cluster _ bits ; ▁cluster _ bits ▁= ▁f fs ( cluster _ size ) ▁- ▁1; ▁if ▁( cluster _ bits ▁< ▁MIN _ CL USTER _ BITS ▁|| ▁cluster _ bits ▁> ▁MAX _ CL USTER _ BITS ▁|| ▁(1 ▁<< ▁cl

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁id r ( H 264 Context ▁* h ){ ▁int ▁i ; ▁ff _ h 2 64_ remove _ all _ refs ( h ); ▁h -> prev _ frame _ num = ▁-1; ▁h -> prev _ frame _ num _ offset = ▁0; ▁h -> prev _ p oc _ ms b = ▁1 << 16 ; ▁h -> prev _ p oc _ ls b = ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁MAX _ DELAY ED _ PIC _ COUNT ; ▁i ++) ▁h -> last _ p ocs [ i ] ▁= ▁INT _ MIN ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁intel _ h da _ mm io _ writ el ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁val ) ▁{ ▁Intel H DA State ▁* d ▁= ▁opaque ; ▁const ▁Intel HD AR eg ▁* reg ▁= ▁intel _ h da _ reg _ find ( d , ▁addr ); ▁intel _ h da _ reg _ write ( d , ▁reg , ▁val , ▁0 xffffffff ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁abort _ codec _ experiment al ( AV Codec ▁* c , ▁int ▁encoder ) ▁{ ▁const ▁char ▁* codec _ string ▁= ▁encoder ▁? ▁" encoder " ▁: ▁" decoder "; ▁AV Codec ▁* codec ; ▁av _ log ( NULL , ▁AV _ LOG _ F ATAL , ▁"% s ▁'% s ' ▁is ▁experimental ▁and ▁might ▁produce ▁bad ▁" ▁" results .\ n Add ▁'- strict ▁experimental ' ▁if ▁you ▁want ▁to ▁use ▁it .\ n ", ▁codec _ string , ▁c -> name ); ▁codec ▁= ▁encoder ▁? ▁av codec _ find _ encoder ( c -> id ) ▁: ▁av codec _ find _ decoder ( c -> id ); ▁if ▁(! ( c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁h ys cale _ fast _ c ( Sw s Context ▁* c , ▁int 16_ t ▁* dst , ▁int ▁dst Width , ▁const ▁uint 8_ t ▁* src , ▁int ▁src W , ▁int ▁x Inc ) ▁{ ▁int ▁i ; ▁unsigned ▁int ▁xpos =0; ▁for ▁( i =0; i < dst Width ; i ++) ▁{ ▁register ▁unsigned ▁int ▁xx = x pos >> 16 ; ▁register ▁unsigned ▁int ▁x alpha =( x pos & 0 xFFFF ) >> 9 ; ▁dst [ i ]= ▁( src [ xx ] << 7) ▁+ ▁( src [ xx +1] ▁- ▁src [ xx ]) * x alpha ; ▁xpos += x Inc ; ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁standard _ decode _ i _ mb s ( VC 9 Context ▁* v ) ▁{ ▁Get Bit Context ▁* gb ▁= ▁& v -> s . gb ; ▁M peg Enc Context ▁* s ▁= ▁& v -> s ; ▁int ▁current _ mb ▁= ▁0; ▁/* ▁MB / Block ▁Position ▁info ▁*/ ▁uint 8_ t ▁cb pc y [4 ], ▁previous _ cb pc y [4 ], ▁predicted _ cb pc y , ▁* p _ cb pc y ▁/* ▁Pointer ▁to ▁skip ▁some ▁math ▁*/ ; ▁/* ▁Reset ▁CB PC Y ▁predict ors ▁*/ ▁mem set ( v -> previous _ line _ cb pc y , ▁0, ▁s -> mb _ stride << 2); ▁/* ▁Select ▁tt mb ▁table ▁depending ▁on ▁pq ▁*/ ▁if ▁( v

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁j az z _ led _ init ( Sys Bus Device ▁* dev ) ▁{ ▁L ed State ▁* s ▁= ▁FROM _ SY SB US ( L ed State , ▁dev ); ▁memory _ region _ init _ io ( & s -> iom em , ▁& led _ ops , ▁s , ▁" led ", ▁1); ▁sys bus _ init _ mm io ( dev , ▁& s -> iom em ); ▁s -> ds ▁= ▁graphic _ console _ init ( j az z _ led _ update _ display , ▁j az z _ led _ in validate _ display , ▁j az z _ led _ screen _ dump , ▁j az z _ led _ text _ update , ▁s ); ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁d ma _ read ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr , ▁unsigned ▁int ▁size ) ▁{ ▁struct ▁fs _ d ma _ ctrl ▁* ctrl ▁= ▁opaque ; ▁int ▁c ; ▁uint 32_ t ▁r ▁= ▁0; ▁if ▁( size ▁!= ▁4) ▁{ ▁d ma _ r invalid ( op aque , ▁addr ); ▁} ▁/* ▁Make ▁addr ▁relative ▁to ▁this ▁channel ▁and ▁bounded ▁to ▁nr ▁regs . ▁*/ ▁c ▁= ▁fs _ channel ( addr ); ▁addr ▁&= ▁0 xff ; ▁addr ▁>>= ▁2; ▁switch ▁( addr ) ▁{ ▁case ▁R W _ STAT : ▁r ▁= ▁ctrl -> channels [ c ]. state ▁& ▁7 ; ▁r ▁|= ▁ctrl -> channels [ c ]. e ol ▁<< ▁5

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p xa 2 xx _ descriptor _ load ( struct ▁p xa 2 xx _ l cd c _ s ▁* s ) ▁{ ▁struct ▁p xa _ frame _ descriptor _ s ▁desc ; ▁target _ ph ys _ addr _ t ▁desc ptr ; ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁P XA _ LC DD MA _ CH ANS ; ▁i ▁++ ) ▁{ ▁s -> d ma _ ch [ i ]. source ▁= ▁0; ▁if ▁(! s -> d ma _ ch [ i ]. up ) ▁continue ; ▁if ▁( s -> d ma _ ch [ i ]. branch ▁& ▁F BR _ BRA ) ▁{ ▁desc ptr ▁= ▁s -> d ma _ ch [ i ]. branch ▁& ▁F BR _ SRC ADDR ; ▁if ▁( s -> d ma _ ch [ i ]. branch ▁& ▁F BR _ B INT ) ▁p 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁sp ap r _ populate _ v device ( V IO s P AP R Bus ▁* bus , ▁void ▁* fd t ) ▁{ ▁Device State ▁* q dev , ▁** q dev s ; ▁Bus Child ▁* k id ; ▁int ▁i , ▁num , ▁ret ▁= ▁0; ▁/* ▁Count ▁q dev s ▁on ▁the ▁bus ▁list ▁*/ ▁num ▁= ▁0; ▁Q TAIL Q _ FORE A CH ( k id , ▁& bus -> bus . children , ▁sibling ) ▁{ ▁num ++; ▁} ▁/* ▁Copy ▁out ▁into ▁an ▁array ▁of ▁pointers ▁*/ ▁q dev s ▁= ▁g _ m alloc ( size of ( q dev ) ▁* ▁num ); ▁num ▁= ▁0; ▁Q TAIL Q _ FORE A CH ( k id , ▁& bus -> bus . children , ▁sibling ) ▁{ ▁q dev 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p pc _ tl b _ in validate _ all ( CP UP PC State ▁* env ) ▁{ ▁switch ▁( env -> mm u _ model ) ▁{ ▁case ▁PO WER PC _ MM U _ SO FT _6 xx : ▁case ▁PO WER PC _ MM U _ SO FT _ 74 xx : ▁p pc 6 xx _ tl b _ in validate _ all ( env ); ▁break ; ▁case ▁PO WER PC _ MM U _ SO FT _4 xx : ▁case ▁PO WER PC _ MM U _ SO FT _4 xx _ Z : ▁p pc 4 xx _ tl b _ in validate _ all ( env ); ▁break ; ▁case ▁PO WER PC _ MM U _ RE AL : ▁cpu _ abort ( env , ▁" No ▁TL B ▁for ▁Power PC ▁4 xx ▁in ▁real ▁mode \ n "); ▁break ; ▁case ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁uint 32_ t ▁HEL PER ( l ce br )( CP US 390 X State ▁* env , ▁uint 32_ t ▁f 1, ▁uint 32_ t ▁f 2) ▁{ ▁env -> fre gs [ f 1 ]. l . upper ▁= ▁float 32_ ch s ( env -> fre gs [ f 2 ]. l . upper ); ▁return ▁set _ cc _ nz _ f 32 ( env -> fre gs [ f 1 ]. l . upper ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁open _ url ( AV Format Context ▁* s , ▁AV IO Context ▁** pb , ▁const ▁char ▁* url , ▁AV Dictionary ▁* opts , ▁AV Dictionary ▁* opts 2, ▁int ▁* is _ http ) ▁{ ▁H LS Context ▁* c ▁= ▁s -> priv _ data ; ▁AV Dictionary ▁* tmp ▁= ▁NULL ; ▁const ▁char ▁* proto _ name ▁= ▁NULL ; ▁int ▁ret ; ▁av _ dict _ copy ( & tmp , ▁opts , ▁0); ▁av _ dict _ copy ( & tmp , ▁opts 2, ▁0); ▁if ▁( av _ str start ( url , ▁" crypto ", ▁NULL )) ▁{ ▁if ▁( url [ 6] ▁== ▁' +' ▁|| ▁url [ 6] ▁== ▁': ') ▁proto _ name ▁= ▁av i

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁qemu _ rd ma _ dest _ init ( RD MA Context ▁* rd ma , ▁Error ▁** err p ) ▁{ ▁int ▁ret ▁= ▁- E IN VAL , ▁idx ; ▁struct ▁rd ma _ cm _ id ▁* listen _ id ; ▁char ▁ip [ 40 ] ▁= ▁" unknown "; ▁struct ▁rd ma _ addrinfo ▁* res ; ▁char ▁port _ str [ 16 ]; ▁for ▁( idx ▁= ▁0; ▁idx ▁< ▁R D MA _ WR ID _ MAX ; ▁idx ++) ▁{ ▁rd ma -> wr _ data [ idx ]. control _ len ▁= ▁0; ▁rd ma -> wr _ data [ idx ]. control _ curr ▁= ▁NULL ; ▁} ▁if ▁( rd ma -> host ▁== ▁NULL ) ▁{ ▁ERROR ( err p , ▁" RD MA ▁host ▁is ▁not ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ck sum ( struct ▁m buf ▁* m , ▁int ▁len ) ▁{ ▁register ▁uint 16_ t ▁* w ; ▁register ▁int ▁sum ▁= ▁0; ▁register ▁int ▁m len ▁= ▁0; ▁int ▁byte _ sw apped ▁= ▁0; ▁union ▁{ ▁uint 8_ t ▁c [2 ]; ▁uint 16_ t ▁s ; ▁} ▁s _ util ; ▁union ▁{ ▁uint 16_ t ▁s [2 ]; ▁uint 32_ t ▁l ; ▁} ▁l _ util ; ▁if ▁( m -> m _ len ▁== ▁0) ▁goto ▁cont ; ▁w ▁= ▁mt od ( m , ▁uint 16_ t ▁* ); ▁m len ▁= ▁m -> m _ len ; ▁if ▁( len ▁< ▁m len ) ▁m len ▁= ▁len ; ▁# if def ▁DEBUG ▁len ▁-= ▁m len ; ▁# end if ▁/* ▁* ▁Force ▁to ▁even ▁bound

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁address _ space _ un map ( Address Space ▁* as , ▁void ▁* buffer , ▁target _ ph ys _ addr _ t ▁len , ▁int ▁is _ write , ▁target _ ph ys _ addr _ t ▁access _ len ) ▁{ ▁if ▁( buffer ▁!= ▁bounce . buffer ) ▁{ ▁if ▁( is _ write ) ▁{ ▁ram _ addr _ t ▁addr 1 ▁= ▁qemu _ ram _ addr _ from _ host _ n of ail ( buffer ); ▁while ▁( access _ len ) ▁{ ▁unsigned ▁l ; ▁l ▁= ▁TARGET _ PAGE _ SIZE ; ▁if ▁( l ▁> ▁access _ len ) ▁l ▁= ▁access _ len ; ▁invalidate _ and _ set _ dirty ( addr 1, ▁l ); ▁addr 1 ▁+= ▁l ; ▁ac

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁a tr ac 3_ decode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁int ▁i , ▁ret ; ▁int ▁version , ▁delay , ▁samples _ per _ frame , ▁frame _ factor ; ▁const ▁uint 8_ t ▁* ed ata _ ptr ▁= ▁av ctx -> ex tr ad ata ; ▁AT RA C 3 Context ▁* q ▁= ▁av ctx -> priv _ data ; ▁if ▁( av ctx -> channels ▁<= ▁0 ▁|| ▁av ctx -> channels ▁> ▁2) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Channel ▁configuration ▁error ! \ n "); ▁} ▁/* ▁Take ▁care ▁of ▁the ▁codec - specific ▁extr ad ata . ▁*/ ▁if ▁( av

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 32_ t ▁unassigned _ mem _ read l ( void ▁* op aque , ▁target _ ph ys _ addr _ t ▁addr ) ▁{ ▁# if def ▁DEBUG _ UN ASS IG NED ▁printf (" Un assigned ▁mem ▁read ▁" ▁TARGET _ F MT _ pl x ▁"\ n ", ▁addr ); ▁# end if ▁# if ▁defined ( TARGET _ ALPHA ) ▁|| ▁defined ( TARGET _ SP AR C ) ▁|| ▁defined ( TARGET _ M IC RO B LA ZE ) ▁do _ un assigned _ access ( addr , ▁0, ▁0, ▁0, ▁4 ); ▁# end if ▁return ▁0; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁TC G v _ i 64 ▁gen _ add q _ m sw ( TC G v _ i 64 ▁a , ▁TC G v ▁b ) ▁{ ▁TC G v _ i 64 ▁tmp 64 ▁= ▁tc g _ temp _ new _ i 64 (); ▁tc g _ gen _ ext u _ i 32_ i 64 ( tmp 64, ▁b ); ▁dead _ tmp ( b ); ▁tc g _ gen _ sh li _ i 64 ( tmp 64, ▁tmp 64, ▁32 ); ▁tc g _ gen _ add _ i 64 ( a , ▁tmp 64, ▁a ); ▁tc g _ temp _ free _ i 64 ( tmp 64 ); ▁return ▁a ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁q virt io _ sc si _ pc i _ free ( Q V irt IO SC SI ▁* vs ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁vs -> num _ queues ▁+ ▁2; ▁i ++) ▁{ ▁q virt queue _ cleanup ( vs -> dev -> bus , ▁vs -> v q [ i ], ▁vs -> alloc ); ▁} ▁pc _ alloc _ un init ( vs -> alloc ); ▁q virt io _ pc i _ device _ disable ( container _ of ( vs -> dev , ▁Q V irt io PC ID evice , ▁v dev )); ▁g _ free ( vs -> dev ); ▁q pc i _ free _ pc ( vs -> bus ); ▁g _ free ( vs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁sp ap r _ clear _ pending _ events ( s P AP R Machine State ▁* sp ap r ) ▁{ ▁s P AP RE vent Log Entry ▁* entry ▁= ▁NULL ; ▁Q TAIL Q _ FORE A CH ( entry , ▁& sp ap r -> pending _ events , ▁next ) ▁{ ▁Q TAIL Q _ REMOVE ( & sp ap r -> pending _ events , ▁entry , ▁next ); ▁g _ free ( entry -> extended _ log ); ▁g _ free ( entry ); ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sc lp _ set _ write _ mask ( void ) ▁{ ▁Write Event Mask ▁* sc cb ▁= ▁( void *) _ sc cb ; ▁sc cb -> h . length ▁= ▁sizeof ( Write Event Mask ); ▁sc cb -> mask _ length ▁= ▁sizeof ( un signed ▁int ); ▁sc cb -> receive _ mask ▁= ▁S CL P _ EVENT _ MASK _ MSG _ ASCII ; ▁sc cb -> cp _ receive _ mask ▁= ▁S CL P _ EVENT _ MASK _ MSG _ ASCII ; ▁sc cb -> send _ mask ▁= ▁S CL P _ EVENT _ MASK _ MSG _ ASCII ; ▁sc cb -> cp _ send _ mask ▁= ▁S CL P _ EVENT _ MASK _ MSG _ ASCII ; ▁sc lp _ service _ call 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁json _ prop _ int ( Q JSON ▁* json , ▁const ▁char ▁* name , ▁int 64_ t ▁val ) ▁{ ▁json _ emit _ element ( json , ▁name ); ▁q string _ append _ int ( json -> str , ▁val ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pm _ update _ sc i ( PI IX 4 PM State ▁* s ) ▁{ ▁int ▁sc i _ level , ▁pm st s ; ▁pm st s ▁= ▁ac pi _ pm 1_ evt _ get _ st s ( & s -> ar ); ▁sc i _ level ▁= ▁( (( pm st s ▁& ▁s -> ar . pm 1. evt . en ) ▁& ▁( AC PI _ BIT MASK _ RT _ C LOCK _ ENABLE ▁| ▁AC PI _ BIT MASK _ PO WER _ BUTTON _ ENABLE ▁| ▁AC PI _ BIT MASK _ GLOBAL _ LOCK _ ENABLE ▁| ▁AC PI _ BIT MASK _ T IMER _ ENABLE )) ▁!= ▁0) ▁|| ▁( (( s -> ar . g pe . st s [0] ▁& ▁s -> ar . g pe . en [0]) ▁& ▁( PI IX 4_ PC I _ H OT PL UG _ STAT

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁w v _ get _ value _ integer ( W av pack Frame Context ▁* s , ▁uint 32_ t ▁* crc , ▁int ▁S ) ▁{ ▁int ▁bit ; ▁if ( s -> extra _ bits ){ ▁S ▁<<= ▁s -> extra _ bits ; ▁if ( s -> got _ extra _ bits ){ ▁S ▁|= ▁get _ bits ( & s -> gb _ extra _ bits , ▁s -> extra _ bits ); ▁* crc ▁= ▁* crc ▁* ▁9 ▁+ ▁( S & 0 xffff ) ▁* ▁3 ▁+ ▁(( un signed ) S >> 16 ); ▁} ▁} ▁bit ▁= ▁( S ▁& ▁s -> and ) ▁| ▁s -> or ; ▁return ▁( (( S ▁+ ▁bit ) ▁<< ▁s -> shift ) ▁- ▁bit ) ▁<< ▁s -> post _ shift ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mx f _ read _ seek ( AV Format Context ▁* s , ▁int ▁stream _ index , ▁int 64_ t ▁sample _ time , ▁int ▁flags ) ▁{ ▁AV Stream ▁* st ▁= ▁s -> streams [ stream _ index ]; ▁int 64_ t ▁seconds ; ▁M XF Context * ▁mx f ▁= ▁s -> priv _ data ; ▁int 64_ t ▁seek pos ; ▁int ▁ret ; ▁M XF Index Table ▁* t ; ▁if ▁( mx f -> nb _ index _ tables ▁<= ▁0) ▁{ ▁if ▁(! s -> bit _ rate ) ▁return ▁A VER ROR _ IN V ALI DD ATA ; ▁if ▁( sample _ time ▁< ▁0) ▁sample _ time ▁= ▁0; ▁seconds ▁= ▁av _ res cale ( sample _ ti

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁if _ start ( Sl ir p ▁* sl ir p ) ▁{ ▁uint 64_ t ▁now ▁= ▁qemu _ get _ clock _ ns ( rt _ clock ); ▁int ▁re queued ▁= ▁0; ▁struct ▁m buf ▁* if m , ▁* if qt ; ▁DEBUG _ CALL (" if _ start "); ▁if ▁( sl ir p -> if _ queued ▁== ▁0) ▁return ; ▁/* ▁Nothing ▁to ▁do ▁*/ ▁again : ▁/* ▁check ▁if ▁we ▁can ▁really ▁output ▁*/ ▁if ▁(! sl ir p _ can _ output ( sl ir p -> op aque )) ▁return ; ▁/* ▁* ▁See ▁which ▁queue ▁to ▁get ▁next ▁packet ▁from ▁* ▁If ▁there ' s ▁something ▁in ▁the ▁fast q , ▁select ▁it ▁immediately ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dump _ human _ image _ check ( Image Check ▁* check ) ▁{ ▁if ▁(! ( check -> cor ru ptions ▁|| ▁check -> le ak s ▁|| ▁check -> check _ errors )) ▁{ ▁printf (" No ▁errors ▁were ▁found ▁on ▁the ▁image .\ n "); ▁} ▁else ▁{ ▁if ▁( check -> cor ru ptions ) ▁{ ▁printf ("\ n %" ▁PR Id 64 ▁" ▁errors ▁were ▁found ▁on ▁the ▁image .\ n " ▁" Data ▁may ▁be ▁corrupted , ▁or ▁further ▁writes ▁to ▁the ▁image ▁" ▁" may ▁corrupt ▁it .\ n ", ▁check -> cor ru ptions ); ▁} ▁if ▁( check -> le ak s ) ▁{ ▁printf ("

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁float 32 ▁int 32_ to _ float 32 ( ▁int 32 ▁a ▁STATUS _ PARAM ▁) ▁{ ▁flag ▁z Sign ; ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁0; ▁if ▁( ▁a ▁== ▁( sb its 32) ▁0 x 8 0000000 ▁) ▁return ▁pack Float 32 ( ▁1, ▁0 x 9 E , ▁0 ▁); ▁z Sign ▁= ▁( ▁a ▁< ▁0 ▁); ▁return ▁normalize Round And Pack Float 32 ( ▁z Sign , ▁0 x 9 C , ▁z Sign ▁? ▁- ▁a ▁: ▁a ▁STATUS _ VAR ▁); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁vf io _ start _ event fd _ inject ion ( V FI O INT p ▁* int p ) ▁{ ▁int ▁ret ; ▁ret ▁= ▁vf io _ set _ trigger _ event fd ( int p , ▁vf io _ int p _ interrupt ); ▁if ▁( ret ) ▁{ ▁error _ report (" vf io : ▁Error : ▁Failed ▁to ▁pass ▁IR Q ▁fd ▁to ▁the ▁driver : ▁% m "); ▁} ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁bt _ h id _ in ( struct ▁bt _ h id _ device _ s ▁* s ) ▁{ ▁USB Packet ▁p ; ▁p . pid ▁= ▁USB _ TOKEN _ IN ; ▁p . de ve p ▁= ▁1; ▁p . data ▁= ▁s -> data in . buffer ; ▁p . len ▁= ▁sizeof ( s -> data in . buffer ); ▁s -> data in . len ▁= ▁s -> usb dev -> info -> handle _ data ( s -> usb dev , ▁& p ); ▁return ▁s -> data in . len ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁q mp _ inject _ n mi ( Error ▁** err p ) ▁{ ▁# if ▁defined ( TARGET _ I 38 6) ▁CPU State ▁* cs ; ▁CPU _ FORE A CH ( cs ) ▁{ ▁X 86 CPU ▁* cpu ▁= ▁X 86_ CPU ( cs ); ▁if ▁(! cpu -> ap ic _ state ) ▁{ ▁cpu _ interrupt ( cs , ▁CPU _ INTER R UP T _ N MI ); ▁} ▁else ▁{ ▁ap ic _ del iver _ n mi ( cpu -> ap ic _ state ); ▁} ▁} ▁# else ▁n mi _ monitor _ handle ( monitor _ get _ cpu _ index (), ▁err p ); ▁# end if ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁eth _ setup _ ip 4_ fragment ation ( const ▁void ▁* l 2 hdr , ▁size _ t ▁l 2 hdr _ len , ▁void ▁* l 3 hdr , ▁size _ t ▁l 3 hdr _ len , ▁size _ t ▁l 3 payload _ len , ▁size _ t ▁frag _ offset , ▁bool ▁more _ f rag s ) ▁{ ▁if ▁( eth _ get _ l 3_ proto ( l 2 hdr , ▁l 2 hdr _ len ) ▁== ▁E TH _ P _ IP ) ▁{ ▁uint 16_ t ▁orig _ flags ; ▁struct ▁ip _ header ▁* iph dr ▁= ▁( struct ▁ip _ header ▁* ) ▁l 3 hdr ; ▁uint 16_ t ▁frag _ off _ units ▁= ▁frag _ offset ▁/ ▁IP _ FR AG _ UNIT _ SIZE ; ▁uint 16_ t ▁new _ ip _ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁float 32 ▁HEL PER ( uc f 64_ subs )( float 32 ▁a , ▁float 32 ▁b , ▁CPU Un i Core 32 State ▁* env ) ▁{ ▁return ▁float 32_ sub ( a , ▁b , ▁& env -> uc f 64. fp _ status ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁do _ ck sum ( uint 8_ t ▁* dp , ▁uint 8_ t ▁* de ) ▁{ ▁unsigned ▁int ▁b sum [2] ▁= ▁{ 0, ▁0 }, ▁i , ▁sum ; ▁for ▁( i ▁= ▁1; ▁dp ▁< ▁de ; ▁b sum [ i ^ =1 ] ▁+= ▁* dp ++) ▁; ▁sum ▁= ▁( b sum [0] ▁<< ▁8) ▁+ ▁b sum [1]; ▁sum ▁= ▁( sum ▁>> ▁16 ) ▁+ ▁( sum ▁& ▁0 xffff ); ▁return ▁~ ( sum ▁+ ▁( sum ▁>> ▁16 )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ics _ simple _ real ize ( Device State ▁* dev , ▁Error ▁** err p ) ▁{ ▁I CS State ▁* ics ▁= ▁I CS _ SI MPLE ( dev ); ▁if ▁(! ics -> nr _ ir qs ) ▁{ ▁error _ set g ( err p , ▁" Number ▁of ▁interrupt s ▁needs ▁to ▁be ▁greater ▁0 "); ▁return ; ▁} ▁ics -> ir qs ▁= ▁g _ m alloc 0( ics -> nr _ ir qs ▁* ▁sizeof ( IC SI R Q State )); ▁ics -> q ir qs ▁= ▁qemu _ allocate _ ir qs ( ics _ simple _ set _ irq , ▁ics , ▁ics -> nr _ ir qs ); ▁qemu _ register _ reset ( ics _ simple _ reset , ▁dev ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁v nc _ flush ( V nc State ▁* vs ) ▁{ ▁if ▁( vs -> output . offset ) ▁v nc _ client _ write ( vs ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ sub channel _ work ( Sub ch Dev ▁* sch , ▁ORB ▁* orb ) ▁{ ▁S CS W ▁* s ▁= ▁& sch -> curr _ status . sc sw ; ▁if ▁( s -> ctrl ▁& ▁S CS W _ F CT L _ CLEAR _ F UNC ) ▁{ ▁sch _ handle _ clear _ func ( sch ); ▁} ▁else ▁if ▁( s -> ctrl ▁& ▁S CS W _ F CT L _ H ALT _ F UNC ) ▁{ ▁sch _ handle _ h alt _ func ( sch ); ▁} ▁else ▁if ▁( s -> ctrl ▁& ▁S CS W _ F CT L _ START _ F UNC ) ▁{ ▁/* ▁Trigger ed ▁by ▁both ▁ss ch ▁and ▁rs ch . ▁*/ ▁sch _ handle _ start _ func ( sch , ▁orb ); ▁} ▁else ▁{ ▁/* ▁C

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sd _ snapshot _ delete ( Block Driver State ▁* bs , ▁const ▁char ▁* snapshot _ id , ▁const ▁char ▁* name , ▁Error ▁** err p ) ▁{ ▁unsigned ▁long ▁snap _ id ▁= ▁0; ▁char ▁snap _ tag [ SD _ MAX _ V DI _ TAG _ LEN ]; ▁Error ▁* local _ err ▁= ▁NULL ; ▁int ▁fd , ▁ret ; ▁char ▁buf [ SD _ MAX _ V DI _ LEN ▁+ ▁SD _ MAX _ V DI _ TAG _ LEN ]; ▁B DR V Sh eep dog State ▁* s ▁= ▁bs -> op aque ; ▁unsigned ▁int ▁w len ▁= ▁SD _ MAX _ V DI _ LEN ▁+ ▁SD _ MAX _ V DI _ TAG _ LEN , ▁r len ▁= ▁0; ▁uint 32_ t ▁vi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁block _ save _ iterate ( Q EM U File ▁* f , ▁void ▁* op aque ) ▁{ ▁int ▁ret ; ▁int 64_ t ▁last _ ft ell ▁= ▁qemu _ ft ell ( f ); ▁D PRI NT F (" Enter ▁save ▁live ▁iterate ▁submitted ▁% d ▁transferred ▁% d \ n ", ▁block _ mig _ state . submitted , ▁block _ mig _ state . transfer red ); ▁ret ▁= ▁flush _ bl ks ( f ); ▁if ▁( ret ) ▁{ ▁return ▁ret ; ▁} ▁blk _ mig _ reset _ dirty _ cursor (); ▁/* ▁control ▁the ▁rate ▁of ▁transfer ▁*/ ▁blk _ mig _ lock (); ▁while ▁(( block _ mig _ state . submitted

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁fft _ init ( AV Codec Context ▁* av ctx , ▁AC 3 MD CT Context ▁* md ct , ▁int ▁ln ) ▁{ ▁int ▁i , ▁n , ▁n 2; ▁float ▁alpha ; ▁n ▁= ▁1 ▁<< ▁ln ; ▁n 2 ▁= ▁n ▁>> ▁1; ▁FF _ AL LOC _ OR _ G OTO ( av ctx , ▁md ct -> cost ab , ▁n 2 ▁* ▁sizeof (* md ct -> cost ab ), ▁fft _ alloc _ fail ); ▁FF _ AL LOC _ OR _ G OTO ( av ctx , ▁md ct -> s int ab , ▁n 2 ▁* ▁sizeof (* md ct -> s int ab ), ▁fft _ alloc _ fail ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁n 2; ▁i ++) ▁{ ▁alpha ▁= ▁2.0 ▁* ▁M _ PI ▁* ▁i ▁/ ▁n ; ▁md

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁always _ inline ▁void ▁gen _ inter mediate _ code _ internal ▁( CPU State ▁* env , ▁Translation Block ▁* tb , ▁int ▁search _ pc ) ▁{ ▁# if ▁defined ▁AL PHA _ DEBUG _ DIS AS ▁static ▁int ▁insn _ count ; ▁# end if ▁Dis as Context ▁ctx , ▁* ctx p ▁= ▁& ctx ; ▁target _ ulong ▁pc _ start ; ▁uint 32_ t ▁insn ; ▁uint 16_ t ▁* gen _ op c _ end ; ▁CP UB reak point ▁* bp ; ▁int ▁j , ▁l j ▁= ▁-1; ▁int ▁ret ; ▁int ▁num _ ins ns ; ▁int ▁max _ ins ns ; ▁pc _ start ▁= ▁tb -> pc ; ▁gen _ op c _ end ▁= ▁gen _ op 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁V nc Job ▁* vn c _ job _ new ( V nc State ▁* vs ) ▁{ ▁V nc Job ▁* job ▁= ▁g _ m alloc 0( size of ( V nc Job )); ▁job -> vs ▁= ▁vs ; ▁v nc _ lock _ queue ( queue ); ▁Q LIST _ INIT ( & job -> rect angles ); ▁v nc _ un lock _ queue ( queue ); ▁return ▁job ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁nb d _ client _ closed ( N BD Client ▁* client ) ▁{ ▁nb _ fds --; ▁if ▁( nb _ fds ▁== ▁0 ▁&& ▁! p ersistent ▁&& ▁state ▁== ▁RUNNING ) ▁{ ▁state ▁= ▁TERMIN ATE ; ▁} ▁nb d _ update _ server _ watch (); ▁nb d _ client _ put ( client ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁uint 16_ t ▁nv me _ create _ sq ( N v me Ctrl ▁* n , ▁N v me Cmd ▁* cmd ) ▁{ ▁N v me S Queue ▁* sq ; ▁N v me Create Sq ▁* c ▁= ▁( N v me Create Sq ▁* ) cmd ; ▁uint 16_ t ▁cq id ▁= ▁le 16_ to _ cpu ( c -> c q id ); ▁uint 16_ t ▁sq id ▁= ▁le 16_ to _ cpu ( c -> sq id ); ▁uint 16_ t ▁q size ▁= ▁le 16_ to _ cpu ( c -> q size ); ▁uint 16_ t ▁q flags ▁= ▁le 16_ to _ cpu ( c -> sq _ flags ); ▁uint 64_ t ▁pr p 1 ▁= ▁le 64_ to _ cpu ( c -> pr p 1); ▁if ▁(! c q id ▁|| ▁nv me _ check _ c q id ( n , ▁cq id )

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ ac 3_ bit _ alloc _ calc _ mask ( AC 3 Bit Alloc Parameters ▁* s , ▁int 16_ t ▁* band _ ps d , ▁int ▁start , ▁int ▁end , ▁int ▁fast _ gain , ▁int ▁is _ l fe , ▁int ▁db a _ mode , ▁int ▁db a _ n se gs , ▁uint 8_ t ▁* db a _ offsets , ▁uint 8_ t ▁* db a _ lengths , ▁uint 8_ t ▁* db a _ values , ▁int 16_ t ▁* mask ) ▁{ ▁int 16_ t ▁exc ite [ 50 ]; ▁/* ▁exc itation ▁*/ ▁int ▁bin , ▁k ; ▁int ▁b nd str t , ▁b nd end , ▁begin , ▁end 1, ▁tmp ; ▁int ▁low comp , ▁fast le ak , ▁slow le ak ; ▁/* ▁exc itati

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁vms v ga _ update _ rect _ delayed ( struct ▁vms v ga _ state _ s ▁* s , ▁int ▁x , ▁int ▁y , ▁int ▁w , ▁int ▁h ) ▁{ ▁struct ▁vms v ga _ rect _ s ▁* rect ▁= ▁& s -> red raw _ f ifo [ s -> red raw _ f ifo _ last ▁++ ]; ▁s -> red raw _ f ifo _ last ▁&= ▁RED RAW _ FI FO _ LEN ▁- ▁1; ▁rect -> x ▁= ▁x ; ▁rect -> y ▁= ▁y ; ▁rect -> w ▁= ▁w ; ▁rect -> h ▁= ▁h ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁t _ gen _ add x _ car ry ( Dis as Context ▁* dc , ▁TC G v ▁d ) ▁{ ▁if ▁( dc -> flag x _ known ) ▁{ ▁if ▁( dc -> flags _ x ) ▁{ ▁TC G v ▁c ; ▁c ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ TL ); ▁t _ gen _ mov _ T N _ p reg ( c , ▁PR _ C CS ); ▁/* ▁C ▁flag ▁is ▁already ▁at ▁bit ▁0. ▁*/ ▁tc g _ gen _ and i _ tl ( c , ▁c , ▁C _ FLAG ); ▁tc g _ gen _ add _ tl ( d , ▁d , ▁c ); ▁tc g _ temp _ free ( c ); ▁} ▁} ▁else ▁{ ▁TC G v ▁x , ▁c ; ▁x ▁= ▁tc g _ temp _ new ( TC G _ TYPE _ TL ); ▁c ▁= ▁tc g 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rt as _ start _ cpu ( s P AP R Environment ▁* sp ap r , ▁uint 32_ t ▁token , ▁uint 32_ t ▁nargs , ▁target _ ulong ▁args , ▁uint 32_ t ▁n ret , ▁target _ ulong ▁ret s ) ▁{ ▁target _ ulong ▁id , ▁start , ▁r 3; ▁CPU State ▁* cs ; ▁if ▁( n args ▁!= ▁3 ▁|| ▁n ret ▁!= ▁1) ▁{ ▁rt as _ st ( ret s , ▁0, ▁- 3); ▁return ; ▁} ▁id ▁= ▁rt as _ ld ( args , ▁0); ▁start ▁= ▁rt as _ ld ( args , ▁1); ▁r 3 ▁= ▁rt as _ ld ( args , ▁2); ▁cs ▁= ▁qemu _ get _ cpu ( id ); ▁if ▁( cs ▁!= ▁NULL ) ▁{ ▁Power PC CPU ▁* c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁i 2 c _ start _ transfer ( i 2 c _ bus ▁* bus , ▁int ▁address , ▁int ▁recv ) ▁{ ▁Device State ▁* q dev ; ▁i 2 c _ slave ▁* slave ▁= ▁NULL ; ▁LIST _ FORE A CH ( q dev , ▁& bus -> q bus . children , ▁sibling ) ▁{ ▁slave ▁= ▁I 2 C _ S LA VE _ FROM _ Q DEV ( q dev ); ▁if ▁( slave -> address ▁== ▁address ) ▁break ; ▁} ▁if ▁(! slave ) ▁return ▁1; ▁/* ▁If ▁the ▁bus ▁is ▁already ▁busy , ▁assume ▁this ▁is ▁a ▁repeated ▁start ▁condition . ▁*/ ▁bus -> current _ dev ▁= ▁slave ; ▁slave -> info -> event ( slave ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁a asc _ decode _ frame ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁A asc Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁int ▁comp r , ▁i , ▁stride ; ▁s -> frame . reference ▁= ▁3; ▁s -> frame . buffer _ hints ▁= ▁FF _ BUFFER _ H INT S _ VALID ▁| ▁FF _ BUFFER _ H INT S _ PRE SER VE ▁| ▁FF _ BUFFER _ H INT S _ RE US ABLE ; ▁if ▁( av ctx -> re get _ buffer ( av c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁ff _ h 2 64_ field _ end ( H 264 Context ▁* h , ▁int ▁in _ setup ) ▁{ ▁AV Codec Context ▁* const ▁av ctx ▁= ▁h -> av ctx ; ▁int ▁err ▁= ▁0; ▁h -> mb _ y ▁= ▁0; ▁if ▁( CONFIG _ H 2 64_ VD PA U _ DE CO DER ▁&& ▁h -> av ctx -> codec -> capabilities ▁& ▁CODE C _ CAP _ H W AC CEL _ VD PA U ) ▁ff _ vd pa u _ h 2 64_ set _ reference _ frames ( h ); ▁if ▁( in _ setup ▁|| ▁! ( av ctx -> active _ thread _ type ▁& ▁FF _ THREAD _ FRAME )) ▁{ ▁if ▁(! h -> dro ppable ) ▁{ ▁err ▁= ▁ff _ h 2 64_ execute _ ref _ pic

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁sd h ci _ write _ data port ( SD H CI State ▁* s , ▁uint 32_ t ▁value , ▁unsigned ▁size ) ▁{ ▁unsigned ▁i ; ▁/* ▁Check ▁that ▁there ▁is ▁free ▁space ▁left ▁in ▁a ▁buffer ▁*/ ▁if ▁(! ( s -> pr n st s ▁& ▁SD H C _ SPACE _ AVAILABLE )) ▁{ ▁ERR PRI NT (" Can ' t ▁write ▁to ▁data ▁buffer : ▁buffer ▁full \ n "); ▁return ; ▁} ▁for ▁( i ▁= ▁0; ▁i ▁< ▁size ; ▁i ++) ▁{ ▁s -> f ifo _ buffer [ s -> data _ count ] ▁= ▁value ▁& ▁0 xFF ; ▁s -> data _ count ++; ▁value ▁>>= ▁8 ; ▁if ▁( s -> data _ count ▁>=

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁Char Driver State ▁* q emu _ chr _ open _ pipe ( Ch ard ev Host dev ▁* opts ) ▁{ ▁const ▁char ▁* filename ▁= ▁opts -> device ; ▁Char Driver State ▁* chr ; ▁Win Char State ▁* s ; ▁chr ▁= ▁qemu _ chr _ alloc (); ▁s ▁= ▁g _ m alloc 0( size of ( Win Char State )); ▁chr -> op aque ▁= ▁s ; ▁chr -> chr _ write ▁= ▁win _ chr _ write ; ▁chr -> chr _ close ▁= ▁win _ chr _ close ; ▁if ▁( win _ chr _ pipe _ init ( chr , ▁filename ) ▁< ▁0) ▁{ ▁g _ free ( s ); ▁g _ free ( chr ); ▁return ▁NULL ; ▁} ▁return ▁chr

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁sb r _ h f _ calc _ n patches ( A AC Context ▁* ac , ▁Spect ral Band Replication ▁* s br ) ▁{ ▁int ▁i , ▁k , ▁sb ▁= ▁0; ▁int ▁ms b ▁= ▁sb r -> k [0]; ▁int ▁usb ▁= ▁sb r -> k x [1]; ▁int ▁goal _ sb ▁= ▁( (1 000 ▁<< ▁11 ) ▁+ ▁( s br -> sample _ rate ▁>> ▁1)) ▁/ ▁sb r -> sample _ rate ; ▁sb r -> num _ patches ▁= ▁0; ▁if ▁( goal _ sb ▁< ▁sb r -> k x [1] ▁+ ▁sb r -> m [1]) ▁{ ▁for ▁( k ▁= ▁0; ▁sb r -> f _ master [ k ] ▁< ▁goal _ sb ; ▁k ++) ▁; ▁} ▁else ▁k ▁= ▁sb r -> n _ master ; ▁do ▁{ ▁int ▁odd

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* thread _ func ( void ▁* p ) ▁{ ▁struct ▁thread _ info ▁* info ▁= ▁p ; ▁rc u _ register _ thread (); ▁atomic _ inc ( & n _ ready _ threads ); ▁while ▁(! atomic _ mb _ read ( & test _ start )) ▁{ ▁cpu _ re lax (); ▁} ▁rc u _ read _ lock (); ▁while ▁(! atomic _ read ( & test _ stop )) ▁{ ▁info -> r ▁= ▁xor shift 64 star ( info -> r ); ▁info -> func ( info ); ▁} ▁rc u _ read _ un lock (); ▁rc u _ un register _ thread (); ▁return ▁NULL ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁http _ start _ receive _ data ( HTTP Context ▁* c ) ▁{ ▁int ▁fd ; ▁if ▁( c -> stream -> feed _ opened ) ▁return ▁-1; ▁/* ▁Don ' t ▁permit ▁writing ▁to ▁this ▁one ▁*/ ▁if ▁( c -> stream -> readonly ) ▁return ▁-1; ▁/* ▁open ▁feed ▁*/ ▁fd ▁= ▁open ( c -> stream -> feed _ filename , ▁O _ RD WR ); ▁if ▁( fd ▁< ▁0) ▁{ ▁http _ log (" Error ▁opening ▁feed er ▁file : ▁% s \ n ", ▁strerror ( err no )); ▁return ▁-1; ▁} ▁c -> feed _ fd ▁= ▁fd ; ▁if ▁( c -> stream -> truncate ) ▁{ ▁/* ▁truncate ▁feed ▁fi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁usb _ host _ scan _ dev ( void ▁* op aque , ▁USB Scan Func ▁* func ) ▁{ ▁FILE ▁* f ▁= ▁NULL ; ▁char ▁line [10 24 ]; ▁char ▁buf [10 24 ]; ▁int ▁bus _ num , ▁addr , ▁speed , ▁device _ count , ▁class _ id , ▁product _ id , ▁vendor _ id ; ▁char ▁product _ name [ 512 ]; ▁int ▁ret ▁= ▁0; ▁if ▁(! usb _ host _ device _ path ) ▁{ ▁per ror (" h usb : ▁USB ▁Host ▁Device ▁Path ▁not ▁set "); ▁goto ▁the _ end ; ▁} ▁sn printf ( line , ▁sizeof ( line ), ▁"% s / devices ", ▁usb _ host _ device _ path ); ▁f ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁p pc _ cpu _ class _ init ( Object Class ▁* oc , ▁void ▁* data ) ▁{ ▁Power PC CPU Class ▁* p cc ▁= ▁PO WER PC _ CPU _ CLASS ( oc ); ▁CPU Class ▁* cc ▁= ▁CPU _ CLASS ( oc ); ▁Device Class ▁* dc ▁= ▁DEVICE _ CLASS ( oc ); ▁p cc -> parent _ real ize ▁= ▁dc -> real ize ; ▁p cc -> pv r ▁= ▁CPU _ PO WER PC _ DEFAULT _ MASK ; ▁p cc -> pv r _ mask ▁= ▁CPU _ PO WER PC _ DEFAULT _ MASK ; ▁p cc -> interrupt s _ big _ endian ▁= ▁p pc _ cpu _ interrupt s _ big _ endian _ always ; ▁dc -> real ize ▁= ▁p p

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁qemu _ del iver _ packet ( V LAN Client State ▁* sender , ▁const ▁uint 8_ t ▁* buf , ▁int ▁size ) ▁{ ▁V LAN Client State ▁* vc ; ▁for ▁( vc ▁= ▁sender -> vlan -> first _ client ; ▁vc ▁!= ▁NULL ; ▁vc ▁= ▁vc -> next ) ▁{ ▁if ▁( vc ▁!= ▁sender ▁&& ▁! vc -> link _ down ) ▁{ ▁vc -> receive ( vc -> op aque , ▁buf , ▁size ); ▁} ▁} ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁p pc 9 70 _ irq _ init ▁( CPU State ▁* env ) ▁{ ▁env -> irq _ inputs ▁= ▁( void ▁** ) q emu _ allocate _ ir qs ( & pp c 9 70 _ set _ irq , ▁env , ▁7 ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁do _ interrupt _ protected ( CPU X 86 State ▁* env , ▁int ▁int no , ▁int ▁is _ int , ▁int ▁error _ code , ▁unsigned ▁int ▁next _ e ip , ▁int ▁is _ hw ) ▁{ ▁Segment Cache ▁* dt ; ▁target _ ulong ▁ptr , ▁s sp ; ▁int ▁type , ▁d pl , ▁selector , ▁ss _ d pl , ▁c pl ; ▁int ▁has _ error _ code , ▁new _ stack , ▁shift ; ▁uint 32_ t ▁e 1, ▁e 2, ▁offset , ▁ss ▁= ▁0, ▁es p , ▁ss _ e 1 ▁= ▁0, ▁ss _ e 2 ▁= ▁0; ▁uint 32_ t ▁old _ e ip , ▁sp _ mask ; ▁int ▁vm 86 ▁= ▁env -> ef lags ▁& ▁VM _ MASK ; ▁has _ e

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ start _ vc pu ( CPU State ▁* env ) ▁{ ▁env -> thread ▁= ▁qemu _ m alloc z ( size of ( Q emu Thread )); ▁env -> h alt _ cond ▁= ▁qemu _ m alloc z ( size of ( Q emu Cond )); ▁qemu _ cond _ init ( env -> h alt _ cond ); ▁qemu _ thread _ create ( env -> thread , ▁k vm _ cpu _ thread _ fn , ▁env ); ▁while ▁( env -> created ▁== ▁0) ▁qemu _ cond _ tim ed wait ( & q emu _ cpu _ cond , ▁& q emu _ global _ mut ex , ▁100); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁hw addr ▁p pc _ hash 64_ pt eg _ search ( Power PC CPU ▁* cpu , ▁hw addr ▁hash , ▁bool ▁secondary , ▁target _ ulong ▁p tem , ▁p pc _ hash _ pt e 64_ t ▁* pt e ) ▁{ ▁CP UP PC State ▁* env ▁= ▁& cpu -> env ; ▁int ▁i ; ▁uint 64_ t ▁token ; ▁target _ ulong ▁p te 0, ▁p te 1; ▁target _ ulong ▁p te _ index ; ▁p te _ index ▁= ▁( hash ▁& ▁env -> ht ab _ mask ) ▁* ▁H P TES _ PER _ GROUP ; ▁token ▁= ▁p pc _ hash 64_ start _ access ( cpu , ▁p te _ index ); ▁if ▁(! token ) ▁{ ▁return ▁-1; ▁} ▁for ▁( i ▁= ▁0; 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁dc ad ec _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁D CA Context ▁* s ▁= ▁av ctx -> priv _ data ; ▁s -> av ctx ▁= ▁av ctx ; ▁s -> core . av ctx ▁= ▁av ctx ; ▁s -> ex ss . av ctx ▁= ▁av ctx ; ▁s -> x ll . av ctx ▁= ▁av ctx ; ▁s -> l br . av ctx ▁= ▁av ctx ; ▁ff _ d ca _ init _ vl cs (); ▁if ▁( ff _ d ca _ core _ init ( & s -> core ) ▁< ▁0) ▁return ▁A VER ROR ( EN O ME M ); ▁if ▁( ff _ d ca _ l br _ init ( & s -> l br ) ▁< ▁0) ▁return ▁A VER ROR ( EN O ME M ); ▁ff _ dc ad sp _ init 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁v orb is _ parse _ setup _ hdr _ mappings ( vor b is _ context ▁* vc ) ▁{ ▁Get Bit Context ▁* gb =& vc -> gb ; ▁uint _ fast 8_ t ▁i , ▁j ; ▁vc -> mapping _ count = get _ bits ( gb , ▁6) +1 ; ▁vc -> mappings =( vor b is _ mapping ▁* ) av _ m alloc z ( vc -> mapping _ count ▁* ▁sizeof ( vor b is _ mapping )); ▁AV _ DEBUG (" ▁There ▁are ▁% d ▁mappings . ▁\ n ", ▁vc -> mapping _ count ); ▁for ( i =0; i < vc -> mapping _ count ; ++ i ) ▁{ ▁v orb is _ mapping ▁* mapping _ setup =& vc -> mappings [

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁st q _ t ce ( V IO s P AP R Device ▁* dev , ▁uint 64_ t ▁t addr , ▁uint 64_ t ▁val ) ▁{ ▁val ▁= ▁t swap 64 ( val ); ▁sp ap r _ t ce _ d ma _ write ( dev , ▁t addr , ▁& val , ▁sizeof ( val )); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁vp 6_ parse _ coeff _ models ( VP 56 Context ▁* s ) ▁{ ▁V P 56 Range Coder ▁* c ▁= ▁& s -> c ; ▁V P 56 Model ▁* model ▁= ▁s -> model p ; ▁int ▁def _ prob [ 11 ]; ▁int ▁node , ▁cg , ▁ctx , ▁pos ; ▁int ▁ct ; ▁/* ▁code ▁type ▁*/ ▁int ▁pt ; ▁/* ▁plane ▁type ▁(0 ▁for ▁Y , ▁1 ▁for ▁U ▁or ▁V ) ▁*/ ▁mem set ( def _ prob , ▁0 x 8 0, ▁sizeof ( def _ prob )); ▁for ▁( pt =0; ▁pt < 2; ▁pt ++) ▁for ▁( node =0; ▁node < 11 ; ▁node ++) ▁if ▁( vp 56 _ rac _ get _ prob ( c , ▁vp 6_ d cc v _ p ct [ pt ][ node 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁test _ opts _ dict _ un visited ( void ) ▁{ ▁Q emu Opts ▁* opts ; ▁Visitor ▁* v ; ▁User Def Options ▁* user def ; ▁opts ▁= ▁qemu _ opts _ parse ( q emu _ find _ opts (" user def "), ▁" i 64 x =0, b ogus =1 ", ▁false , ▁& error _ abort ); ▁v ▁= ▁opts _ visitor _ new ( opts ); ▁/* ▁BU G : ▁bogus ▁should ▁be ▁diag n osed ▁*/ ▁visit _ type _ User Def Options ( v , ▁NULL , ▁& user def , ▁& error _ abort ); ▁visit _ free ( v ); ▁qemu _ opts _ del ( opts ); ▁q api _ free _ User Def Options ( user def ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int 64_ t ▁coroutine _ fn ▁parallel s _ co _ get _ block _ status ( Block Driver State ▁* bs , ▁int 64_ t ▁sector _ num , ▁int ▁nb _ sect ors , ▁int ▁* p num ) ▁{ ▁B DR V Parallel s State ▁* s ▁= ▁bs -> op aque ; ▁int 64_ t ▁offset ; ▁qemu _ co _ mut ex _ lock ( & s -> lock ); ▁offset ▁= ▁block _ status ( s , ▁sector _ num , ▁nb _ sect ors , ▁p num ); ▁qemu _ co _ mut ex _ un lock ( & s -> lock ); ▁if ▁( offset ▁< ▁0) ▁{ ▁return ▁0; ▁} ▁return ▁( offset ▁<< ▁B DR V _ SE CTOR _ BITS ) ▁| ▁B DR V _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁helper _4 xx _ tl b we _ hi ▁( target _ ulong ▁entry , ▁target _ ulong ▁val ) ▁{ ▁pp ce mb _ tl b _ t ▁* tl b ; ▁target _ ulong ▁page , ▁end ; ▁LOG _ S WT LB ("% s ▁entry ▁% d ▁val ▁" ▁TARGET _ F MT _ l x ▁"\ n ", ▁__ func __, ▁( int ) entry , ▁val ); ▁entry ▁&= ▁0 x 3 F ; ▁tl b ▁= ▁& env -> tl b [ entry ]. tl be ; ▁/* ▁Invalid ate ▁previous ▁TL B ▁( if ▁it ' s ▁valid ) ▁*/ ▁if ▁( tl b -> prot ▁& ▁PAGE _ VALID ) ▁{ ▁end ▁= ▁tl b -> EP N ▁+ ▁tl b -> size ; ▁LOG _ S WT LB ("% s : ▁invalidate ▁old ▁TL

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁k vm _ update _ m si _ routes _ all ( void ▁* private , ▁bool ▁global , ▁uint 32_ t ▁index , ▁uint 32_ t ▁mask ) ▁{ ▁int ▁cnt ▁= ▁0; ▁M SI Route Entry ▁* entry ; ▁M SI Message ▁msg ; ▁/* ▁TODO : ▁explicit ▁route ▁update ▁*/ ▁Q LIST _ FORE A CH ( entry , ▁& m si _ route _ list , ▁list ) ▁{ ▁cnt ++; ▁msg ▁= ▁pci _ get _ m si _ message ( entry -> dev , ▁entry -> vector ); ▁k vm _ irq ch ip _ update _ m si _ route ( k vm _ state , ▁entry -> vir q , ▁msg , ▁entry -> dev ); ▁} ▁k vm _ irq ch ip _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁spr _ write _6 01_ ub at u ▁( void ▁* op aque , ▁int ▁spr n ) ▁{ ▁Dis as Context ▁* ctx ▁= ▁opaque ; ▁gen _ op _ store _6 01_ bat u (( sp rn ▁- ▁SP R _ IB AT 0 U ) ▁/ ▁2); ▁RET _ STOP ( ctx ); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁ide _ sect or _ write ( IDE State ▁* s ) ▁{ ▁int 64_ t ▁sector _ num ; ▁int ▁ret , ▁n , ▁n 1; ▁s -> status ▁= ▁READ Y _ STAT ▁| ▁SE EK _ STAT ; ▁sector _ num ▁= ▁ide _ get _ sect or ( s ); ▁# if ▁defined ( DEBUG _ IDE ) ▁printf (" write ▁sector =% L d \ n ", ▁sector _ num ); ▁# end if ▁n ▁= ▁s -> n sect or ; ▁if ▁( n ▁> ▁s -> req _ nb _ sect ors ) ▁n ▁= ▁s -> req _ nb _ sect ors ; ▁ret ▁= ▁b dr v _ write ( s -> bs , ▁sector _ num , ▁s -> io _ buffer , ▁n ); ▁s -> n sect or ▁-= ▁n ; ▁if ▁( s

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁A io Context ▁* io handler _ get _ a io _ context ( void ) ▁{ ▁io handler _ init (); ▁return ▁io handler _ ctx ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁abi _ long ▁do _ sy scall ( void ▁* cpu _ env , ▁int ▁num , ▁abi _ long ▁arg 1, ▁abi _ long ▁arg 2, ▁abi _ long ▁arg 3, ▁abi _ long ▁arg 4, ▁abi _ long ▁arg 5, ▁abi _ long ▁arg 6) ▁{ ▁abi _ long ▁ret ; ▁struct ▁stat ▁st ; ▁struct ▁stat fs ▁st fs ; ▁void ▁* p ; ▁# if def ▁DEBUG ▁gem u _ log (" sy scall ▁% d ", ▁num ); ▁# end if ▁if ( do _ stra ce ) ▁print _ sy scall ( num , ▁arg 1, ▁arg 2, ▁arg 3, ▁arg 4, ▁arg 5, ▁arg 6 ); ▁switch ( num ) ▁{ ▁case ▁TARGET _ N R _ exit : ▁# if def ▁CONFIG _ USE _ N PT L ▁/

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁cpu _ x 86_ dump _ seg _ cache ( CPU State ▁* env , ▁FILE ▁* f , ▁f printf _ function ▁cpu _ f printf , ▁const ▁char ▁* name , ▁struct ▁Segment Cache ▁* sc ) ▁{ ▁# if def ▁TARGET _ X 86_64 ▁if ▁( env -> h flags ▁& ▁H F _ CS 64_ MASK ) ▁{ ▁cpu _ f printf ( f , ▁"% -3 s =% 04 x ▁% 01 6" ▁PRI x 64 ▁" ▁% 08 x ▁% 08 x ", ▁name , ▁sc -> selector , ▁sc -> base , ▁sc -> limit , ▁sc -> flags ); ▁} ▁else ▁# end if ▁{ ▁cpu _ f printf ( f , ▁"% -3 s =% 04 x ▁% 08 x ▁% 08 x ▁% 08 x ", ▁name , ▁sc -> selector , ▁( uin

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁F UN CC ( ff _ h 2 64_ id ct _ add )( uint 8_ t ▁* _ dst , ▁D CT E LE M ▁* _ block , ▁int ▁stride ) ▁{ ▁int ▁i ; ▁INIT _ CLI P ▁pixel ▁* dst ▁= ▁( pixel *) _ dst ; ▁dct coef ▁* block ▁= ▁( d ct coef *) _ block ; ▁stride ▁/= ▁sizeof ( pixel ); ▁block [0] ▁+= ▁1 ▁<< ▁5; ▁for ( i =0; ▁i < 4; ▁i ++){ ▁const ▁int ▁z 0 = ▁block [ i ▁+ ▁4 * 0] ▁+ ▁block [ i ▁+ ▁4 * 2 ]; ▁const ▁int ▁z 1= ▁block [ i ▁+ ▁4 * 0] ▁- ▁block [ i ▁+ ▁4 * 2 ]; ▁const ▁int ▁z 2= ▁( block [ i ▁+ ▁4 * 1] >> 1) ▁- ▁block [ i ▁+ ▁4 * 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁dis as _ fp _ c comp ( Dis as Context ▁* s , ▁uint 32_ t ▁insn ) ▁{ ▁unsigned ▁int ▁mos , ▁type , ▁rm , ▁cond , ▁rn , ▁op , ▁nz cv ; ▁TC G v _ i 64 ▁tc g _ flags ; ▁int ▁label _ continue ▁= ▁-1; ▁mos ▁= ▁extract 32 ( ins n , ▁29, ▁3 ); ▁type ▁= ▁extract 32 ( ins n , ▁22, ▁2); ▁/* ▁0 ▁= ▁single , ▁1 ▁= ▁double ▁*/ ▁rm ▁= ▁extract 32 ( ins n , ▁16, ▁5 ); ▁cond ▁= ▁extract 32 ( ins n , ▁12, ▁4 ); ▁rn ▁= ▁extract 32 ( ins n , ▁5, ▁5 ); ▁op ▁= ▁extract 32 ( ins n , ▁4, ▁1); ▁nz cv ▁= ▁extract 32

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁int ▁test _ bit ( un signed ▁int ▁bit , ▁const ▁unsigned ▁long ▁* map ) ▁{ ▁return ▁!! (( map ) [( bit ) ▁/ ▁B ITS _ PER _ LONG ] ▁& ▁(1 UL ▁<< ▁(( bit ) ▁% ▁B ITS _ PER _ LONG ))); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁bool ▁try _ poll _ mode ( A io Context ▁* ctx , ▁bool ▁blocking ) ▁{ ▁if ▁( blocking ▁&& ▁ctx -> poll _ max _ ns ▁&& ▁ctx -> poll _ disable _ cnt ▁== ▁0) ▁{ ▁/* ▁See ▁qemu _ so on est _ timeout () ▁uint 64_ t ▁hack ▁*/ ▁int 64_ t ▁max _ ns ▁= ▁MIN (( uint 64_ t ) a io _ compute _ timeout ( ctx ), ▁( uint 64_ t ) ctx -> poll _ ns ); ▁if ▁( max _ ns ) ▁{ ▁poll _ set _ started ( ctx , ▁true ); ▁if ▁( run _ poll _ handlers ( ctx , ▁max _ ns )) ▁{ ▁return ▁true ; ▁} ▁} ▁} ▁poll _ set _ started ( ctx ,

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁q mp _ tmp 10 5_ get _ temperature ( const ▁char ▁* id ) ▁{ ▁Q Dict ▁* response ; ▁int ▁ret ; ▁response ▁= ▁q mp ("{ ▁' execute ': ▁' q om - get ', ▁' arguments ': ▁{ ▁' path ': ▁'% s ', ▁" ▁"' property ': ▁' temperature ' ▁} ▁} ", ▁id ); ▁g _ assert ( q dict _ has key ( response , ▁" return ")); ▁ret ▁= ▁q dict _ get _ int ( response , ▁" return "); ▁Q DE CRE F ( response ); ▁return ▁ret ; ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁decode _ sys _ interrupt s ( CP UT ri Core State ▁* env , ▁Dis as Context ▁* ctx ) ▁{ ▁uint 32_ t ▁op 2; ▁uint 32_ t ▁r 1; ▁TC G Label ▁* l 1; ▁TC G v ▁tmp ; ▁op 2 ▁= ▁MASK _ OP _ SY S _ OP 2( ctx -> op code ); ▁r 1 ▁= ▁MASK _ OP _ SY S _ S 1 D ( ctx -> op code ); ▁switch ▁( op 2) ▁{ ▁case ▁O PC 2_ 32_ SY S _ DEBUG : ▁/* ▁raise ▁EX CP _ DEBUG ▁*/ ▁break ; ▁case ▁O PC 2_ 32_ SY S _ DIS ABLE : ▁tc g _ gen _ and i _ tl ( cpu _ IC R , ▁cpu _ IC R , ▁~ MASK _ IC R _ IE ); ▁break ; ▁case ▁O PC 2_

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁pci _ hot plug ( void ) ▁{ ▁Q V irt io PC ID evice ▁* dev ; ▁Q OS State ▁* qs ; ▁const ▁char ▁* arch ▁= ▁q test _ get _ arch (); ▁qs ▁= ▁pci _ test _ start (); ▁/* ▁plug ▁secondary ▁disk ▁*/ ▁q pc i _ plug _ device _ test (" virt io - blk - pc i ", ▁" dr v 1", ▁P CI _ SL OT _ HP , ▁"' drive ': ▁' drive 1' "); ▁dev ▁= ▁virt io _ blk _ pc i _ init ( qs -> pc ibus , ▁P CI _ SL OT _ HP ); ▁g _ assert ( dev ); ▁q virt io _ pc i _ device _ disable ( dev ); ▁g _ free ( dev ); ▁/* ▁un plug ▁seconda

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁unsigned ▁long ▁iv _ decode _ frame ( Ind eo 3 Decode Context ▁* s , ▁unsigned ▁char ▁* buf , ▁int ▁buf _ size ) ▁{ ▁unsigned ▁int ▁hdr _ width , ▁hdr _ height , ▁chrom a _ width , ▁chrom a _ height ; ▁unsigned ▁long ▁f flags 1, ▁f flags 2, ▁f flags 3, ▁offs 1, ▁offs 2, ▁offs 3, ▁offs ; ▁unsigned ▁char ▁* hdr _ pos , ▁* buf _ pos ; ▁buf _ pos ▁= ▁buf ; ▁buf _ pos ▁+= ▁18 ; ▁f flags 1 ▁= ▁le 2 me _16 (* ( uint 16_ t ▁* ) buf _ pos ); ▁buf _ pos ▁+= ▁2; ▁f flags 3 ▁= ▁le 2 me _32 (* ( uint 32_ t ▁*

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁gen _ inter mediate _ code _ internal ▁( CPU State ▁* env , ▁Translation Block ▁* tb , ▁int ▁search _ pc ) ▁{ ▁Dis as Context ▁ctx , ▁* ctx p ▁= ▁& ctx ; ▁op c _ handler _ t ▁** table , ▁* handler ; ▁target _ ulong ▁pc _ start ; ▁uint 16_ t ▁* gen _ op c _ end ; ▁int ▁j , ▁l j ▁= ▁-1; ▁pc _ start ▁= ▁tb -> pc ; ▁gen _ op c _ ptr ▁= ▁gen _ op c _ buf ; ▁gen _ op c _ end ▁= ▁gen _ op c _ buf ▁+ ▁O PC _ MAX _ SIZE ; ▁gen _ o pp ar am _ ptr ▁= ▁gen _ o pp ar am _ buf ; ▁nb _ gen _ labels ▁= ▁0; ▁ctx . n

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁test _ ide _ drive _ cd _0 ( void ) ▁{ ▁char ▁* argv [ 256 ]; ▁int ▁arg c , ▁ide _ idx ; ▁Backend ▁i ; ▁arg c ▁= ▁setup _ common ( argv , ▁ARRAY _ SIZE ( argv )); ▁for ▁( i ▁= ▁0; ▁i ▁<= ▁backend _ empty ; ▁i ++) ▁{ ▁ide _ idx ▁= ▁backend _ empty ▁- ▁i ; ▁cur _ ide [ ide _ idx ] ▁= ▁& hd _ ch st [ i ][ mb r _ blank ]; ▁arg c ▁= ▁setup _ ide ( arg c , ▁argv , ▁ARRAY _ SIZE ( argv ), ▁ide _ idx , ▁NULL , ▁i , ▁m br _ blank , ▁""); ▁} ▁q test _ start ( g _ str join v (" ▁", ▁argv )); ▁test _ c

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁decode _ vol _ header ( M peg Enc Context ▁* s , ▁Get Bit Context ▁* gb ){ ▁int ▁width , ▁height , ▁vo _ ver _ id ; ▁/* ▁vol ▁header ▁*/ ▁skip _ bits ( gb , ▁1); ▁/* ▁random ▁access ▁*/ ▁s -> vo _ type = ▁get _ bits ( gb , ▁8 ); ▁if ▁( get _ bits 1( gb ) ▁!= ▁0) ▁{ ▁/* ▁is _ ol _ id ▁*/ ▁vo _ ver _ id ▁= ▁get _ bits ( gb , ▁4 ); ▁/* ▁vo _ ver _ id ▁*/ ▁skip _ bits ( gb , ▁3 ); ▁/* ▁vo _ priority ▁*/ ▁} ▁else ▁{ ▁vo _ ver _ id ▁= ▁1; ▁} ▁// printf (" vo ▁type :% d \ n ", s -> vo _ type ); ▁s 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁void ▁ff _ init _ me ( M peg Enc Context ▁* s ){ ▁M otion Est Context ▁* ▁const ▁c = ▁& s -> me ; ▁c -> av ctx = ▁s -> av ctx ; ▁ff _ set _ cmp ( & s -> d sp , ▁s -> d sp . me _ pre _ cmp , ▁c -> av ctx -> me _ pre _ cmp ); ▁ff _ set _ cmp ( & s -> d sp , ▁s -> d sp . me _ cmp , ▁c -> av ctx -> me _ cmp ); ▁ff _ set _ cmp ( & s -> d sp , ▁s -> d sp . me _ sub _ cmp , ▁c -> av ctx -> me _ sub _ cmp ); ▁ff _ set _ cmp ( & s -> d sp , ▁s -> d sp . mb _ cmp , ▁c -> av ctx -> mb _ cmp ); ▁c -> flags ▁= ▁get _

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁filter ( M peg Audio Context ▁* s , ▁int ▁ch , ▁short ▁* samples , ▁int ▁incr ) ▁{ ▁short ▁* p , ▁* q ; ▁int ▁sum , ▁offset , ▁i , ▁j , ▁norm , ▁n ; ▁short ▁tmp [ 64 ]; ▁int ▁tmp 1[ 32 ]; ▁int ▁* out ; ▁// ▁print _ pow 1( samples , ▁115 2); ▁offset ▁= ▁s -> samples _ offset [ ch ]; ▁out ▁= ▁& s -> sb _ samples [ ch ][0] [0] [0]; ▁for ( j =0; j < 36 ; j ++) ▁{ ▁/* ▁32 ▁samples ▁at ▁once ▁*/ ▁for ( i =0; i < 32 ; i ++) ▁{ ▁s -> samples _ buf [ ch ][ offset ▁+ ▁( 31 ▁- ▁i )] ▁= ▁samples [0]; ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁int ▁k vm _ arch _ handle _ exit ( CPU State ▁* cs , ▁struct ▁k vm _ run ▁* run ) ▁{ ▁S 390 CPU ▁* cpu ▁= ▁S 39 0_ CPU ( cs ); ▁int ▁ret ▁= ▁0; ▁switch ▁( run -> exit _ reason ) ▁{ ▁case ▁K VM _ EXIT _ S 39 0_ SI E IC : ▁ret ▁= ▁handle _ intercept ( cpu ); ▁break ; ▁case ▁K VM _ EXIT _ S 39 0_ RE SET : ▁qemu _ system _ reset _ request (); ▁break ; ▁case ▁K VM _ EXIT _ S 39 0_ TS CH : ▁ret ▁= ▁handle _ ts ch ( cpu ); ▁break ; ▁case ▁K VM _ EXIT _ DEBUG : ▁ret ▁= ▁k vm _ arch _ handle _ debug _ exit ( cpu 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁Address Space ▁* pc i _ device _ iom mu _ address _ space ( PC ID evice ▁* dev ) ▁{ ▁P CI Bus ▁* bus ▁= ▁P CI _ B US ( dev -> bus ); ▁P CI Bus ▁* iom mu _ bus ▁= ▁bus ; ▁while ( iom mu _ bus ▁&& ▁! iom mu _ bus -> iom mu _ fn ▁&& ▁i omm u _ bus -> parent _ dev ) ▁{ ▁i omm u _ bus ▁= ▁P CI _ B US ( iom mu _ bus -> parent _ dev -> bus ); ▁} ▁if ▁( iom mu _ bus ▁&& ▁i omm u _ bus -> iom mu _ fn ) ▁{ ▁return ▁i omm u _ bus -> iom mu _ fn ( bus , ▁i omm u _ bus -> iom mu _ op aque , ▁dev -> dev fn ); ▁} ▁retu

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁inline ▁void ▁gen _ op _ eval _ f bo ( TC G v ▁dst , ▁TC G v ▁src , ▁unsigned ▁int ▁f cc _ offset ) ▁{ ▁gen _ mov _ reg _ F CC 0( dst , ▁src , ▁f cc _ offset ); ▁gen _ mov _ reg _ F CC 1( cpu _ tmp 0, ▁src , ▁f cc _ offset ); ▁tc g _ gen _ and _ tl ( dst , ▁dst , ▁cpu _ tmp 0); ▁tc g _ gen _ xor i _ tl ( dst , ▁dst , ▁0 x 1); ▁}

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁dv b sub _ decode ( AV Codec Context ▁* av ctx , ▁void ▁* data , ▁int ▁* data _ size , ▁AV Packet ▁* av pk t ) ▁{ ▁const ▁uint 8_ t ▁* buf ▁= ▁av pk t -> data ; ▁int ▁buf _ size ▁= ▁av pk t -> size ; ▁D VB Sub Context ▁* ctx ▁= ▁av ctx -> priv _ data ; ▁AV Sub title ▁* sub ▁= ▁data ; ▁const ▁uint 8_ t ▁* p , ▁* p _ end ; ▁int ▁segment _ type ; ▁int ▁page _ id ; ▁int ▁segment _ length ; ▁int ▁i ; ▁av _ d log ( av ctx , ▁" D VB ▁sub ▁packet :\ n "); ▁for ▁( i =0; ▁i ▁< ▁buf _ size ; ▁i ++) ▁{ 

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁* mp c 85 44 _ load _ device _ tree ( target _ ph ys _ addr _ t ▁addr , ▁uint 32_ t ▁ram size , ▁target _ ph ys _ addr _ t ▁init rd _ base , ▁target _ ph ys _ addr _ t ▁init rd _ size , ▁const ▁char ▁* kernel _ cmdline ) ▁{ ▁void ▁* fd t ▁= ▁NULL ; ▁# if def ▁CONFIG _ F DT ▁uint 32_ t ▁mem _ reg _ property [] ▁= ▁{ 0, ▁ram size }; ▁char ▁* filename ; ▁int ▁fd t _ size ; ▁int ▁ret ; ▁filename ▁= ▁qemu _ find _ file ( Q EM U _ FILE _ TYPE _ B IOS , ▁BINARY _ DEVICE _ TREE _ FILE ); ▁if ▁(! fi

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁int ▁mov _ read _ tr ak ( MO V Context ▁* c , ▁Byte IO Context ▁* pb , ▁MO V _ atom _ t ▁atom ) ▁{ ▁AV Stream ▁* st ; ▁MO V Stream Context ▁* sc ; ▁int ▁ret ; ▁st ▁= ▁av _ new _ stream ( c -> fc , ▁c -> fc -> nb _ streams ); ▁if ▁(! st ) ▁return ▁A VER ROR ( EN O ME M ); ▁sc ▁= ▁av _ m alloc z ( size of ( MO V Stream Context )); ▁if ▁(! sc ) ▁return ▁A VER ROR ( EN O ME M ); ▁st -> priv _ data ▁= ▁sc ; ▁st -> codec -> codec _ type ▁= ▁CODE C _ TYPE _ DATA ; ▁st -> start _ time ▁= ▁0; ▁/* ▁XXX : ▁

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁av _ col d ▁int ▁libs ch ro ed inger _ encode _ init ( AV Codec Context ▁* av ctx ) ▁{ ▁S ch ro Encoder Params ▁* p _ sch ro _ params ▁= ▁av ctx -> priv _ data ; ▁S ch ro Video Format Enum ▁preset ; ▁/* ▁Initialize ▁the ▁libraries ▁that ▁libs ch ro ed inger ▁depends ▁on . ▁*/ ▁sch ro _ init (); ▁/* ▁Create ▁an ▁encoder ▁object . ▁*/ ▁p _ sch ro _ params -> encoder ▁= ▁sch ro _ encoder _ new (); ▁if ▁(! p _ sch ro _ params -> encoder ) ▁{ ▁av _ log ( av ctx , ▁AV _ LOG _ ERROR , ▁" Un recover able

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁struct ▁o map _ m cb sp _ s ▁* om ap _ m cb sp _ init ( Memory Region ▁* system _ memory , ▁target _ ph ys _ addr _ t ▁base , ▁qemu _ irq ▁tx irq , ▁qemu _ irq ▁rx irq , ▁qemu _ irq ▁* d ma , ▁o map _ cl k ▁cl k ) ▁{ ▁struct ▁o map _ m cb sp _ s ▁* s ▁= ▁( struct ▁o map _ m cb sp _ s ▁* ) ▁g _ m alloc 0( size of ( struct ▁o map _ m cb sp _ s )); ▁s -> tx irq ▁= ▁tx irq ; ▁s -> rx irq ▁= ▁rx irq ; ▁s -> tx dr q ▁= ▁d ma [0]; ▁s -> rx dr q ▁= ▁d ma [1]; ▁s -> sink _ timer ▁= ▁qemu _ new _ timer _ n

INFO:absl:Found text fields for LIME attribution: ['sentence']
INFO:absl:Explaining: ▁static ▁void ▁rv 34 _ pred _ mv ( RV 34 Dec Context ▁* r , ▁int ▁block _ type , ▁int ▁sub block _ no , ▁int ▁dm v _ no ) ▁{ ▁M peg Enc Context ▁* s ▁= ▁& r -> s ; ▁int ▁mv _ pos ▁= ▁s -> mb _ x ▁* ▁2 ▁+ ▁s -> mb _ y ▁* ▁2 ▁* ▁s -> b 8_ stride ; ▁int ▁A [2] ▁= ▁{0 }, ▁B [2], ▁C [2 ]; ▁int ▁i , ▁j ; ▁int ▁mx , ▁my ; ▁int ▁avail _ index ▁= ▁avail _ indexes [ sub block _ no ]; ▁int ▁c _ off ▁= ▁part _ sizes _ w [ block _ type ]; ▁mv _ pos ▁+= ▁( sub block _ no ▁& ▁1) ▁+ ▁( sub block _ no ▁>> ▁1) * s -> b 8_ 

